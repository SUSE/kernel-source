#!/usr/bin/python3
import sys, re, os, argparse, datetime
import bugzilla
from bugzilla._cli import DEFAULT_BZ
import git_sort.pygit2_wrapper as git

# dashboard kss script - work in progress

CVE_PATTERN = re.compile(r"CVE-[0-9]{4}-[0-9]{4,}")
CVSS_PATTERN = re.compile(r"CVSSv3.1:SUSE:CVE-[0-9]{4}-[0-9]{4,}:([0-9].[0-9])")
FIXES_PATTERN = re.compile(r"Fixes: ([0-9a-f]{12,})")
PATCH_PATTERN = re.compile(r"\+\+\+ b/([^ ]{1,})\n")

T_RED = "\033[01;31m"
T_GREEN = "\033[01;32m"
T_YELLOW = "\033[01;33m"
T_PURPLE = "\033[01;35m"
T_END = "\033[0m"
show_colors = os.isatty(sys.stdout.fileno())

def check_envvar(var):
    result = os.environ.get(var)
    if not result:
        print("Please set {} environment variable!\n\nThe script requires a clone of https://git.kernel.org/pub/scm/linux/security/vulns.git in VULNS_GIT\n"\
              "and a clone of https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git in LINUX_GIT ".format(var), file=sys.stderr)
        sys.exit(1)
    return result

def color_format(color, msg):
    if show_colors and msg:
        return "{}{}{}".format(color, msg, T_END)
    return msg

def get_cve(s):
    m = re.search(CVE_PATTERN, s)
    return m.group(0) if m else ''

def get_score(s):
    m = re.search(CVSS_PATTERN, s)
    return m.group(1) if m else ''

def fetch_cves():
    repo = git.Repository(check_envvar('VULNS_GIT'))
    tree_index = git.Index()
    tree_index.read_tree(repo.revparse_single('origin/master').tree)
    return { get_cve(t.path): repo[t.id].data.decode('ascii').rstrip() for t in tree_index if t.path.startswith('cve/published/') and t.path.endswith('.sha1') }

def show_patch(p, h):
    print('--- Begin {} ---'.format(h))
    for l in p.splitlines():
        if l.startswith('-'):
            print(color_format(T_RED, l))
        elif l.startswith('+'):
            print(color_format(T_GREEN, l))
        else:
            print(l)
    print('--- End {} ---'.format(h))

class MainlineRepo:
    def __init__(self):
        self.repo = git.Repository(check_envvar('LINUX_GIT'))
        self.patches = dict()

    def get_all_fixes(self, h):
        msg = self.repo[h].raw_message.decode('utf8')
        return { str(self.repo.revparse_single(f).id) for f in re.findall(FIXES_PATTERN, msg) }

    def get_patch(self, h):
        if h not in self.patches:
            t0 = self.repo.revparse_single(h + "^")
            t1 = self.repo.revparse_single(h)
            self.patches[h] = self.repo.diff(t0, t1).patch
        return self.patches[h]

    def get_all_paths(self, h):
        return { p.lstrip() for p in re.findall(PATCH_PATTERN, self.get_patch(h)) }

class BugData:
    def __init__(self, bug, cves):
        self.data = bug
        self.cve = get_cve(self.data.summary)
        self.sha = cves.get(self.cve, '')
        self.score = get_score(self.data.status_whiteboard)
        self.mtime = datetime.datetime.strptime(str(bug.last_change_time), '%Y%m%dT%H:%M:%S')
        self.paths = None
        self.comments = []

    def grep_paths(self, regex, linux_git):
        if not self.sha:
            return False
        self.paths = linux_git.get_all_paths(self.sha)
        if [ p for p in self.paths if re.search(regex, p) ]:
            return True

    def grep_patch(self, regex, linux_git):
        if not self.sha:
            return False
        patch = linux_git.get_patch(self.sha)
        return re.search(regex, patch)

    def grep_comments(self, regex):
        raw_comments = self.data.getcomments()
        for rc in raw_comments:
            m = re.search(regex, rc['text'])
            if m:
                text = '--- Begin https://bugzilla.suse.com/show_bug.cgi?id={}#c{} ---\n'.format(self.data.id, rc['count'])
                text += rc['text'].replace(m.group(0), color_format(T_YELLOW, m.group(0)))
                text +='\n--- End https://bugzilla.suse.com/show_bug.cgi?id={}#c{} ---\n'.format(self.data.id, rc['count'])
                self.comments.append(text)
        return self.comments

def fetch_bugs(email):
    bzapi = bugzilla.Bugzilla(DEFAULT_BZ)
    query = bzapi.build_query(status=['NEW', 'IN_PROGRESS', 'CONFIRMED', 'REOPENED'],
                              product='SUSE Security Incidents',
                              component='Incidents',
                              assigned_to=email,
                              include_fields=["id", "status", "summary", "status_whiteboard", "last_change_time"])
    return bzapi.query(query)

def show_bug(n, b, linux_git, short, print_patch):
    color = T_RED
    fixes = []
    paths = []
    if b.sha:
        fixes = linux_git.get_all_fixes(b.sha)
        if fixes and b.score and b.sha:
            color = T_GREEN
        if not short:
            if b.paths:
                paths = b.paths
            else:
                paths = linux_git.get_all_paths(b.sha)
        else:
            fixes = []
    print("{:>3}: {} ; {:<11} ; {:<14} ; {:<40}".format(n, b.data.id, b.data.status, b.cve, color_format(color, b.sha)), end=' ')
    print("; {:>4} ; {} ; {}".format(b.score, b.mtime, b.data.summary))
    for f in fixes:
        print("{:>46}{}".format('', f))
    if print_patch and paths:
        show_patch(linux_git.patches[b.sha], b.sha)
    else:
        for p in sorted(paths):
            print("{:>46}{}".format('', color_format(T_PURPLE, p)))
    for c in b.comments:
        print(c)

def handle_grep(regex):
    if not regex:
        return None
    try:
        return re.compile(regex)
    except Exception as e:
        print(regex, ": ", e, file=sys.stderr)
    sys.exit(1)

def handle_modulo(qr):
    if not qr:
        return 0, 0
    try:
        q, r = qr.split(':')
        q = int(q)
        r = int(r)
        if q < 1 or r < 0 or r >= q:
            raise Exception()
        return (q, r)
    except Exception:
        print(qr, ": expected format is Q:R were Q > 0 and R < Q", file=sys.stderr)
    sys.exit(1)

def handle_email(email):
    if len(email) < 9 or "@suse." not in email:
        print("no valid bz email provided", file=sys.stderr)
        sys.exit(1)
    return email

def parse_args():
    parser = argparse.ArgumentParser(description="KSS Dashboard")
    parser.add_argument("-c", "--colors", help="show colors unconditionally (by default they show only in terminal); this is useful for piping into \"less -iR\"", action="store_true", default=False)
    parser.add_argument("-C", "--no-colors", help="do not show colors unconditionally (by default they show only in terminal)", action="store_true", default=False)
    parser.add_argument("-w", "--whiteboard", help="show only bugs with whiteboard set (thus CVSS score set)", action="store_true", default=False)
    parser.add_argument("-W", "--no-whiteboard", help="show only bugs with whiteboard not set (thus no CVSS score)", action="store_true", default=False)
    parser.add_argument("-s", "--short", help="show only bug headers (one bug per line; no fixes tags and no path from patches)", action="store_true", default=False)
    parser.add_argument("-p", "--patch", help="show the entire fixing patch instead of just paths; incompatible with --short", action="store_true", default=False)
    parser.add_argument("-S", "--sort-score", help="sort bugs by CVSS score instead of their bug ids, implies -w (--whiteboard)", action="store_true", default=False)
    parser.add_argument("-N", "--sort-cve", help="sort bugs by CVE number instead of their bug ids", action="store_true", default=False)
    parser.add_argument("-t", "--sort-time", help="sort bugs by modification time", action="store_true", default=False)
    parser.add_argument("-r", "--reverse", help="sort bugs in reverse order (descending)", action="store_true", default=False)
    parser.add_argument("-e", "--email", help="instead of incoming CVE queue, display CVE queue for another email (for example yours)", default='kernel-bugs@suse.de', type=str)
    parser.add_argument("-k", "--cve-kpm", help="show CVE Kernel Patch Monkey queue", action="store_true", default=False)
    parser.add_argument("-g", "--grep", help="grep summary for REGEX and show only bugs that match it", default=None, type=str)
    parser.add_argument("-G", "--grep-paths", help="grep fix commit paths for REGEX and show only bugs with fix commits that match it", default=None, type=str)
    parser.add_argument("-P", "--grep-patch", help="grep fix commit patch for REGEX and show only bugs with fix commits that match it", default=None, type=str)
    parser.add_argument("-T", "--grep-comments", help="grep bugzilla comments and show only bugs that match including the matching comments (highlighted)", default=None, type=str)
    parser.add_argument("-m", "--modulo", help="takes two integers in the format \"Q:R\" and shows only bugs with IDs that satisfy N %% Q == R", default=None, type=str)
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()
    grep = handle_grep(args.grep)
    grep_paths = handle_grep(args.grep_paths)
    grep_patch = handle_grep(args.grep_patch)
    grep_comments = handle_grep(args.grep_comments)
    q, r = handle_modulo(args.modulo)
    email = handle_email(args.email)
    if args.cve_kpm:
        email = 'cve-kpm@suse.de'
    bugs = fetch_bugs(email)
    cves = fetch_cves()
    linux_git = MainlineRepo()

    if args.colors:
        show_colors = True
    elif args.no_colors:
        show_colors = False

    bugs = [ BugData(b, cves) for b in bugs ]

    if args.whiteboard or args.sort_score:
        bugs = [ b for b in bugs if b.data.status_whiteboard ]
    elif args.no_whiteboard:
        bugs = [ b for b in bugs if not b.data.status_whiteboard ]

    if grep:
        bugs = [ b for b in bugs if re.search(grep, b.data.summary) ]

    if grep_paths:
        bugs = [ b for b in bugs if b.grep_paths(grep_paths, linux_git) ]

    if grep_patch:
        bugs = [ b for b in bugs if b.grep_patch(grep_patch, linux_git) ]

    if grep_comments:
        bugs = [ b for b in bugs if b.grep_comments(grep_comments) ]

    if q:
        bugs = [ b for b in bugs if b.data.id % q == r ]

    if args.sort_score:
        keyf = lambda x: float(x.score or 0.0)
    elif args.sort_cve:
        keyf = lambda x: x.cve
    elif args.sort_time:
        keyf = lambda x: x.mtime
    else:
        keyf = lambda x: x.data.id

    for n, b in enumerate(sorted(bugs, key=keyf, reverse=args.reverse), 1):
        show_bug(n, b, linux_git, args.short, args.patch)
