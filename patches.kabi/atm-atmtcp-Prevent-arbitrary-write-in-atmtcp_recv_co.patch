From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for struct atmdev_ops extension
Patch-mainline: Never, kABI workaround
References: CVE-2025-39828 bsc#1250205

The upstream fix commit ec79003c5f9d
  atm: atmtcp: Prevent arbitrary write in atmtcp_recv_control().
added a new field pre_send to struct atmdev_ops that broke kABI.

For keeping the kABI, move the newly added field at the end and wrap
with the standard ifdef.  Since the access to this new field must be
restricted only to the drivers that set the ops, add a new flag in
struct atm_dev indicating that it's an extended atmdev_ops, and check
it before accessing the new pre_send op.

Reviewed-by: Jan Kara <jack@suse.cz>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/atm/atmtcp.c   |    1 +
 include/linux/atmdev.h |    9 ++++++++-
 net/atm/common.c       |    2 +-
 3 files changed, 10 insertions(+), 2 deletions(-)

--- a/drivers/atm/atmtcp.c
+++ b/drivers/atm/atmtcp.c
@@ -384,6 +384,7 @@ static int atmtcp_create(int itf,int per
 		kfree(dev_data);
 		return itf == -1 ? -ENOMEM : -EBUSY;
 	}
+	dev->ext_ops = 1; /* FIXME: for kABI compatibility */
 	dev->ci_range.vpi_bits = MAX_VPI_BITS;
 	dev->ci_range.vci_bits = MAX_VCI_BITS;
 	dev->dev_data = dev_data;
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -159,6 +159,10 @@ struct atm_dev {
 	struct atm_cirange ci_range;	/* VPI/VCI range */
 	struct k_atm_dev_stats stats;	/* statistics */
 	char		signal;		/* signal status (ATM_PHY_SIG_*) */
+#ifndef __GENKSYMS__
+	/* FIXME: extended ops for kABI compatibility */
+	unsigned char	ext_ops;
+#endif
 	int		link_rate;	/* link rate (default: OC3) */
 	refcount_t	refcnt;		/* reference count */
 	spinlock_t	lock;		/* protect internal members */
@@ -185,7 +189,6 @@ struct atmdev_ops { /* only send is requ
 	int (*compat_ioctl)(struct atm_dev *dev,unsigned int cmd,
 			    void __user *arg);
 #endif
-	int (*pre_send)(struct atm_vcc *vcc, struct sk_buff *skb);
 	int (*send)(struct atm_vcc *vcc,struct sk_buff *skb);
 	int (*send_bh)(struct atm_vcc *vcc, struct sk_buff *skb);
 	int (*send_oam)(struct atm_vcc *vcc,void *cell,int flags);
@@ -195,6 +198,10 @@ struct atmdev_ops { /* only send is requ
 	int (*change_qos)(struct atm_vcc *vcc,struct atm_qos *qos,int flags);
 	int (*proc_read)(struct atm_dev *dev,loff_t *pos,char *page);
 	struct module *owner;
+#ifndef __GENKSYMS__
+	/* extended ops; the driver must set dev->ext_ops flag */
+	int (*pre_send)(struct atm_vcc *vcc, struct sk_buff *skb);
+#endif
 };
 
 struct atmphy_ops {
--- a/net/atm/common.c
+++ b/net/atm/common.c
@@ -641,7 +641,7 @@ int vcc_sendmsg(struct socket *sock, str
 	if (eff != size)
 		memset(skb->data + size, 0, eff-size);
 
-	if (vcc->dev->ops->pre_send) {
+	if (vcc->dev->ext_ops && vcc->dev->ops->pre_send) {
 		error = vcc->dev->ops->pre_send(vcc, skb);
 		if (error)
 			goto free_skb;
