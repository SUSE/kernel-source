From: Shung-Hsi Yu <shung-hsi.yu@suse.com>
Subject: kABI: bpf: struct bpf_map kABI workaround
Patch-mainline: never, kabi
References: CVE-2024-50063

Upstream commit 28ead3eaabc1 ("bpf: Prevent tail call between progs attached to
different hooks") changed struct bpf_map and thus breaks kABI.

Luckily we have kABI padding inplace right within struct bpf_map, hence all
that's needed is to move the newly added field to where the padding is located
and kABI will be preserved.

Signed-off-by: Shung-Hsi Yu <shung-hsi.yu@suse.com>
---
 include/linux/bpf.h |    6 +++++-
 kernel/bpf/core.c   |    4 ++--
 2 files changed, 7 insertions(+), 3 deletions(-)

--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -289,7 +289,6 @@ struct bpf_map {
 	 * same prog type, JITed flag and xdp_has_frags flag.
 	 */
 	struct {
-		const struct btf_type *attach_func_proto;
 		spinlock_t lock;
 		enum bpf_prog_type type;
 		bool jited;
@@ -301,7 +300,12 @@ struct bpf_map {
 	bool free_after_rcu_gp;
 	atomic64_t sleepable_refcnt;
 	s64 __percpu *elem_count;
+#ifndef __GENKSYMS__
+	/* Synchornized with struct owner.lock */
+	const struct btf_type *owner_attach_func_proto;
+#else
 	void *suse_kabi_padding;
+#endif
 };
 
 static inline const char *btf_field_type_name(enum btf_field_type type)
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -2274,14 +2274,14 @@ bool bpf_prog_map_compatible(struct bpf_
 		map->owner.type  = prog_type;
 		map->owner.jited = fp->jited;
 		map->owner.xdp_has_frags = aux->xdp_has_frags;
-		map->owner.attach_func_proto = aux->attach_func_proto;
+		map->owner_attach_func_proto = aux->attach_func_proto;
 		ret = true;
 	} else {
 		ret = map->owner.type  == prog_type &&
 		      map->owner.jited == fp->jited &&
 		      map->owner.xdp_has_frags == aux->xdp_has_frags;
 		if (ret &&
-		    map->owner.attach_func_proto != aux->attach_func_proto) {
+		    map->owner_attach_func_proto != aux->attach_func_proto) {
 			switch (prog_type) {
 			case BPF_PROG_TYPE_TRACING:
 			case BPF_PROG_TYPE_LSM:
