From: Jiri Slaby <jslaby@suse.cz>
Subject: kABI: PCI: dwc: Add dw_pcie_ops.host_deinit() callback
Patch-mainline: never, kabi
References: kabi bsc#1210206

Commit c6481d51dc65 (PCI: dwc: Add dw_pcie_ops.host_deinit() callback)
added a callback to struct dw_pcie_host_ops. This made the kABI checker
complaining.

While struct dw_pcie_host_ops is strictly internal, dw_pcie_host_init()
is exported.

So deal with this by:
* moving dw_pcie_host_ops::host_deinit to the end,
* protect it by usual __GENKSYMS__,
* introduce dw_pcie_host_init2() which should take the new member
  into account (and only that),
* use that in pcie-qcom which is the only user of ::host_deinit.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/pci/controller/dwc/pcie-designware-host.c |   24 ++++++++++++++++++----
 drivers/pci/controller/dwc/pcie-designware.h      |    5 +++-
 drivers/pci/controller/dwc/pcie-qcom.c            |    2 -
 3 files changed, 25 insertions(+), 6 deletions(-)

--- a/drivers/pci/controller/dwc/pcie-designware-host.c
+++ b/drivers/pci/controller/dwc/pcie-designware-host.c
@@ -286,7 +286,7 @@ static void dw_pcie_msi_init(struct pcie
 	dw_pcie_writel_dbi(pci, PCIE_MSI_ADDR_HI, upper_32_bits(msi_target));
 }
 
-int dw_pcie_host_init(struct pcie_port *pp)
+int __dw_pcie_host_init(struct pcie_port *pp, bool v2)
 {
 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
 	struct device *dev = pci->dev;
@@ -432,14 +432,25 @@ err_free_msi:
 		dw_pcie_free_msi(pp);
 
 err_deinit_host:
-	if (pp->ops->host_deinit)
+	if (v2 && pp->ops->host_deinit)
 		pp->ops->host_deinit(pp);
 
 	return ret;
 }
+
+int dw_pcie_host_init(struct pcie_port *pp)
+{
+	return __dw_pcie_host_init(pp, false);
+}
 EXPORT_SYMBOL_GPL(dw_pcie_host_init);
 
-void dw_pcie_host_deinit(struct pcie_port *pp)
+int dw_pcie_host_init2(struct pcie_port *pp)
+{
+	return __dw_pcie_host_init(pp, true);
+}
+EXPORT_SYMBOL_GPL(dw_pcie_host_init2);
+
+void __dw_pcie_host_deinit(struct pcie_port *pp, bool v2)
 {
 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
 
@@ -452,9 +463,14 @@ void dw_pcie_host_deinit(struct pcie_por
 	if (pp->has_msi_ctrl)
 		dw_pcie_free_msi(pp);
 
-	if (pp->ops->host_deinit)
+	if (v2 && pp->ops->host_deinit)
 		pp->ops->host_deinit(pp);
 }
+
+void dw_pcie_host_deinit(struct pcie_port *pp)
+{
+	return __dw_pcie_host_deinit(pp, false);
+}
 EXPORT_SYMBOL_GPL(dw_pcie_host_deinit);
 
 static void __iomem *dw_pcie_other_conf_map_bus(struct pci_bus *bus,
--- a/drivers/pci/controller/dwc/pcie-designware.h
+++ b/drivers/pci/controller/dwc/pcie-designware.h
@@ -174,8 +174,10 @@ enum dw_pcie_device_mode {
 
 struct dw_pcie_host_ops {
 	int (*host_init)(struct pcie_port *pp);
-	void (*host_deinit)(struct pcie_port *pp);
 	int (*msi_host_init)(struct pcie_port *pp);
+#ifndef __GENKSYMS__
+	void (*host_deinit)(struct pcie_port *pp);
+#endif
 };
 
 struct pcie_port {
@@ -370,6 +372,7 @@ static inline void dw_pcie_dbi_ro_wr_dis
 irqreturn_t dw_handle_msi_irq(struct pcie_port *pp);
 void dw_pcie_setup_rc(struct pcie_port *pp);
 int dw_pcie_host_init(struct pcie_port *pp);
+int dw_pcie_host_init2(struct pcie_port *pp);
 void dw_pcie_host_deinit(struct pcie_port *pp);
 int dw_pcie_allocate_domains(struct pcie_port *pp);
 void __iomem *dw_pcie_own_conf_map_bus(struct pci_bus *bus, unsigned int devfn,
--- a/drivers/pci/controller/dwc/pcie-qcom.c
+++ b/drivers/pci/controller/dwc/pcie-qcom.c
@@ -1537,7 +1537,7 @@ static int qcom_pcie_probe(struct platfo
 
 	platform_set_drvdata(pdev, pcie);
 
-	ret = dw_pcie_host_init(pp);
+	ret = dw_pcie_host_init2(pp);
 	if (ret) {
 		dev_err(dev, "cannot initialize host\n");
 		goto err_phy_exit;
