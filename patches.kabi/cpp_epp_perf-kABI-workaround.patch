From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for cpp_acpi extensions for EPP
Patch-mainline: Never, kABI workaround
References: bsc#1212445

The extension of cppc_perf_caps and cppc_perf_ctrls for supporting EPP
caused kABI breakage.  As those new fields are accessed only by the new
functions, put them into the newly renamed structs (with _epp prefix),
and replace with those types to keep the old structs intact.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/acpi/cppc_acpi.c     |    4 ++--
 drivers/cpufreq/amd-pstate.c |   14 ++++++++------
 include/acpi/cppc_acpi.h     |   26 +++++++++++++++++++++-----
 3 files changed, 31 insertions(+), 13 deletions(-)

--- a/drivers/acpi/cppc_acpi.c
+++ b/drivers/acpi/cppc_acpi.c
@@ -1395,7 +1395,7 @@ EXPORT_SYMBOL_GPL(cppc_get_perf_ctrs);
  * Set Energy Performance Preference Register value through
  * Performance Controls Interface
  */
-int cppc_set_epp_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls, bool enable)
+int cppc_set_epp_perf(int cpu, struct cppc_epp_perf_ctrls *perf_ctrls, bool enable)
 {
 	int pcc_ss_id = per_cpu(cpu_pcc_subspace_idx, cpu);
 	struct cpc_register_resource *epp_set_reg;
@@ -1450,7 +1450,7 @@ EXPORT_SYMBOL_GPL(cppc_set_epp_perf);
  * @cpunum : CPU from which to read register.
  * @perf_caps : struct where autonomous selection register value is updated.
  */
-int cppc_get_auto_sel_caps(int cpunum, struct cppc_perf_caps *perf_caps)
+int cppc_get_auto_sel_caps(int cpunum, struct cppc_epp_perf_caps *perf_caps)
 {
 	struct cpc_desc *cpc_desc = per_cpu(cpc_desc_ptr, cpunum);
 	struct cpc_register_resource *auto_sel_reg;
--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@ -175,7 +175,7 @@ static int amd_pstate_get_energy_pref_in
 static int amd_pstate_set_epp(struct amd_cpudata *cpudata, u32 epp)
 {
 	int ret;
-	struct cppc_perf_ctrls perf_ctrls;
+	struct cppc_epp_perf_ctrls perf_ctrls;
 
 	if (boot_cpu_has(X86_FEATURE_CPPC)) {
 		u64 value = READ_ONCE(cpudata->cppc_req_cached);
@@ -289,10 +289,10 @@ static int pstate_init_perf(struct amd_c
 
 static int cppc_init_perf(struct amd_cpudata *cpudata)
 {
-	struct cppc_perf_caps cppc_perf;
+	struct cppc_epp_perf_caps cppc_perf = {};
 	u32 highest_perf;
 
-	int ret = cppc_get_perf_caps(cpudata->cpu, &cppc_perf);
+	int ret = cppc_get_perf_caps(cpudata->cpu, (struct cppc_perf_caps *)&cppc_perf);
 	if (ret)
 		return ret;
 
@@ -1002,7 +1002,7 @@ static int amd_pstate_epp_set_policy(str
 
 static void amd_pstate_epp_reenable(struct amd_cpudata *cpudata)
 {
-	struct cppc_perf_ctrls perf_ctrls;
+	struct cppc_epp_perf_ctrls perf_ctrls;
 	u64 value, max_perf;
 	int ret;
 
@@ -1018,7 +1018,8 @@ static void amd_pstate_epp_reenable(stru
 	} else {
 		perf_ctrls.max_perf = max_perf;
 		perf_ctrls.energy_perf = AMD_CPPC_ENERGY_PERF_PREF(cpudata->epp_cached);
-		cppc_set_perf(cpudata->cpu, &perf_ctrls);
+		cppc_set_perf(cpudata->cpu, (struct cppc_perf_ctrls *)&perf_ctrls);
+		cppc_set_epp_perf(cpudata->cpu, &perf_ctrls, 1);
 	}
 }
 
@@ -1059,7 +1060,8 @@ static void amd_pstate_epp_offline(struc
 	} else {
 		perf_ctrls.desired_perf = 0;
 		perf_ctrls.max_perf = min_perf;
-		perf_ctrls.energy_perf = AMD_CPPC_ENERGY_PERF_PREF(HWP_EPP_BALANCE_POWERSAVE);
+		// FIXME: SLE15-SP5 kABI workaround
+		// perf_ctrls.energy_perf = AMD_CPPC_ENERGY_PERF_PREF(HWP_EPP_BALANCE_POWERSAVE);
 		cppc_set_perf(cpudata->cpu, &perf_ctrls);
 	}
 	mutex_unlock(&amd_pstate_limits_lock);
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -108,11 +108,27 @@ struct cppc_perf_caps {
 	u32 lowest_nonlinear_perf;
 	u32 lowest_freq;
 	u32 nominal_freq;
+};
+
+struct cppc_perf_ctrls {
+	u32 max_perf;
+	u32 min_perf;
+	u32 desired_perf;
+};
+
+struct cppc_epp_perf_caps {
+	u32 guaranteed_perf;
+	u32 highest_perf;
+	u32 nominal_perf;
+	u32 lowest_perf;
+	u32 lowest_nonlinear_perf;
+	u32 lowest_freq;
+	u32 nominal_freq;
 	u32 energy_perf;
 	bool auto_sel;
 };
 
-struct cppc_perf_ctrls {
+struct cppc_epp_perf_ctrls {
 	u32 max_perf;
 	u32 min_perf;
 	u32 desired_perf;
@@ -153,8 +169,8 @@ extern bool cpc_supported_by_cpu(void);
 extern int cpc_read_ffh(int cpunum, struct cpc_reg *reg, u64 *val);
 extern int cpc_write_ffh(int cpunum, struct cpc_reg *reg, u64 val);
 extern int cppc_get_epp_perf(int cpunum, u64 *epp_perf);
-extern int cppc_set_epp_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls, bool enable);
-extern int cppc_get_auto_sel_caps(int cpunum, struct cppc_perf_caps *perf_caps);
+extern int cppc_set_epp_perf(int cpu, struct cppc_epp_perf_ctrls *perf_ctrls, bool enable);
+extern int cppc_get_auto_sel_caps(int cpunum, struct cppc_epp_perf_caps *perf_caps);
 extern int cppc_set_auto_sel(int cpu, bool enable);
 #else /* !CONFIG_ACPI_CPPC_LIB */
 static inline int cppc_get_desired_perf(int cpunum, u64 *desired_perf)
@@ -209,7 +225,7 @@ static inline int cpc_write_ffh(int cpun
 {
 	return -ENOTSUPP;
 }
-static inline int cppc_set_epp_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls, bool enable)
+static inline int cppc_set_epp_perf(int cpu, struct cppc_epp_perf_ctrls *perf_ctrls, bool enable)
 {
 	return -ENOTSUPP;
 }
@@ -221,7 +237,7 @@ static inline int cppc_set_auto_sel(int
 {
 	return -ENOTSUPP;
 }
-static inline int cppc_get_auto_sel_caps(int cpunum, struct cppc_perf_caps *perf_caps)
+static inline int cppc_get_auto_sel_caps(int cpunum, struct cppc_epp_perf_caps *perf_caps)
 {
 	return -ENOTSUPP;
 }
