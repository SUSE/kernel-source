From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for ieee80211 and co
Patch-mainline: Never, kABI workaround
References: bsc#1209980

Apply a few workarounds for keeping kABI compatibility:

- The standard __GENKSYMS__ workaround for kABI compatibility in ieee80211,
  cfg80211 and mac80211 stuff.

- Added ops_revision field to ieee80211_local for distinguishing the
  new ops; the enry function is modified to pass the revision number,
  and each accessor checks the revision number beforehand

- cfg80211_radar_event() is un-inlined again for providing kABI symbol.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 include/linux/ieee80211.h    |    2 ++
 include/net/cfg80211.h       |   12 +++++-------
 include/net/mac80211.h       |   19 ++++++++++++++++---
 include/uapi/linux/nl80211.h |    4 ++++
 net/mac80211/cfg.c           |    4 ++++
 net/mac80211/ieee80211_i.h   |    3 +++
 net/mac80211/main.c          |   18 +++++++++++++++---
 net/mac80211/rx.c            |    4 ++++
 net/mac80211/s1g.c           |    8 ++++++++
 net/wireless/mlme.c          |    8 ++++++++
 10 files changed, 69 insertions(+), 13 deletions(-)

--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -1296,10 +1296,12 @@ struct ieee80211_mgmt {
 					__le16 toa_error;
 					u8 variable[0];
 				} __packed ftm;
+#ifndef __GENKSYMS__
 				struct {
 					u8 action_code;
 					u8 variable[];
 				} __packed s1g;
+#endif
 			} u;
 		} __packed action;
 	} u;
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -4357,8 +4357,10 @@ struct cfg80211_ops {
 	int	(*color_change)(struct wiphy *wiphy,
 				struct net_device *dev,
 				struct cfg80211_color_change_settings *params);
+#ifndef __GENKSYMS__
 	int	(*set_radar_background)(struct wiphy *wiphy,
 					struct cfg80211_chan_def *chandef);
+#endif
 };
 
 /*
@@ -7551,13 +7553,9 @@ void __cfg80211_radar_event(struct wiphy
 			    struct cfg80211_chan_def *chandef,
 			    bool offchan, gfp_t gfp);
 
-static inline void
-cfg80211_radar_event(struct wiphy *wiphy,
-		     struct cfg80211_chan_def *chandef,
-		     gfp_t gfp)
-{
-	__cfg80211_radar_event(wiphy, chandef, false, gfp);
-}
+void cfg80211_radar_event(struct wiphy *wiphy,
+			  struct cfg80211_chan_def *chandef,
+			  gfp_t gfp);
 
 static inline void
 cfg80211_background_radar_event(struct wiphy *wiphy,
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -4274,6 +4274,7 @@ struct ieee80211_ops {
 	void (*sta_set_decap_offload)(struct ieee80211_hw *hw,
 				      struct ieee80211_vif *vif,
 				      struct ieee80211_sta *sta, bool enabled);
+#ifndef __GENKSYMS__
 	void (*add_twt_setup)(struct ieee80211_hw *hw,
 			      struct ieee80211_sta *sta,
 			      struct ieee80211_twt_setup *twt);
@@ -4281,6 +4282,7 @@ struct ieee80211_ops {
 				     struct ieee80211_sta *sta, u8 flowid);
 	int (*set_radar_background)(struct ieee80211_hw *hw,
 				    struct cfg80211_chan_def *chandef);
+#endif
 };
 
 /**
@@ -4299,9 +4301,20 @@ struct ieee80211_ops {
  *
  * Return: A pointer to the new hardware device, or %NULL on error.
  */
-struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
-					   const struct ieee80211_ops *ops,
-					   const char *requested_name);
+struct ieee80211_hw *__ieee80211_alloc_hw_nm(size_t priv_data_len,
+					     const struct ieee80211_ops *ops,
+					     const char *requested_name,
+					     unsigned char revision);
+
+/* FIXME: for SLE kABI compatibility */
+static inline struct ieee80211_hw *
+ieee80211_alloc_hw_nm_v2(size_t priv_data_len,
+			 const struct ieee80211_ops *ops,
+			 const char *requested_name)
+{
+	return __ieee80211_alloc_hw_nm(priv_data_len, ops, requested_name, 2);
+}
+#define ieee80211_alloc_hw_nm ieee80211_alloc_hw_nm_v2
 
 /**
  * ieee80211_alloc_hw - Allocate a new hardware device
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -3103,7 +3103,9 @@ enum nl80211_attrs {
 	NL80211_ATTR_COLOR_CHANGE_COLOR,
 	NL80211_ATTR_COLOR_CHANGE_ELEMS,
 
+#ifndef __GENKSYMS__
 	NL80211_ATTR_RADAR_BACKGROUND,
+#endif
 
 	/* add attributes here, update the policy in nl80211.c */
 
@@ -6072,7 +6074,9 @@ enum nl80211_ext_feature_index {
 	NL80211_EXT_FEATURE_SECURE_RTT,
 	NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE,
 	NL80211_EXT_FEATURE_BSS_COLOR,
+#ifndef __GENKSYMS__
 	NL80211_EXT_FEATURE_RADAR_BACKGROUND,
+#endif
 
 	/* add new features before the definition below */
 	NUM_NL80211_EXT_FEATURES,
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -4335,6 +4335,10 @@ ieee80211_set_radar_background(struct wi
 {
 	struct ieee80211_local *local = wiphy_priv(wiphy);
 
+	/* FIXME: SLE kABI compatibility check */
+	if (local->ops_revision < 2)
+		return -EOPNOTSUPP;
+
 	if (!local->ops->set_radar_background)
 		return -EOPNOTSUPP;
 
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -1220,6 +1220,9 @@ struct ieee80211_local {
 	/* protects active_txqs and txqi->schedule_order */
 	struct airtime_sched_info airtime[IEEE80211_NUM_ACS];
 	u16 airtime_flags;
+#ifndef __GENKSYMS__
+	u8 ops_revision; /* filled at padding; for kABI compatibility check */
+#endif
 	u32 aql_threshold;
 	atomic_t aql_total_pending_airtime;
 
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -540,9 +540,10 @@ static const struct ieee80211_vht_cap ma
 	},
 };
 
-struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
-					   const struct ieee80211_ops *ops,
-					   const char *requested_name)
+struct ieee80211_hw *__ieee80211_alloc_hw_nm(size_t priv_data_len,
+					     const struct ieee80211_ops *ops,
+					     const char *requested_name,
+					     unsigned char revision)
 {
 	struct ieee80211_local *local;
 	int priv_size, i;
@@ -650,6 +651,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
 
 	local->hw.priv = (char *)local + ALIGN(sizeof(*local), NETDEV_ALIGN);
 
+	local->ops_revision = revision; // FIXME: SLE kABI compatibility
 	local->ops = ops;
 	local->use_chanctx = use_chanctx;
 
@@ -772,6 +774,16 @@ struct ieee80211_hw *ieee80211_alloc_hw_
 	wiphy_free(wiphy);
 	return NULL;
 }
+EXPORT_SYMBOL(__ieee80211_alloc_hw_nm);
+
+/* FIXME: define ieee80211_alloc_hw_nm for kABI compatibility with GA version */
+#undef ieee80211_alloc_hw_nm
+struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
+					   const struct ieee80211_ops *ops,
+					   const char *requested_name)
+{
+	return __ieee80211_alloc_hw_nm(priv_data_len, ops, requested_name, 0);
+}
 EXPORT_SYMBOL(ieee80211_alloc_hw_nm);
 
 static int ieee80211_init_cipher_suites(struct ieee80211_local *local)
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -3270,6 +3270,10 @@ ieee80211_process_rx_twt_action(struct i
 	if (sdata->vif.type != NL80211_IFTYPE_AP)
 		return false;
 
+	/* FIXME: SLE kABI compatibility check */
+	if (rx->local->ops_revision < 2)
+		return false;
+
 	if (!rx->local->ops->add_twt_setup)
 		return false;
 
--- a/net/mac80211/s1g.c
+++ b/net/mac80211/s1g.c
@@ -153,6 +153,10 @@ void ieee80211_s1g_rx_twt_action(struct
 	struct ieee80211_local *local = sdata->local;
 	struct sta_info *sta;
 
+	/* FIXME: SLE kABI compatibility check */
+	if (local->ops_revision < 2)
+		return;
+
 	mutex_lock(&local->sta_mtx);
 
 	sta = sta_info_get_bss(sdata, mgmt->sa);
@@ -181,6 +185,10 @@ void ieee80211_s1g_status_twt_action(str
 	struct ieee80211_local *local = sdata->local;
 	struct sta_info *sta;
 
+	/* FIXME: SLE kABI compatibility check */
+	if (local->ops_revision < 2)
+		return;
+
 	mutex_lock(&local->sta_mtx);
 
 	sta = sta_info_get_bss(sdata, mgmt->da);
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -931,6 +931,14 @@ void __cfg80211_radar_event(struct wiphy
 }
 EXPORT_SYMBOL(__cfg80211_radar_event);
 
+void cfg80211_radar_event(struct wiphy *wiphy,
+			  struct cfg80211_chan_def *chandef,
+			  gfp_t gfp)
+{
+	__cfg80211_radar_event(wiphy, chandef, false, gfp);
+}
+EXPORT_SYMBOL(cfg80211_radar_event);
+
 void cfg80211_cac_event(struct net_device *netdev,
 			const struct cfg80211_chan_def *chandef,
 			enum nl80211_radar_event event, gfp_t gfp)
