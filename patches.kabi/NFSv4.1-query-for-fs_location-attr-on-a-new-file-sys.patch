From: NeilBrown <neilb@suse.com>
Subject: KABI FIX FOR: NFSv4.1 query for fs_location attr on a new file system
References: Never, kabi

Hide the new fields from kabi - it is at the end.
Add a magic cookie so that if some module does define one of these
ops structures, we can tell be the lack of a cooke, and ignore it.

If a module managed to allocate a structure that was followed
immediately by an invalid address, that would be awkward.  I cannot see
it happening though.

The change to nfs4_mig_recovery_ops is completely local to the nfsv4
module.  Nothing else can notice it.  It only affects kabi because there
is a pointer to it in a shared object.
So hide the change - it is irrelevant for practical purposes.

Signed-off-by: NeilBrown <neilb@suse.com>
---
 fs/nfs/client.c         |    1 +
 fs/nfs/nfs4_fs.h        |    5 +++++
 fs/nfs/nfs4proc.c       |    1 +
 include/linux/nfs_xdr.h |    8 ++++++++
 4 files changed, 15 insertions(+)

--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -859,6 +859,7 @@ int nfs_probe_fsinfo(struct nfs_server *
 	}
 
 	if (clp->rpc_ops->discover_trunking != NULL &&
+	    clp->rpc_ops->trunking_cookie == NFS_TRUNKING_COOKIE &&
 			(server->caps & NFS_CAP_FS_LOCATIONS &&
 			 (server->flags & NFS_MOUNT_TRUNK_DISCOVERY))) {
 		error = clp->rpc_ops->discover_trunking(server, mntfh);
--- a/fs/nfs/nfs4_fs.h
+++ b/fs/nfs/nfs4_fs.h
@@ -262,8 +262,13 @@ struct nfs4_state_maintenance_ops {
 };
 
 struct nfs4_mig_recovery_ops {
+#ifdef __GENKSYMS__
+	int (*get_locations)(struct inode *, struct nfs4_fs_locations *,
+		struct page *, const struct cred *);
+#else
 	int (*get_locations)(struct nfs_server *, struct nfs_fh *,
 		struct nfs4_fs_locations *, struct page *, const struct cred *);
+#endif
 	int (*fsid_present)(struct inode *, const struct cred *);
 };
 
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -10628,6 +10628,7 @@ const struct nfs_rpc_ops nfs_v4_clientop
 	.create_server	= nfs4_create_server,
 	.clone_server	= nfs_clone_server,
 	.discover_trunking = nfs4_discover_trunking,
+	.trunking_cookie = NFS_TRUNKING_COOKIE,
 	.enable_swap	= nfs4_enable_swap,
 	.disable_swap	= nfs4_disable_swap,
 };
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1805,7 +1805,15 @@ struct nfs_rpc_ops {
 	struct nfs_server *(*create_server)(struct fs_context *);
 	struct nfs_server *(*clone_server)(struct nfs_server *, struct nfs_fh *,
 					   struct nfs_fattr *, rpc_authflavor_t);
+#ifndef __GENKSYMS__
 	int	(*discover_trunking)(struct nfs_server *, struct nfs_fh *);
+	/* If trunking_cookie is not correct, this might
+	 * be in an external modules and discover_trunking
+	 * cannot be trusted.
+	 */
+	unsigned long long trunking_cookie;
+#define NFS_TRUNKING_COOKIE 0xbf18046af9c4dc73ULL
+#endif
 	void	(*enable_swap)(struct inode *inode);
 	void	(*disable_swap)(struct inode *inode);
 };
