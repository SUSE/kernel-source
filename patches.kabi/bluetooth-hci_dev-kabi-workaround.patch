From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for bluetooth hci_dev changes
Patch-mainline: Never, kABI workaround
References: CVE-2025-38250 bsc#1246182

The patch
  patches.suse/Bluetooth-hci_core-Fix-use-after-free-in-vhci_flush.patch
introduced a new field for SRCU in struct hci_dev that broke kABI.
Unfortunately struct hci_dev can't be resized because the private data
is put after this object.

Since SRCU sync is needed only for rare cases like reset and disconnect,
move it as a local common object instead of the embedded object, for
keeping kABI compatibility.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 include/net/bluetooth/hci_core.h |    2 --
 net/bluetooth/hci_core.c         |   16 +++++++---------
 2 files changed, 7 insertions(+), 11 deletions(-)

--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -29,7 +29,6 @@
 #include <linux/idr.h>
 #include <linux/leds.h>
 #include <linux/rculist.h>
-#include <linux/srcu.h>
 
 #include <net/bluetooth/hci.h>
 #include <net/bluetooth/hci_sync.h>
@@ -339,7 +338,6 @@ struct adv_monitor {
 
 struct hci_dev {
 	struct list_head list;
-	struct srcu_struct srcu;
 	struct mutex	lock;
 
 	struct ida	unset_handle_ida;
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -31,6 +31,7 @@
 #include <linux/crypto.h>
 #include <linux/kcov.h>
 #include <linux/property.h>
+#include <linux/srcu.h>
 #include <linux/suspend.h>
 #include <linux/wait.h>
 #include <linux/unaligned.h>
@@ -62,6 +63,9 @@ DEFINE_MUTEX(hci_cb_list_lock);
 /* HCI ID Numbering */
 static DEFINE_IDA(hci_index_ida);
 
+/* FIXME: global SRCU instead of hci_dev.srcu for kABI compatibility */
+DEFINE_STATIC_SRCU(__hci_dev_srcu);
+
 /* Get HCI device by index.
  * Device is held on return. */
 static struct hci_dev *__hci_dev_get(int index, int *srcu_index)
@@ -78,7 +82,7 @@ static struct hci_dev *__hci_dev_get(int
 		if (d->id == index) {
 			hdev = hci_dev_hold(d);
 			if (srcu_index)
-				*srcu_index = srcu_read_lock(&d->srcu);
+				*srcu_index = srcu_read_lock(&__hci_dev_srcu);
 			break;
 		}
 	}
@@ -98,7 +102,7 @@ static struct hci_dev *hci_dev_get_srcu(
 
 static void hci_dev_put_srcu(struct hci_dev *hdev, int srcu_index)
 {
-	srcu_read_unlock(&hdev->srcu, srcu_index);
+	srcu_read_unlock(&__hci_dev_srcu, srcu_index);
 	hci_dev_put(hdev);
 }
 
@@ -2457,11 +2461,6 @@ struct hci_dev *hci_alloc_dev_priv(int s
 	if (!hdev)
 		return NULL;
 
-	if (init_srcu_struct(&hdev->srcu)) {
-		kfree(hdev);
-		return NULL;
-	}
-
 	hdev->pkt_type  = (HCI_DM1 | HCI_DH1 | HCI_HV1);
 	hdev->esco_type = (ESCO_HV1);
 	hdev->link_mode = (HCI_LM_ACCEPT);
@@ -2706,8 +2705,7 @@ void hci_unregister_dev(struct hci_dev *
 	list_del(&hdev->list);
 	write_unlock(&hci_dev_list_lock);
 
-	synchronize_srcu(&hdev->srcu);
-	cleanup_srcu_struct(&hdev->srcu);
+	synchronize_srcu(&__hci_dev_srcu);
 
 	disable_work_sync(&hdev->rx_work);
 	disable_work_sync(&hdev->cmd_work);
