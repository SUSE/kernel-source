Subject: Kabi fix for ipv6: fix memory leak in fib6_rule_suppress
From: Davide Benini <davide.benini@suse.com>
Date: Fri Jun 14 17:20:34 CEST 2024
Patch-mainline: Never, kABI workaround
References: CVE-2021-47546 bsc#1225504

Commit "ipv6: fix memory leak in fib6_rule_suppress" added a `int flags`
argument to functions fib6_rule_suppress and fib4_rule_suppress.
To maintain compatibility with external modules, the "old" suppress pointer is
kept, and the new functions are called through a suppress_new pointer.

---
 include/net/fib_rules.h |   16 ++++++++++++----
 net/core/fib_rules.c    |   13 +++++++++++--
 net/ipv4/fib_rules.c    |   11 ++++++++++-
 net/ipv6/fib6_rules.c   |   20 +++++++++++++++++++-
 4 files changed, 52 insertions(+), 8 deletions(-)

--- a/include/net/fib_rules.h
+++ b/include/net/fib_rules.h
@@ -69,8 +69,8 @@ struct fib_rules_ops {
 	int			(*action)(struct fib_rule *,
 					  struct flowi *, int,
 					  struct fib_lookup_arg *);
-	bool			(*suppress)(struct fib_rule *, int,
-					    struct fib_lookup_arg *);
+ 	bool			(*suppress)(struct fib_rule *,
+ 					    struct fib_lookup_arg *);
 	int			(*match)(struct fib_rule *,
 					 struct flowi *, int);
 	int			(*configure)(struct fib_rule *,
@@ -96,6 +96,10 @@ struct fib_rules_ops {
 	struct module		*owner;
 	struct net		*fro_net;
 	struct rcu_head		rcu;
+#ifndef __GENKSYMS__
+	bool			(*suppress_new)(struct fib_rule *, int,
+					    struct fib_lookup_arg *);
+#endif
 };
 
 struct fib_rule_notifier_info {
@@ -218,9 +222,13 @@ INDIRECT_CALLABLE_DECLARE(int fib4_rule_
 			    struct fib_lookup_arg *arg));
 
 INDIRECT_CALLABLE_DECLARE(bool fib6_rule_suppress(struct fib_rule *rule,
-						int flags,
 						struct fib_lookup_arg *arg));
-INDIRECT_CALLABLE_DECLARE(bool fib4_rule_suppress(struct fib_rule *rule,
+INDIRECT_CALLABLE_DECLARE(bool fib6_rule_suppress_new(struct fib_rule *rule,
 						int flags,
+ 						struct fib_lookup_arg *arg));
+INDIRECT_CALLABLE_DECLARE(bool fib4_rule_suppress(struct fib_rule *rule,
 						struct fib_lookup_arg *arg));
+INDIRECT_CALLABLE_DECLARE(bool fib4_rule_suppress_new(struct fib_rule *rule,
+						int flags,
+ 						struct fib_lookup_arg *arg));
 #endif
--- a/net/core/fib_rules.c
+++ b/net/core/fib_rules.c
@@ -319,11 +319,20 @@ jumped:
 					       fib6_rule_action,
 					       fib4_rule_action,
 					       rule, fl, flags, arg);
-
+#ifndef __GENKSYMS__
+		if (!err && ops->suppress_new && INDIRECT_CALL_MT(ops->suppress_new,
+							      fib6_rule_suppress_new,
+							      fib4_rule_suppress_new,
+							      rule,
+							      flags,
+							      arg))
+#else
 		if (!err && ops->suppress && INDIRECT_CALL_MT(ops->suppress,
 							      fib6_rule_suppress,
 							      fib4_rule_suppress,
-							      rule, flags, arg))
+							      rule,
+							      arg))
+#endif
 			continue;
 
 		if (err != -EAGAIN) {
--- a/net/ipv4/fib_rules.c
+++ b/net/ipv4/fib_rules.c
@@ -140,7 +140,7 @@ INDIRECT_CALLABLE_SCOPE int fib4_rule_ac
 	return err;
 }
 
-INDIRECT_CALLABLE_SCOPE bool fib4_rule_suppress(struct fib_rule *rule,
+INDIRECT_CALLABLE_SCOPE bool fib4_rule_suppress_new(struct fib_rule *rule,
 						int flags,
 						struct fib_lookup_arg *arg)
 {
@@ -173,6 +173,12 @@ suppress_route:
 	return true;
 }
 
+INDIRECT_CALLABLE_SCOPE bool fib4_rule_suppress(struct fib_rule *rule,
+						struct fib_lookup_arg *arg)
+{
+	return fib4_rule_suppress_new(rule, 0, arg);
+}
+
 INDIRECT_CALLABLE_SCOPE int fib4_rule_match(struct fib_rule *rule,
 					    struct flowi *fl, int flags)
 {
@@ -388,6 +394,9 @@ static const struct fib_rules_ops __net_
 	.nlgroup	= RTNLGRP_IPV4_RULE,
 	.policy		= fib4_rule_policy,
 	.owner		= THIS_MODULE,
+#ifndef __GENKSYMS__
+	.suppress_new	= fib4_rule_suppress_new,
+#endif
 };
 
 static int fib_default_rules_init(struct fib_rules_ops *ops)
--- a/net/ipv6/fib6_rules.c
+++ b/net/ipv6/fib6_rules.c
@@ -266,7 +266,7 @@ INDIRECT_CALLABLE_SCOPE int fib6_rule_ac
 	return __fib6_rule_action(rule, flp, flags, arg);
 }
 
-INDIRECT_CALLABLE_SCOPE bool fib6_rule_suppress(struct fib_rule *rule,
+INDIRECT_CALLABLE_SCOPE bool fib6_rule_suppress_new(struct fib_rule *rule,
 						int flags,
 						struct fib_lookup_arg *arg)
 {
@@ -299,6 +299,21 @@ suppress_route:
 	return true;
 }
 
+INDIRECT_CALLABLE_SCOPE bool fib6_rule_suppress(struct fib_rule *rule,
+						struct fib_lookup_arg *arg)
+{
+	/*
+	 * The new fib6_rule_suppress_new is expecting to have a flags argument,
+	 * which I don't have here. To have the same behavior I had before, I
+	 * need to use the FIB_LOOKUP_NOREF bit of arg->flags to set the
+	 * RT6_LOOKUP_F_DST_NOREF bit of flags, as that bit will be checked.
+	 * Setting flags in this way, the ip6_rt_put_flags checks will be the same
+	 * as was done here
+	 */
+	int flags = ( !(arg->flags & FIB_LOOKUP_NOREF) ? 0 : RT6_LOOKUP_F_DST_NOREF);
+	return fib6_rule_suppress_new(rule, flags, arg);
+}
+
 INDIRECT_CALLABLE_SCOPE int fib6_rule_match(struct fib_rule *rule,
 					    struct flowi *fl, int flags)
 {
@@ -462,6 +477,9 @@ static const struct fib_rules_ops __net_
 	.policy			= fib6_rule_policy,
 	.owner			= THIS_MODULE,
 	.fro_net		= &init_net,
+#ifndef __GENKSYMS__
+	.suppress_new		= fib6_rule_suppress_new,
+#endif
 };
 
 static int __net_init fib6_rules_net_init(struct net *net)
