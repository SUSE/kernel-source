From: Shung-Hsi Yu <shung-hsi.yu@suse.com>
Subject: kABI: bpf: bpf_reg_state reorganization kABI workaround
Patch-mainline: never, kabi
References: bsc#1225903

Upstream commit a73bf9f2d969 ("bpf: reorganize struct bpf_reg_state fields")
moved the id and ref_obj_id fields after var_off and ranges (i.e
u32_max_value), breaking kABI.

Workaround the kABI breakage mostly by reverting commit a73bf9f2d969 ("bpf:
reorganize struct bpf_reg_state fields"). Restore id and ref_obj_id back to
their original position.

However, this requires extra care as changes after commit a73bf9f2d969 assumes
that operations like memcmp(rold, rcur, offsetof(struct bpf_reg_state, id))
takes var_off and ranges into account; but after we restore id and ref_obj_id
back to their original position this is no longer true. Further introduce
suse_regcmp() that compares var_off and ranges with memcmp() for this.

---
 include/linux/bpf_verifier.h |   40 ++++++++++++++++++++--------------------
 kernel/bpf/verifier.c        |   25 ++++++++++++++++++-------
 2 files changed, 38 insertions(+), 27 deletions(-)

--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@ -102,26 +102,6 @@ struct bpf_reg_state {
 
 		u32 subprogno; /* for PTR_TO_FUNC */
 	};
-	/* For scalar types (SCALAR_VALUE), this represents our knowledge of
-	 * the actual value.
-	 * For pointer types, this represents the variable part of the offset
-	 * from the pointed-to object, and is shared with all bpf_reg_states
-	 * with the same id as us.
-	 */
-	struct tnum var_off;
-	/* Used to determine if any memory access using this register will
-	 * result in a bad access.
-	 * These refer to the same value as var_off, not necessarily the actual
-	 * contents of the register.
-	 */
-	s64 smin_value; /* minimum possible (s64)value */
-	s64 smax_value; /* maximum possible (s64)value */
-	u64 umin_value; /* minimum possible (u64)value */
-	u64 umax_value; /* maximum possible (u64)value */
-	s32 s32_min_value; /* minimum possible (s32)value */
-	s32 s32_max_value; /* maximum possible (s32)value */
-	u32 u32_min_value; /* minimum possible (u32)value */
-	u32 u32_max_value; /* maximum possible (u32)value */
 	/* For PTR_TO_PACKET, used to find other pointers with the same variable
 	 * offset, so they can share range knowledge.
 	 * For PTR_TO_MAP_VALUE_OR_NULL this is used to share which map value we
@@ -174,6 +154,26 @@ struct bpf_reg_state {
 	 * allowed and has the same effect as bpf_sk_release(sk).
 	 */
 	u32 ref_obj_id;
+	/* For scalar types (SCALAR_VALUE), this represents our knowledge of
+	 * the actual value.
+	 * For pointer types, this represents the variable part of the offset
+	 * from the pointed-to object, and is shared with all bpf_reg_states
+	 * with the same id as us.
+	 */
+	struct tnum var_off;
+	/* Used to determine if any memory access using this register will
+	 * result in a bad access.
+	 * These refer to the same value as var_off, not necessarily the actual
+	 * contents of the register.
+	 */
+	s64 smin_value; /* minimum possible (s64)value */
+	s64 smax_value; /* maximum possible (s64)value */
+	u64 umin_value; /* minimum possible (u64)value */
+	u64 umax_value; /* maximum possible (u64)value */
+	s32 s32_min_value; /* minimum possible (s32)value */
+	s32 s32_max_value; /* maximum possible (s32)value */
+	u32 u32_min_value; /* minimum possible (u32)value */
+	u32 u32_max_value; /* maximum possible (u32)value */
 	/* parentage chain for liveness checking */
 	struct bpf_reg_state *parent;
 	/* Inside the callee two registers can be both PTR_TO_STACK like
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -1736,11 +1736,9 @@ static void ___mark_reg_known(struct bpf
  */
 static void __mark_reg_known(struct bpf_reg_state *reg, u64 imm)
 {
-	/* Clear off and union(map_ptr, range) */
+	/* Clear id, off and union(map_ptr, range) */
 	memset(((u8 *)reg) + sizeof(reg->type), 0,
 	       offsetof(struct bpf_reg_state, var_off) - sizeof(reg->type));
-	reg->id = 0;
-	reg->ref_obj_id = 0;
 	___mark_reg_known(reg, imm);
 }
 
@@ -2083,13 +2081,11 @@ static void __mark_reg_unknown(const str
 			       struct bpf_reg_state *reg)
 {
 	/*
-	 * Clear type, off, and union(map_ptr, range) and
+	 * Clear type, id, off, and union(map_ptr, range) and
 	 * padding between 'type' and union
 	 */
 	memset(reg, 0, offsetof(struct bpf_reg_state, var_off));
 	reg->type = SCALAR_VALUE;
-	reg->id = 0;
-	reg->ref_obj_id = 0;
 	reg->var_off = tnum_unknown;
 	reg->frameno = 0;
 	reg->precise = !env->bpf_capable;
@@ -12727,11 +12723,25 @@ next:
 	}
 }
 
+static bool suse_regcmp(const struct bpf_reg_state *rold,
+			const struct bpf_reg_state *rcur)
+{
+	/* Compare var_off and ranges with respect to kABI workaround for
+	 * bpf_reg_state.
+	 */
+	const size_t var_off_offset = offsetof(struct bpf_reg_state, var_off);
+	u8 * const rold_vals = ((u8*)rold) + var_off_offset;
+	u8 * const rcur_vals = ((u8*)rcur) + var_off_offset;
+
+	return memcmp(rold_vals, rcur_vals, offsetof(struct bpf_reg_state, parent) - var_off_offset) == 0;
+}
+
 static bool regs_exact(const struct bpf_reg_state *rold,
 		       const struct bpf_reg_state *rcur,
 		       struct bpf_idmap *idmap)
 {
 	return memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 && 
+	       suse_regcmp(rold, rcur) &&
 	       check_ids(rold->id, rcur->id, idmap) &&
 	       check_ids(rold->ref_obj_id, rcur->ref_obj_id, idmap);
 }
@@ -12783,6 +12793,7 @@ static bool regsafe(struct bpf_verifier_
 			 * logic and requires everything to be strict
 			 */
 			return memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&
+			       suse_regcmp(rold, rcur) &&
 			       check_scalar_ids(rold->id, rcur->id, idmap);
 		}
 		if (!rold->precise)
@@ -12819,7 +12830,7 @@ static bool regsafe(struct bpf_verifier_
 		/* If the new min/max/var_off satisfy the old ones and
 		 * everything else matches, we are OK.
 		 */
-		return memcmp(rold, rcur, offsetof(struct bpf_reg_state, var_off)) == 0 &&
+		return memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&
 		       range_within(rold, rcur) &&
 		       tnum_in(rold->var_off, rcur->var_off) &&
 		       check_ids(rold->id, rcur->id, idmap);
