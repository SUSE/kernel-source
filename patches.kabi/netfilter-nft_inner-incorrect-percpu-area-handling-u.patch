From: Davide Benini <davide.benini@suse.com>
Date: Fri Feb 28 10:58:11 2025 +0100
Subject: kABI fix for "netfilter: nft_inner: incorrect percpu area handling under softirq"
References: CVE-2024-56638 bsc#1235524
Patch-mainline: Never, kABI workaround

As the nft_meta_inner_eval() is exported, I wrap the nft_inner_tun_ctx in a 
struct nft_inner_tun_ctx_extended {
	unsigned long cookie;
	struct nft_inner_tun_ctx nft_inner_tun_ctx;
};


Signed-off-by: Davide Benini <davide.benini@suse.com>

---
 include/net/netfilter/nf_tables_core.h |    1 
 net/netfilter/nft_inner.c              |   52 +++++++++++++++++++--------------
 2 files changed, 30 insertions(+), 23 deletions(-)

--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -161,7 +161,6 @@ enum {
 };
 
 struct nft_inner_tun_ctx {
-	unsigned long cookie;
 	u16	type;
 	u16	inner_tunoff;
 	u16	inner_lloff;
--- a/net/netfilter/nft_inner.c
+++ b/net/netfilter/nft_inner.c
@@ -23,7 +23,12 @@
 #include <linux/ip.h>
 #include <linux/ipv6.h>
 
-static DEFINE_PER_CPU(struct nft_inner_tun_ctx, nft_pcpu_tun_ctx);
+struct nft_inner_tun_ctx_extended {
+	unsigned long cookie;
+	struct nft_inner_tun_ctx nft_inner_tun_ctx;
+};
+
+static DEFINE_PER_CPU(struct nft_inner_tun_ctx_extended, nft_pcpu_tun_ctx_extended);
 
 /* Same layout as nft_expr but it embeds the private expression data area. */
 struct __nft_expr {
@@ -208,9 +213,11 @@ static int nft_inner_parse_tunhdr(const
 
 static int nft_inner_parse(const struct nft_inner *priv,
 			   struct nft_pktinfo *pkt,
-			   struct nft_inner_tun_ctx *tun_ctx)
+			   struct nft_inner_tun_ctx_extended *tun_ctx_extended)
 {
 	u32 off = pkt->inneroff;
+	struct nft_inner_tun_ctx *tun_ctx = &tun_ctx_extended->nft_inner_tun_ctx;
+
 
 	if (priv->flags & NFT_INNER_HDRSIZE &&
 	    nft_inner_parse_tunhdr(priv, pkt, tun_ctx, &off) < 0)
@@ -225,52 +232,52 @@ static int nft_inner_parse(const struct
 	}
 
 	tun_ctx->type = priv->type;
-	tun_ctx->cookie = (unsigned long)pkt->skb;
+	tun_ctx_extended->cookie = (unsigned long)pkt->skb;
 	pkt->flags |= NFT_PKTINFO_INNER_FULL;
 
 	return 0;
 }
 
 static bool nft_inner_restore_tun_ctx(const struct nft_pktinfo *pkt,
-				      struct nft_inner_tun_ctx *tun_ctx)
+				      struct nft_inner_tun_ctx_extended *tun_ctx_ext)
 {
-	struct nft_inner_tun_ctx *this_cpu_tun_ctx;
+	struct nft_inner_tun_ctx_extended *this_cpu_tun_ctx_extended;
 
 	local_bh_disable();
-	this_cpu_tun_ctx = this_cpu_ptr(&nft_pcpu_tun_ctx);
-	if (this_cpu_tun_ctx->cookie != (unsigned long)pkt->skb) {
+	this_cpu_tun_ctx_extended = this_cpu_ptr(&nft_pcpu_tun_ctx_extended);
+	if (this_cpu_tun_ctx_extended->cookie != (unsigned long)pkt->skb) {
 		local_bh_enable();
 		return false;
 	}
-	*tun_ctx = *this_cpu_tun_ctx;
+	*tun_ctx_ext = *this_cpu_tun_ctx_extended;
 	local_bh_enable();
 
 	return true;
 }
 
 static void nft_inner_save_tun_ctx(const struct nft_pktinfo *pkt,
-				   const struct nft_inner_tun_ctx *tun_ctx)
+				   const struct nft_inner_tun_ctx_extended *tun_ctx_ext)
 {
-	struct nft_inner_tun_ctx *this_cpu_tun_ctx;
+	struct nft_inner_tun_ctx_extended *this_cpu_tun_ctx_extended;
 
 	local_bh_disable();
-	this_cpu_tun_ctx = this_cpu_ptr(&nft_pcpu_tun_ctx);
-	if (this_cpu_tun_ctx->cookie != tun_ctx->cookie)
-		*this_cpu_tun_ctx = *tun_ctx;
+	this_cpu_tun_ctx_extended = this_cpu_ptr(&nft_pcpu_tun_ctx_extended);
+	if (this_cpu_tun_ctx_extended->cookie != tun_ctx_ext->cookie)
+		*this_cpu_tun_ctx_extended = *tun_ctx_ext;
 	local_bh_enable();
 }
 
 static bool nft_inner_parse_needed(const struct nft_inner *priv,
 				   const struct nft_pktinfo *pkt,
-				   struct nft_inner_tun_ctx *tun_ctx)
+				   struct nft_inner_tun_ctx_extended *tun_ctx_ext)
 {
 	if (!(pkt->flags & NFT_PKTINFO_INNER_FULL))
 		return true;
 
-	if (!nft_inner_restore_tun_ctx(pkt, tun_ctx))
+	if (!nft_inner_restore_tun_ctx(pkt, tun_ctx_ext))
 		return true;
 
-	if (priv->type != tun_ctx->type)
+	if (priv->type != tun_ctx_ext->nft_inner_tun_ctx.type)
 		return true;
 
 	return false;
@@ -280,27 +287,28 @@ static void nft_inner_eval(const struct
 			   const struct nft_pktinfo *pkt)
 {
 	const struct nft_inner *priv = nft_expr_priv(expr);
-	struct nft_inner_tun_ctx tun_ctx = {};
+	struct nft_inner_tun_ctx_extended tun_ctx_ext = {};
+	struct nft_inner_tun_ctx *tun_ctx = &tun_ctx_ext.nft_inner_tun_ctx;
 
 	if (nft_payload_inner_offset(pkt) < 0)
 		goto err;
 
-	if (nft_inner_parse_needed(priv, pkt, &tun_ctx) &&
-	    nft_inner_parse(priv, (struct nft_pktinfo *)pkt, &tun_ctx) < 0)
+	if (nft_inner_parse_needed(priv, pkt, &tun_ctx_ext) &&
+	    nft_inner_parse(priv, (struct nft_pktinfo *)pkt, &tun_ctx_ext) < 0)
 		goto err;
 
 	switch (priv->expr_type) {
 	case NFT_INNER_EXPR_PAYLOAD:
-		nft_payload_inner_eval((struct nft_expr *)&priv->expr, regs, pkt, &tun_ctx);
+		nft_payload_inner_eval((struct nft_expr *)&priv->expr, regs, pkt, tun_ctx);
 		break;
 	case NFT_INNER_EXPR_META:
-		nft_meta_inner_eval((struct nft_expr *)&priv->expr, regs, pkt, &tun_ctx);
+		nft_meta_inner_eval((struct nft_expr *)&priv->expr, regs, pkt, tun_ctx);
 		break;
 	default:
 		WARN_ON_ONCE(1);
 		goto err;
 	}
-	nft_inner_save_tun_ctx(pkt, &tun_ctx);
+	nft_inner_save_tun_ctx(pkt, &tun_ctx_ext);
 
 	return;
 err:
