From: Shung-Hsi Yu <shung-hsi.yu@suse.com>
Subject: kABI: bpf: struct bpf_insn_aux_data kABI workaround
Patch-mainline: never, kabi
References: bsc#1225756 bsc#1225903

This kABI workaround deals with the following changes in struct
bpf_insn_aux_data:
- Upstream commit bffdeaa8a5af ("bpf: decouple prune and jump points") that was
  backoprted as context of 3feb263bb516 ("bpf: handle ldimm64 properly in
  check_cfg()") breaks kABI by adding a "bool jmp_point" field in "struct
  bpf_insn_aux_data"
- Upstream commit 4b5ce570dbef ("bpf: ensure state checkpointing at iter_next()
  call sites") move the "bool prune_point" after "bool jmp_point" as well as
  adding "bool force_checkpoint" as the last field
- Upstream commit ab5cfac139ab ("bpf: verify callbacks as if they are called
  unknown number of times") added a "bool calls_callback" field

Luckily bpf_insn_aux_data are accessed through pointers, so just restore
prune_point to the original position, and simply hiding jmp_point and
and other new fields from genksyms.

Signed-off-by: Shung-Hsi Yu <shung-hsi.yu@suse.com>
---
 include/linux/bpf_verifier.h |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@ -441,8 +441,9 @@ struct bpf_insn_aux_data {
 
 	/* below fields are initialized once */
 	unsigned int orig_idx; /* original instruction index */
-	bool jmp_point;
 	bool prune_point;
+#ifndef __GENKSYMS__
+	bool jmp_point;
 	/* ensure we check state equivalence and save state checkpoint and
 	 * this instruction, regardless of any heuristics
 	 */
@@ -451,6 +452,7 @@ struct bpf_insn_aux_data {
 	 * accepts callback function as a parameter.
 	 */
 	bool calls_callback;
+#endif
 };
 
 #define MAX_USED_MAPS 64 /* max number of maps accessed by one eBPF program */
