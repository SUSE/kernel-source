From: Shung-Hsi Yu <shung-hsi.yu@suse.com>
Subject: kABI: bpf: struct bpf_insn_aux_data kABI workaround
Patch-mainline: never, kabi
References: bsc#1225756 bsc#1225903

Upstream commit bffdeaa8a5af ("bpf: decouple prune and jump points") that was
backoprted as context of 3feb263bb516 ("bpf: handle ldimm64 properly in
check_cfg()") breaks kABI by adding a "bool jmp_point" field in "struct
bpf_insn_aux_data".

Later upstream commit 4b5ce570dbef ("bpf: ensure state checkpointing at iter_next()
call sites") move the "bool prune_point" after "bool jmp_point" as well as adding "bool force_checkpoint" as the last field.

Luckily bpf_insn_aux_data are accessed through pointers, so just restore
prune_point to the original position, and simply hiding jmp_point and
force_checkpoint from genksyms.

Signed-off-by: Shung-Hsi Yu <shung-hsi.yu@suse.com>
---
 include/linux/bpf_verifier.h |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@ -421,12 +421,14 @@ struct bpf_insn_aux_data {
 
 	/* below fields are initialized once */
 	unsigned int orig_idx; /* original instruction index */
-	bool jmp_point;
 	bool prune_point;
+#ifndef __GENKSYMS__
+	bool jmp_point;
 	/* ensure we check state equivalence and save state checkpoint and
 	 * this instruction, regardless of any heuristics
 	 */
 	bool force_checkpoint;
+#endif
 };
 
 #define MAX_USED_MAPS 64 /* max number of maps accessed by one eBPF program */
