From c96f563a96a158edd4a3a56cf46db972449ad278 Mon Sep 17 00:00:00 2001
From: Oliver Neukum <oneukum@suse.com>
Date: Tue, 7 Oct 2025 14:28:15 +0200
Subject: [PATCH] usb: xhci: Limit Stop Endpoint retries
Patch-mainline: Never (kABI fixup)
References: git-fixes

struct xhci_virt_device contains an array
of struct suse_xhci_virt_ep. Hence it cannot be just
elongated. As this has to go into SP7
I dare not just convert the padding.
Allocate a custom extension allocated and freed
together with struct xhci_virt_device.

This is ultimately needed for
8f5b7e2bec1c36578fdaa74a6951833541103e27
which is a real bug hitting people.

Signed-off-by: Oliver Neukum <oneukum@suse.com>
Reviewed-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/usb/host/xhci-mem.c  | 13 ++++++++++++-
 drivers/usb/host/xhci-ring.c |  2 +-
 drivers/usb/host/xhci.c      |  2 +-
 drivers/usb/host/xhci.h      |  9 ++++++++-
 4 files changed, 22 insertions(+), 4 deletions(-)

diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 353cc1d7e..996a9e0b6 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -902,6 +902,8 @@ void xhci_free_virt_device(struct xhci_hcd *xhci, struct xhci_virt_device *dev,
 		dev->udev->slot_id = 0;
 	if (xhci->devs[slot_id] == dev)
 		xhci->devs[slot_id] = NULL;
+	for (i = 0 ; i < EP_CTX_PER_DEV; i++)
+		kfree(dev->eps[i].suse_extension);
 	kfree(dev);
 }
 
@@ -988,6 +990,14 @@ int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id,
 		INIT_LIST_HEAD(&dev->eps[i].bw_endpoint_list);
 	}
 
+	for (i = 0; i < EP_CTX_PER_DEV; i++) {
+		dev->eps[i].suse_extension = kzalloc(
+				sizeof(struct suse_xhci_virt_ep_extension),
+				flags);
+		if (!dev->eps[i].suse_extension)
+			goto fail;
+	}
+
 	/* Allocate endpoint 0 ring */
 	dev->eps[0].ring = xhci_ring_alloc(xhci, 2, 1, TYPE_CTRL, 0, flags);
 	if (!dev->eps[0].ring)
@@ -1008,7 +1018,8 @@ int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id,
 
 	return 1;
 fail:
-
+	for (i = 0; i < EP_CTX_PER_DEV; i++)
+		kfree(dev->eps[i].suse_extension);
 	if (dev->in_ctx)
 		xhci_free_container_ctx(xhci, dev->in_ctx);
 	if (dev->out_ctx)
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 01332a1df..cedc54db3 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -1232,7 +1232,7 @@ static void xhci_handle_cmd_stop_ep(struct xhci_hcd *xhci, int slot_id,
 			 */
 			if (!(xhci->quirks & XHCI_NEC_HOST))
 				break;
-			if (time_is_before_jiffies(ep->stop_time + msecs_to_jiffies(100)))
+			if (time_is_before_jiffies(ep->suse_extension->stop_time + msecs_to_jiffies(100)))
 				break;
 			fallthrough;
 		case EP_STATE_RUNNING:
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 686a714d6..1ba20e44f 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -1764,7 +1764,7 @@ static int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			ret = -ENOMEM;
 			goto done;
 		}
-		ep->stop_time = jiffies;
+		ep->suse_extension->stop_time = jiffies;
 		ep->ep_state |= EP_STOP_CMD_PENDING;
 		xhci_queue_stop_endpoint(xhci, command, urb->dev->slot_id,
 					 ep_index, 0);
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e03b17c94..d5ddbf24e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -929,6 +929,10 @@ struct xhci_bw_info {
 #define HS_BW_RESERVED		20
 #define SS_BW_RESERVED		10
 
+struct suse_xhci_virt_ep_extension {
+	unsigned long		stop_time;
+};
+
 struct xhci_virt_ep {
 	struct xhci_virt_device		*vdev;	/* parent */
 	unsigned int			ep_index;
@@ -973,12 +977,15 @@ struct xhci_virt_ep {
 	/* Bandwidth checking storage */
 	struct xhci_bw_info	bw_info;
 	struct list_head	bw_endpoint_list;
-	unsigned long		stop_time;
 	/* Isoch Frame ID checking storage */
 	int			next_frame_id;
 	/* Use new Isoch TRB layout needed for extended TBC support */
 	bool			use_extended_tbc;
+#ifdef __GENKSYMS__
 	void *suse_kabi_padding;
+#else
+	struct suse_xhci_virt_ep_extension *suse_extension;
+#endif
 };
 
 enum xhci_overhead_type {
-- 
2.51.0

