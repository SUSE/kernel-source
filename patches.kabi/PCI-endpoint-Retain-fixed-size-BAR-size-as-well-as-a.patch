From: Jiri Slaby <jslaby@suse.cz>
Subject: kABI: PCI: endpoint: Retain fixed-size BAR size as well as aligned size
Patch-mainline: never, kabi
References: git-fixes

Commit 793908d60b87 (PCI: endpoint: Retain fixed-size BAR size as well
as aligned size) added an aligned_size into struct pci_epf_bar. This
broke kabi for already built modules.

struct pci_epf_bar is embedded into struct pci_epf. That is allocated
and freed by pci_epf_create() and pci_epf_dev_release(), respectively.

So we can add these members to the end of struct pci_epf, adapt the code
and hide it via __GENKSYMS__.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/pci/endpoint/pci-epf-core.c |   12 +++++++++---
 include/linux/pci-epf.h             |    5 ++++-
 2 files changed, 13 insertions(+), 4 deletions(-)

--- a/drivers/pci/endpoint/pci-epf-core.c
+++ b/drivers/pci/endpoint/pci-epf-core.c
@@ -223,6 +223,7 @@ void pci_epf_free_space(struct pci_epf *
 	struct device *dev;
 	struct pci_epf_bar *epf_bar;
 	struct pci_epc *epc;
+	size_t *p_aligned_size;
 
 	if (!addr)
 		return;
@@ -230,19 +231,21 @@ void pci_epf_free_space(struct pci_epf *
 	if (type == PRIMARY_INTERFACE) {
 		epc = epf->epc;
 		epf_bar = epf->bar;
+		p_aligned_size = &epf->bar_aligned_size[bar];
 	} else {
 		epc = epf->sec_epc;
 		epf_bar = epf->sec_epc_bar;
+		p_aligned_size = &epf->sec_bar_aligned_size[bar];
 	}
 
 	dev = epc->dev.parent;
-	dma_free_coherent(dev, epf_bar[bar].aligned_size, addr,
+	dma_free_coherent(dev, *p_aligned_size, addr,
 			  epf_bar[bar].phys_addr);
 
 	epf_bar[bar].phys_addr = 0;
 	epf_bar[bar].addr = NULL;
 	epf_bar[bar].size = 0;
-	epf_bar[bar].aligned_size = 0;
+	*p_aligned_size = 0;
 	epf_bar[bar].barno = 0;
 	epf_bar[bar].flags = 0;
 }
@@ -270,6 +273,7 @@ void *pci_epf_alloc_space(struct pci_epf
 	dma_addr_t phys_addr;
 	struct pci_epc *epc;
 	struct device *dev;
+	size_t *p_aligned_size;
 	void *space;
 
 	if (size < 128)
@@ -298,9 +302,11 @@ void *pci_epf_alloc_space(struct pci_epf
 	if (type == PRIMARY_INTERFACE) {
 		epc = epf->epc;
 		epf_bar = epf->bar;
+		p_aligned_size = &epf->bar_aligned_size[bar];
 	} else {
 		epc = epf->sec_epc;
 		epf_bar = epf->sec_epc_bar;
+		p_aligned_size = &epf->sec_bar_aligned_size[bar];
 	}
 
 	dev = epc->dev.parent;
@@ -313,7 +319,7 @@ void *pci_epf_alloc_space(struct pci_epf
 	epf_bar[bar].phys_addr = phys_addr;
 	epf_bar[bar].addr = space;
 	epf_bar[bar].size = size;
-	epf_bar[bar].aligned_size = aligned_size;
+	*p_aligned_size = aligned_size;
 	epf_bar[bar].barno = bar;
 	if (upper_32_bits(size) || epc_features->bar[bar].only_64bit)
 		epf_bar[bar].flags |= PCI_BASE_ADDRESS_MEM_TYPE_64;
--- a/include/linux/pci-epf.h
+++ b/include/linux/pci-epf.h
@@ -123,7 +123,6 @@ struct pci_epf_bar {
 	dma_addr_t	phys_addr;
 	void		*addr;
 	size_t		size;
-	size_t		aligned_size;
 	enum pci_barno	barno;
 	int		flags;
 };
@@ -185,6 +184,10 @@ struct pci_epf {
 	unsigned long		vfunction_num_map;
 	struct list_head	pci_vepf;
 	const struct pci_epc_event_ops *event_ops;
+#ifndef __GENKSYMS__
+	size_t			bar_aligned_size[6];
+	size_t			sec_bar_aligned_size[6];
+#endif
 };
 
 /**
