From: Petr Tesarik <ptesarik@suse.com>
Date: Thue, 26 Jun 2025 13:11:31 +0200
Subject: kabi: add struct cgroup_extra
Patch-mainline: Never, kabi workaround
References: bsc#1247963

New fields cannot be added to struct cgroup, but since this structure is
always allocated dynamically by cgroup_create(), new fields can be added
at the end.

However, struct cgroup ends with a flexible array, and new fields should
be added _after_ that flexible array. So, allocate an additional struct
cgroup_extra and provide a helper to get its address,

Then there are root cgroups. They are embedded inside struct cgroup_root,
which must not change layout either. So, add the extra field to the end
of struct cgroup_root and make it a special case.

Oh, the joys of stable kABI...

Signed-off-by: Petr Tesarik <ptesarik@suse.com>
---
 include/linux/cgroup-defs.h |   32 +++++++++++++++++++++++++-------
 kernel/cgroup/cgroup.c      |    2 +-
 kernel/cgroup/rstat.c       |   12 ++++++------
 3 files changed, 32 insertions(+), 14 deletions(-)

--- a/include/linux/cgroup-defs.h
+++ b/include/linux/cgroup-defs.h
@@ -477,13 +477,6 @@ struct cgroup {
 	struct cgroup_rstat_cpu __percpu *rstat_cpu;
 	struct list_head rstat_css_list;
 
-	/*
-	 * A singly-linked list of cgroup structures to be rstat flushed.
-	 * This is a scratch field to be used exclusively by
-	 * cgroup_rstat_flush_locked() and protected by cgroup_rstat_lock.
-	 */
-	struct cgroup	*rstat_flush_next;
-
 	/* cgroup basic resource statistics */
 	struct cgroup_base_stat last_bstat;
 	struct cgroup_base_stat bstat;
@@ -522,6 +515,22 @@ struct cgroup {
 	struct cgroup *ancestors[];
 };
 
+#define struct_cgroup_size(level) \
+	struct_size_t(struct cgroup, ancestors, (level) + 1)
+
+/* Extra fields added to struct cgroup, but moved to a separate
+ * struct to preserve kABI. These extra fields are allocated after
+ * the ancestors[] flexible array in struct cgroup.
+ */
+struct cgroup_extra {
+	/*
+	 * A singly-linked list of cgroup structures to be rstat flushed.
+	 * This is a scratch field to be used exclusively by
+	 * cgroup_rstat_flush_locked() and protected by cgroup_rstat_lock.
+	 */
+	struct cgroup	*rstat_flush_next;
+};
+
 /*
  * A cgroup_root represents the root of a cgroup hierarchy, and may be
  * associated with a kernfs_root to form an active hierarchy.  This is
@@ -562,9 +571,18 @@ struct cgroup_root {
 	char name[MAX_CGROUP_ROOT_NAMELEN];
 #ifndef __GENKSYMS__
 	struct rcu_head rcu;
+	struct cgroup_extra extra;
 #endif
 };
 
+static inline struct cgroup_extra *cgroup_extra(struct cgroup *cgrp)
+{
+	if (!cgrp->level)
+		return &container_of(cgrp, struct cgroup_root, cgrp)->extra;
+	else
+		return (void *)&cgrp->ancestors[cgrp->level+1];
+}
+
 /*
  * struct cftype: handler definitions for cgroup control files
  *
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@ -5664,7 +5664,7 @@ static struct cgroup *cgroup_create(stru
 	int ret;
 
 	/* allocate the cgroup and its ID, 0 is reserved for the root */
-	cgrp = kzalloc(struct_size(cgrp, ancestors, (level + 1)), GFP_KERNEL);
+	cgrp = kzalloc(struct_cgroup_size(level) + sizeof(struct cgroup_extra), GFP_KERNEL);
 	if (!cgrp)
 		return ERR_PTR(-ENOMEM);
 
--- a/kernel/cgroup/rstat.c
+++ b/kernel/cgroup/rstat.c
@@ -93,24 +93,24 @@ static struct cgroup *cgroup_rstat_push_
 	struct cgroup *parent, *grandchild;
 	struct cgroup_rstat_cpu *crstatc;
 
-	child->rstat_flush_next = NULL;
+	cgroup_extra(child)->rstat_flush_next = NULL;
 
 next_level:
 	while (chead) {
 		child = chead;
-		chead = child->rstat_flush_next;
+		chead = cgroup_extra(child)->rstat_flush_next;
 		parent = cgroup_parent(child);
 
 		/* updated_next is parent cgroup terminated */
 		while (child != parent) {
-			child->rstat_flush_next = head;
+			cgroup_extra(child)->rstat_flush_next = head;
 			head = child;
 			crstatc = cgroup_rstat_cpu(child, cpu);
 			grandchild = crstatc->updated_children;
 			if (grandchild != child) {
 				/* Push the grand child to the next level */
 				crstatc->updated_children = child;
-				grandchild->rstat_flush_next = ghead;
+				cgroup_extra(grandchild)->rstat_flush_next = ghead;
 				ghead = grandchild;
 			}
 			child = crstatc->updated_next;
@@ -190,7 +190,7 @@ static struct cgroup *cgroup_rstat_updat
 
 	/* Push @root to the list first before pushing the children */
 	head = root;
-	root->rstat_flush_next = NULL;
+	cgroup_extra(root)->rstat_flush_next = NULL;
 	child = rstatc->updated_children;
 	rstatc->updated_children = root;
 	if (child != root)
@@ -236,7 +236,7 @@ static void cgroup_rstat_flush_locked(st
 	for_each_possible_cpu(cpu) {
 		struct cgroup *pos = cgroup_rstat_updated_list(cgrp, cpu);
 
-		for (; pos; pos = pos->rstat_flush_next) {
+		for (; pos; pos = cgroup_extra(pos)->rstat_flush_next) {
 			struct cgroup_subsys_state *css;
 
 			cgroup_base_stat_flush(pos, cpu);
