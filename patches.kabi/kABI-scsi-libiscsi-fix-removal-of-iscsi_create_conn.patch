From: Lee Duncan <lduncan@suse.com>
Date: Mon 29 Aug 2022 08:54:21 AM PDT
Subject: [PATCH] kABI: scsi: libiscsi: fix removal of iscsi_create_conn
Patch-mainline: Never, kABI fix
References: bsc#1198410

Patch scsi-libiscsi-Add-iscsi_cls_conn-to-sysfs-after-initialization.patch
removed iscsi_create_conn() since it was no longer used, but this patch
puts it back, in case any external module expects it to be present,
for kABI compatability.
---
 drivers/scsi/scsi_transport_iscsi.c |   78 ++++++++++++++++++++++++++++++++++++
 1 file changed, 78 insertions(+)

--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -2517,6 +2517,84 @@ void iscsi_remove_conn(struct iscsi_cls_
 }
 EXPORT_SYMBOL_GPL(iscsi_remove_conn);
 
+ /**
+ * iscsi_create_conn - create iscsi class connection
+ * @session: iscsi cls session
+ * @dd_size: private driver data size
+ * @cid: connection id
+ *
+ * This can be called from a LLD or iscsi_transport. The connection
+ * is child of the session so cid must be unique for all connections
+ * on the session.
+ *
+ * Since we do not support MCS, cid will normally be zero. In some cases
+ * for software iscsi we could be trying to preallocate a connection struct
+ * in which case there could be two connection structs and cid would be
+ * non-zero.
+ *
+ * NOTE: This is here for kABI compatability
+ */
+struct iscsi_cls_conn *
+iscsi_create_conn(struct iscsi_cls_session *session, int dd_size, uint32_t cid)
+{
+	struct iscsi_transport *transport = session->transport;
+	struct iscsi_cls_conn *conn;
+	unsigned long flags;
+	int err;
+
+	conn = kzalloc(sizeof(*conn) + dd_size, GFP_KERNEL);
+	if (!conn)
+		return NULL;
+	if (dd_size)
+		conn->dd_data = &conn[1];
+
+	mutex_init(&conn->ep_mutex);
+	INIT_LIST_HEAD(&conn->conn_list);
+	INIT_WORK(&conn->cleanup_work, iscsi_cleanup_conn_work_fn);
+	conn->transport = transport;
+	conn->cid = cid;
+	conn->state = ISCSI_CONN_DOWN;
+
+	/* this is released in the dev's release function */
+	if (!get_device(&session->dev))
+		goto free_conn;
+
+	dev_set_name(&conn->dev, "connection%d:%u", session->sid, cid);
+	conn->dev.parent = &session->dev;
+	conn->dev.release = iscsi_conn_release;
+	err = device_register(&conn->dev);
+	if (err) {
+		iscsi_cls_session_printk(KERN_ERR, session, "could not "
+					 "register connection's dev\n");
+		goto release_parent_ref;
+	}
+	err = transport_register_device(&conn->dev);
+	if (err) {
+		iscsi_cls_session_printk(KERN_ERR, session, "could not "
+					 "register transport's dev\n");
+		goto release_conn_ref;
+	}
+
+	spin_lock_irqsave(&connlock, flags);
+	list_add(&conn->conn_list, &connlist);
+	spin_unlock_irqrestore(&connlock, flags);
+
+	ISCSI_DBG_TRANS_CONN(conn, "Completed conn creation\n");
+	return conn;
+
+release_conn_ref:
+	device_unregister(&conn->dev);
+	put_device(&session->dev);
+	return NULL;
+release_parent_ref:
+	put_device(&session->dev);
+free_conn:
+	kfree(conn);
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_create_conn);
+
 /**
  * iscsi_destroy_conn - destroy iscsi class connection
  * @conn: iscsi cls session
