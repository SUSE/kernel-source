From: NeilBrown <neilb@suse.com>
Subject: KABI FIX FOR: NFSD: Have legacy NFSD WRITE decoders use xdr_stream_subsegment()
Patch-mainline: Never, kabi
References: git-fixes

Instead of changing the exported function, create a static-inline
wrapper with the same effect, and use that.

Signed-off-by: NeilBrown <neilb@suse.com>

---
 fs/nfsd/nfs3proc.c         |    2 +-
 fs/nfsd/nfs4proc.c         |    2 +-
 fs/nfsd/nfsproc.c          |    2 +-
 include/linux/sunrpc/svc.h |   12 +++++++++++-
 net/sunrpc/svc.c           |    6 ++----
 5 files changed, 16 insertions(+), 8 deletions(-)

--- a/fs/nfsd/nfs3proc.c
+++ b/fs/nfsd/nfs3proc.c
@@ -210,7 +210,7 @@ nfsd3_proc_write(struct svc_rqst *rqstp)
 
 	fh_copy(&resp->fh, &argp->fh);
 	resp->committed = argp->stable;
-	nvecs = svc_fill_write_vector(rqstp, &argp->payload);
+	nvecs = svc_fill_write_vector_new(rqstp, &argp->payload);
 
 	resp->status = nfsd_write(rqstp, &resp->fh, argp->offset,
 				  rqstp->rq_vec, nvecs, &cnt,
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -1038,7 +1038,7 @@ nfsd4_write(struct svc_rqst *rqstp, stru
 
 	write->wr_how_written = write->wr_stable_how;
 
-	nvecs = svc_fill_write_vector(rqstp, &write->wr_payload);
+	nvecs = svc_fill_write_vector_new(rqstp, &write->wr_payload);
 	WARN_ON_ONCE(nvecs > ARRAY_SIZE(rqstp->rq_vec));
 
 	status = nfsd_vfs_write(rqstp, &cstate->current_fh, nf,
--- a/fs/nfsd/nfsproc.c
+++ b/fs/nfsd/nfsproc.c
@@ -235,7 +235,7 @@ nfsd_proc_write(struct svc_rqst *rqstp)
 		SVCFH_fmt(&argp->fh),
 		argp->len, argp->offset);
 
-	nvecs = svc_fill_write_vector(rqstp, &argp->payload);
+	nvecs = svc_fill_write_vector_new(rqstp, &argp->payload);
 
 	resp->status = nfsd_write(rqstp, fh_copy(&resp->fh, &argp->fh),
 				  argp->offset, rqstp->rq_vec, nvecs,
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@ -532,7 +532,17 @@ int		   svc_encode_result_payload(struct
 					     unsigned int offset,
 					     unsigned int length);
 unsigned int	   svc_fill_write_vector(struct svc_rqst *rqstp,
-					 struct xdr_buf *payload);
+					 struct page **pages,
+					 struct kvec *first, size_t total);
+
+static inline unsigned int svc_fill_write_vector_new(
+	struct svc_rqst *rqstp,
+	struct xdr_buf *payload)
+{
+	return svc_fill_write_vector(rqstp, payload->pages,
+				     payload->head, payload->len);
+}
+
 char		  *svc_fill_symlink_pathname(struct svc_rqst *rqstp,
 					     struct kvec *first, void *p,
 					     size_t total);
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@ -1669,12 +1669,10 @@ EXPORT_SYMBOL_GPL(svc_encode_result_payl
  * Fills in rqstp::rq_vec, and returns the number of elements.
  */
 unsigned int svc_fill_write_vector(struct svc_rqst *rqstp,
-				   struct xdr_buf *payload)
+				   struct page **pages,
+				   struct kvec *first, size_t total)
 {
-	struct page **pages = payload->pages;
-	struct kvec *first = payload->head;
 	struct kvec *vec = rqstp->rq_vec;
-	size_t total = payload->len;
 	unsigned int i;
 
 	/* Some types of transport can present the write payload
