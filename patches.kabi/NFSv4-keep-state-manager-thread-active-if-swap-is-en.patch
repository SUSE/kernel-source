From: NeilBrown <neilb@suse.com>
Subject: KABI FIX FOR: NFSv4: keep state manager thread active if swap is enabled
References: Never, kabi

Hide the new fields from kabi - they are at the end.
Update the magic cookie so that if some module does define one of these
ops structures, we can tell be the lack of a cookie value, and ignore it.

If a module managed to allocate a structure that was followed
immediately by an invalid address, that would be awkward.  I cannot see
it happening though.

Signed-off-by: NeilBrown <neilb@suse.com>
---
 fs/nfs/client.c         |    5 +++--
 fs/nfs/file.c           |    6 ++++--
 fs/nfs/nfs4proc.c       |    2 +-
 include/linux/nfs_xdr.h |   11 ++++++-----
 4 files changed, 14 insertions(+), 10 deletions(-)

--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -859,8 +859,9 @@ int nfs_probe_fsinfo(struct nfs_server *
 	}
 
 	if (clp->rpc_ops->discover_trunking != NULL &&
-	    clp->rpc_ops->trunking_cookie == NFS_TRUNKING_COOKIE &&
-			(server->caps & NFS_CAP_FS_LOCATIONS &&
+	    (clp->rpc_ops->rpc_ops_cookie == NFS_RPC_OPS_COOKIE_1 ||
+	     clp->rpc_ops->rpc_ops_cookie == NFS_RPC_OPS_COOKIE_2) &&
+	    (server->caps & NFS_CAP_FS_LOCATIONS &&
 			 (server->flags & NFS_MOUNT_TRUNK_DISCOVERY))) {
 		error = clp->rpc_ops->discover_trunking(server, mntfh);
 		if (error < 0)
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -511,7 +511,8 @@ static int nfs_swap_activate(struct swap
 	*span = sis->pages;
 
 
-	if (cl->rpc_ops->enable_swap)
+	if (cl->rpc_ops->rpc_ops_cookie == NFS_RPC_OPS_COOKIE_2 &&
+	    cl->rpc_ops->enable_swap)
 		cl->rpc_ops->enable_swap(inode);
 
 	return rpc_clnt_swap_activate(clnt);
@@ -524,7 +525,8 @@ static void nfs_swap_deactivate(struct f
 	struct nfs_client *cl = NFS_SERVER(inode)->nfs_client;
 
 	rpc_clnt_swap_deactivate(clnt);
-	if (cl->rpc_ops->disable_swap)
+	if (cl->rpc_ops->rpc_ops_cookie == NFS_RPC_OPS_COOKIE_2 &&
+	    cl->rpc_ops->disable_swap)
 		cl->rpc_ops->disable_swap(file_inode(file));
 }
 
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -10628,7 +10628,7 @@ const struct nfs_rpc_ops nfs_v4_clientop
 	.create_server	= nfs4_create_server,
 	.clone_server	= nfs_clone_server,
 	.discover_trunking = nfs4_discover_trunking,
-	.trunking_cookie = NFS_TRUNKING_COOKIE,
+	.rpc_ops_cookie = NFS_RPC_OPS_COOKIE_2,
 	.enable_swap	= nfs4_enable_swap,
 	.disable_swap	= nfs4_disable_swap,
 };
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1816,15 +1816,16 @@ struct nfs_rpc_ops {
 					   struct nfs_fattr *, rpc_authflavor_t);
 #ifndef __GENKSYMS__
 	int	(*discover_trunking)(struct nfs_server *, struct nfs_fh *);
-	/* If trunking_cookie is not correct, this might
-	 * be in an external modules and discover_trunking
+	/* If rpc_ops_cookie is not correct, this might
+	 * be in an external modules and added fields
 	 * cannot be trusted.
 	 */
-	unsigned long long trunking_cookie;
-#define NFS_TRUNKING_COOKIE 0xbf18046af9c4dc73ULL
-#endif
+	unsigned long long rpc_ops_cookie;
+#define NFS_RPC_OPS_COOKIE_1 0xbf18046af9c4dc73ULL
 	void	(*enable_swap)(struct inode *inode);
 	void	(*disable_swap)(struct inode *inode);
+#define NFS_RPC_OPS_COOKIE_2 0x8ba619aa70e05960ULL
+#endif
 };
 
 /*
