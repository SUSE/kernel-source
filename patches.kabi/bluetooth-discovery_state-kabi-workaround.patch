From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for bluetooth discovery_state change
Patch-mainline: Never, kABI workaround
References: CVE-2025-38593 bsc#1248357

The patch Bluetooth-hci_sync-fix-double-free-in-hci_discovery_.patch
introduced a new spinlock_t into struct discovery_state, but since the
struct is embedded, it breaks kABI.

For keeping kABI compatibility, replace it with a global spinlock.
As it's called rather in a slow path and the code executed there is
small, there shouldn't be any actual peformance impact.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 include/net/bluetooth/hci_core.h |   10 ++++++----
 net/bluetooth/hci_core.c         |    3 +++
 2 files changed, 9 insertions(+), 4 deletions(-)

--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -95,7 +95,6 @@ struct discovery_state {
 	unsigned long		scan_start;
 	unsigned long		scan_duration;
 	unsigned long		name_resolve_timeout;
-	spinlock_t		lock;
 };
 
 #define SUSPEND_NOTIFIER_TIMEOUT	msecs_to_jiffies(2000) /* 2 seconds */
@@ -904,9 +903,11 @@ static inline void iso_recv(struct hci_c
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */
 #define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   /* 60 seconds */
 
+/* FIXME: global spinlock for kABI compatibility */
+extern spinlock_t __hci_dev_discovery_lock;
+
 static inline void discovery_init(struct hci_dev *hdev)
 {
-	spin_lock_init(&hdev->discovery.lock);
 	hdev->discovery.state = DISCOVERY_STOPPED;
 	INIT_LIST_HEAD(&hdev->discovery.all);
 	INIT_LIST_HEAD(&hdev->discovery.unknown);
@@ -922,12 +923,13 @@ static inline void hci_discovery_filter_
 	hdev->discovery.rssi = HCI_RSSI_INVALID;
 	hdev->discovery.uuid_count = 0;
 
-	spin_lock(&hdev->discovery.lock);
+	/* FIXME: global spinlock for kABI compatibility */
+	spin_lock(&__hci_dev_discovery_lock);
 	kfree(hdev->discovery.uuids);
 	hdev->discovery.uuids = NULL;
 	hdev->discovery.scan_start = 0;
 	hdev->discovery.scan_duration = 0;
-	spin_unlock(&hdev->discovery.lock);
+	spin_unlock(&__hci_dev_discovery_lock);
 }
 
 bool hci_discovery_active(struct hci_dev *hdev);
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -67,6 +67,9 @@ static DEFINE_IDA(hci_index_ida);
 /* FIXME: global SRCU instead of hci_dev.srcu for kABI compatibility */
 DEFINE_STATIC_SRCU(__hci_dev_srcu);
 
+/* FIXME: global spinlock instead of discovery_state.lock for kABI */
+DEFINE_SPINLOCK(__hci_dev_discovery_lock);
+
 /* Get HCI device by index.
  * Device is held on return. */
 static struct hci_dev *__hci_dev_get(int index, int *srcu_index)
