From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for wireless updates
Patch-mainline: Never, kABI workaround
References: bsc#1227149

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 include/net/cfg80211.h       |  106 ++++++++++++++++++++++++++++++++++---------
 include/net/mac80211.h       |   47 +++++++++++++++----
 include/net/regulatory.h     |    2 
 include/uapi/linux/nl80211.h |   16 ++++++
 net/mac80211/Kconfig         |    2 
 net/mac80211/iface.c         |    1 
 net/mac80211/mlme.c          |    8 +++
 net/mac80211/status.c        |    7 ++
 net/wireless/core.c          |    1 
 net/wireless/core.h          |    6 ++
 net/wireless/mlme.c          |   13 ++++-
 net/wireless/scan.c          |   13 +++++
 net/wireless/util.c          |    9 +++
 13 files changed, 198 insertions(+), 33 deletions(-)

--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -198,7 +198,9 @@ struct ieee80211_channel {
 	enum nl80211_dfs_state dfs_state;
 	unsigned long dfs_state_entered;
 	unsigned int dfs_cac_ms;
+#ifndef __GENKSYMS__
 	s8 psd;
+#endif
 };
 
 /**
@@ -1391,9 +1393,13 @@ struct cfg80211_acl_data {
  *	frame headers.
  */
 struct cfg80211_fils_discovery {
-	bool update;
 	u32 min_interval;
+#ifdef __GENKSYMS__
 	u32 max_interval;
+#else
+	u32 max_interval:31;
+	u32 update:1;
+#endif
 	size_t tmpl_len;
 	const u8 *tmpl;
 };
@@ -1410,8 +1416,12 @@ struct cfg80211_fils_discovery {
  * @tmpl: Template data for probe response
  */
 struct cfg80211_unsol_bcast_probe_resp {
-	bool update;
+#ifdef __GENKSYMS__
 	u32 interval;
+#else
+	u32 interval:31;
+	u32 update:1;
+#endif
 	size_t tmpl_len;
 	const u8 *tmpl;
 };
@@ -2647,6 +2657,7 @@ struct cfg80211_scan_request {
 	struct cfg80211_ssid *ssids;
 	int n_ssids;
 	u32 n_channels;
+	enum nl80211_bss_scan_width scan_width; // FIXME: kABI placeholder
 	const u8 *ie;
 	size_t ie_len;
 	u16 duration;
@@ -2668,9 +2679,11 @@ struct cfg80211_scan_request {
 	bool notified;
 	bool no_cck;
 	bool scan_6ghz;
+#ifndef __GENKSYMS__
+	s8 tsf_report_link_id;
+#endif
 	u32 n_6ghz_params;
 	struct cfg80211_scan_6ghz_params *scan_6ghz_params;
-	s8 tsf_report_link_id;
 
 	/* keep last */
 	struct ieee80211_channel *channels[];
@@ -2789,6 +2802,7 @@ struct cfg80211_sched_scan_request {
 	struct cfg80211_ssid *ssids;
 	int n_ssids;
 	u32 n_channels;
+	enum nl80211_bss_scan_width scan_width; // FIXME: kABI placeholder
 	const u8 *ie;
 	size_t ie_len;
 	u32 flags;
@@ -2862,6 +2876,7 @@ enum cfg80211_signal_type {
  */
 struct cfg80211_inform_bss {
 	struct ieee80211_channel *chan;
+	enum nl80211_bss_scan_width scan_width; // FIXME: kABI placeholder
 	s32 signal;
 	u64 boottime_ns;
 	u64 parent_tsf;
@@ -2869,8 +2884,10 @@ struct cfg80211_inform_bss {
 	u8 chains;
 	s8 chain_signal[IEEE80211_MAX_CHAINS];
 
+#ifndef __GENKSYMS__
 	u8 restrict_use:1, use_for:7;
 	u8 cannot_use_reasons;
+#endif
 
 	void *drv_data;
 };
@@ -2934,6 +2951,7 @@ struct cfg80211_bss_ies {
  */
 struct cfg80211_bss {
 	struct ieee80211_channel *channel;
+	enum nl80211_bss_scan_width scan_width; // FIXME: kABI placeholder
 
 	const struct cfg80211_bss_ies __rcu *ies;
 	const struct cfg80211_bss_ies __rcu *beacon_ies;
@@ -2952,13 +2970,14 @@ struct cfg80211_bss {
 	u8 chains;
 	s8 chain_signal[IEEE80211_MAX_CHAINS];
 
-	u8 proberesp_ecsa_stuck:1;
-
 	u8 bssid_index;
 	u8 max_bssid_indicator;
 
+#ifndef __GENKSYMS__
+	u8 proberesp_ecsa_stuck:1;
 	u8 use_for;
 	u8 cannot_use_reasons;
+#endif
 
 	u8 priv[] __aligned(sizeof(void *));
 };
@@ -3045,7 +3064,9 @@ struct cfg80211_assoc_link {
 	const u8 *elems;
 	size_t elems_len;
 	bool disabled;
+#ifndef __GENKSYMS__
 	int error;
+#endif
 };
 
 /**
@@ -3605,8 +3626,10 @@ struct cfg80211_wowlan_wakeup {
 	bool disconnect, magic_pkt, gtk_rekey_failure,
 	     eap_identity_req, four_way_handshake,
 	     rfkill_release, packet_80211,
-	     tcp_match, tcp_connlost, tcp_nomoretokens,
-	     unprot_deauth_disassoc;
+	     tcp_match, tcp_connlost, tcp_nomoretokens;
+#ifndef __GENKSYMS__
+	bool unprot_deauth_disassoc;
+#endif
 	s32 pattern_idx;
 	u32 packet_present_len, packet_len;
 	const void *packet;
@@ -4604,8 +4627,13 @@ struct cfg80211_ops {
 
 	int	(*start_ap)(struct wiphy *wiphy, struct net_device *dev,
 			    struct cfg80211_ap_settings *settings);
+#ifdef __GENKSYMS__
+	int	(*change_beacon)(struct wiphy *wiphy, struct net_device *dev,
+				 struct cfg80211_beacon_data *info);
+#else
 	int	(*change_beacon)(struct wiphy *wiphy, struct net_device *dev,
 				 struct cfg80211_ap_update *info);
+#endif
 	int	(*stop_ap)(struct wiphy *wiphy, struct net_device *dev,
 			   unsigned int link_id);
 
@@ -4915,8 +4943,10 @@ struct cfg80211_ops {
 				    struct link_station_del_parameters *params);
 	int	(*set_hw_timestamp)(struct wiphy *wiphy, struct net_device *dev,
 				    struct cfg80211_set_hw_timestamp *hwts);
+#ifndef __GENKSYMS__
 	int	(*set_ttlm)(struct wiphy *wiphy, struct net_device *dev,
 			    struct cfg80211_ttlm_params *params);
+#endif
 };
 
 /*
@@ -6143,6 +6173,8 @@ struct wireless_dev {
 	struct list_head mgmt_registrations;
 	u8 mgmt_registrations_need_update:1;
 
+	struct mutex mtx; // FIXME: kABI placeholder
+
 	bool use_4addr, is_running, registered, registering;
 
 	u8 address[ETH_ALEN] __aligned(sizeof(u16));
@@ -6437,7 +6469,9 @@ ieee80211_get_response_rate(struct ieee8
  * This function returns a bitmap of the mandatory rates for the given
  * band, bits are set according to the rate position in the bitrates array.
  */
-u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband);
+u32 _ieee80211_mandatory_rates(struct ieee80211_supported_band *sband);
+// FIXME: rename for kABI workaround
+#define ieee80211_mandatory_rates _ieee80211_mandatory_rates
 
 /*
  * Radiotap parsing functions -- for controlled injection support
@@ -7273,16 +7307,12 @@ struct cfg80211_bss *__cfg80211_get_bss(
  *
  * This version implies regular usage, %NL80211_BSS_USE_FOR_NORMAL.
  */
-static inline struct cfg80211_bss *
-cfg80211_get_bss(struct wiphy *wiphy, struct ieee80211_channel *channel,
-		 const u8 *bssid, const u8 *ssid, size_t ssid_len,
-		 enum ieee80211_bss_type bss_type,
-		 enum ieee80211_privacy privacy)
-{
-	return __cfg80211_get_bss(wiphy, channel, bssid, ssid, ssid_len,
-				  bss_type, privacy,
-				  NL80211_BSS_USE_FOR_NORMAL);
-}
+struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
+				      struct ieee80211_channel *channel,
+				      const u8 *bssid,
+				      const u8 *ssid, size_t ssid_len,
+				      enum ieee80211_bss_type bss_type,
+				      enum ieee80211_privacy privacy);
 
 static inline struct cfg80211_bss *
 cfg80211_get_ibss(struct wiphy *wiphy,
@@ -7391,7 +7421,7 @@ void cfg80211_auth_timeout(struct net_de
  * @links.status: Set this (along with a BSS pointer) for links that
  *	were rejected by the AP.
  */
-struct cfg80211_rx_assoc_resp_data {
+struct cfg80211_rx_assoc_resp {
 	const u8 *buf;
 	size_t len;
 	const u8 *req_ies;
@@ -7405,6 +7435,9 @@ struct cfg80211_rx_assoc_resp_data {
 	} links[IEEE80211_MLD_MAX_NUM_LINKS];
 };
 
+// FIXME: rename for kABI workaround
+#define cfg80211_rx_assoc_resp_data cfg80211_rx_assoc_resp
+
 /**
  * cfg80211_rx_assoc_resp - notification of processed association response
  * @dev: network device
@@ -7415,8 +7448,10 @@ struct cfg80211_rx_assoc_resp_data {
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_rx_assoc_resp(struct net_device *dev,
-			    const struct cfg80211_rx_assoc_resp_data *data);
+void _cfg80211_rx_assoc_resp(struct net_device *dev,
+			     const struct cfg80211_rx_assoc_resp_data *data);
+// FIXME: rename for kABI workaround
+#define cfg80211_rx_assoc_resp(dev, data) _cfg80211_rx_assoc_resp(dev, data)
 
 /**
  * struct cfg80211_assoc_failure - association failure data
@@ -9448,6 +9483,35 @@ ssize_t wiphy_locked_debugfs_write(struc
 						      size_t count,
 						      void *data),
 				   void *data);
+#else
+static inline ssize_t
+wiphy_locked_debugfs_read(struct wiphy *wiphy, struct file *file,
+			  char *buf, size_t bufsize,
+			  char __user *userbuf, size_t count,
+			  loff_t *ppos,
+			  ssize_t (*handler)(struct wiphy *wiphy,
+					     struct file *file,
+					     char *buf,
+					     size_t bufsize,
+					     void *data),
+			  void *data)
+{
+	return -ENOENT;
+}
+
+static inline ssize_t
+wiphy_locked_debugfs_write(struct wiphy *wiphy, struct file *file,
+			   char *buf, size_t bufsize,
+			   const char __user *userbuf, size_t count,
+			   ssize_t (*handler)(struct wiphy *wiphy,
+					      struct file *file,
+					      char *buf,
+					      size_t count,
+					      void *data),
+			   void *data)
+{
+	return -ENOENT;
+}
 #endif
 
 #endif /* __NET_CFG80211_H */
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -1157,12 +1157,21 @@ ieee80211_rate_get_vht_nss(const struct
 struct ieee80211_tx_info {
 	/* common information */
 	u32 flags;
+
+#ifdef __GENKSYMS__
 	u32 band:3,
-	    status_data_idr:1,
-	    status_data:13,
+	    ack_frame_id:13,
 	    hw_queue:4,
 	    tx_time_est:10;
+	/* 2 free bits */
+#else
+	u32 band:3,
+	    status_data:13,
+	    hw_queue:4,
+	    tx_time_est:10,
+	    status_data_idr:1;
 	/* 1 free bit */
+#endif
 
 	union {
 		struct {
@@ -1177,8 +1186,10 @@ struct ieee80211_tx_info {
 					u8 short_preamble:1;
 					u8 skip_table:1;
 
+#ifndef __GENKSYMS__
 					/* for injection only (bitmap) */
 					u8 antennas:2;
+#endif
 
 					/* 14 bits free */
 				};
@@ -2794,7 +2805,9 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_SUPPORTS_CONC_MON_RX_DECAP,
 	IEEE80211_HW_DETECTS_COLOR_COLLISION,
 	IEEE80211_HW_MLO_MCAST_MULTI_LINK_TX,
+#ifndef __GENKSYMS__
 	IEEE80211_HW_DISALLOW_PUNCTURING,
+#endif
 
 	/* keep last, obviously */
 	NUM_IEEE80211_HW_FLAGS
@@ -3698,7 +3711,9 @@ struct ieee80211_prep_tx_info {
 	u16 duration;
 	u16 subtype;
 	u8 success:1;
+#ifndef __GENKSYMS__
 	int link_id;
+#endif
 };
 
 /**
@@ -4431,8 +4446,6 @@ struct ieee80211_ops {
 	int (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			  struct ieee80211_sta *sta);
 #ifdef CONFIG_MAC80211_DEBUGFS
-	void (*vif_add_debugfs)(struct ieee80211_hw *hw,
-				struct ieee80211_vif *vif);
 	void (*link_add_debugfs)(struct ieee80211_hw *hw,
 				 struct ieee80211_vif *vif,
 				 struct ieee80211_bss_conf *link_conf,
@@ -4580,9 +4593,14 @@ struct ieee80211_ops {
 				   struct ieee80211_vif *vif,
 				   struct ieee80211_prep_tx_info *info);
 
+#ifdef __GENKSYMS__
+	void	(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,
+					     struct ieee80211_vif *vif);
+#else
 	void	(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,
 					     struct ieee80211_vif *vif,
 					     unsigned int link_id);
+#endif
 
 	int (*add_chanctx)(struct ieee80211_hw *hw,
 			   struct ieee80211_chanctx_conf *ctx);
@@ -4619,9 +4637,14 @@ struct ieee80211_ops {
 				  struct ieee80211_vif *vif,
 				  struct ieee80211_channel_switch *ch_switch);
 
+#ifdef __GENKSYMS__
+	int (*post_channel_switch)(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif);
+#else
 	int (*post_channel_switch)(struct ieee80211_hw *hw,
 				   struct ieee80211_vif *vif,
 				   struct ieee80211_bss_conf *link_conf);
+#endif
 	void (*abort_channel_switch)(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif);
 	void (*channel_switch_rx_beacon)(struct ieee80211_hw *hw,
@@ -4703,9 +4726,6 @@ struct ieee80211_ops {
 				     struct ieee80211_sta *sta,
 				     struct net_device_path_ctx *ctx,
 				     struct net_device_path *path);
-	bool (*can_activate_links)(struct ieee80211_hw *hw,
-				   struct ieee80211_vif *vif,
-				   u16 active_links);
 	int (*change_vif_links)(struct ieee80211_hw *hw,
 				struct ieee80211_vif *vif,
 				u16 old_links, u16 new_links,
@@ -4722,9 +4742,18 @@ struct ieee80211_ops {
 			    struct net_device *dev,
 			    enum tc_setup_type type,
 			    void *type_data);
+#ifndef __GENKSYMS__
+	bool (*can_activate_links)(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   u16 active_links);
+#ifdef CONFIG_MAC80211_DEBUGFS
+	void (*vif_add_debugfs)(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif);
+#endif
 	enum ieee80211_neg_ttlm_res
 	(*can_neg_ttlm)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			struct ieee80211_neg_ttlm *ttlm);
+#endif
 };
 
 /**
@@ -6632,8 +6661,10 @@ void ieee80211_radar_detected(struct iee
  * Complete the channel switch post-process: set the new operational channel
  * and wake up the suspended queues.
  */
-void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success,
+void _ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success,
 			     unsigned int link_id);
+// FIXME: rename for kABI workaround
+#define ieee80211_chswitch_done _ieee80211_chswitch_done
 
 /**
  * ieee80211_channel_switch_disconnect - disconnect due to channel switch error
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -213,7 +213,9 @@ struct ieee80211_reg_rule {
 	u32 flags;
 	u32 dfs_cac_ms;
 	bool has_wmm;
+#ifndef __GENKSYMS__
 	s8 psd;
+#endif
 };
 
 struct ieee80211_regdomain {
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -1584,7 +1584,9 @@ enum nl80211_commands {
 
 	NL80211_CMD_LINKS_REMOVED,
 
+#ifndef __GENKSYMS__
 	NL80211_CMD_SET_TID_TO_LINK_MAPPING,
+#endif
 
 	/* add new commands above here */
 
@@ -3389,12 +3391,14 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_MLO_LINK_DISABLED,
 
+#ifndef __GENKSYMS__
 	NL80211_ATTR_BSS_DUMP_INCLUDE_USE_DATA,
 
 	NL80211_ATTR_MLO_TTLM_DLINK,
 	NL80211_ATTR_MLO_TTLM_ULINK,
 
 	NL80211_ATTR_ASSOC_SPP_AMSDU,
+#endif
 
 	/* add attributes here, update the policy in nl80211.c */
 
@@ -4306,10 +4310,12 @@ enum nl80211_frequency_attr {
 	NL80211_FREQUENCY_ATTR_16MHZ,
 	NL80211_FREQUENCY_ATTR_NO_320MHZ,
 	NL80211_FREQUENCY_ATTR_NO_EHT,
+#ifndef __GENKSYMS__
 	NL80211_FREQUENCY_ATTR_PSD,
 	NL80211_FREQUENCY_ATTR_DFS_CONCURRENT,
 	NL80211_FREQUENCY_ATTR_NO_6GHZ_VLP_CLIENT,
 	NL80211_FREQUENCY_ATTR_NO_6GHZ_AFC_CLIENT,
+#endif
 
 	/* keep last */
 	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
@@ -4433,7 +4439,9 @@ enum nl80211_reg_rule_attr {
 
 	NL80211_ATTR_DFS_CAC_TIME,
 
+#ifndef __GENKSYMS__
 	NL80211_ATTR_POWER_RULE_PSD,
+#endif
 
 	/* keep last */
 	__NL80211_REG_RULE_ATTR_AFTER_LAST,
@@ -4545,10 +4553,12 @@ enum nl80211_reg_rule_flags {
 	NL80211_RRF_NO_HE		= 1<<17,
 	NL80211_RRF_NO_320MHZ		= 1<<18,
 	NL80211_RRF_NO_EHT		= 1<<19,
+#ifndef __GENKSYMS__
 	NL80211_RRF_PSD			= 1<<20,
 	NL80211_RRF_DFS_CONCURRENT	= 1<<21,
 	NL80211_RRF_NO_6GHZ_VLP_CLIENT	= 1<<22,
 	NL80211_RRF_NO_6GHZ_AFC_CLIENT	= 1<<23,
+#endif
 };
 
 #define NL80211_RRF_PASSIVE_SCAN	NL80211_RRF_NO_IR
@@ -5204,8 +5214,10 @@ enum nl80211_bss {
 	NL80211_BSS_FREQUENCY_OFFSET,
 	NL80211_BSS_MLO_LINK_ID,
 	NL80211_BSS_MLD_ADDR,
+#ifndef __GENKSYMS__
 	NL80211_BSS_USE_FOR,
 	NL80211_BSS_CANNOT_USE_REASONS,
+#endif
 
 	/* keep last */
 	__NL80211_BSS_AFTER_LAST,
@@ -5784,7 +5796,9 @@ enum nl80211_wowlan_triggers {
 	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS,
 	NL80211_WOWLAN_TRIG_NET_DETECT,
 	NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS,
+#ifndef __GENKSYMS__
 	NL80211_WOWLAN_TRIG_UNPROTECTED_DEAUTH_DISASSOC,
+#endif
 
 	/* keep last */
 	NUM_NL80211_WOWLAN_TRIG,
@@ -6612,10 +6626,12 @@ enum nl80211_ext_feature_index {
 	NL80211_EXT_FEATURE_PUNCT,
 	NL80211_EXT_FEATURE_SECURE_NAN,
 	NL80211_EXT_FEATURE_AUTH_AND_DEAUTH_RANDOM_TA,
+#ifndef __GENKSYMS__
 	NL80211_EXT_FEATURE_OWE_OFFLOAD,
 	NL80211_EXT_FEATURE_OWE_OFFLOAD_AP,
 	NL80211_EXT_FEATURE_DFS_CONCURRENT,
 	NL80211_EXT_FEATURE_SPP_AMSDU_SUPPORT,
+#endif
 
 	/* add new features before the definition below */
 	NUM_NL80211_EXT_FEATURES,
--- a/net/mac80211/Kconfig
+++ b/net/mac80211/Kconfig
@@ -77,7 +77,7 @@ config MAC80211_LEDS
 
 config MAC80211_DEBUGFS
 	bool "Export mac80211 internals in DebugFS"
-	depends on MAC80211 && CFG80211_DEBUGFS
+	depends on MAC80211 && DEBUG_FS
 	help
 	  Select this to see extensive information about
 	  the internal state of mac80211 in debugfs.
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -1139,6 +1139,7 @@ int ieee80211_add_virtual_monitor(struct
 	snprintf(sdata->name, IFNAMSIZ, "%s-monitor",
 		 wiphy_name(local->hw.wiphy));
 	sdata->wdev.iftype = NL80211_IFTYPE_MONITOR;
+	mutex_init(&sdata->wdev.mtx); // FIXME: re-added for kABI compatibility
 	sdata->wdev.wiphy = local->hw.wiphy;
 
 	ieee80211_sdata_init(local, sdata);
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -8596,3 +8596,11 @@ void ieee80211_disable_rssi_reports(stru
 	_ieee80211_enable_rssi_reports(sdata, 0, 0);
 }
 EXPORT_SYMBOL(ieee80211_disable_rssi_reports);
+
+/* FIXME: old symbol for kABI compatibility */
+#undef ieee80211_chswitch_done
+void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success)
+{
+	_ieee80211_chswitch_done(vif, success, 0);
+}
+EXPORT_SYMBOL(ieee80211_chswitch_done);
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -1113,6 +1113,13 @@ void ieee80211_tx_status_skb(struct ieee
 }
 EXPORT_SYMBOL(ieee80211_tx_status_skb);
 
+// FIXME: for kABI compatibility
+void ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	ieee80211_tx_status_skb(hw, skb);
+}
+EXPORT_SYMBOL(ieee80211_tx_status);
+
 void ieee80211_tx_status_ext(struct ieee80211_hw *hw,
 			     struct ieee80211_tx_status *status)
 {
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -1359,6 +1359,7 @@ EXPORT_SYMBOL(cfg80211_stop_iface);
 
 void cfg80211_init_wdev(struct wireless_dev *wdev)
 {
+	mutex_init(&wdev->mtx);
 	INIT_LIST_HEAD(&wdev->event_list);
 	spin_lock_init(&wdev->event_lock);
 	INIT_LIST_HEAD(&wdev->mgmt_registrations);
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -293,8 +293,12 @@ struct cfg80211_cqm_config {
 	u32 rssi_hyst;
 	s32 last_rssi_event_value;
 	enum nl80211_cqm_rssi_threshold_event last_rssi_event_type;
-	bool use_range_api;
+#ifdef __GENKSYMS__
 	int n_rssi_thresholds;
+#else
+	u32 n_rssi_thresholds:31;
+	u32 use_range_api:1;
+#endif
 	s32 rssi_thresholds[];
 };
 
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -21,7 +21,7 @@
 #include "rdev-ops.h"
 
 
-void cfg80211_rx_assoc_resp(struct net_device *dev,
+void _cfg80211_rx_assoc_resp(struct net_device *dev,
 			    const struct cfg80211_rx_assoc_resp_data *data)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -95,7 +95,7 @@ void cfg80211_rx_assoc_resp(struct net_d
 	/* update current_bss etc., consumes the bss reference */
 	__cfg80211_connect_result(dev, &cr, cr.status == WLAN_STATUS_SUCCESS);
 }
-EXPORT_SYMBOL(cfg80211_rx_assoc_resp);
+EXPORT_SYMBOL(_cfg80211_rx_assoc_resp);
 
 static void cfg80211_process_auth(struct wireless_dev *wdev,
 				  const u8 *buf, size_t len)
@@ -1183,3 +1183,12 @@ void cfg80211_stop_background_radar_dete
 					&rdev->background_radar_chandef,
 					NL80211_RADAR_CAC_ABORTED);
 }
+
+/* FIXME: kABI compatibility */
+#undef cfg80211_rx_assoc_resp
+void cfg80211_rx_assoc_resp(struct net_device *dev,
+			    struct cfg80211_rx_assoc_resp *data)
+{
+	_cfg80211_rx_assoc_resp(dev, data);
+}
+EXPORT_SYMBOL(cfg80211_rx_assoc_resp);
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -1587,6 +1587,19 @@ struct cfg80211_bss *__cfg80211_get_bss(
 }
 EXPORT_SYMBOL(__cfg80211_get_bss);
 
+// FIXME: exported here for kABI compatibility
+struct cfg80211_bss *
+cfg80211_get_bss(struct wiphy *wiphy, struct ieee80211_channel *channel,
+		 const u8 *bssid, const u8 *ssid, size_t ssid_len,
+		 enum ieee80211_bss_type bss_type,
+		 enum ieee80211_privacy privacy)
+{
+	return __cfg80211_get_bss(wiphy, channel, bssid, ssid, ssid_len,
+				  bss_type, privacy,
+				  NL80211_BSS_USE_FOR_NORMAL);
+}
+EXPORT_SYMBOL(cfg80211_get_bss);
+
 static void rb_insert_bss(struct cfg80211_registered_device *rdev,
 			  struct cfg80211_internal_bss *bss)
 {
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -2760,3 +2760,12 @@ cfg80211_get_iftype_ext_capa(struct wiph
 	return NULL;
 }
 EXPORT_SYMBOL(cfg80211_get_iftype_ext_capa);
+
+/* FIXME: old symbol for kABI compatibility */
+#undef ieee80211_mandatory_rates
+u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
+			      enum nl80211_bss_scan_width scan_width)
+{
+	return _ieee80211_mandatory_rates(sband);
+}
+EXPORT_SYMBOL(ieee80211_mandatory_rates);
