From: Michal Kubecek <mkubecek@suse.cz>
Date: Tue, 5 Sep 2023 09:57:31 +0200
Subject: kabi: hide changes in struct nft_set
Patch-mainline: never, kabi workaround
References: CVE-2023-4563 bsc#1214727

Mainline commit 5f68718b34a5 ("netfilter: nf_tables: GC transaction API to
avoid race with control plane"), backported as a prerequisity for
bsc#1214727 fix, adds a new members refs and dead to kabi protected struct
nft_set. Adding the bitfield dead does not actually change structure layout
as it just uses one previously reserved bit in a bitfield. New member refs
can be moved into existing hole just before cacheline aligned member ops.

Move refs and mask both resulting changes from genksyms. To make sure
structure layout is preserved, add static asserts checking that offset of
members ops and klen (both right after our changes) is preserved, compared
to a copy of the original structure definition.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/netfilter/nf_tables.h | 49 +++++++++++++++++++++++++++++--
 1 file changed, 47 insertions(+), 2 deletions(-)

--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -452,7 +452,6 @@ struct nft_set_elem_expr {
  *
  *	@list: table set list node
  *	@bindings: list of set bindings
- *	@refs: internal refcounting for async set destruction
  *	@table: table this set belongs to
  *	@net: netnamespace this set belongs to
  * 	@name: name of the set
@@ -472,6 +471,7 @@ struct nft_set_elem_expr {
  *	@udlen: user data length
  *	@udata: user data
  *	@expr: stateful expression
+ *	@refs: internal refcounting for async set destruction
  * 	@ops: set ops
  * 	@flags: set flags
  *	@dead: set will be freed, never cleared
@@ -483,7 +483,6 @@ struct nft_set_elem_expr {
 struct nft_set {
 	struct list_head		list;
 	struct list_head		bindings;
-	refcount_t			refs;
 	struct nft_table		*table;
 	possible_net_t			net;
 	char				*name;
@@ -502,11 +501,53 @@ struct nft_set {
 	u16				policy;
 	u16				udlen;
 	unsigned char			*udata;
+#ifndef __GENKSYMS__
+	refcount_t			refs;
+#endif
 	/* runtime data below here */
 	const struct nft_set_ops	*ops ____cacheline_aligned;
+#ifndef __GENKSYMS__
 	u16				flags:13,
 					dead:1,
 					genmask:2;
+#else
+	u16				flags:14,
+					genmask:2;
+#endif
+	u8				klen;
+	u8				dlen;
+	u8				num_exprs;
+	struct nft_expr			*exprs[NFT_SET_EXPR_MAX];
+	struct list_head		catchall_list;
+	unsigned char			data[]
+		__attribute__((aligned(__alignof__(u64))));
+};
+
+struct __orig_nft_set {
+	struct list_head		list;
+	struct list_head		bindings;
+	struct nft_table		*table;
+	possible_net_t			net;
+	char				*name;
+	u64				handle;
+	u32				ktype;
+	u32				dtype;
+	u32				objtype;
+	u32				size;
+	u8				field_len[NFT_REG32_COUNT];
+	u8				field_count;
+	u32				use;
+	atomic_t			nelems;
+	u32				ndeact;
+	u64				timeout;
+	u32				gc_int;
+	u16				policy;
+	u16				udlen;
+	unsigned char			*udata;
+	/* runtime data below here */
+	const struct nft_set_ops	*ops ____cacheline_aligned;
+	u16				flags:14,
+					genmask:2;
 	u8				klen;
 	u8				dlen;
 	u8				num_exprs;
@@ -515,6 +556,10 @@ struct nft_set {
 	unsigned char			data[]
 		__attribute__((aligned(__alignof__(u64))));
 };
+static_assert(offsetof(struct nft_set, ops) ==
+	      offsetof(struct __orig_nft_set, ops));
+static_assert(offsetof(struct nft_set, klen) ==
+	      offsetof(struct __orig_nft_set, klen));
 
 static inline bool nft_set_is_anonymous(const struct nft_set *set)
 {
