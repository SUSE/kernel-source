From: Ales Novak <alnovak@suse.cz>
Date: Mon, 7 Feb 2022 08:41:37 +0100
Subject: [PATCH] scsi: kABI fix for 'eh_should_retry_cmd'
Patch-mainline: Never, kABI fix only
References: bsc#1195506 bsc#1206351

Patch 'scsi: core: No retries on abort success' introduced a new scsi host template
callback 'eh_should_retry_cmd', which of course breaks the kABI.
So add a kABI padding here.

This struct is usually allocated statically, even by 3rd party modules relying
on kABI. Before we use the member we need to signalize that it is to be
expected. As we only expect the member to be set by in-tree modules that we can
control, we can use a space in the bitfield to signalize that; provided that
unused bitfield members will be initialized to 0.

Signed-off-by: Ales Novak <alnovak@suse.cz>
---
 drivers/scsi/lpfc/lpfc_scsi.c |    2 ++
 drivers/scsi/qla2xxx/qla_os.c |    1 +
 drivers/scsi/scsi_error.c     |    2 +-
 include/scsi/scsi_host.h      |   17 +++++++++++------
 4 files changed, 15 insertions(+), 7 deletions(-)

--- a/drivers/scsi/lpfc/lpfc_scsi.c
+++ b/drivers/scsi/lpfc/lpfc_scsi.c
@@ -6805,6 +6805,7 @@ struct scsi_host_template lpfc_template
 	.vendor_id		= LPFC_NL_VENDOR_ID,
 	.change_queue_depth	= scsi_change_queue_depth,
 	.track_queue_depth	= 1,
+	.template_has_eh_should_retry_cmd = 1,
 };
 
 struct scsi_host_template lpfc_vport_template = {
@@ -6832,4 +6833,5 @@ struct scsi_host_template lpfc_vport_tem
 	.vendor_id		= 0,
 	.change_queue_depth	= scsi_change_queue_depth,
 	.track_queue_depth	= 1,
+	.template_has_eh_should_retry_cmd = 1,
 };
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -8016,6 +8016,7 @@ struct scsi_host_template qla2xxx_driver
 	.supported_mode		= MODE_INITIATOR,
 	.track_queue_depth	= 1,
 	.cmd_size		= sizeof(srb_t),
+	.template_has_eh_should_retry_cmd = 1,
 };
 
 static const struct pci_error_handlers qla2xxx_err_handler = {
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -129,7 +129,7 @@ static bool scsi_eh_should_retry_cmd(str
 	struct scsi_device *sdev = cmd->device;
 	struct Scsi_Host *host = sdev->host;
 
-	if (host->hostt->eh_should_retry_cmd)
+	if (host->hostt->template_has_eh_should_retry_cmd &&  host->hostt->eh_should_retry_cmd)
 		return  host->hostt->eh_should_retry_cmd(cmd);
 
 	return true;
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -324,12 +324,6 @@ struct scsi_host_template {
 	 * Status: OPTIONAL
 	 */
 	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
-	/*
-	 * Optional routine that allows the transport to decide if a cmd
-	 * is retryable. Return true if the transport is in a state the
-	 * cmd should be retried on.
-	 */
-	bool (*eh_should_retry_cmd)(struct scsi_cmnd *scmd);
 
 	/* This is an optional routine that allows transport to initiate
 	 * LLD adapter or firmware reset using sysfs attribute.
@@ -458,6 +452,9 @@ struct scsi_host_template {
 	/* True if the low-level driver supports blk-mq only */
 	unsigned force_blk_mq:1;
 
+#ifndef __GENKSYMS__
+	unsigned template_has_eh_should_retry_cmd:1;
+#endif
 	/*
 	 * Countdown for host blocking with no commands outstanding.
 	 */
@@ -502,6 +499,14 @@ struct scsi_host_template {
 	 */
 	unsigned int cmd_size;
 	struct scsi_host_cmd_pool *cmd_pool;
+#ifndef __GENKSYMS__
+	/*
+	 * Optional routine that allows the transport to decide if a cmd
+	 * is retryable. Return true if the transport is in a state the
+	 * cmd should be retried on.
+	 */
+	bool (*eh_should_retry_cmd)(struct scsi_cmnd *scmd);
+#endif
 };
 
 /*
