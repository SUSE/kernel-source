From 81553610846a37bd5ca3648c0dd9cd2969b9a2de Mon Sep 17 00:00:00 2001
From: root <root@sparrow1.arch.suse.cz>
Date: Sun, 16 Feb 2025 18:05:06 +0100
Subject: [PATCH] NFS: Improve heuristic for readdirplus -revert

Patch-mainline: Never, SLERT-specific
References: bsc#1237160

As reported in bsc#1237160, it's possible to cause RCU stalls on
RT-specific kernels. It appears virtual machines make it easier to
trigger although unclear if it is required. The nature of the
optimisation requires tracking state under RCU in a manner that
is not PREEMPT_RT-safe. Fixing this is out of scope for LTSS given
that the optimisation is targetting for SAP workloads, PREEMPT_RT
is not expected to be used with such workloads and NFS performance
for realtime workloads is typically not a concern. Revert the patch
as the safest solution for resolving bsc#1237160.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 fs/nfs/dir.c           | 83 +++++++++++++++++++-------------------------------
 fs/nfs/inode.c         |  4 +--
 fs/nfs/internal.h      |  4 +--
 fs/nfs/nfstrace.h      |  2 ++
 include/linux/nfs_fs.h |  5 ++-
 5 files changed, 40 insertions(+), 58 deletions(-)

diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 5bdf8fcb1fb39..0491f71ad52a6 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -88,7 +88,8 @@ static struct nfs_open_dir_context *alloc_nfs_open_dir_context(struct inode *dir
 		    (nfsi->cache_validity & NFS_INO_DATA_INVAL_DEFER))
 			nfsi->cache_validity |= NFS_INO_INVALID_DATA |
 				NFS_INO_REVAL_FORCED;
-		list_add_tail_rcu(&ctx->list, &nfsi->open_files);
+		list_add(&ctx->list, &nfsi->open_files);
+		clear_bit(NFS_INO_FORCE_READDIR, &nfsi->flags);
 		spin_unlock(&dir->i_lock);
 		return ctx;
 	}
@@ -98,9 +99,9 @@ static struct nfs_open_dir_context *alloc_nfs_open_dir_context(struct inode *dir
 static void put_nfs_open_dir_context(struct inode *dir, struct nfs_open_dir_context *ctx)
 {
 	spin_lock(&dir->i_lock);
-	list_del_rcu(&ctx->list);
+	list_del(&ctx->list);
 	spin_unlock(&dir->i_lock);
-	kfree_rcu(ctx, rcu_head);
+	kfree(ctx);
 }
 
 /*
@@ -529,6 +530,7 @@ static int nfs_readdir_xdr_filler(struct nfs_readdir_descriptor *desc,
 		/* We requested READDIRPLUS, but the server doesn't grok it */
 		if (error == -ENOTSUPP && desc->plus) {
 			NFS_SERVER(inode)->caps &= ~NFS_CAP_READDIRPLUS;
+			clear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);
 			desc->plus = false;
 			goto again;
 		}
@@ -578,63 +580,51 @@ int nfs_same_file(struct dentry *dentry, struct nfs_entry *entry)
 	return 1;
 }
 
-#define NFS_READDIR_CACHE_USAGE_THRESHOLD (8UL)
-
-static bool nfs_use_readdirplus(struct inode *dir, struct dir_context *ctx,
-				unsigned int cache_hits,
-				unsigned int cache_misses)
+static
+bool nfs_use_readdirplus(struct inode *dir, struct dir_context *ctx)
 {
 	if (!nfs_server_capable(dir, NFS_CAP_READDIRPLUS))
 		return false;
-	if (ctx->pos == 0 ||
-	    cache_hits + cache_misses > NFS_READDIR_CACHE_USAGE_THRESHOLD)
+	if (test_and_clear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags))
+		return true;
+	if (ctx->pos == 0)
 		return true;
 	return false;
 }
 
 /*
- * This function is called by the getattr code to request the
+ * This function is called by the lookup and getattr code to request the
  * use of readdirplus to accelerate any future lookups in the same
  * directory.
  */
-void nfs_readdir_record_entry_cache_hit(struct inode *dir)
+void nfs_advise_use_readdirplus(struct inode *dir)
 {
 	struct nfs_inode *nfsi = NFS_I(dir);
-	struct nfs_open_dir_context *ctx;
 
 	if (nfs_server_capable(dir, NFS_CAP_READDIRPLUS) &&
-	    S_ISDIR(dir->i_mode)) {
-		rcu_read_lock();
-		list_for_each_entry_rcu (ctx, &nfsi->open_files, list)
-			atomic_inc(&ctx->cache_hits);
-		rcu_read_unlock();
-	}
+	    !list_empty(&nfsi->open_files))
+		set_bit(NFS_INO_ADVISE_RDPLUS, &nfsi->flags);
 }
 
 /*
  * This function is mainly for use by nfs_getattr().
  *
  * If this is an 'ls -l', we want to force use of readdirplus.
+ * Do this by checking if there is an active file descriptor
+ * and calling nfs_advise_use_readdirplus, then forcing a
+ * cache flush.
  */
-void nfs_readdir_record_entry_cache_miss(struct inode *dir)
+void nfs_force_use_readdirplus(struct inode *dir)
 {
 	struct nfs_inode *nfsi = NFS_I(dir);
-	struct nfs_open_dir_context *ctx;
 
 	if (nfs_server_capable(dir, NFS_CAP_READDIRPLUS) &&
-	    S_ISDIR(dir->i_mode)) {
-		rcu_read_lock();
-		list_for_each_entry_rcu (ctx, &nfsi->open_files, list)
-			atomic_inc(&ctx->cache_misses);
-		rcu_read_unlock();
+	    !list_empty(&nfsi->open_files)) {
+		set_bit(NFS_INO_ADVISE_RDPLUS, &nfsi->flags);
+		set_bit(NFS_INO_FORCE_READDIR, &nfsi->flags);
 	}
 }
 
-static void nfs_lookup_advise_force_readdirplus(struct inode *dir)
-{
-	nfs_readdir_record_entry_cache_miss(dir);
-}
-
 static
 void nfs_prime_dcache(struct dentry *parent, struct nfs_entry *entry,
 		unsigned long dir_verifier)
@@ -1071,17 +1061,6 @@ int uncached_readdir(nfs_readdir_descriptor_t *desc)
 	return status;
 }
 
-static void nfs_readdir_handle_cache_misses(struct inode *inode,
-					    struct nfs_readdir_descriptor *desc,
-					    pgoff_t page_index,
-					    unsigned int cache_misses)
-{
-	if (desc->ctx->pos == 0 ||
-	    cache_misses <= NFS_READDIR_CACHE_MISS_THRESHOLD)
-		return;
-	invalidate_mapping_pages(inode->i_mapping, page_index + 1, -1);
-}
-
 /* The file offset position represents the dirent entry number.  A
    last cookie cache takes care of the common case of reading the
    whole directory.
@@ -1090,9 +1069,9 @@ static int nfs_readdir(struct file *file, struct dir_context *ctx)
 {
 	struct dentry	*dentry = file_dentry(file);
 	struct inode	*inode = d_inode(dentry);
+	struct nfs_inode *nfsi = NFS_I(inode);
 	struct nfs_open_dir_context *dir_ctx = file->private_data;
 	struct nfs_readdir_descriptor *desc;
-	unsigned int cache_hits, cache_misses;
 	pgoff_t page_index;
 	int res;
 
@@ -1118,6 +1097,7 @@ static int nfs_readdir(struct file *file, struct dir_context *ctx)
 		goto out;
 	desc->file = file;
 	desc->ctx = ctx;
+	desc->plus = nfs_use_readdirplus(inode, ctx);
 	desc->page_index_max = -1;
 
 	spin_lock(&file->f_lock);
@@ -1130,17 +1110,16 @@ static int nfs_readdir(struct file *file, struct dir_context *ctx)
 	desc->attr_gencount = dir_ctx->attr_gencount;
 	desc->eof = dir_ctx->eof;
 	nfs_set_dtsize(desc, dir_ctx->dtsize);
-	cache_hits = atomic_xchg(&dir_ctx->cache_hits, 0);
+	spin_unlock(&file->f_lock);
+
 	if (desc->eof) {
 		res = 0;
 		goto out_free;
 	}
 
-	cache_misses = atomic_xchg(&dir_ctx->cache_misses, 0);
-	spin_unlock(&file->f_lock);
-
-	desc->plus = nfs_use_readdirplus(inode, ctx, cache_hits, cache_misses);
-	nfs_readdir_handle_cache_misses(inode, desc, page_index, cache_misses);
+	if (test_and_clear_bit(NFS_INO_FORCE_READDIR, &nfsi->flags) &&
+	    list_is_singular(&nfsi->open_files))
+		invalidate_mapping_pages(inode->i_mapping, page_index + 1, -1);
 
 	do {
 		res = readdir_search_pagecache(desc);
@@ -1157,6 +1136,7 @@ static int nfs_readdir(struct file *file, struct dir_context *ctx)
 			break;
 		}
 		if (res == -ETOOSMALL && desc->plus) {
+			clear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);
 			nfs_zap_caches(inode);
 			desc->page_index = 0;
 			desc->plus = false;
@@ -1464,7 +1444,7 @@ nfs_lookup_revalidate_dentry(struct inode *dir, struct dentry *dentry,
 	nfs_set_verifier(dentry, dir_verifier);
 
 	/* set a readdirplus hint that we had a cache miss */
-	nfs_lookup_advise_force_readdirplus(dir);
+	nfs_force_use_readdirplus(dir);
 	ret = 1;
 out:
 	nfs_free_fattr(fattr);
@@ -1524,6 +1504,7 @@ nfs_do_lookup_revalidate(struct inode *dir, struct dentry *dentry,
 			}
 			goto out_bad;
 		}
+		nfs_advise_use_readdirplus(dir);
 		goto out_valid;
 	}
 
@@ -1733,7 +1714,7 @@ struct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, unsigned in
 		goto out_label;
 
 	/* Notify readdir to use READDIRPLUS */
-	nfs_lookup_advise_force_readdirplus(dir);
+	nfs_force_use_readdirplus(dir);
 
 no_entry:
 	res = d_splice_alias(inode, dentry);
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index 888fd451afb9d..05b6018aaa1f9 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -755,7 +755,7 @@ static void nfs_readdirplus_parent_cache_miss(struct dentry *dentry)
 	if (!nfs_server_capable(d_inode(dentry), NFS_CAP_READDIRPLUS))
 		return;
 	parent = dget_parent(dentry);
-	nfs_readdir_record_entry_cache_miss(d_inode(parent));
+	nfs_force_use_readdirplus(d_inode(parent));
 	dput(parent);
 }
 
@@ -766,7 +766,7 @@ static void nfs_readdirplus_parent_cache_hit(struct dentry *dentry)
 	if (!nfs_server_capable(d_inode(dentry), NFS_CAP_READDIRPLUS))
 		return;
 	parent = dget_parent(dentry);
-	nfs_readdir_record_entry_cache_hit(d_inode(parent));
+	nfs_advise_use_readdirplus(d_inode(parent));
 	dput(parent);
 }
 
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 675e5e25a2d6b..bf7c94cd6daa5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -356,8 +356,8 @@ extern struct nfs_client *nfs_init_client(struct nfs_client *clp,
 			   const struct nfs_client_initdata *);
 
 /* dir.c */
-extern void nfs_readdir_record_entry_cache_hit(struct inode *dir);
-extern void nfs_readdir_record_entry_cache_miss(struct inode *dir);
+extern void nfs_advise_use_readdirplus(struct inode *dir);
+extern void nfs_force_use_readdirplus(struct inode *dir);
 extern unsigned long nfs_access_cache_count(struct shrinker *shrink,
 					    struct shrink_control *sc);
 extern unsigned long nfs_access_cache_scan(struct shrinker *shrink,
diff --git a/fs/nfs/nfstrace.h b/fs/nfs/nfstrace.h
index d57214f518675..81dc6daa2187b 100644
--- a/fs/nfs/nfstrace.h
+++ b/fs/nfs/nfstrace.h
@@ -61,6 +61,7 @@ TRACE_DEFINE_ENUM(NFS_INO_INVALID_OTHER);
 			{ NFS_INO_INVALID_SIZE, "INVALID_SIZE" }, \
 			{ NFS_INO_INVALID_OTHER, "INVALID_OTHER" })
 
+TRACE_DEFINE_ENUM(NFS_INO_ADVISE_RDPLUS);
 TRACE_DEFINE_ENUM(NFS_INO_STALE);
 TRACE_DEFINE_ENUM(NFS_INO_ACL_LRU_SET);
 TRACE_DEFINE_ENUM(NFS_INO_INVALIDATING);
@@ -73,6 +74,7 @@ TRACE_DEFINE_ENUM(NFS_INO_ODIRECT);
 
 #define nfs_show_nfsi_flags(v) \
 	__print_flags(v, "|", \
+			{ BIT(NFS_INO_ADVISE_RDPLUS), "ADVISE_RDPLUS" }, \
 			{ BIT(NFS_INO_STALE), "STALE" }, \
 			{ BIT(NFS_INO_ACL_LRU_SET), "ACL_LRU_SET" }, \
 			{ BIT(NFS_INO_INVALIDATING), "INVALIDATING" }, \
diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
index 7f8286420810b..e2ca12b71a0a3 100644
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -98,8 +98,6 @@ struct nfs_open_context {
 
 struct nfs_open_dir_context {
 	struct list_head list;
-	atomic_t cache_hits;
-	atomic_t cache_misses;
 	unsigned long attr_gencount;
 	__u64 dir_cookie;
 	__u64 dup_cookie;
@@ -108,7 +106,6 @@ struct nfs_open_dir_context {
 	unsigned int dtsize;
 	signed char duped;
 	bool eof;
-	struct rcu_head rcu_head;
 };
 
 /*
@@ -256,11 +253,13 @@ struct nfs4_copy_state {
 /*
  * Bit offsets in flags field
  */
+#define NFS_INO_ADVISE_RDPLUS	(0)		/* advise readdirplus */
 #define NFS_INO_STALE		(1)		/* possible stale inode */
 #define NFS_INO_ACL_LRU_SET	(2)		/* Inode is on the LRU list */
 #define NFS_INO_INVALIDATING	(3)		/* inode is being invalidated */
 #define NFS_INO_FSCACHE		(5)		/* inode can be cached by FS-Cache */
 #define NFS_INO_FSCACHE_LOCK	(6)		/* FS-Cache cookie management lock */
+#define NFS_INO_FORCE_READDIR	(7)		/* force readdirplus */
 #define NFS_INO_LAYOUTCOMMIT	(9)		/* layoutcommit required */
 #define NFS_INO_LAYOUTCOMMITTING (10)		/* layoutcommit inflight */
 #define NFS_INO_LAYOUTSTATS	(11)		/* layoutstats inflight */
