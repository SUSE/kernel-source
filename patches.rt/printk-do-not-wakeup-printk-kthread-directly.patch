From: Petr Mladek <pmladek@suse.com>
Subject: printk: Do not wakeup printk kthread directly
Patch-mainline: Not yet, still being discussed upstream
References: bsc#1174146

printk_deferred() prevents deadlock when wake_up_process() is called from
scheduler context. The deadlock was rare. It happened only when printk()
was called from scheduler context, console_trylock() succeeded and another
process started waiting for the console semaphore while the original
printk was still holding it.

But there might be locations where normal printk() is called from scheduler
context by mistake. In this case, the deadlock will happen for sure now
because wake_up_process() is always called to wakeup the printk kthread.

Prevent this by waking the kthread via the already existing irq work.
It is the same way that is already used by printk_deferred().

Signed-off-by: Petr Mladek <pmladek@suse.com>
---
 kernel/printk/printk.c |    3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2058,8 +2058,7 @@ asmlinkage int vprintk_emit(int facility
 		if (console_loglevel != CONSOLE_LOGLEVEL_MOTORMOUTH &&
 				can_printk_async()) {
 			/* Offload printing to a schedulable context. */
-			printk_kthread_need_flush_console = true;
-			wake_up_process(printk_kthread);
+			defer_console_output();
 		} else {
 			/*
 			 * Disable preemption to avoid being preempted while
