From f82742dd479dfec7dc6a30a84f165a258c51ce09 Mon Sep 17 00:00:00 2001
From: Charles Keepax <ckeepax@opensource.cirrus.com>
Date: Tue, 8 Aug 2023 14:20:11 +0100
Subject: [PATCH] ASoC: intel: sof_sdw: Support multiple groups on the same link
Git-commit: f82742dd479dfec7dc6a30a84f165a258c51ce09
Patch-mainline: v6.6-rc1
References: jsc#PED-6045 jsc#PED-6036 jsc#PED-6104 jsc#PED-6114 jsc#PED-6067 jsc#PED-6123

The current code checks the first device on a link and assumes
that all the other devices on the link will have the same endpoint
aggregation status and endpoint group ID.

Say for example a system looked like:

SDW0 - Amp 1 (Aggregated, Group 1), Mic 1 (Aggregated, Group 2)
SDW1 - Amp 2 (Aggregated, Group 1), Mic 2 (Aggregated, Group 2)

The current code would create the DAI link for the aggregated amps,
although it is worth noting that the only reason Mic 2 is not added is
the additional check that aborts processing the link when the device
changes. Then when processing the DAI link for the microphones, Mic
2 would not be added, as the check will only be done on the first
device, which would be Amp 2 and thus the wrong group, causing the
whole link to be skipped.

Move the endpoint check to be for each device rather than the first
device on each link.

Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20230808132013.889419-10-ckeepax@opensource.cirrus.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/intel/boards/sof_sdw.c | 42 ++++++++++++++++----------------
 1 file changed, 21 insertions(+), 21 deletions(-)

diff --git a/sound/soc/intel/boards/sof_sdw.c b/sound/soc/intel/boards/sof_sdw.c
index 767c49022eae..357946365e76 100644
--- a/sound/soc/intel/boards/sof_sdw.c
+++ b/sound/soc/intel/boards/sof_sdw.c
@@ -1288,25 +1288,24 @@ static int get_slave_info(const struct snd_soc_acpi_link_adr *adr_link,
 	}
 
 	/* gather other link ID of slaves in the same group */
-	for (adr_next = adr_link + 1; adr_next && adr_next->num_adr;
-		adr_next++) {
-		const struct snd_soc_acpi_endpoint *endpoint;
+	for (adr_next = adr_link + 1; adr_next && adr_next->num_adr; adr_next++) {
+		unsigned int link_codecs = 0;
 
-		endpoint = adr_next->adr_d->endpoints;
-		if (!endpoint->aggregated ||
-		    endpoint->group_id != *group_id)
-			continue;
-
-		if (index >= SDW_MAX_CPU_DAIS) {
-			dev_err(dev, "cpu_dai_id array overflows\n");
-			return -EINVAL;
-		}
-
-		cpu_dai_id[index++] = ffs(adr_next->mask) - 1;
 		for (i = 0; i < adr_next->num_adr; i++) {
 			if (adr_next->adr_d[i].endpoints->aggregated &&
 			    adr_next->adr_d[i].endpoints->group_id == *group_id)
-				(*codec_num)++;
+				link_codecs++;
+		}
+
+		if (link_codecs) {
+			*codec_num += link_codecs;
+
+			if (index >= SDW_MAX_CPU_DAIS) {
+				dev_err(dev, "cpu_dai_id array overflowed\n");
+				return -EINVAL;
+			}
+
+			cpu_dai_id[index++] = ffs(adr_next->mask) - 1;
 		}
 	}
 
@@ -1369,20 +1368,15 @@ static int create_sdw_dailink(struct snd_soc_card *card, int *link_index,
 	j = adr_index;
 	for (adr_link_next = adr_link; adr_link_next && adr_link_next->num_adr &&
 	     i < cpu_dai_num; adr_link_next++) {
-		const struct snd_soc_acpi_endpoint *endpoints;
 		int _codec_index = -1;
 
-		endpoints = adr_link_next->adr_d->endpoints;
-		if (group_id && (!endpoints->aggregated ||
-				 endpoints->group_id != group_id))
-			continue;
-
 		/* skip the link excluded by this processed group */
 		if (cpu_dai_id[i] != ffs(adr_link_next->mask) - 1)
 			continue;
 
 		/* j reset after loop, adr_index only applies to first link */
 		for (; j < adr_link_next->num_adr; j++) {
+			const struct snd_soc_acpi_endpoint *endpoints;
 			int codec_index;
 			u64 adr = adr_link_next->adr_d[j].adr;
 
@@ -1395,6 +1389,12 @@ static int create_sdw_dailink(struct snd_soc_card *card, int *link_index,
 			}
 			_codec_index = codec_index;
 
+			endpoints = adr_link_next->adr_d[j].endpoints;
+
+			if (group_id && (!endpoints->aggregated ||
+					 endpoints->group_id != group_id))
+				continue;
+
 			/* sanity check */
 			if (*codec_conf_index >= codec_count) {
 				dev_err(dev, "codec_conf array overflowed\n");
-- 
2.35.3

