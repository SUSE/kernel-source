From 8d38f12840df33b1ec95da3fd51784fd55fbcb0b Mon Sep 17 00:00:00 2001
From: Vinay Belgaumkar <vinay.belgaumkar@intel.com>
Date: Fri, 17 Nov 2023 18:06:16 -0800
Subject: drm/xe: Rename xe_gt_idle_sysfs to xe_gt_idle
Git-commit: c550f64f082b9da305ab7d07b8716389a80b641a
Patch-mainline: v6.8-rc1
References: jsc#PED-9898 jsc#PED-10191 jsc#PED-10197 jsc#PED-10226 jsc#PED-10237 jsc#PED-10340 jsc#PED-10852 jsc#PED-11022

Prep this file to contain C6 toggling as well instead
of just sysfs related stuff.

Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Signed-off-by: Vinay Belgaumkar <vinay.belgaumkar@intel.com>
Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/xe/Makefile                 |   2 +-
 drivers/gpu/drm/xe/xe_gt.c                  |   2 +-
 drivers/gpu/drm/xe/xe_gt_idle.c             | 168 ++++++++++++++++++++
 drivers/gpu/drm/xe/xe_gt_idle.h             |  13 ++
 drivers/gpu/drm/xe/xe_gt_idle_sysfs.c       | 168 --------------------
 drivers/gpu/drm/xe/xe_gt_idle_sysfs.h       |  13 --
 drivers/gpu/drm/xe/xe_gt_idle_sysfs_types.h |  38 -----
 drivers/gpu/drm/xe/xe_gt_idle_types.h       |  38 +++++
 drivers/gpu/drm/xe/xe_gt_types.h            |   2 +-
 9 files changed, 222 insertions(+), 222 deletions(-)
 create mode 100644 drivers/gpu/drm/xe/xe_gt_idle.c
 create mode 100644 drivers/gpu/drm/xe/xe_gt_idle.h
 delete mode 100644 drivers/gpu/drm/xe/xe_gt_idle_sysfs.c
 delete mode 100644 drivers/gpu/drm/xe/xe_gt_idle_sysfs.h
 delete mode 100644 drivers/gpu/drm/xe/xe_gt_idle_sysfs_types.h
 create mode 100644 drivers/gpu/drm/xe/xe_gt_idle_types.h

diff --git a/drivers/gpu/drm/xe/Makefile b/drivers/gpu/drm/xe/Makefile
index 161e8ead9114..b8ad42fcbea2 100644
--- a/drivers/gpu/drm/xe/Makefile
+++ b/drivers/gpu/drm/xe/Makefile
@@ -72,7 +72,7 @@ xe-y += xe_bb.o \
 	xe_gt.o \
 	xe_gt_clock.o \
 	xe_gt_debugfs.o \
-	xe_gt_idle_sysfs.o \
+	xe_gt_idle.o \
 	xe_gt_mcr.o \
 	xe_gt_pagefault.o \
 	xe_gt_sysfs.o \
diff --git a/drivers/gpu/drm/xe/xe_gt.c b/drivers/gpu/drm/xe/xe_gt.c
index 00193b02a7e5..8a6fb9641cd6 100644
--- a/drivers/gpu/drm/xe/xe_gt.c
+++ b/drivers/gpu/drm/xe/xe_gt.c
@@ -23,7 +23,7 @@
 #include "xe_ggtt.h"
 #include "xe_gsc.h"
 #include "xe_gt_clock.h"
-#include "xe_gt_idle_sysfs.h"
+#include "xe_gt_idle.h"
 #include "xe_gt_mcr.h"
 #include "xe_gt_pagefault.h"
 #include "xe_gt_printk.h"
diff --git a/drivers/gpu/drm/xe/xe_gt_idle.c b/drivers/gpu/drm/xe/xe_gt_idle.c
new file mode 100644
index 000000000000..e5b7e5d38e76
--- /dev/null
+++ b/drivers/gpu/drm/xe/xe_gt_idle.c
@@ -0,0 +1,168 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright © 2023 Intel Corporation
+ */
+
+#include <drm/drm_managed.h>
+
+#include "xe_device.h"
+#include "xe_gt.h"
+#include "xe_gt_idle.h"
+#include "xe_gt_sysfs.h"
+#include "xe_guc_pc.h"
+
+/**
+ * DOC: Xe GT Idle
+ *
+ * Contains functions that init GT idle features like C6
+ *
+ * device/gt#/gtidle/name - name of the state
+ * device/gt#/gtidle/idle_residency_ms - Provides residency of the idle state in ms
+ * device/gt#/gtidle/idle_status - Provides current idle state
+ */
+
+static struct xe_gt_idle *dev_to_gtidle(struct device *dev)
+{
+	struct kobject *kobj = &dev->kobj;
+
+	return &kobj_to_gt(kobj->parent)->gtidle;
+}
+
+static struct xe_gt *gtidle_to_gt(struct xe_gt_idle *gtidle)
+{
+	return container_of(gtidle, struct xe_gt, gtidle);
+}
+
+static struct xe_guc_pc *gtidle_to_pc(struct xe_gt_idle *gtidle)
+{
+	return &gtidle_to_gt(gtidle)->uc.guc.pc;
+}
+
+static const char *gt_idle_state_to_string(enum xe_gt_idle_state state)
+{
+	switch (state) {
+	case GT_IDLE_C0:
+		return "gt-c0";
+	case GT_IDLE_C6:
+		return "gt-c6";
+	default:
+		return "unknown";
+	}
+}
+
+static u64 get_residency_ms(struct xe_gt_idle *gtidle, u64 cur_residency)
+{
+	u64 delta, overflow_residency, prev_residency;
+
+	overflow_residency = BIT_ULL(32);
+
+	/*
+	 * Counter wrap handling
+	 * Store previous hw counter values for counter wrap-around handling
+	 * Relying on sufficient frequency of queries otherwise counters can still wrap.
+	 */
+	prev_residency = gtidle->prev_residency;
+	gtidle->prev_residency = cur_residency;
+
+	/* delta */
+	if (cur_residency >= prev_residency)
+		delta = cur_residency - prev_residency;
+	else
+		delta = cur_residency + (overflow_residency - prev_residency);
+
+	/* Add delta to extended raw driver copy of idle residency */
+	cur_residency = gtidle->cur_residency + delta;
+	gtidle->cur_residency = cur_residency;
+
+	/* residency multiplier in ns, convert to ms */
+	cur_residency = mul_u64_u32_div(cur_residency, gtidle->residency_multiplier, 1e6);
+
+	return cur_residency;
+}
+
+static ssize_t name_show(struct device *dev,
+			 struct device_attribute *attr, char *buff)
+{
+	struct xe_gt_idle *gtidle = dev_to_gtidle(dev);
+
+	return sysfs_emit(buff, "%s\n", gtidle->name);
+}
+static DEVICE_ATTR_RO(name);
+
+static ssize_t idle_status_show(struct device *dev,
+				struct device_attribute *attr, char *buff)
+{
+	struct xe_gt_idle *gtidle = dev_to_gtidle(dev);
+	struct xe_guc_pc *pc = gtidle_to_pc(gtidle);
+	enum xe_gt_idle_state state;
+
+	state = gtidle->idle_status(pc);
+
+	return sysfs_emit(buff, "%s\n", gt_idle_state_to_string(state));
+}
+static DEVICE_ATTR_RO(idle_status);
+
+static ssize_t idle_residency_ms_show(struct device *dev,
+				      struct device_attribute *attr, char *buff)
+{
+	struct xe_gt_idle *gtidle = dev_to_gtidle(dev);
+	struct xe_guc_pc *pc = gtidle_to_pc(gtidle);
+	u64 residency;
+
+	residency = gtidle->idle_residency(pc);
+	return sysfs_emit(buff, "%llu\n", get_residency_ms(gtidle, residency));
+}
+static DEVICE_ATTR_RO(idle_residency_ms);
+
+static const struct attribute *gt_idle_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_idle_status.attr,
+	&dev_attr_idle_residency_ms.attr,
+	NULL,
+};
+
+static void gt_idle_sysfs_fini(struct drm_device *drm, void *arg)
+{
+	struct kobject *kobj = arg;
+
+	sysfs_remove_files(kobj, gt_idle_attrs);
+	kobject_put(kobj);
+}
+
+void xe_gt_idle_sysfs_init(struct xe_gt_idle *gtidle)
+{
+	struct xe_gt *gt = gtidle_to_gt(gtidle);
+	struct xe_device *xe = gt_to_xe(gt);
+	struct kobject *kobj;
+	int err;
+
+	kobj = kobject_create_and_add("gtidle", gt->sysfs);
+	if (!kobj) {
+		drm_warn(&xe->drm, "%s failed, err: %d\n", __func__, -ENOMEM);
+		return;
+	}
+
+	if (xe_gt_is_media_type(gt)) {
+		sprintf(gtidle->name, "gt%d-mc\n", gt->info.id);
+		gtidle->idle_residency = xe_guc_pc_mc6_residency;
+	} else {
+		sprintf(gtidle->name, "gt%d-rc\n", gt->info.id);
+		gtidle->idle_residency = xe_guc_pc_rc6_residency;
+	}
+
+	/* Multiplier for Residency counter in units of 1.28us */
+	gtidle->residency_multiplier = 1280;
+	gtidle->idle_status = xe_guc_pc_c_status;
+
+	err = sysfs_create_files(kobj, gt_idle_attrs);
+	if (err) {
+		kobject_put(kobj);
+		drm_warn(&xe->drm, "failed to register gtidle sysfs, err: %d\n", err);
+		return;
+	}
+
+	err = drmm_add_action_or_reset(&xe->drm, gt_idle_sysfs_fini, kobj);
+	if (err)
+		drm_warn(&xe->drm, "%s: drmm_add_action_or_reset failed, err: %d\n",
+			 __func__, err);
+}
diff --git a/drivers/gpu/drm/xe/xe_gt_idle.h b/drivers/gpu/drm/xe/xe_gt_idle.h
new file mode 100644
index 000000000000..9b36bf7db3a7
--- /dev/null
+++ b/drivers/gpu/drm/xe/xe_gt_idle.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright © 2023 Intel Corporation
+ */
+
+#ifndef _XE_GT_IDLE_H_
+#define _XE_GT_IDLE_H_
+
+#include "xe_gt_idle_types.h"
+
+void xe_gt_idle_sysfs_init(struct xe_gt_idle *gtidle);
+
+#endif /* _XE_GT_IDLE_H_ */
diff --git a/drivers/gpu/drm/xe/xe_gt_idle_sysfs.c b/drivers/gpu/drm/xe/xe_gt_idle_sysfs.c
deleted file mode 100644
index 8df9840811cd..000000000000
--- a/drivers/gpu/drm/xe/xe_gt_idle_sysfs.c
+++ /dev/null
@@ -1,168 +0,0 @@
-// SPDX-License-Identifier: MIT
-/*
- * Copyright © 2023 Intel Corporation
- */
-
-#include <drm/drm_managed.h>
-
-#include "xe_device.h"
-#include "xe_gt.h"
-#include "xe_gt_idle_sysfs.h"
-#include "xe_gt_sysfs.h"
-#include "xe_guc_pc.h"
-
-/**
- * DOC: Xe GT Idle
- *
- * Provides sysfs entries for idle properties of GT
- *
- * device/gt#/gtidle/name - name of the state
- * device/gt#/gtidle/idle_residency_ms - Provides residency of the idle state in ms
- * device/gt#/gtidle/idle_status - Provides current idle state
- */
-
-static struct xe_gt_idle *dev_to_gtidle(struct device *dev)
-{
-	struct kobject *kobj = &dev->kobj;
-
-	return &kobj_to_gt(kobj->parent)->gtidle;
-}
-
-static struct xe_gt *gtidle_to_gt(struct xe_gt_idle *gtidle)
-{
-	return container_of(gtidle, struct xe_gt, gtidle);
-}
-
-static struct xe_guc_pc *gtidle_to_pc(struct xe_gt_idle *gtidle)
-{
-	return &gtidle_to_gt(gtidle)->uc.guc.pc;
-}
-
-static const char *gt_idle_state_to_string(enum xe_gt_idle_state state)
-{
-	switch (state) {
-	case GT_IDLE_C0:
-		return "gt-c0";
-	case GT_IDLE_C6:
-		return "gt-c6";
-	default:
-		return "unknown";
-	}
-}
-
-static u64 get_residency_ms(struct xe_gt_idle *gtidle, u64 cur_residency)
-{
-	u64 delta, overflow_residency, prev_residency;
-
-	overflow_residency = BIT_ULL(32);
-
-	/*
-	 * Counter wrap handling
-	 * Store previous hw counter values for counter wrap-around handling
-	 * Relying on sufficient frequency of queries otherwise counters can still wrap.
-	 */
-	prev_residency = gtidle->prev_residency;
-	gtidle->prev_residency = cur_residency;
-
-	/* delta */
-	if (cur_residency >= prev_residency)
-		delta = cur_residency - prev_residency;
-	else
-		delta = cur_residency + (overflow_residency - prev_residency);
-
-	/* Add delta to extended raw driver copy of idle residency */
-	cur_residency = gtidle->cur_residency + delta;
-	gtidle->cur_residency = cur_residency;
-
-	/* residency multiplier in ns, convert to ms */
-	cur_residency = mul_u64_u32_div(cur_residency, gtidle->residency_multiplier, 1e6);
-
-	return cur_residency;
-}
-
-static ssize_t name_show(struct device *dev,
-			 struct device_attribute *attr, char *buff)
-{
-	struct xe_gt_idle *gtidle = dev_to_gtidle(dev);
-
-	return sysfs_emit(buff, "%s\n", gtidle->name);
-}
-static DEVICE_ATTR_RO(name);
-
-static ssize_t idle_status_show(struct device *dev,
-				struct device_attribute *attr, char *buff)
-{
-	struct xe_gt_idle *gtidle = dev_to_gtidle(dev);
-	struct xe_guc_pc *pc = gtidle_to_pc(gtidle);
-	enum xe_gt_idle_state state;
-
-	state = gtidle->idle_status(pc);
-
-	return sysfs_emit(buff, "%s\n", gt_idle_state_to_string(state));
-}
-static DEVICE_ATTR_RO(idle_status);
-
-static ssize_t idle_residency_ms_show(struct device *dev,
-				      struct device_attribute *attr, char *buff)
-{
-	struct xe_gt_idle *gtidle = dev_to_gtidle(dev);
-	struct xe_guc_pc *pc = gtidle_to_pc(gtidle);
-	u64 residency;
-
-	residency = gtidle->idle_residency(pc);
-	return sysfs_emit(buff, "%llu\n", get_residency_ms(gtidle, residency));
-}
-static DEVICE_ATTR_RO(idle_residency_ms);
-
-static const struct attribute *gt_idle_attrs[] = {
-	&dev_attr_name.attr,
-	&dev_attr_idle_status.attr,
-	&dev_attr_idle_residency_ms.attr,
-	NULL,
-};
-
-static void gt_idle_sysfs_fini(struct drm_device *drm, void *arg)
-{
-	struct kobject *kobj = arg;
-
-	sysfs_remove_files(kobj, gt_idle_attrs);
-	kobject_put(kobj);
-}
-
-void xe_gt_idle_sysfs_init(struct xe_gt_idle *gtidle)
-{
-	struct xe_gt *gt = gtidle_to_gt(gtidle);
-	struct xe_device *xe = gt_to_xe(gt);
-	struct kobject *kobj;
-	int err;
-
-	kobj = kobject_create_and_add("gtidle", gt->sysfs);
-	if (!kobj) {
-		drm_warn(&xe->drm, "%s failed, err: %d\n", __func__, -ENOMEM);
-		return;
-	}
-
-	if (xe_gt_is_media_type(gt)) {
-		sprintf(gtidle->name, "gt%d-mc\n", gt->info.id);
-		gtidle->idle_residency = xe_guc_pc_mc6_residency;
-	} else {
-		sprintf(gtidle->name, "gt%d-rc\n", gt->info.id);
-		gtidle->idle_residency = xe_guc_pc_rc6_residency;
-	}
-
-	/* Multiplier for Residency counter in units of 1.28us */
-	gtidle->residency_multiplier = 1280;
-	gtidle->idle_status = xe_guc_pc_c_status;
-
-	err = sysfs_create_files(kobj, gt_idle_attrs);
-	if (err) {
-		kobject_put(kobj);
-		drm_warn(&xe->drm, "failed to register gtidle sysfs, err: %d\n", err);
-		return;
-	}
-
-	err = drmm_add_action_or_reset(&xe->drm, gt_idle_sysfs_fini, kobj);
-	if (err)
-		drm_warn(&xe->drm, "%s: drmm_add_action_or_reset failed, err: %d\n",
-			 __func__, err);
-}
diff --git a/drivers/gpu/drm/xe/xe_gt_idle_sysfs.h b/drivers/gpu/drm/xe/xe_gt_idle_sysfs.h
deleted file mode 100644
index b0973f96c7ab..000000000000
--- a/drivers/gpu/drm/xe/xe_gt_idle_sysfs.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-/*
- * Copyright © 2023 Intel Corporation
- */
-
-#ifndef _XE_GT_IDLE_SYSFS_H_
-#define _XE_GT_IDLE_SYSFS_H_
-
-#include "xe_gt_idle_sysfs_types.h"
-
-void xe_gt_idle_sysfs_init(struct xe_gt_idle *gtidle);
-
-#endif /* _XE_GT_IDLE_SYSFS_H_ */
diff --git a/drivers/gpu/drm/xe/xe_gt_idle_sysfs_types.h b/drivers/gpu/drm/xe/xe_gt_idle_sysfs_types.h
deleted file mode 100644
index f99b447534f3..000000000000
--- a/drivers/gpu/drm/xe/xe_gt_idle_sysfs_types.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-/*
- * Copyright © 2023 Intel Corporation
- */
-
-#ifndef _XE_GT_IDLE_SYSFS_TYPES_H_
-#define _XE_GT_IDLE_SYSFS_TYPES_H_
-
-#include <linux/types.h>
-
-struct xe_guc_pc;
-
-/* States of GT Idle */
-enum xe_gt_idle_state {
-	GT_IDLE_C0,
-	GT_IDLE_C6,
-	GT_IDLE_UNKNOWN,
-};
-
-/**
- * struct xe_gt_idle - A struct that contains idle properties based of gt
- */
-struct xe_gt_idle {
-	/** @name: name */
-	char name[16];
-	/** @residency_multiplier: residency multiplier in ns */
-	u32 residency_multiplier;
-	/** @cur_residency: raw driver copy of idle residency */
-	u64 cur_residency;
-	/** @prev_residency: previous residency counter */
-	u64 prev_residency;
-	/** @idle_status: get the current idle state */
-	enum xe_gt_idle_state (*idle_status)(struct xe_guc_pc *pc);
-	/** @idle_residency: get idle residency counter */
-	u64 (*idle_residency)(struct xe_guc_pc *pc);
-};
-
-#endif /* _XE_GT_IDLE_SYSFS_TYPES_H_ */
diff --git a/drivers/gpu/drm/xe/xe_gt_idle_types.h b/drivers/gpu/drm/xe/xe_gt_idle_types.h
new file mode 100644
index 000000000000..f99b447534f3
--- /dev/null
+++ b/drivers/gpu/drm/xe/xe_gt_idle_types.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright © 2023 Intel Corporation
+ */
+
+#ifndef _XE_GT_IDLE_SYSFS_TYPES_H_
+#define _XE_GT_IDLE_SYSFS_TYPES_H_
+
+#include <linux/types.h>
+
+struct xe_guc_pc;
+
+/* States of GT Idle */
+enum xe_gt_idle_state {
+	GT_IDLE_C0,
+	GT_IDLE_C6,
+	GT_IDLE_UNKNOWN,
+};
+
+/**
+ * struct xe_gt_idle - A struct that contains idle properties based of gt
+ */
+struct xe_gt_idle {
+	/** @name: name */
+	char name[16];
+	/** @residency_multiplier: residency multiplier in ns */
+	u32 residency_multiplier;
+	/** @cur_residency: raw driver copy of idle residency */
+	u64 cur_residency;
+	/** @prev_residency: previous residency counter */
+	u64 prev_residency;
+	/** @idle_status: get the current idle state */
+	enum xe_gt_idle_state (*idle_status)(struct xe_guc_pc *pc);
+	/** @idle_residency: get idle residency counter */
+	u64 (*idle_residency)(struct xe_guc_pc *pc);
+};
+
+#endif /* _XE_GT_IDLE_SYSFS_TYPES_H_ */
diff --git a/drivers/gpu/drm/xe/xe_gt_types.h b/drivers/gpu/drm/xe/xe_gt_types.h
index d3f2793684e2..a96ee7d028aa 100644
--- a/drivers/gpu/drm/xe/xe_gt_types.h
+++ b/drivers/gpu/drm/xe/xe_gt_types.h
@@ -7,7 +7,7 @@
 #define _XE_GT_TYPES_H_
 
 #include "xe_force_wake_types.h"
-#include "xe_gt_idle_sysfs_types.h"
+#include "xe_gt_idle_types.h"
 #include "xe_hw_engine_types.h"
 #include "xe_hw_fence_types.h"
 #include "xe_reg_sr_types.h"
-- 
2.46.1

