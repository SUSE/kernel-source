From b3b280ea2599aa79b2d8fff26e442300c9ada8c0 Mon Sep 17 00:00:00 2001
From: Oscar Salvador <osalvador@suse.de>
Date: Tue, 26 Mar 2024 05:31:33 +0100
Subject: [PATCH] mm,page_owner: Fix accounting of pages when migrating
References: bsc#1222366
Patch-mainline: submitted https://patchwork.kernel.org/project/linux-mm/patch/20240404070702.2744-4-osalvador@suse.de/

Upon migration, new allocated pages are being given the handle of the old
pages. This is problematic because it means that for the stack which
allocated the old page, we will be substracting the old page + the new one
when that page is freed, creating an accounting imbalance.

There is an interest in keeping it that way, as otherwise the output will
biased towards migration stacks should those operations occur often, but
that is not really helpful.
The link from the new page to the old stack is being performed by calling
__update_page_owner_handle() in __folio_copy_owner().
The only thing that is left is to link the migrate stack to the old
page, so the old page will be subtracted from the migrate stack,
avoiding by doing so any possible imbalance.

Fixes: 217b2119b9e2 ("mm,page_owner: implement the tracking of the stacks count")
Signed-off-by: Oscar Salvador <osalvador@suse.de>
Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
---
 mm/page_owner.c |   15 +++++++++++++++
 1 file changed, 15 insertions(+)

--- a/mm/page_owner.c
+++ b/mm/page_owner.c
@@ -344,14 +344,18 @@ void __split_page_owner(struct page *pag
 
 void __copy_page_owner(struct page *oldpage, struct page *newpage)
 {
+	int i;
 	struct page_ext *old_ext = lookup_page_ext(oldpage);
 	struct page_ext *new_ext = lookup_page_ext(newpage);
 	struct page_owner *old_page_owner, *new_page_owner;
+	depot_stack_handle_t migrate_handle;
 
 	if (unlikely(!old_ext || !new_ext))
 		return;
 
 	old_page_owner = get_page_owner(old_ext);
+	new_page_owner = get_page_owner(new_ext);
+	migrate_handle = new_page_owner->handle;
 	__update_page_owner_handle(new_ext, old_page_owner->handle,
 				   old_page_owner->order, old_page_owner->gfp_mask,
 				   old_page_owner->last_migrate_reason,
@@ -364,6 +368,17 @@ void __copy_page_owner(struct page *oldp
 	 */
 	__update_page_owner_free_handle(new_ext, 0, old_page_owner->order,
 					old_page_owner->free_ts_nsec);
+
+	/*
+	 * We linked the original stack to the new page, we need to do the same
+	 * for the new one and the old page otherwise there will be an imbalance
+	 * when subtracting those pages from the stack.
+	 */
+	for (i = 0; i < (1 << new_page_owner->order); i++) {
+		old_page_owner->handle = migrate_handle;
+		old_ext = page_ext_next(old_ext);
+		old_page_owner = get_page_owner(old_ext);
+	}
 }
 
 void pagetypeinfo_showmixedcount_print(struct seq_file *m,
