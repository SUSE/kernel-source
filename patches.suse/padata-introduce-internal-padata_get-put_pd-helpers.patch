From 77bf627189256c7051c401336d0a00d9712df2f6 Mon Sep 17 00:00:00 2001
From: Nicolai Stange <nstange@suse.de>
Date: Sat, 24 Sep 2022 20:10:42 +0200
Patch-mainline: Submitted, 2022-10-19 linux-crypto@vger.kernel.org
References: bsc#1202638
Subject: padata: introduce internal padata_get/put_pd() helpers

The next commit in this series will add yet another code site decrementing
a struct parallel_data's refcount and invoking dealloction as appropriate.

With that, it's due to provide proper helper functions for managing
parallel_datas' refcounts and to convert the existing open-coded
refcount manipulation sites.

Implement padata_put_pd() as well as a padata_put_pd_many() for batched
releases as needed in padata_serial_worker(). For symmetry reasons, also
provide a padata_put_get(), even though its implementation is fairly
trivial.

Convert the exisiting open-coded parallel_data ->refcnt manipulation code
sites to these new helpers.

Signed-off-by: Nicolai Stange <nstange@suse.de>
---
 kernel/padata.c |   27 ++++++++++++++++++++++-----
 1 file changed, 22 insertions(+), 5 deletions(-)

--- a/kernel/padata.c
+++ b/kernel/padata.c
@@ -36,6 +36,9 @@
 #define MAX_OBJ_NUM 1000
 
 static void padata_free_pd(struct parallel_data *pd);
+static inline void padata_get_pd(struct parallel_data *pd);
+static void padata_put_pd_many(struct parallel_data *pd, int cnt);
+static inline void padata_put_pd(struct parallel_data *pd);
 
 static int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)
 {
@@ -140,7 +143,7 @@ int padata_do_parallel(struct padata_she
 		goto out;
 
 	err = 0;
-	atomic_inc(&pd->refcnt);
+	padata_get_pd(pd);
 	padata->pd = pd;
 	padata->cb_cpu = *cb_cpu;
 
@@ -311,8 +314,7 @@ static void padata_serial_worker(struct
 	}
 	local_bh_enable();
 
-	if (atomic_sub_and_test(cnt, &pd->refcnt))
-		padata_free_pd(pd);
+	padata_put_pd_many(pd, cnt);
 }
 
 /**
@@ -491,6 +493,22 @@ static void padata_free_pd(struct parall
 	kfree(pd);
 }
 
+static inline void padata_get_pd(struct parallel_data *pd)
+{
+	atomic_inc(&pd->refcnt);
+}
+
+static void padata_put_pd_many(struct parallel_data *pd, int cnt)
+{
+	if (atomic_sub_and_test(cnt, &pd->refcnt))
+		padata_free_pd(pd);
+}
+
+static inline void padata_put_pd(struct parallel_data *pd)
+{
+	padata_put_pd_many(pd, 1);
+}
+
 static void __padata_start(struct padata_instance *pinst)
 {
 	pinst->flags |= PADATA_INIT;
@@ -550,8 +568,7 @@ static int padata_replace(struct padata_
 	synchronize_rcu();
 
 	list_for_each_entry_continue_reverse(ps, &pinst->pslist, list)
-		if (atomic_dec_and_test(&ps->opd->refcnt))
-			padata_free_pd(ps->opd);
+		padata_put_pd(ps->opd);
 
 	if (notification_mask)
 		blocking_notifier_call_chain(&pinst->cpumask_change_notifier,
