From 722cbbfaed2a290b1de1fb0ec4ee9a15ec240f7c Mon Sep 17 00:00:00 2001
From: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date: Thu, 21 Apr 2022 15:31:59 -0500
Subject: [PATCH] ASoC: SOF: Intel: hda-dai: reset dma_data and release stream
Mime-version: 1.0
Content-type: text/plain; charset=UTF-8
Content-transfer-encoding: 8bit
Git-commit: 722cbbfaed2a290b1de1fb0ec4ee9a15ec240f7c
Patch-mainline: v5.19-rc1
References: jsc#PED-850

The sequences are missing a call to snd_soc_dai_set_dma_data() when
the stream is cleared, as well as a release of the stream, and tests
to avoid pointer dereferences.

This fixes an underflow issue in a corner case with two streams paused
before a suspend-resume cycle. After resume, the pause_release of the
last stream causes an underflow due to an invalid sequence.

This problem probably existed since the beginning and is only see with
prototypes of a 'deep-buffer' capability, which depends on additional
ASoC fixes, so there's is no Fixes: tag and no real requirement to
backport this patch.

Buglink: https://github.com/thesofproject/linux/issues/3151
Co-developed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Reviewed-by: Rander Wang <rander.wang@intel.com>
Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
Link: https://lore.kernel.org/r/20220421203201.1550328-13-pierre-louis.bossart@linux.intel.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/sof/intel/hda-dai.c | 18 ++++++++++++++++--
 1 file changed, 16 insertions(+), 2 deletions(-)

diff --git a/sound/soc/sof/intel/hda-dai.c b/sound/soc/sof/intel/hda-dai.c
index dbccd75defe8..644f75081edd 100644
--- a/sound/soc/sof/intel/hda-dai.c
+++ b/sound/soc/sof/intel/hda-dai.c
@@ -230,6 +230,9 @@ static int hda_link_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 		return -EINVAL;
 
 	dev_dbg(cpu_dai->dev, "%s: cmd=%d\n", __func__, cmd);
+	if (!hext_stream)
+		return 0;
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
@@ -243,8 +246,10 @@ static int hda_link_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 			stream_tag = hdac_stream(hext_stream)->stream_tag;
 			snd_hdac_ext_link_clear_stream_id(link, stream_tag);
 		}
-
+		snd_soc_dai_set_dma_data(cpu_dai, substream, NULL);
+		snd_hdac_ext_stream_release(hext_stream, HDAC_EXT_STREAM_TYPE_LINK);
 		hext_stream->link_prepared = 0;
+
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		snd_hdac_ext_link_stream_clear(hext_stream);
@@ -370,7 +375,7 @@ static int ipc3_hda_dai_prepare(struct snd_pcm_substream *substream,
 	int stream = substream->stream;
 	int ret;
 
-	if (hext_stream->link_prepared)
+	if (hext_stream && hext_stream->link_prepared)
 		return 0;
 
 	dev_dbg(sdev->dev, "%s: prepare stream dir %d\n", __func__, substream->stream);
@@ -460,6 +465,8 @@ static int hda_dai_suspend(struct hdac_bus *bus)
 
 	/* set internal flag for BE */
 	list_for_each_entry(s, &bus->stream_list, list) {
+		struct sof_intel_hda_stream *hda_stream;
+
 		hext_stream = stream_to_hdac_ext_stream(s);
 
 		/*
@@ -489,13 +496,20 @@ static int hda_dai_suspend(struct hdac_bus *bus)
 				stream_tag = hdac_stream(hext_stream)->stream_tag;
 				snd_hdac_ext_link_clear_stream_id(link, stream_tag);
 			}
+			snd_soc_dai_set_dma_data(cpu_dai, hext_stream->link_substream, NULL);
+			snd_hdac_ext_stream_release(hext_stream, HDAC_EXT_STREAM_TYPE_LINK);
 			hext_stream->link_prepared = 0;
 
+			/* free the host DMA channel reserved by hostless streams */
+			hda_stream = hstream_to_sof_hda_stream(hext_stream);
+			hda_stream->host_reserved = 0;
+
 			/* for consistency with TRIGGER_SUSPEND we free DAI resources */
 			ret = hda_dai_hw_free_ipc(hdac_stream(hext_stream)->direction, cpu_dai);
 			if (ret < 0)
 				return ret;
 		}
+
 	}
 
 	return 0;
-- 
2.35.3

