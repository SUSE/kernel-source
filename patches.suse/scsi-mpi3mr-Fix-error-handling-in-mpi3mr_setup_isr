From: Dan Carpenter <dan.carpenter@oracle.com>
Date: Wed, 9 Jun 2021 12:27:14 +0300
Subject: scsi: mpi3mr: Fix error handling in mpi3mr_setup_isr()
Git-commit: 2938bedd0efa0964db563999b9b3b866b2d1a090
Patch-mainline: v5.14-rc1
References: git-fixes

The pci_alloc_irq_vectors_affinity() function returns negative error codes
or it returns a number between the minimum vectors (1 in this case) and
max_vectors.  It won't return zero.  Because "i" is a u16 then the error
handling won't work.  And also if it did work the error code was not set.

Really "max_vectors" can be an int as well because we're doing a min_t() on
int type.  The other change is that it's better to remove unnecessary
initialization so that static checkers can warn us if there are ever
uninitialized variable bugs introduced in the future.

I changed the error code from -1 (-EPERM) if the kmalloc() failed to
-ENOMEM.  And on success path I changed it from "return retval;" to "return
0;" which shouldn't affect the compiled code but makes it more readable.

Link: https://lore.kernel.org/r/YMCJcnmSI4kOIyv/@mwanda
Fixes: 824a156633df ("scsi: mpi3mr: Base driver code")
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Acked-by: Lee Duncan <lduncan@suse.com>
---
 drivers/scsi/mpi3mr/mpi3mr_fw.c | 24 +++++++++++++-----------
 1 file changed, 13 insertions(+), 11 deletions(-)

diff --git a/drivers/scsi/mpi3mr/mpi3mr_fw.c b/drivers/scsi/mpi3mr/mpi3mr_fw.c
index 40696b75345d..88db2f0e13fd 100644
--- a/drivers/scsi/mpi3mr/mpi3mr_fw.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_fw.c
@@ -665,8 +665,9 @@ static inline int mpi3mr_request_irq(struct mpi3mr_ioc *mrioc, u16 index)
 static int mpi3mr_setup_isr(struct mpi3mr_ioc *mrioc, u8 setup_one)
 {
 	unsigned int irq_flags = PCI_IRQ_MSIX;
-	u16 max_vectors = 0, i;
-	int retval = 0;
+	int max_vectors;
+	int retval;
+	int i;
 	struct irq_affinity desc = { .pre_vectors =  1};
 
 	mpi3mr_cleanup_isr(mrioc);
@@ -687,29 +688,29 @@ static int mpi3mr_setup_isr(struct mpi3mr_ioc *mrioc, u8 setup_one)
 	irq_flags |= PCI_IRQ_AFFINITY | PCI_IRQ_ALL_TYPES;
 
 	mrioc->op_reply_q_offset = (max_vectors > 1) ? 1 : 0;
-	i = pci_alloc_irq_vectors_affinity(mrioc->pdev,
-	    1, max_vectors, irq_flags, &desc);
-	if (i <= 0) {
+	retval = pci_alloc_irq_vectors_affinity(mrioc->pdev,
+				1, max_vectors, irq_flags, &desc);
+	if (retval < 0) {
 		ioc_err(mrioc, "Cannot alloc irq vectors\n");
 		goto out_failed;
 	}
-	if (i != max_vectors) {
+	if (retval != max_vectors) {
 		ioc_info(mrioc,
 		    "allocated vectors (%d) are less than configured (%d)\n",
-		    i, max_vectors);
+		    retval, max_vectors);
 		/*
 		 * If only one MSI-x is allocated, then MSI-x 0 will be shared
 		 * between Admin queue and operational queue
 		 */
-		if (i == 1)
+		if (retval == 1)
 			mrioc->op_reply_q_offset = 0;
 
-		max_vectors = i;
+		max_vectors = retval;
 	}
 	mrioc->intr_info = kzalloc(sizeof(struct mpi3mr_intr_info) * max_vectors,
 	    GFP_KERNEL);
 	if (!mrioc->intr_info) {
-		retval = -1;
+		retval = -ENOMEM;
 		pci_free_irq_vectors(mrioc->pdev);
 		goto out_failed;
 	}
@@ -722,7 +723,8 @@ static int mpi3mr_setup_isr(struct mpi3mr_ioc *mrioc, u8 setup_one)
 	}
 	mrioc->intr_info_count = max_vectors;
 	mpi3mr_ioc_enable_intr(mrioc);
-	return retval;
+	return 0;
+
 out_failed:
 	mpi3mr_cleanup_isr(mrioc);
 

