From: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
Date: Tue, 24 Oct 2023 13:09:21 +0200
Subject: ice: remove VF pointer reference in eswitch code
Patch-mainline: v6.8-rc1
Git-commit: e4c46abc729130d03e22ce7e54554c698df8893d
References: jsc#PED-4876

Make eswitch code generic by removing VF pointer reference in functions.
It is needed to support eswitch mode for other type of devices.

Previously queue id used for Rx was based on VF number. Use ::q_id saved
in port representor instead.

After adding or removing port representor ::q_id value can change. It
isn't good idea to iterate over representors list using this value.
Use xa_find starting from the first one instead to get next port
representor to remap.

The number of port representors has to be equal to ::num_rx/tx_q. Warn if
it isn't true.

Reviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>
Reviewed-by: Wojciech Drewek <wojciech.drewek@intel.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
Signed-off-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
Tested-by: Sujai Buvaneswaran <sujai.buvaneswaran@intel.com>
Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/intel/ice/ice_eswitch.c |   39 +++++++++++++--------------
 drivers/net/ethernet/intel/ice/ice_eswitch.h |    5 ++-
 drivers/net/ethernet/intel/ice/ice_repr.c    |    1 
 drivers/net/ethernet/intel/ice/ice_vf_lib.c  |    2 -
 4 files changed, 25 insertions(+), 22 deletions(-)

--- a/drivers/net/ethernet/intel/ice/ice_eswitch.c
+++ b/drivers/net/ethernet/intel/ice/ice_eswitch.c
@@ -47,7 +47,8 @@ ice_eswitch_add_sp_rule(struct ice_pf *p
 	err = ice_add_adv_rule(hw, list, lkups_cnt, &rule_info,
 			       &repr->sp_rule);
 	if (err)
-		dev_err(ice_pf_to_dev(pf), "Unable to add slow-path rule in switchdev mode");
+		dev_err(ice_pf_to_dev(pf), "Unable to add slow-path rule for eswitch for PR %d",
+			repr->id);
 
 	kfree(list);
 	return err;
@@ -142,6 +143,7 @@ err_def_rx:
 static void ice_eswitch_remap_rings_to_vectors(struct ice_pf *pf)
 {
 	struct ice_vsi *vsi = pf->eswitch.control_vsi;
+	unsigned long repr_id = 0;
 	int q_id;
 
 	ice_for_each_txq(vsi, q_id) {
@@ -149,13 +151,14 @@ static void ice_eswitch_remap_rings_to_v
 		struct ice_tx_ring *tx_ring;
 		struct ice_rx_ring *rx_ring;
 		struct ice_repr *repr;
-		struct ice_vf *vf;
 
-		vf = ice_get_vf_by_id(pf, q_id);
-		if (WARN_ON(!vf))
-			continue;
+		repr = xa_find(&pf->eswitch.reprs, &repr_id, U32_MAX,
+			       XA_PRESENT);
+		if (WARN_ON(!repr))
+			break;
 
-		repr = vf->repr;
+		repr_id += 1;
+		repr->q_id = q_id;
 		q_vector = repr->q_vector;
 		tx_ring = vsi->tx_rings[q_id];
 		rx_ring = vsi->rx_rings[q_id];
@@ -178,8 +181,6 @@ static void ice_eswitch_remap_rings_to_v
 		rx_ring->q_vector = q_vector;
 		rx_ring->next = NULL;
 		rx_ring->netdev = repr->netdev;
-
-		ice_put_vf(vf);
 	}
 }
 
@@ -284,20 +285,17 @@ err:
 
 /**
  * ice_eswitch_update_repr - reconfigure port representor
- * @vsi: VF VSI for which port representor is configured
+ * @repr: pointer to repr struct
+ * @vsi: VSI for which port representor is configured
  */
-void ice_eswitch_update_repr(struct ice_vsi *vsi)
+void ice_eswitch_update_repr(struct ice_repr *repr, struct ice_vsi *vsi)
 {
 	struct ice_pf *pf = vsi->back;
-	struct ice_repr *repr;
-	struct ice_vf *vf;
 	int ret;
 
 	if (!ice_is_switchdev_running(pf))
 		return;
 
-	vf = vsi->vf;
-	repr = vf->repr;
 	repr->src_vsi = vsi;
 	repr->dst->u.port_info.port_id = vsi->vsi_num;
 
@@ -306,9 +304,10 @@ void ice_eswitch_update_repr(struct ice_
 
 	ret = ice_vsi_update_security(vsi, ice_vsi_ctx_clear_antispoof);
 	if (ret) {
-		ice_fltr_add_mac_and_broadcast(vsi, vf->hw_lan_addr, ICE_FWD_TO_VSI);
-		dev_err(ice_pf_to_dev(pf), "Failed to update VF %d port representor",
-			vsi->vf->vf_id);
+		ice_fltr_add_mac_and_broadcast(vsi, repr->parent_mac,
+					       ICE_FWD_TO_VSI);
+		dev_err(ice_pf_to_dev(pf), "Failed to update VSI of port representor %d",
+			repr->id);
 	}
 }
 
@@ -340,7 +339,7 @@ ice_eswitch_port_start_xmit(struct sk_bu
 	skb_dst_drop(skb);
 	dst_hold((struct dst_entry *)repr->dst);
 	skb_dst_set(skb, (struct dst_entry *)repr->dst);
-	skb->queue_mapping = repr->vf->vf_id;
+	skb->queue_mapping = repr->q_id;
 
 	return ice_start_xmit(skb, netdev);
 }
@@ -486,7 +485,7 @@ static int ice_eswitch_enable_switchdev(
 	ice_eswitch_remap_rings_to_vectors(pf);
 
 	if (ice_vsi_open(ctrl_vsi))
-		goto err_setup_reprs;
+		goto err_vsi_open;
 
 	if (ice_eswitch_br_offloads_init(pf))
 		goto err_br_offloads;
@@ -497,6 +496,8 @@ static int ice_eswitch_enable_switchdev(
 
 err_br_offloads:
 	ice_vsi_close(ctrl_vsi);
+err_vsi_open:
+	ice_eswitch_release_reprs(pf);
 err_setup_reprs:
 	ice_repr_rem_from_all_vfs(pf);
 err_repr_add:
--- a/drivers/net/ethernet/intel/ice/ice_eswitch.h
+++ b/drivers/net/ethernet/intel/ice/ice_eswitch.h
@@ -17,7 +17,7 @@ ice_eswitch_mode_set(struct devlink *dev
 		     struct netlink_ext_ack *extack);
 bool ice_is_eswitch_mode_switchdev(struct ice_pf *pf);
 
-void ice_eswitch_update_repr(struct ice_vsi *vsi);
+void ice_eswitch_update_repr(struct ice_repr *repr, struct ice_vsi *vsi);
 
 void ice_eswitch_stop_all_tx_queues(struct ice_pf *pf);
 
@@ -34,7 +34,8 @@ static inline void
 ice_eswitch_set_target_vsi(struct sk_buff *skb,
 			   struct ice_tx_offload_params *off) { }
 
-static inline void ice_eswitch_update_repr(struct ice_vsi *vsi) { }
+static inline void
+ice_eswitch_update_repr(struct ice_repr *repr, struct ice_vsi *vsi) { }
 
 static inline int ice_eswitch_configure(struct ice_pf *pf)
 {
--- a/drivers/net/ethernet/intel/ice/ice_repr.c
+++ b/drivers/net/ethernet/intel/ice/ice_repr.c
@@ -336,6 +336,7 @@ static int ice_repr_add(struct ice_vf *v
 	if (err)
 		goto err_netdev;
 
+	ether_addr_copy(repr->parent_mac, vf->hw_lan_addr);
 	ice_virtchnl_set_repr_ops(vf);
 
 	return 0;
--- a/drivers/net/ethernet/intel/ice/ice_vf_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_vf_lib.c
@@ -943,7 +943,7 @@ int ice_reset_vf(struct ice_vf *vf, u32
 		goto out_unlock;
 	}
 
-	ice_eswitch_update_repr(vsi);
+	ice_eswitch_update_repr(vf->repr, vsi);
 
 	/* if the VF has been reset allow it to come up again */
 	ice_mbx_clear_malvf(&vf->mbx_info);
