From: Maxim Mikityanskiy <maximmi@nvidia.com>
Date: Tue, 25 Jan 2022 12:52:57 +0200
Subject: net/mlx5e: Optimize mlx5e_select_queue
Patch-mainline: v5.18-rc1
Git-commit: 3c87aedd48997f9ab3afdeb2084f6b6163a21db8
References: jsc#PED-1549

This commit optimizes mlx5e_select_queue for HTB and PTP cases by
short-cutting some checks, without sacrificing performance of the common
non-HTB non-PTP flow.

1. The HTB flow uses the fact that num_tcs == 1 to drop these checks
(it's not possible to attach both mqprio and htb as the root qdisc).
It's also enough to calculate `txq_ix % num_channels` only once, instead
of twice.

2. The PTP flow drops the check for HTB and the second calculation of
`txq_ix % num_channels`.

Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/en/selq.c |   58 +++++++++++++++-------
 1 file changed, 42 insertions(+), 16 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/en/selq.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/selq.c
@@ -164,36 +164,62 @@ u16 mlx5e_select_queue(struct net_device
 	if (unlikely(!selq))
 		return 0;
 
-	if (unlikely(selq->is_ptp || selq->is_htb)) {
-		if (unlikely(selq->is_htb)) {
-			txq_ix = mlx5e_select_htb_queue(priv, skb);
-			if (txq_ix > 0)
-				return txq_ix;
-		}
+	if (likely(!selq->is_ptp && !selq->is_htb)) {
+		/* No special queues, netdev_pick_tx returns one of the regular ones. */
+
+		txq_ix = netdev_pick_tx(dev, skb, NULL);
+
+		if (selq->num_tcs <= 1)
+			return txq_ix;
+
+		up = mlx5e_get_up(priv, skb);
+
+		/* Normalize any picked txq_ix to [0, num_channels),
+		 * So we can return a txq_ix that matches the channel and
+		 * packet UP.
+		 */
+		return txq_ix % selq->num_channels + up * selq->num_channels;
+	}
+
+	if (unlikely(selq->is_htb)) {
+		/* num_tcs == 1, shortcut for PTP */
+
+		txq_ix = mlx5e_select_htb_queue(priv, skb);
+		if (txq_ix > 0)
+			return txq_ix;
 
 		if (unlikely(selq->is_ptp && mlx5e_use_ptpsq(skb)))
-			return mlx5e_select_ptpsq(dev, skb, selq);
+			return selq->num_channels;
 
 		txq_ix = netdev_pick_tx(dev, skb, NULL);
+
 		/* Fix netdev_pick_tx() not to choose ptp_channel and HTB txqs.
 		 * If they are selected, switch to regular queues.
 		 * Driver to select these queues only at mlx5e_select_ptpsq()
 		 * and mlx5e_select_htb_queue().
 		 */
-		if (unlikely(txq_ix >= selq->num_regular_queues))
-			txq_ix %= selq->num_regular_queues;
-	} else {
-		txq_ix = netdev_pick_tx(dev, skb, NULL);
+		return txq_ix % selq->num_channels;
 	}
 
+	/* PTP is enabled */
+
+	if (mlx5e_use_ptpsq(skb))
+		return mlx5e_select_ptpsq(dev, skb, selq);
+
+	txq_ix = netdev_pick_tx(dev, skb, NULL);
+
+	/* Normalize any picked txq_ix to [0, num_channels). Queues in range
+	 * [0, num_regular_queues) will be mapped to the corresponding channel
+	 * index, so that we can apply the packet's UP (if num_tcs > 1).
+	 * If netdev_pick_tx() picks ptp_channel, switch to a regular queue,
+	 * because driver should select the PTP only at mlx5e_select_ptpsq().
+	 */
+	txq_ix %= selq->num_channels;
+
 	if (selq->num_tcs <= 1)
 		return txq_ix;
 
 	up = mlx5e_get_up(priv, skb);
 
-	/* Normalize any picked txq_ix to [0, num_channels),
-	 * So we can return a txq_ix that matches the channel and
-	 * packet UP.
-	 */
-	return txq_ix % selq->num_channels + up * selq->num_channels;
+	return txq_ix + up * selq->num_channels;
 }
