From e5b3d733b5508ec286b312401240838cad22fd30 Mon Sep 17 00:00:00 2001
From: Nicolai Stange <nstange@suse.de>
Date: Mon, 21 Apr 2025 16:41:26 +0200
References: jsc#PED-12225
Patch-mainline: Submitted, RFC v2 security ML 2025-03-23, about to submit v3
Subject: [PATCH 7/9] tpm: enable bank selection for PCR extend

tpm_pcr_extend() extends all of a PCR's allocated banks with the
corresponding digest from the provided digests[] argument.

IMA will need to skip over selected banks for handling hashes with no
implementation available to the kernel.

Amend tpm_pcr_extend()'s parameter list by 'banks_skip_mask', and make it
to skip the extension of any bank having its corresponding bit set there.

Adapt the two existing users of tpm_pcr_extend(), ima_pcr_extend() and
pcrlock() from trusted-keys/trusted_tpm1, accordingly.

Signed-off-by: Nicolai Stange <nstange@suse.de>
---
 drivers/char/tpm/tpm-interface.c          |   15 ++++++++++++---
 drivers/char/tpm/tpm.h                    |    3 ++-
 drivers/char/tpm/tpm2-cmd.c               |   26 ++++++++++++++++++++++++--
 include/linux/tpm.h                       |    6 ++++--
 security/integrity/ima/ima_queue.c        |    2 +-
 security/keys/trusted-keys/trusted_tpm1.c |    2 +-
 6 files changed, 44 insertions(+), 10 deletions(-)

--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -306,14 +306,17 @@ EXPORT_SYMBOL_GPL(tpm_pcr_read);
  * @chip:	a &struct tpm_chip instance, %NULL for the default chip
  * @pcr_idx:	the PCR to be retrieved
  * @digests:	array of tpm_digest structures used to extend PCRs
+ * @banks_skip_mask:	pcr banks to skip
  *
  * Note: callers must pass a digest for every allocated PCR bank, in the same
- * order of the banks in chip->allocated_banks.
+ * order of the banks in chip->allocated_banks, independent of the value of
+ * @banks_skip_mask.
  *
  * Return: same as with tpm_transmit_cmd()
  */
 int tpm_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,
-		   struct tpm_digest *digests)
+		   struct tpm_digest *digests,
+		   unsigned long banks_skip_mask)
 {
 	int rc;
 	int i;
@@ -330,7 +333,13 @@ int tpm_pcr_extend(struct tpm_chip *chip
 	}
 
 	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
-		rc = tpm2_pcr_extend(chip, pcr_idx, digests);
+		rc = tpm2_pcr_extend(chip, pcr_idx, digests, banks_skip_mask);
+		goto out;
+	}
+
+	/* There's only one SHA1 bank with TPM 1. */
+	if (banks_skip_mask & 1) {
+		rc = 0;
 		goto out;
 	}
 
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@ -291,7 +291,8 @@ int tpm2_get_timeouts(struct tpm_chip *c
 int tpm2_pcr_read(struct tpm_chip *chip, u32 pcr_idx,
 		  struct tpm_digest *digest, u16 *digest_size_ptr);
 int tpm2_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,
-		    struct tpm_digest *digests);
+		    struct tpm_digest *digests,
+		    unsigned long banks_skip_mask);
 int tpm2_get_random(struct tpm_chip *chip, u8 *dest, size_t max);
 ssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id,
 			u32 *value, const char *desc);
--- a/drivers/char/tpm/tpm2-cmd.c
+++ b/drivers/char/tpm/tpm2-cmd.c
@@ -226,16 +226,31 @@ out:
  * @chip:	TPM chip to use.
  * @pcr_idx:	index of the PCR.
  * @digests:	list of pcr banks and corresponding digest values to extend.
+ * @banks_skip_mask:	pcr banks to skip
  *
  * Return: Same as with tpm_transmit_cmd.
  */
 int tpm2_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,
-		    struct tpm_digest *digests)
+		    struct tpm_digest *digests,
+		    unsigned long banks_skip_mask)
 {
 	struct tpm_buf buf;
+	unsigned long skip_mask;
+	u32 skipped_banks_count, banks_count;
 	int rc;
 	int i;
 
+	skipped_banks_count = 0;
+	skip_mask = banks_skip_mask;
+	for (i = 0; skip_mask && i < chip->nr_allocated_banks; i++) {
+		skipped_banks_count += skip_mask & 1;
+		skip_mask >>= 1;
+	}
+	banks_count = chip->nr_allocated_banks - skipped_banks_count;
+
+	if (banks_count == 0)
+		return 0;
+
 	if (!disable_pcr_integrity) {
 		rc = tpm2_start_auth_session(chip);
 		if (rc)
@@ -257,9 +272,16 @@ int tpm2_pcr_extend(struct tpm_chip *chi
 		tpm_buf_append_auth(chip, &buf, 0, NULL, 0);
 	}
 
-	tpm_buf_append_u32(&buf, chip->nr_allocated_banks);
+	tpm_buf_append_u32(&buf, banks_count);
 
+	skip_mask = banks_skip_mask;
 	for (i = 0; i < chip->nr_allocated_banks; i++) {
+		const bool skip_bank = skip_mask & 1;
+
+		skip_mask >>= 1;
+		if (skip_bank)
+			continue;
+
 		tpm_buf_append_u16(&buf, digests[i].alg_id);
 		tpm_buf_append(&buf, (const unsigned char *)&digests[i].digest,
 			       chip->allocated_banks[i].digest_size);
--- a/include/linux/tpm.h
+++ b/include/linux/tpm.h
@@ -447,7 +447,8 @@ extern ssize_t tpm_transmit_cmd(struct t
 extern int tpm_pcr_read(struct tpm_chip *chip, u32 pcr_idx,
 			struct tpm_digest *digest);
 extern int tpm_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,
-			  struct tpm_digest *digests);
+			  struct tpm_digest *digests,
+			  unsigned long banks_skip_mask);
 extern int tpm_get_random(struct tpm_chip *chip, u8 *data, size_t max);
 extern struct tpm_chip *tpm_default_chip(void);
 void tpm2_flush_context(struct tpm_chip *chip, u32 handle);
@@ -473,7 +474,8 @@ static inline int tpm_pcr_read(struct tp
 }
 
 static inline int tpm_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,
-				 struct tpm_digest *digests)
+				 struct tpm_digest *digests,
+				 unsigned long banks_skip_mask)
 {
 	return -ENODEV;
 }
--- a/security/integrity/ima/ima_queue.c
+++ b/security/integrity/ima/ima_queue.c
@@ -142,7 +142,7 @@ static int ima_pcr_extend(struct tpm_dig
 	if (!ima_tpm_chip)
 		return result;
 
-	result = tpm_pcr_extend(ima_tpm_chip, pcr, digests_arg);
+	result = tpm_pcr_extend(ima_tpm_chip, pcr, digests_arg, 0);
 	if (result != 0)
 		pr_err("Error Communicating to TPM chip, result: %d\n", result);
 	return result;
--- a/security/keys/trusted-keys/trusted_tpm1.c
+++ b/security/keys/trusted-keys/trusted_tpm1.c
@@ -393,7 +393,7 @@ static int pcrlock(const int pcrnum)
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	return tpm_pcr_extend(chip, pcrnum, digests) ? -EINVAL : 0;
+	return tpm_pcr_extend(chip, pcrnum, digests, 0) ? -EINVAL : 0;
 }
 
 /*
