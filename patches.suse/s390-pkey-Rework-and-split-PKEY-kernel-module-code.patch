From: Harald Freudenberger <freude@linux.ibm.com>
Date: Thu, 22 Aug 2024 11:32:17 +0200
Subject: s390/pkey: Rework and split PKEY kernel module code
Git-commit: 86fbf5e2a0ca58f10261a264ee25bf2a936ee5d2
Patch-mainline: v6.12-rc1
References: jsc#PED-10278

This is a huge rework of all the pkey kernel module code.
The goal is to split the code into individual parts with
a dedicated calling interface:
- move all the sysfs related code into pkey_sysfs.c
- all the CCA related code goes to pkey_cca.c
- the EP11 stuff has been moved to pkey_ep11.c
- the PCKMO related code is now in pkey_pckmo.c

The CCA, EP11 and PCKMO code may be seen as "handlers" with
a similar calling interface. The new header file pkey_base.h
declares this calling interface. The remaining code in
pkey_api.c handles the ioctl, the pkey module things and the
"handler" independent code on top of the calling interface
invoking the handlers.

This regrouping of the code will be the base for a real
pkey kernel module split into a pkey base module which acts
as a dispatcher and handler modules providing their service.

Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
Reviewed-by: Holger Dengler <dengler@linux.ibm.com>
Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
Acked-by: Miroslav Franc <mfranc@suse.cz>
---
 arch/s390/crypto/paes_s390.c          |    4 +-
 arch/s390/include/asm/pkey.h          |    4 +-
 drivers/s390/crypto/Makefile          |    2 +-
 drivers/s390/crypto/pkey_api.c        | 2160 +++++++--------------------------
 drivers/s390/crypto/pkey_base.h       |  162 +++
 drivers/s390/crypto/pkey_cca.c        |  453 +++++++
 drivers/s390/crypto/pkey_ep11.c       |  406 +++++++
 drivers/s390/crypto/pkey_pckmo.c      |  346 ++++++
 drivers/s390/crypto/pkey_sysfs.c      |  506 ++++++++
 drivers/s390/crypto/zcrypt_ccamisc.c  |    8 +-
 drivers/s390/crypto/zcrypt_ccamisc.h  |    6 +-
 drivers/s390/crypto/zcrypt_ep11misc.c |   28 +-
 drivers/s390/crypto/zcrypt_ep11misc.h |   14 +-
 13 files changed, 2330 insertions(+), 1769 deletions(-)

diff --git a/arch/s390/crypto/paes_s390.c b/arch/s390/crypto/paes_s390.c
index 99ea3f12c5d2..d68647d64eb4 100644
--- a/arch/s390/crypto/paes_s390.c
+++ b/arch/s390/crypto/paes_s390.c
@@ -133,8 +133,8 @@ static inline int __paes_keyblob2pkey(struct key_blob *kb,
 			if (msleep_interruptible(1000))
 				return -EINTR;
 		}
-		ret = pkey_keyblob2pkey(kb->key, kb->keylen,
-					pk->protkey, &pk->len, &pk->type);
+		ret = pkey_key2protkey(kb->key, kb->keylen,
+				       pk->protkey, &pk->len, &pk->type);
 	}
 
 	return ret;
diff --git a/arch/s390/include/asm/pkey.h b/arch/s390/include/asm/pkey.h
index 47d80a7451a6..5dca1a46a9f6 100644
--- a/arch/s390/include/asm/pkey.h
+++ b/arch/s390/include/asm/pkey.h
@@ -22,7 +22,7 @@
  * @param protkey pointer to buffer receiving the protected key
  * @return 0 on success, negative errno value on failure
  */
-int pkey_keyblob2pkey(const u8 *key, u32 keylen,
-		      u8 *protkey, u32 *protkeylen, u32 *protkeytype);
+int pkey_key2protkey(const u8 *key, u32 keylen,
+		     u8 *protkey, u32 *protkeylen, u32 *protkeytype);
 
 #endif /* _KAPI_PKEY_H */
diff --git a/drivers/s390/crypto/Makefile b/drivers/s390/crypto/Makefile
index bd94811fd9f1..863d6fbd2e79 100644
--- a/drivers/s390/crypto/Makefile
+++ b/drivers/s390/crypto/Makefile
@@ -14,7 +14,7 @@ obj-$(CONFIG_ZCRYPT) += zcrypt.o
 obj-$(CONFIG_ZCRYPT) += zcrypt_cex4.o
 
 # pkey kernel module
-pkey-objs := pkey_api.o
+pkey-objs := pkey_api.o pkey_cca.o pkey_ep11.o pkey_pckmo.o pkey_sysfs.o
 obj-$(CONFIG_PKEY) += pkey.o
 
 # adjunct processor matrix
diff --git a/drivers/s390/crypto/pkey_api.c b/drivers/s390/crypto/pkey_api.c
index f3dca56f0808..732437bf3823 100644
--- a/drivers/s390/crypto/pkey_api.c
+++ b/drivers/s390/crypto/pkey_api.c
@@ -17,36 +17,26 @@
 #include <linux/slab.h>
 #include <linux/kallsyms.h>
 #include <linux/debugfs.h>
-#include <linux/random.h>
 #include <linux/cpufeature.h>
 #include <asm/zcrypt.h>
 #include <asm/cpacf.h>
 #include <asm/pkey.h>
-#include <crypto/aes.h>
 
 #include "zcrypt_api.h"
 #include "zcrypt_ccamisc.h"
 #include "zcrypt_ep11misc.h"
 
+#include "pkey_base.h"
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("IBM Corporation");
 MODULE_DESCRIPTION("s390 protected key interface");
 
-#define KEYBLOBBUFSIZE 8192	/* key buffer size used for internal processing */
-#define MINKEYBLOBBUFSIZE (sizeof(struct keytoken_header))
-#define PROTKEYBLOBBUFSIZE 256	/* protected key buffer size used internal */
-#define MAXAPQNSINLIST 64	/* max 64 apqns within a apqn list */
-#define AES_WK_VP_SIZE 32	/* Size of WK VP block appended to a prot key */
-
 /*
- * debug feature data and functions
+ * Debug feature data and functions
  */
 
-static debug_info_t *pkey_dbf_info;
-
-#define PKEY_DBF_INFO(...) debug_sprintf_event(pkey_dbf_info, 5, ##__VA_ARGS__)
-#define PKEY_DBF_WARN(...) debug_sprintf_event(pkey_dbf_info, 4, ##__VA_ARGS__)
-#define PKEY_DBF_ERR(...)  debug_sprintf_event(pkey_dbf_info, 3, ##__VA_ARGS__)
+debug_info_t *pkey_dbf_info;
 
 static void __init pkey_debug_init(void)
 {
@@ -61,1271 +51,382 @@ static void __exit pkey_debug_exit(void)
 	debug_unregister(pkey_dbf_info);
 }
 
-/* inside view of a protected key token (only type 0x00 version 0x01) */
-struct protaeskeytoken {
-	u8  type;     /* 0x00 for PAES specific key tokens */
-	u8  res0[3];
-	u8  version;  /* should be 0x01 for protected AES key token */
-	u8  res1[3];
-	u32 keytype;  /* key type, one of the PKEY_KEYTYPE values */
-	u32 len;      /* bytes actually stored in protkey[] */
-	u8  protkey[MAXPROTKEYSIZE]; /* the protected key blob */
-} __packed;
-
-/* inside view of a clear key token (type 0x00 version 0x02) */
-struct clearkeytoken {
-	u8  type;	/* 0x00 for PAES specific key tokens */
-	u8  res0[3];
-	u8  version;	/* 0x02 for clear key token */
-	u8  res1[3];
-	u32 keytype;	/* key type, one of the PKEY_KEYTYPE_* values */
-	u32 len;	/* bytes actually stored in clearkey[] */
-	u8  clearkey[]; /* clear key value */
-} __packed;
-
-/* helper function which translates the PKEY_KEYTYPE_AES_* to their keysize */
-static inline u32 pkey_keytype_aes_to_size(u32 keytype)
-{
-	switch (keytype) {
-	case PKEY_KEYTYPE_AES_128:
-		return 16;
-	case PKEY_KEYTYPE_AES_192:
-		return 24;
-	case PKEY_KEYTYPE_AES_256:
-		return 32;
-	default:
-		return 0;
-	}
-}
-
-/*
- * Create a protected key from a clear key value via PCKMO instruction.
- */
-static int pkey_clr2protkey(u32 keytype, const u8 *clrkey,
-			    u8 *protkey, u32 *protkeylen, u32 *protkeytype)
-{
-	/* mask of available pckmo subfunctions */
-	static cpacf_mask_t pckmo_functions;
-
-	u8 paramblock[112];
-	u32 pkeytype;
-	int keysize;
-	long fc;
-
-	switch (keytype) {
-	case PKEY_KEYTYPE_AES_128:
-		/* 16 byte key, 32 byte aes wkvp, total 48 bytes */
-		keysize = 16;
-		pkeytype = keytype;
-		fc = CPACF_PCKMO_ENC_AES_128_KEY;
-		break;
-	case PKEY_KEYTYPE_AES_192:
-		/* 24 byte key, 32 byte aes wkvp, total 56 bytes */
-		keysize = 24;
-		pkeytype = keytype;
-		fc = CPACF_PCKMO_ENC_AES_192_KEY;
-		break;
-	case PKEY_KEYTYPE_AES_256:
-		/* 32 byte key, 32 byte aes wkvp, total 64 bytes */
-		keysize = 32;
-		pkeytype = keytype;
-		fc = CPACF_PCKMO_ENC_AES_256_KEY;
-		break;
-	case PKEY_KEYTYPE_ECC_P256:
-		/* 32 byte key, 32 byte aes wkvp, total 64 bytes */
-		keysize = 32;
-		pkeytype = PKEY_KEYTYPE_ECC;
-		fc = CPACF_PCKMO_ENC_ECC_P256_KEY;
-		break;
-	case PKEY_KEYTYPE_ECC_P384:
-		/* 48 byte key, 32 byte aes wkvp, total 80 bytes */
-		keysize = 48;
-		pkeytype = PKEY_KEYTYPE_ECC;
-		fc = CPACF_PCKMO_ENC_ECC_P384_KEY;
-		break;
-	case PKEY_KEYTYPE_ECC_P521:
-		/* 80 byte key, 32 byte aes wkvp, total 112 bytes */
-		keysize = 80;
-		pkeytype = PKEY_KEYTYPE_ECC;
-		fc = CPACF_PCKMO_ENC_ECC_P521_KEY;
-		break;
-	case PKEY_KEYTYPE_ECC_ED25519:
-		/* 32 byte key, 32 byte aes wkvp, total 64 bytes */
-		keysize = 32;
-		pkeytype = PKEY_KEYTYPE_ECC;
-		fc = CPACF_PCKMO_ENC_ECC_ED25519_KEY;
-		break;
-	case PKEY_KEYTYPE_ECC_ED448:
-		/* 64 byte key, 32 byte aes wkvp, total 96 bytes */
-		keysize = 64;
-		pkeytype = PKEY_KEYTYPE_ECC;
-		fc = CPACF_PCKMO_ENC_ECC_ED448_KEY;
-		break;
-	default:
-		PKEY_DBF_ERR("%s unknown/unsupported keytype %u\n",
-			     __func__, keytype);
-		return -EINVAL;
-	}
-
-	if (*protkeylen < keysize + AES_WK_VP_SIZE) {
-		PKEY_DBF_ERR("%s prot key buffer size too small: %u < %d\n",
-			     __func__, *protkeylen, keysize + AES_WK_VP_SIZE);
-		return -EINVAL;
-	}
-
-	/* Did we already check for PCKMO ? */
-	if (!pckmo_functions.bytes[0]) {
-		/* no, so check now */
-		if (!cpacf_query(CPACF_PCKMO, &pckmo_functions))
-			return -ENODEV;
-	}
-	/* check for the pckmo subfunction we need now */
-	if (!cpacf_test_func(&pckmo_functions, fc)) {
-		PKEY_DBF_ERR("%s pckmo functions not available\n", __func__);
-		return -ENODEV;
-	}
-
-	/* prepare param block */
-	memset(paramblock, 0, sizeof(paramblock));
-	memcpy(paramblock, clrkey, keysize);
-
-	/* call the pckmo instruction */
-	cpacf_pckmo(fc, paramblock);
-
-	/* copy created protected key to key buffer including the wkvp block */
-	*protkeylen = keysize + AES_WK_VP_SIZE;
-	memcpy(protkey, paramblock, *protkeylen);
-	*protkeytype = pkeytype;
-
-	return 0;
-}
-
-/*
- * Find card and transform secure key into protected key.
- */
-static int pkey_skey2pkey(const u8 *key, u8 *protkey,
-			  u32 *protkeylen, u32 *protkeytype)
-{
-	struct keytoken_header *hdr = (struct keytoken_header *)key;
-	u16 cardnr, domain;
-	int rc, verify;
-
-	zcrypt_wait_api_operational();
-
-	/*
-	 * The cca_xxx2protkey call may fail when a card has been
-	 * addressed where the master key was changed after last fetch
-	 * of the mkvp into the cache. Try 3 times: First without verify
-	 * then with verify and last round with verify and old master
-	 * key verification pattern match not ignored.
-	 */
-	for (verify = 0; verify < 3; verify++) {
-		rc = cca_findcard(key, &cardnr, &domain, verify);
-		if (rc < 0)
-			continue;
-		if (rc > 0 && verify < 2)
-			continue;
-		switch (hdr->version) {
-		case TOKVER_CCA_AES:
-			rc = cca_sec2protkey(cardnr, domain, key,
-					     protkey, protkeylen, protkeytype);
-			break;
-		case TOKVER_CCA_VLSC:
-			rc = cca_cipher2protkey(cardnr, domain, key,
-						protkey, protkeylen,
-						protkeytype);
-			break;
-		default:
-			return -EINVAL;
-		}
-		if (rc == 0)
-			break;
-	}
-
-	if (rc)
-		pr_debug("%s failed rc=%d\n", __func__, rc);
-
-	return rc;
-}
-
-/*
- * Construct EP11 key with given clear key value.
- */
-static int pkey_clr2ep11key(const u8 *clrkey, size_t clrkeylen,
-			    u8 *keybuf, size_t *keybuflen)
-{
-	u32 nr_apqns, *apqns = NULL;
-	u16 card, dom;
-	int i, rc;
-
-	zcrypt_wait_api_operational();
-
-	/* build a list of apqns suitable for ep11 keys with cpacf support */
-	rc = ep11_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,
-			    ZCRYPT_CEX7,
-			    ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4,
-			    NULL);
-	if (rc)
-		goto out;
-
-	/* go through the list of apqns and try to bild an ep11 key */
-	for (rc = -ENODEV, i = 0; i < nr_apqns; i++) {
-		card = apqns[i] >> 16;
-		dom = apqns[i] & 0xFFFF;
-		rc = ep11_clr2keyblob(card, dom, clrkeylen * 8,
-				      0, clrkey, keybuf, keybuflen,
-				      PKEY_TYPE_EP11);
-		if (rc == 0)
-			break;
-	}
-
-out:
-	kfree(apqns);
-	if (rc)
-		pr_debug("%s failed rc=%d\n", __func__, rc);
-	return rc;
-}
-
-/*
- * Find card and transform EP11 secure key into protected key.
- */
-static int pkey_ep11key2pkey(const u8 *key, size_t keylen,
-			     u8 *protkey, u32 *protkeylen, u32 *protkeytype)
-{
-	u32 nr_apqns, *apqns = NULL;
-	int i, j, rc = -ENODEV;
-	u16 card, dom;
-
-	zcrypt_wait_api_operational();
-
-	/* try two times in case of failure */
-	for (i = 0; i < 2 && rc; i++) {
-
-		/* build a list of apqns suitable for this key */
-		rc = ep11_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,
-				    ZCRYPT_CEX7,
-				    ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4,
-				    ep11_kb_wkvp(key, keylen));
-		if (rc)
-			continue; /* retry findcard on failure */
-
-		/* go through the list of apqns and try to derive an pkey */
-		for (rc = -ENODEV, j = 0; j < nr_apqns && rc; j++) {
-			card = apqns[j] >> 16;
-			dom = apqns[j] & 0xFFFF;
-			rc = ep11_kblob2protkey(card, dom, key, keylen,
-						protkey, protkeylen, protkeytype);
-		}
-
-		kfree(apqns);
-	}
-
-	if (rc)
-		pr_debug("%s failed rc=%d\n", __func__, rc);
-
-	return rc;
-}
-
-/*
- * Verify key and give back some info about the key.
- */
-static int pkey_verifykey(const struct pkey_seckey *seckey,
-			  u16 *pcardnr, u16 *pdomain,
-			  u16 *pkeysize, u32 *pattributes)
-{
-	struct secaeskeytoken *t = (struct secaeskeytoken *)seckey;
-	u16 cardnr, domain;
-	int rc;
-
-	/* check the secure key for valid AES secure key */
-	rc = cca_check_secaeskeytoken(pkey_dbf_info, 3, (u8 *)seckey, 0);
-	if (rc)
-		goto out;
-	if (pattributes)
-		*pattributes = PKEY_VERIFY_ATTR_AES;
-	if (pkeysize)
-		*pkeysize = t->bitsize;
-
-	/* try to find a card which can handle this key */
-	rc = cca_findcard(seckey->seckey, &cardnr, &domain, 1);
-	if (rc < 0)
-		goto out;
-
-	if (rc > 0) {
-		/* key mkvp matches to old master key mkvp */
-		pr_debug("%s secure key has old mkvp\n", __func__);
-		if (pattributes)
-			*pattributes |= PKEY_VERIFY_ATTR_OLD_MKVP;
-		rc = 0;
-	}
-
-	if (pcardnr)
-		*pcardnr = cardnr;
-	if (pdomain)
-		*pdomain = domain;
-
-out:
-	pr_debug("%s rc=%d\n", __func__, rc);
-	return rc;
-}
-
 /*
- * Generate a random protected key
+ * Helper functions
  */
-static int pkey_genprotkey(u32 keytype, u8 *protkey,
-			   u32 *protkeylen, u32 *protkeytype)
-{
-	u8 clrkey[32];
-	int keysize;
-	int rc;
-
-	keysize = pkey_keytype_aes_to_size(keytype);
-	if (!keysize) {
-		PKEY_DBF_ERR("%s unknown/unsupported keytype %d\n", __func__,
-			     keytype);
-		return -EINVAL;
-	}
-
-	/* generate a dummy random clear key */
-	get_random_bytes(clrkey, keysize);
-
-	/* convert it to a dummy protected key */
-	rc = pkey_clr2protkey(keytype, clrkey,
-			      protkey, protkeylen, protkeytype);
-	if (rc)
-		return rc;
 
-	/* replace the key part of the protected key with random bytes */
-	get_random_bytes(protkey, keysize);
-
-	return 0;
-}
-
-/*
- * Verify if a protected key is still valid
- */
-static int pkey_verifyprotkey(const u8 *protkey, u32 protkeylen,
-			      u32 protkeytype)
+static int apqns4key(const u8 *key, size_t keylen, u32 flags,
+		     struct pkey_apqn *apqns, size_t *nr_apqns)
 {
-	struct {
-		u8 iv[AES_BLOCK_SIZE];
-		u8 key[MAXPROTKEYSIZE];
-	} param;
-	u8 null_msg[AES_BLOCK_SIZE];
-	u8 dest_buf[AES_BLOCK_SIZE];
-	unsigned int k, pkeylen;
-	unsigned long fc;
-
-	switch (protkeytype) {
-	case PKEY_KEYTYPE_AES_128:
-		pkeylen = 16 + AES_WK_VP_SIZE;
-		fc = CPACF_KMC_PAES_128;
-		break;
-	case PKEY_KEYTYPE_AES_192:
-		pkeylen = 24 + AES_WK_VP_SIZE;
-		fc = CPACF_KMC_PAES_192;
-		break;
-	case PKEY_KEYTYPE_AES_256:
-		pkeylen = 32 + AES_WK_VP_SIZE;
-		fc = CPACF_KMC_PAES_256;
-		break;
-	default:
-		PKEY_DBF_ERR("%s unknown/unsupported keytype %u\n", __func__,
-			     protkeytype);
-		return -EINVAL;
-	}
-	if (protkeylen != pkeylen) {
-		PKEY_DBF_ERR("%s invalid protected key size %u for keytype %u\n",
-			     __func__, protkeylen, protkeytype);
-		return -EINVAL;
-	}
-
-	memset(null_msg, 0, sizeof(null_msg));
-
-	memset(param.iv, 0, sizeof(param.iv));
-	memcpy(param.key, protkey, protkeylen);
-
-	k = cpacf_kmc(fc | CPACF_ENCRYPT, &param, null_msg, dest_buf,
-		      sizeof(null_msg));
-	if (k != sizeof(null_msg)) {
-		PKEY_DBF_ERR("%s protected key is not valid\n", __func__);
-		return -EKEYREJECTED;
-	}
-
-	return 0;
-}
-
-/* Helper for pkey_nonccatok2pkey, handles aes clear key token */
-static int nonccatokaes2pkey(const struct clearkeytoken *t,
-			     u8 *protkey, u32 *protkeylen, u32 *protkeytype)
-{
-	size_t tmpbuflen = max_t(size_t, SECKEYBLOBSIZE, MAXEP11AESKEYBLOBSIZE);
-	u8 *tmpbuf = NULL;
-	u32 keysize;
-	int rc;
+	if (pkey_is_cca_key(key, keylen)) {
+		return pkey_cca_apqns4key(key, keylen, flags,
+					  apqns, nr_apqns);
+	} else if (pkey_is_ep11_key(key, keylen)) {
+		return pkey_ep11_apqns4key(key, keylen, flags,
+					   apqns, nr_apqns);
+	} else {
+		struct keytoken_header *hdr = (struct keytoken_header *)key;
 
-	keysize = pkey_keytype_aes_to_size(t->keytype);
-	if (!keysize) {
-		PKEY_DBF_ERR("%s unknown/unsupported keytype %u\n",
-			     __func__, t->keytype);
+		PKEY_DBF_ERR("%s unknown/unsupported key type %d version %d\n",
+			     __func__, hdr->type, hdr->version);
 		return -EINVAL;
 	}
-	if (t->len != keysize) {
-		PKEY_DBF_ERR("%s non clear key aes token: invalid key len %u\n",
-			     __func__, t->len);
-		return -EINVAL;
-	}
-
-	/* try direct way with the PCKMO instruction */
-	rc = pkey_clr2protkey(t->keytype, t->clearkey,
-			      protkey, protkeylen, protkeytype);
-	if (!rc)
-		goto out;
-
-	/* PCKMO failed, so try the CCA secure key way */
-	tmpbuf = kmalloc(tmpbuflen, GFP_ATOMIC);
-	if (!tmpbuf)
-		return -ENOMEM;
-	zcrypt_wait_api_operational();
-	rc = cca_clr2seckey(0xFFFF, 0xFFFF, t->keytype, t->clearkey, tmpbuf);
-	if (rc)
-		goto try_via_ep11;
-	rc = pkey_skey2pkey(tmpbuf,
-			    protkey, protkeylen, protkeytype);
-	if (!rc)
-		goto out;
-
-try_via_ep11:
-	/* if the CCA way also failed, let's try via EP11 */
-	rc = pkey_clr2ep11key(t->clearkey, t->len,
-			      tmpbuf, &tmpbuflen);
-	if (rc)
-		goto failure;
-	rc = pkey_ep11key2pkey(tmpbuf, tmpbuflen,
-			       protkey, protkeylen, protkeytype);
-	if (!rc)
-		goto out;
-
-failure:
-	PKEY_DBF_ERR("%s unable to build protected key from clear", __func__);
-
-out:
-	kfree(tmpbuf);
-	return rc;
 }
 
-/* Helper for pkey_nonccatok2pkey, handles ecc clear key token */
-static int nonccatokecc2pkey(const struct clearkeytoken *t,
-			     u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+static int apqns4keytype(enum pkey_key_type ktype,
+			 u8 cur_mkvp[32], u8 alt_mkvp[32], u32 flags,
+			 struct pkey_apqn *apqns, size_t *nr_apqns)
 {
-	u32 keylen;
-	int rc;
-
-	switch (t->keytype) {
-	case PKEY_KEYTYPE_ECC_P256:
-		keylen = 32;
-		break;
-	case PKEY_KEYTYPE_ECC_P384:
-		keylen = 48;
-		break;
-	case PKEY_KEYTYPE_ECC_P521:
-		keylen = 80;
-		break;
-	case PKEY_KEYTYPE_ECC_ED25519:
-		keylen = 32;
-		break;
-	case PKEY_KEYTYPE_ECC_ED448:
-		keylen = 64;
-		break;
-	default:
-		PKEY_DBF_ERR("%s unknown/unsupported keytype %u\n",
-			     __func__, t->keytype);
-		return -EINVAL;
-	}
-
-	if (t->len != keylen) {
-		PKEY_DBF_ERR("%s non clear key ecc token: invalid key len %u\n",
-			     __func__, t->len);
+	if (pkey_is_cca_keytype(ktype)) {
+		return pkey_cca_apqns4type(ktype, cur_mkvp, alt_mkvp, flags,
+					   apqns, nr_apqns);
+	} else if (pkey_is_ep11_keytype(ktype)) {
+		return pkey_ep11_apqns4type(ktype, cur_mkvp, alt_mkvp, flags,
+					    apqns, nr_apqns);
+	} else {
+		PKEY_DBF_ERR("%s unknown/unsupported key type %d\n",
+			     __func__, ktype);
 		return -EINVAL;
 	}
-
-	/* only one path possible: via PCKMO instruction */
-	rc = pkey_clr2protkey(t->keytype, t->clearkey,
-			      protkey, protkeylen, protkeytype);
-	if (rc) {
-		PKEY_DBF_ERR("%s unable to build protected key from clear",
-			     __func__);
-	}
-
-	return rc;
 }
 
-/*
- * Transform a non-CCA key token into a protected key
- */
-static int pkey_nonccatok2pkey(const u8 *key, u32 keylen,
-			       u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+static int genseck2(const struct pkey_apqn *apqns, size_t nr_apqns,
+		    enum pkey_key_type keytype, enum pkey_key_size keybitsize,
+		    u32 flags, u8 *keybuf, u32 *keybuflen)
 {
-	struct keytoken_header *hdr = (struct keytoken_header *)key;
-	int rc = -EINVAL;
-
-	switch (hdr->version) {
-	case TOKVER_PROTECTED_KEY: {
-		struct protaeskeytoken *t;
-
-		if (keylen != sizeof(struct protaeskeytoken))
-			goto out;
-		t = (struct protaeskeytoken *)key;
-		rc = pkey_verifyprotkey(t->protkey, t->len, t->keytype);
-		if (rc)
-			goto out;
-		memcpy(protkey, t->protkey, t->len);
-		*protkeylen = t->len;
-		*protkeytype = t->keytype;
-		break;
-	}
-	case TOKVER_CLEAR_KEY: {
-		struct clearkeytoken *t = (struct clearkeytoken *)key;
-
-		if (keylen < sizeof(struct clearkeytoken) ||
-		    keylen != sizeof(*t) + t->len)
-			goto out;
-		switch (t->keytype) {
-		case PKEY_KEYTYPE_AES_128:
-		case PKEY_KEYTYPE_AES_192:
-		case PKEY_KEYTYPE_AES_256:
-			rc = nonccatokaes2pkey(t, protkey,
-					       protkeylen, protkeytype);
-			break;
-		case PKEY_KEYTYPE_ECC_P256:
-		case PKEY_KEYTYPE_ECC_P384:
-		case PKEY_KEYTYPE_ECC_P521:
-		case PKEY_KEYTYPE_ECC_ED25519:
-		case PKEY_KEYTYPE_ECC_ED448:
-			rc = nonccatokecc2pkey(t, protkey,
-					       protkeylen, protkeytype);
-			break;
-		default:
-			PKEY_DBF_ERR("%s unknown/unsupported non cca clear key type %u\n",
-				     __func__, t->keytype);
+	int i, rc;
+	u32 u;
+
+	if (pkey_is_cca_keytype(keytype)) {
+		/* As of now only CCA AES key generation is supported */
+		u = pkey_aes_bitsize_to_keytype(keybitsize);
+		if (!u) {
+			PKEY_DBF_ERR("%s unknown/unsupported keybitsize %d\n",
+				     __func__, keybitsize);
 			return -EINVAL;
 		}
-		break;
-	}
-	case TOKVER_EP11_AES: {
-		/* check ep11 key for exportable as protected key */
-		rc = ep11_check_aes_key(pkey_dbf_info, 3, key, keylen, 1);
-		if (rc)
-			goto out;
-		rc = pkey_ep11key2pkey(key, keylen,
-				       protkey, protkeylen, protkeytype);
-		break;
-	}
-	case TOKVER_EP11_AES_WITH_HEADER:
-		/* check ep11 key with header for exportable as protected key */
-		rc = ep11_check_aes_key_with_hdr(pkey_dbf_info,
-						 3, key, keylen, 1);
-		if (rc)
-			goto out;
-		rc = pkey_ep11key2pkey(key, keylen,
-				       protkey, protkeylen, protkeytype);
-		break;
-	default:
-		PKEY_DBF_ERR("%s unknown/unsupported non-CCA token version %d\n",
-			     __func__, hdr->version);
-	}
-
-out:
-	return rc;
-}
-
-/*
- * Transform a CCA internal key token into a protected key
- */
-static int pkey_ccainttok2pkey(const u8 *key, u32 keylen,
-			       u8 *protkey, u32 *protkeylen, u32 *protkeytype)
-{
-	struct keytoken_header *hdr = (struct keytoken_header *)key;
-
-	switch (hdr->version) {
-	case TOKVER_CCA_AES:
-		if (keylen != sizeof(struct secaeskeytoken))
-			return -EINVAL;
-		break;
-	case TOKVER_CCA_VLSC:
-		if (keylen < hdr->len || keylen > MAXCCAVLSCTOKENSIZE)
+		for (rc = -ENODEV, i = 0; rc && i < nr_apqns; i++) {
+			rc = pkey_cca_gen_key(apqns[i].card,
+					      apqns[i].domain,
+					      u, keytype, keybitsize, flags,
+					      keybuf, keybuflen);
+		}
+	} else if (pkey_is_ep11_keytype(keytype)) {
+		/* As of now only EP11 AES key generation is supported */
+		u = pkey_aes_bitsize_to_keytype(keybitsize);
+		if (!u) {
+			PKEY_DBF_ERR("%s unknown/unsupported keybitsize %d\n",
+				     __func__, keybitsize);
 			return -EINVAL;
-		break;
-	default:
-		PKEY_DBF_ERR("%s unknown/unsupported CCA internal token version %d\n",
-			     __func__, hdr->version);
-		return -EINVAL;
-	}
-
-	return pkey_skey2pkey(key, protkey, protkeylen, protkeytype);
-}
-
-/*
- * Transform a key blob (of any type) into a protected key
- */
-int pkey_keyblob2pkey(const u8 *key, u32 keylen,
-		      u8 *protkey, u32 *protkeylen, u32 *protkeytype)
-{
-	struct keytoken_header *hdr = (struct keytoken_header *)key;
-	int rc;
-
-	if (keylen < sizeof(struct keytoken_header)) {
-		PKEY_DBF_ERR("%s invalid keylen %d\n", __func__, keylen);
-		return -EINVAL;
-	}
-
-	switch (hdr->type) {
-	case TOKTYPE_NON_CCA:
-		rc = pkey_nonccatok2pkey(key, keylen,
-					 protkey, protkeylen, protkeytype);
-		break;
-	case TOKTYPE_CCA_INTERNAL:
-		rc = pkey_ccainttok2pkey(key, keylen,
-					 protkey, protkeylen, protkeytype);
-		break;
-	default:
-		PKEY_DBF_ERR("%s unknown/unsupported blob type %d\n",
-			     __func__, hdr->type);
+		}
+		for (rc = -ENODEV, i = 0; rc && i < nr_apqns; i++) {
+			rc = pkey_ep11_gen_key(apqns[i].card,
+					       apqns[i].domain,
+					       u, keytype, keybitsize, flags,
+					       keybuf, keybuflen);
+		}
+	} else {
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %d\n",
+			     __func__, keytype);
 		return -EINVAL;
 	}
 
-	pr_debug("%s rc=%d\n", __func__, rc);
 	return rc;
 }
-EXPORT_SYMBOL(pkey_keyblob2pkey);
 
-static int pkey_genseckey2(const struct pkey_apqn *apqns, size_t nr_apqns,
-			   enum pkey_key_type ktype, enum pkey_key_size ksize,
-			   u32 kflags, u8 *keybuf, size_t *keybufsize)
+static int clr2seckey2(const struct pkey_apqn *apqns, size_t nr_apqns,
+		       enum pkey_key_type keytype, enum pkey_key_size kbitsize,
+		       u32 flags, const u8 *clrkey, u8 *keybuf, u32 *keybuflen)
 {
-	int i, card, dom, rc;
-
-	/* check for at least one apqn given */
-	if (!apqns || !nr_apqns)
-		return -EINVAL;
-
-	/* check key type and size */
-	switch (ktype) {
-	case PKEY_TYPE_CCA_DATA:
-	case PKEY_TYPE_CCA_CIPHER:
-		if (*keybufsize < SECKEYBLOBSIZE)
-			return -EINVAL;
-		break;
-	case PKEY_TYPE_EP11:
-		if (*keybufsize < MINEP11AESKEYBLOBSIZE)
-			return -EINVAL;
-		break;
-	case PKEY_TYPE_EP11_AES:
-		if (*keybufsize < (sizeof(struct ep11kblob_header) +
-				   MINEP11AESKEYBLOBSIZE))
+	int i, rc;
+	u32 u;
+
+	if (pkey_is_cca_keytype(keytype)) {
+		/* As of now only CCA AES key generation is supported */
+		u = pkey_aes_bitsize_to_keytype(kbitsize);
+		if (!u) {
+			PKEY_DBF_ERR("%s unknown/unsupported keybitsize %d\n",
+				     __func__, kbitsize);
 			return -EINVAL;
-		break;
-	default:
-		return -EINVAL;
-	}
-	switch (ksize) {
-	case PKEY_SIZE_AES_128:
-	case PKEY_SIZE_AES_192:
-	case PKEY_SIZE_AES_256:
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* simple try all apqns from the list */
-	for (i = 0, rc = -ENODEV; i < nr_apqns; i++) {
-		card = apqns[i].card;
-		dom = apqns[i].domain;
-		if (ktype == PKEY_TYPE_EP11 ||
-		    ktype == PKEY_TYPE_EP11_AES) {
-			rc = ep11_genaeskey(card, dom, ksize, kflags,
-					    keybuf, keybufsize, ktype);
-		} else if (ktype == PKEY_TYPE_CCA_DATA) {
-			rc = cca_genseckey(card, dom, ksize, keybuf);
-			*keybufsize = (rc ? 0 : SECKEYBLOBSIZE);
-		} else {
-			/* TOKVER_CCA_VLSC */
-			rc = cca_gencipherkey(card, dom, ksize, kflags,
-					      keybuf, keybufsize);
 		}
-		if (rc == 0)
-			break;
-	}
-
-	return rc;
-}
-
-static int pkey_clr2seckey2(const struct pkey_apqn *apqns, size_t nr_apqns,
-			    enum pkey_key_type ktype, enum pkey_key_size ksize,
-			    u32 kflags, const u8 *clrkey,
-			    u8 *keybuf, size_t *keybufsize)
-{
-	int i, card, dom, rc;
-
-	/* check for at least one apqn given */
-	if (!apqns || !nr_apqns)
-		return -EINVAL;
-
-	/* check key type and size */
-	switch (ktype) {
-	case PKEY_TYPE_CCA_DATA:
-	case PKEY_TYPE_CCA_CIPHER:
-		if (*keybufsize < SECKEYBLOBSIZE)
-			return -EINVAL;
-		break;
-	case PKEY_TYPE_EP11:
-		if (*keybufsize < MINEP11AESKEYBLOBSIZE)
-			return -EINVAL;
-		break;
-	case PKEY_TYPE_EP11_AES:
-		if (*keybufsize < (sizeof(struct ep11kblob_header) +
-				   MINEP11AESKEYBLOBSIZE))
+		for (rc = -ENODEV, i = 0; rc && i < nr_apqns; i++) {
+			rc = pkey_cca_clr2key(apqns[i].card,
+					      apqns[i].domain,
+					      u, keytype, kbitsize, flags,
+					      clrkey, kbitsize / 8,
+					      keybuf, keybuflen);
+		}
+	} else if (pkey_is_ep11_keytype(keytype)) {
+		/* As of now only EP11 AES key generation is supported */
+		u = pkey_aes_bitsize_to_keytype(kbitsize);
+		if (!u) {
+			PKEY_DBF_ERR("%s unknown/unsupported keybitsize %d\n",
+				     __func__, kbitsize);
 			return -EINVAL;
-		break;
-	default:
-		return -EINVAL;
-	}
-	switch (ksize) {
-	case PKEY_SIZE_AES_128:
-	case PKEY_SIZE_AES_192:
-	case PKEY_SIZE_AES_256:
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	zcrypt_wait_api_operational();
-
-	/* simple try all apqns from the list */
-	for (i = 0, rc = -ENODEV; i < nr_apqns; i++) {
-		card = apqns[i].card;
-		dom = apqns[i].domain;
-		if (ktype == PKEY_TYPE_EP11 ||
-		    ktype == PKEY_TYPE_EP11_AES) {
-			rc = ep11_clr2keyblob(card, dom, ksize, kflags,
-					      clrkey, keybuf, keybufsize,
-					      ktype);
-		} else if (ktype == PKEY_TYPE_CCA_DATA) {
-			rc = cca_clr2seckey(card, dom, ksize,
-					    clrkey, keybuf);
-			*keybufsize = (rc ? 0 : SECKEYBLOBSIZE);
-		} else {
-			/* TOKVER_CCA_VLSC */
-			rc = cca_clr2cipherkey(card, dom, ksize, kflags,
-					       clrkey, keybuf, keybufsize);
 		}
-		if (rc == 0)
-			break;
+		for (rc = -ENODEV, i = 0; rc && i < nr_apqns; i++) {
+			rc = pkey_ep11_clr2key(apqns[i].card,
+					       apqns[i].domain,
+					       u, keytype, kbitsize, flags,
+					       clrkey, kbitsize / 8,
+					       keybuf, keybuflen);
+		}
+	} else {
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %d\n",
+			     __func__, keytype);
+		return -EINVAL;
 	}
 
 	return rc;
 }
 
-static int pkey_verifykey2(const u8 *key, size_t keylen,
-			   u16 *cardnr, u16 *domain,
-			   enum pkey_key_type *ktype,
-			   enum pkey_key_size *ksize, u32 *flags)
+static int ccakey2protkey(const struct pkey_apqn *apqns, size_t nr_apqns,
+			  const u8 *key, size_t keylen,
+			  u8 *protkey, u32 *protkeylen, u32 *protkeytype)
 {
-	struct keytoken_header *hdr = (struct keytoken_header *)key;
-	u32 _nr_apqns, *_apqns = NULL;
-	int rc;
+	struct pkey_apqn *local_apqns = NULL;
+	int i, j, rc;
 
-	if (keylen < sizeof(struct keytoken_header))
-		return -EINVAL;
-
-	if (hdr->type == TOKTYPE_CCA_INTERNAL &&
-	    hdr->version == TOKVER_CCA_AES) {
-		struct secaeskeytoken *t = (struct secaeskeytoken *)key;
-
-		rc = cca_check_secaeskeytoken(pkey_dbf_info, 3, key, 0);
-		if (rc)
-			goto out;
-		if (ktype)
-			*ktype = PKEY_TYPE_CCA_DATA;
-		if (ksize)
-			*ksize = (enum pkey_key_size)t->bitsize;
-
-		rc = cca_findcard2(&_apqns, &_nr_apqns, *cardnr, *domain,
-				   ZCRYPT_CEX3C, AES_MK_SET, t->mkvp, 0, 1);
-		if (rc == 0 && flags)
-			*flags = PKEY_FLAGS_MATCH_CUR_MKVP;
-		if (rc == -ENODEV) {
-			rc = cca_findcard2(&_apqns, &_nr_apqns,
-					   *cardnr, *domain,
-					   ZCRYPT_CEX3C, AES_MK_SET,
-					   0, t->mkvp, 1);
-			if (rc == 0 && flags)
-				*flags = PKEY_FLAGS_MATCH_ALT_MKVP;
-		}
-		if (rc)
-			goto out;
-
-		*cardnr = ((struct pkey_apqn *)_apqns)->card;
-		*domain = ((struct pkey_apqn *)_apqns)->domain;
-
-	} else if (hdr->type == TOKTYPE_CCA_INTERNAL &&
-		   hdr->version == TOKVER_CCA_VLSC) {
-		struct cipherkeytoken *t = (struct cipherkeytoken *)key;
+	/* alloc space for list of apqns if no list given */
+	if (!apqns || (nr_apqns == 1 &&
+		       apqns[0].card == 0xFFFF && apqns[0].domain == 0xFFFF)) {
+		nr_apqns = MAXAPQNSINLIST;
+		local_apqns = kmalloc_array(nr_apqns, sizeof(struct pkey_apqn),
+					    GFP_KERNEL);
+		if (!local_apqns)
+			return -ENOMEM;
+		apqns = local_apqns;
+	}
 
-		rc = cca_check_secaescipherkey(pkey_dbf_info, 3, key, 0, 1);
-		if (rc)
-			goto out;
-		if (ktype)
-			*ktype = PKEY_TYPE_CCA_CIPHER;
-		if (ksize) {
-			*ksize = PKEY_SIZE_UNKNOWN;
-			if (!t->plfver && t->wpllen == 512)
-				*ksize = PKEY_SIZE_AES_128;
-			else if (!t->plfver && t->wpllen == 576)
-				*ksize = PKEY_SIZE_AES_192;
-			else if (!t->plfver && t->wpllen == 640)
-				*ksize = PKEY_SIZE_AES_256;
+	/* try two times in case of failure */
+	for (i = 0, rc = -ENODEV; i < 2 && rc; i++) {
+		if (local_apqns) {
+			/* gather list of apqns able to deal with this key */
+			nr_apqns = MAXAPQNSINLIST;
+			rc = pkey_cca_apqns4key(key, keylen, 0,
+						local_apqns, &nr_apqns);
+			if (rc)
+				continue;
 		}
-
-		rc = cca_findcard2(&_apqns, &_nr_apqns, *cardnr, *domain,
-				   ZCRYPT_CEX6, AES_MK_SET, t->mkvp0, 0, 1);
-		if (rc == 0 && flags)
-			*flags = PKEY_FLAGS_MATCH_CUR_MKVP;
-		if (rc == -ENODEV) {
-			rc = cca_findcard2(&_apqns, &_nr_apqns,
-					   *cardnr, *domain,
-					   ZCRYPT_CEX6, AES_MK_SET,
-					   0, t->mkvp0, 1);
-			if (rc == 0 && flags)
-				*flags = PKEY_FLAGS_MATCH_ALT_MKVP;
+		/* go through the list of apqns until success or end */
+		for (j = 0, rc = -ENODEV; j < nr_apqns && rc; j++) {
+			rc = pkey_cca_key2protkey(apqns[j].card,
+						  apqns[j].domain,
+						  key, keylen,
+						  protkey, protkeylen,
+						  protkeytype);
 		}
-		if (rc)
-			goto out;
-
-		*cardnr = ((struct pkey_apqn *)_apqns)->card;
-		*domain = ((struct pkey_apqn *)_apqns)->domain;
-
-	} else if (hdr->type == TOKTYPE_NON_CCA &&
-		   hdr->version == TOKVER_EP11_AES) {
-		struct ep11keyblob *kb = (struct ep11keyblob *)key;
-		int api;
-
-		rc = ep11_check_aes_key(pkey_dbf_info, 3, key, keylen, 1);
-		if (rc)
-			goto out;
-		if (ktype)
-			*ktype = PKEY_TYPE_EP11;
-		if (ksize)
-			*ksize = kb->head.bitlen;
-
-		api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
-		rc = ep11_findcard2(&_apqns, &_nr_apqns, *cardnr, *domain,
-				    ZCRYPT_CEX7, api,
-				    ep11_kb_wkvp(key, keylen));
-		if (rc)
-			goto out;
-
-		if (flags)
-			*flags = PKEY_FLAGS_MATCH_CUR_MKVP;
-
-		*cardnr = ((struct pkey_apqn *)_apqns)->card;
-		*domain = ((struct pkey_apqn *)_apqns)->domain;
-
-	} else if (hdr->type == TOKTYPE_NON_CCA &&
-		   hdr->version == TOKVER_EP11_AES_WITH_HEADER) {
-		struct ep11kblob_header *kh = (struct ep11kblob_header *)key;
-		int api;
-
-		rc = ep11_check_aes_key_with_hdr(pkey_dbf_info,
-						 3, key, keylen, 1);
-		if (rc)
-			goto out;
-		if (ktype)
-			*ktype = PKEY_TYPE_EP11_AES;
-		if (ksize)
-			*ksize = kh->bitlen;
-
-		api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
-		rc = ep11_findcard2(&_apqns, &_nr_apqns, *cardnr, *domain,
-				    ZCRYPT_CEX7, api,
-				    ep11_kb_wkvp(key, keylen));
-		if (rc)
-			goto out;
-
-		if (flags)
-			*flags = PKEY_FLAGS_MATCH_CUR_MKVP;
-
-		*cardnr = ((struct pkey_apqn *)_apqns)->card;
-		*domain = ((struct pkey_apqn *)_apqns)->domain;
-	} else {
-		rc = -EINVAL;
 	}
 
-out:
-	kfree(_apqns);
+	kfree(local_apqns);
+
 	return rc;
 }
 
-static int pkey_keyblob2pkey2(const struct pkey_apqn *apqns, size_t nr_apqns,
-			      const u8 *key, size_t keylen,
-			      u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+static int ep11key2protkey(const struct pkey_apqn *apqns, size_t nr_apqns,
+			   const u8 *key, size_t keylen,
+			   u8 *protkey, u32 *protkeylen, u32 *protkeytype)
 {
-	struct keytoken_header *hdr = (struct keytoken_header *)key;
-	int i, card, dom, rc;
-
-	/* check for at least one apqn given */
-	if (!apqns || !nr_apqns)
-		return -EINVAL;
+	struct pkey_apqn *local_apqns = NULL;
+	int i, j, rc;
 
-	if (keylen < sizeof(struct keytoken_header))
-		return -EINVAL;
+	/* alloc space for list of apqns if no list given */
+	if (!apqns || (nr_apqns == 1 &&
+		       apqns[0].card == 0xFFFF && apqns[0].domain == 0xFFFF)) {
+		nr_apqns = MAXAPQNSINLIST;
+		local_apqns = kmalloc_array(nr_apqns, sizeof(struct pkey_apqn),
+					    GFP_KERNEL);
+		if (!local_apqns)
+			return -ENOMEM;
+		apqns = local_apqns;
+	}
 
-	if (hdr->type == TOKTYPE_CCA_INTERNAL) {
-		if (hdr->version == TOKVER_CCA_AES) {
-			if (keylen != sizeof(struct secaeskeytoken))
-				return -EINVAL;
-			if (cca_check_secaeskeytoken(pkey_dbf_info, 3, key, 0))
-				return -EINVAL;
-		} else if (hdr->version == TOKVER_CCA_VLSC) {
-			if (keylen < hdr->len || keylen > MAXCCAVLSCTOKENSIZE)
-				return -EINVAL;
-			if (cca_check_secaescipherkey(pkey_dbf_info,
-						      3, key, 0, 1))
-				return -EINVAL;
-		} else {
-			PKEY_DBF_ERR("%s unknown CCA internal token version %d\n",
-				     __func__, hdr->version);
-			return -EINVAL;
+	/* try two times in case of failure */
+	for (i = 0, rc = -ENODEV; i < 2 && rc; i++) {
+		if (local_apqns) {
+			/* gather list of apqns able to deal with this key */
+			nr_apqns = MAXAPQNSINLIST;
+			rc = pkey_ep11_apqns4key(key, keylen, 0,
+						 local_apqns, &nr_apqns);
+			if (rc)
+				continue;
 		}
-	} else if (hdr->type == TOKTYPE_NON_CCA) {
-		if (hdr->version == TOKVER_EP11_AES) {
-			if (ep11_check_aes_key(pkey_dbf_info,
-					       3, key, keylen, 1))
-				return -EINVAL;
-		} else if (hdr->version == TOKVER_EP11_AES_WITH_HEADER) {
-			if (ep11_check_aes_key_with_hdr(pkey_dbf_info,
-							3, key, keylen, 1))
-				return -EINVAL;
-		} else {
-			return pkey_nonccatok2pkey(key, keylen,
+		/* go through the list of apqns until success or end */
+		for (j = 0, rc = -ENODEV; j < nr_apqns && rc; j++) {
+			rc = pkey_ep11_key2protkey(apqns[j].card,
+						   apqns[j].domain,
+						   key, keylen,
 						   protkey, protkeylen,
 						   protkeytype);
 		}
-	} else {
-		PKEY_DBF_ERR("%s unknown/unsupported blob type %d\n",
-			     __func__, hdr->type);
-		return -EINVAL;
 	}
 
-	zcrypt_wait_api_operational();
-
-	/* simple try all apqns from the list */
-	for (i = 0, rc = -ENODEV; i < nr_apqns; i++) {
-		card = apqns[i].card;
-		dom = apqns[i].domain;
-		if (hdr->type == TOKTYPE_CCA_INTERNAL &&
-		    hdr->version == TOKVER_CCA_AES) {
-			rc = cca_sec2protkey(card, dom, key,
-					     protkey, protkeylen, protkeytype);
-		} else if (hdr->type == TOKTYPE_CCA_INTERNAL &&
-			   hdr->version == TOKVER_CCA_VLSC) {
-			rc = cca_cipher2protkey(card, dom, key,
-						protkey, protkeylen,
-						protkeytype);
-		} else {
-			rc = ep11_kblob2protkey(card, dom, key, keylen,
-						protkey, protkeylen,
-						protkeytype);
-		}
-		if (rc == 0)
-			break;
-	}
+	kfree(local_apqns);
 
 	return rc;
 }
 
-static int pkey_apqns4key(const u8 *key, size_t keylen, u32 flags,
-			  struct pkey_apqn *apqns, size_t *nr_apqns)
-{
-	struct keytoken_header *hdr = (struct keytoken_header *)key;
-	u32 _nr_apqns, *_apqns = NULL;
-	int rc;
+static int pckmokey2protkey_fallback(const struct clearkeytoken *t,
+				     u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+{
+	size_t tmpbuflen = max_t(size_t, SECKEYBLOBSIZE, MAXEP11AESKEYBLOBSIZE);
+	struct pkey_apqn *apqns = NULL;
+	u32 keysize, tmplen;
+	u8 *tmpbuf = NULL;
+	size_t nr_apqns;
+	int i, j, rc;
+
+	/* As of now only for AES keys a fallback is available */
 
-	if (keylen < sizeof(struct keytoken_header) || flags == 0)
+	keysize = pkey_keytype_aes_to_size(t->keytype);
+	if (!keysize) {
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %u\n",
+			     __func__, t->keytype);
+		return -EINVAL;
+	}
+	if (t->len != keysize) {
+		PKEY_DBF_ERR("%s clear key AES token: invalid key len %u\n",
+			     __func__, t->len);
 		return -EINVAL;
+	}
 
-	zcrypt_wait_api_operational();
+	/* alloc tmp buffer and space for apqns */
+	tmpbuf = kmalloc(tmpbuflen, GFP_ATOMIC);
+	if (!tmpbuf)
+		return -ENOMEM;
+	nr_apqns = MAXAPQNSINLIST;
+	apqns = kmalloc_array(nr_apqns, sizeof(struct pkey_apqn), GFP_KERNEL);
+	if (!apqns) {
+		kfree(tmpbuf);
+		return -ENOMEM;
+	}
 
-	if (hdr->type == TOKTYPE_NON_CCA &&
-	    (hdr->version == TOKVER_EP11_AES_WITH_HEADER ||
-	     hdr->version == TOKVER_EP11_ECC_WITH_HEADER) &&
-	    is_ep11_keyblob(key + sizeof(struct ep11kblob_header))) {
-		struct ep11keyblob *kb = (struct ep11keyblob *)
-			(key + sizeof(struct ep11kblob_header));
-		int minhwtype = 0, api = 0;
+	/* try two times in case of failure */
+	for (i = 0, rc = -ENODEV; i < 2 && rc; i++) {
 
-		if (flags != PKEY_FLAGS_MATCH_CUR_MKVP)
-			return -EINVAL;
-		if (kb->attr & EP11_BLOB_PKEY_EXTRACTABLE) {
-			minhwtype = ZCRYPT_CEX7;
-			api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
-		}
-		rc = ep11_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
-				    minhwtype, api, kb->wkvp);
+		/* CCA secure key way */
+		nr_apqns = MAXAPQNSINLIST;
+		rc = pkey_cca_apqns4type(PKEY_TYPE_CCA_DATA,
+					 NULL, NULL, 0, apqns, &nr_apqns);
 		if (rc)
-			goto out;
-	} else if (hdr->type == TOKTYPE_NON_CCA &&
-		   hdr->version == TOKVER_EP11_AES &&
-		   is_ep11_keyblob(key)) {
-		struct ep11keyblob *kb = (struct ep11keyblob *)key;
-		int minhwtype = 0, api = 0;
-
-		if (flags != PKEY_FLAGS_MATCH_CUR_MKVP)
-			return -EINVAL;
-		if (kb->attr & EP11_BLOB_PKEY_EXTRACTABLE) {
-			minhwtype = ZCRYPT_CEX7;
-			api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
+			goto try_via_ep11;
+		for (j = 0, rc = -ENODEV; j < nr_apqns && rc; j++) {
+			tmplen = tmpbuflen;
+			rc = pkey_cca_clr2key(apqns[j].card, apqns[j].domain,
+					      t->keytype, PKEY_TYPE_CCA_DATA,
+					      8 * keysize, 0,
+					      t->clearkey, t->len,
+					      tmpbuf, &tmplen);
 		}
-		rc = ep11_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
-				    minhwtype, api, kb->wkvp);
 		if (rc)
-			goto out;
-	} else if (hdr->type == TOKTYPE_CCA_INTERNAL) {
-		u64 cur_mkvp = 0, old_mkvp = 0;
-		int minhwtype = ZCRYPT_CEX3C;
-
-		if (hdr->version == TOKVER_CCA_AES) {
-			struct secaeskeytoken *t = (struct secaeskeytoken *)key;
-
-			if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
-				cur_mkvp = t->mkvp;
-			if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
-				old_mkvp = t->mkvp;
-		} else if (hdr->version == TOKVER_CCA_VLSC) {
-			struct cipherkeytoken *t = (struct cipherkeytoken *)key;
-
-			minhwtype = ZCRYPT_CEX6;
-			if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
-				cur_mkvp = t->mkvp0;
-			if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
-				old_mkvp = t->mkvp0;
-		} else {
-			/* unknown cca internal token type */
-			return -EINVAL;
+			goto try_via_ep11;
+		for (j = 0, rc = -ENODEV; j < nr_apqns && rc; j++) {
+			rc = pkey_cca_key2protkey(apqns[j].card,
+						  apqns[j].domain,
+						  tmpbuf, tmplen,
+						  protkey, protkeylen,
+						  protkeytype);
 		}
-		rc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
-				   minhwtype, AES_MK_SET,
-				   cur_mkvp, old_mkvp, 1);
+		if (!rc)
+			break;
+
+try_via_ep11:
+		/* the CCA way failed, try via EP11 */
+		nr_apqns = MAXAPQNSINLIST;
+		rc = pkey_ep11_apqns4type(PKEY_TYPE_EP11_AES,
+					  NULL, NULL, 0, apqns, &nr_apqns);
 		if (rc)
-			goto out;
-	} else if (hdr->type == TOKTYPE_CCA_INTERNAL_PKA) {
-		struct eccprivkeytoken *t = (struct eccprivkeytoken *)key;
-		u64 cur_mkvp = 0, old_mkvp = 0;
-
-		if (t->secid == 0x20) {
-			if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
-				cur_mkvp = t->mkvp;
-			if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
-				old_mkvp = t->mkvp;
-		} else {
-			/* unknown cca internal 2 token type */
-			return -EINVAL;
+			continue;
+		for (j = 0, rc = -ENODEV; j < nr_apqns && rc; j++) {
+			tmplen = tmpbuflen;
+			rc = pkey_ep11_clr2key(apqns[j].card, apqns[j].domain,
+					       t->keytype, PKEY_TYPE_EP11_AES,
+					       8 * keysize, 0,
+					       t->clearkey, t->len,
+					       tmpbuf, &tmplen);
 		}
-		rc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
-				   ZCRYPT_CEX7, APKA_MK_SET,
-				   cur_mkvp, old_mkvp, 1);
 		if (rc)
-			goto out;
-	} else {
-		return -EINVAL;
+			continue;
+		for (j = 0, rc = -ENODEV; j < nr_apqns && rc; j++) {
+			rc = pkey_ep11_key2protkey(apqns[j].card,
+						   apqns[j].domain,
+						   tmpbuf, tmplen,
+						   protkey, protkeylen,
+						   protkeytype);
+		}
 	}
 
-	if (apqns) {
-		if (*nr_apqns < _nr_apqns)
-			rc = -ENOSPC;
-		else
-			memcpy(apqns, _apqns, _nr_apqns * sizeof(u32));
-	}
-	*nr_apqns = _nr_apqns;
+	kfree(tmpbuf);
+	kfree(apqns);
 
-out:
-	kfree(_apqns);
 	return rc;
 }
 
-static int pkey_apqns4keytype(enum pkey_key_type ktype,
-			      u8 cur_mkvp[32], u8 alt_mkvp[32], u32 flags,
-			      struct pkey_apqn *apqns, size_t *nr_apqns)
+static int pckmokey2protkey(const u8 *key, size_t keylen,
+			    u8 *protkey, u32 *protkeylen, u32 *protkeytype)
 {
-	u32 _nr_apqns, *_apqns = NULL;
 	int rc;
 
-	zcrypt_wait_api_operational();
-
-	if (ktype == PKEY_TYPE_CCA_DATA || ktype == PKEY_TYPE_CCA_CIPHER) {
-		u64 cur_mkvp = 0, old_mkvp = 0;
-		int minhwtype = ZCRYPT_CEX3C;
-
-		if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
-			cur_mkvp = *((u64 *)cur_mkvp);
-		if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
-			old_mkvp = *((u64 *)alt_mkvp);
-		if (ktype == PKEY_TYPE_CCA_CIPHER)
-			minhwtype = ZCRYPT_CEX6;
-		rc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
-				   minhwtype, AES_MK_SET,
-				   cur_mkvp, old_mkvp, 1);
-		if (rc)
-			goto out;
-	} else if (ktype == PKEY_TYPE_CCA_ECC) {
-		u64 cur_mkvp = 0, old_mkvp = 0;
-
-		if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
-			cur_mkvp = *((u64 *)cur_mkvp);
-		if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
-			old_mkvp = *((u64 *)alt_mkvp);
-		rc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
-				   ZCRYPT_CEX7, APKA_MK_SET,
-				   cur_mkvp, old_mkvp, 1);
-		if (rc)
-			goto out;
-
-	} else if (ktype == PKEY_TYPE_EP11 ||
-		   ktype == PKEY_TYPE_EP11_AES ||
-		   ktype == PKEY_TYPE_EP11_ECC) {
-		u8 *wkvp = NULL;
-		int api;
-
-		if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
-			wkvp = cur_mkvp;
-		api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
-		rc = ep11_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
-				    ZCRYPT_CEX7, api, wkvp);
-		if (rc)
-			goto out;
+	rc = pkey_pckmo_key2protkey(key, keylen,
+				    protkey, protkeylen,
+				    protkeytype);
+	if (rc == -ENODEV) {
+		struct keytoken_header *hdr = (struct keytoken_header *)key;
+		struct clearkeytoken *t = (struct clearkeytoken *)key;
 
-	} else {
-		return -EINVAL;
+		/* maybe a fallback is possible */
+		if (hdr->type == TOKTYPE_NON_CCA &&
+		    hdr->version == TOKVER_CLEAR_KEY) {
+			rc = pckmokey2protkey_fallback(t, protkey,
+						       protkeylen,
+						       protkeytype);
+			if (rc)
+				rc = -ENODEV;
+		}
 	}
 
-	if (apqns) {
-		if (*nr_apqns < _nr_apqns)
-			rc = -ENOSPC;
-		else
-			memcpy(apqns, _apqns, _nr_apqns * sizeof(u32));
-	}
-	*nr_apqns = _nr_apqns;
+	if (rc)
+		PKEY_DBF_ERR("%s unable to build protected key from clear, rc=%d",
+			     __func__, rc);
 
-out:
-	kfree(_apqns);
 	return rc;
 }
 
-static int pkey_keyblob2pkey3(const struct pkey_apqn *apqns, size_t nr_apqns,
-			      const u8 *key, size_t keylen,
-			      u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+static int key2protkey(const struct pkey_apqn *apqns, size_t nr_apqns,
+		       const u8 *key, size_t keylen,
+		       u8 *protkey, u32 *protkeylen, u32 *protkeytype)
 {
-	struct keytoken_header *hdr = (struct keytoken_header *)key;
-	int i, card, dom, rc;
-
-	/* check for at least one apqn given */
-	if (!apqns || !nr_apqns)
-		return -EINVAL;
-
-	if (keylen < sizeof(struct keytoken_header))
-		return -EINVAL;
-
-	if (hdr->type == TOKTYPE_NON_CCA &&
-	    hdr->version == TOKVER_EP11_AES_WITH_HEADER &&
-	    is_ep11_keyblob(key + sizeof(struct ep11kblob_header))) {
-		/* EP11 AES key blob with header */
-		if (ep11_check_aes_key_with_hdr(pkey_dbf_info,
-						3, key, keylen, 1))
-			return -EINVAL;
-	} else if (hdr->type == TOKTYPE_NON_CCA &&
-		   hdr->version == TOKVER_EP11_ECC_WITH_HEADER &&
-		   is_ep11_keyblob(key + sizeof(struct ep11kblob_header))) {
-		/* EP11 ECC key blob with header */
-		if (ep11_check_ecc_key_with_hdr(pkey_dbf_info,
-						3, key, keylen, 1))
-			return -EINVAL;
-	} else if (hdr->type == TOKTYPE_NON_CCA &&
-		   hdr->version == TOKVER_EP11_AES &&
-		   is_ep11_keyblob(key)) {
-		/* EP11 AES key blob with header in session field */
-		if (ep11_check_aes_key(pkey_dbf_info, 3, key, keylen, 1))
-			return -EINVAL;
-	} else	if (hdr->type == TOKTYPE_CCA_INTERNAL) {
-		if (hdr->version == TOKVER_CCA_AES) {
-			/* CCA AES data key */
-			if (keylen != sizeof(struct secaeskeytoken))
-				return -EINVAL;
-			if (cca_check_secaeskeytoken(pkey_dbf_info, 3, key, 0))
-				return -EINVAL;
-		} else if (hdr->version == TOKVER_CCA_VLSC) {
-			/* CCA AES cipher key */
-			if (keylen < hdr->len || keylen > MAXCCAVLSCTOKENSIZE)
-				return -EINVAL;
-			if (cca_check_secaescipherkey(pkey_dbf_info,
-						      3, key, 0, 1))
-				return -EINVAL;
-		} else {
-			PKEY_DBF_ERR("%s unknown CCA internal token version %d\n",
-				     __func__, hdr->version);
-			return -EINVAL;
-		}
-	} else if (hdr->type == TOKTYPE_CCA_INTERNAL_PKA) {
-		/* CCA ECC (private) key */
-		if (keylen < sizeof(struct eccprivkeytoken))
-			return -EINVAL;
-		if (cca_check_sececckeytoken(pkey_dbf_info, 3, key, keylen, 1))
-			return -EINVAL;
-	} else if (hdr->type == TOKTYPE_NON_CCA) {
-		return pkey_nonccatok2pkey(key, keylen,
-					   protkey, protkeylen, protkeytype);
+	if (pkey_is_cca_key(key, keylen)) {
+		return ccakey2protkey(apqns, nr_apqns, key, keylen,
+				      protkey, protkeylen, protkeytype);
+	} else if (pkey_is_ep11_key(key, keylen)) {
+		return ep11key2protkey(apqns, nr_apqns, key, keylen,
+				       protkey, protkeylen, protkeytype);
+	} else if (pkey_is_pckmo_key(key, keylen)) {
+		return pckmokey2protkey(key, keylen,
+					protkey, protkeylen, protkeytype);
 	} else {
-		PKEY_DBF_ERR("%s unknown/unsupported blob type %d\n",
-			     __func__, hdr->type);
-		return -EINVAL;
-	}
+		struct keytoken_header *hdr = (struct keytoken_header *)key;
 
-	/* simple try all apqns from the list */
-	for (rc = -ENODEV, i = 0; rc && i < nr_apqns; i++) {
-		card = apqns[i].card;
-		dom = apqns[i].domain;
-		if (hdr->type == TOKTYPE_NON_CCA &&
-		    (hdr->version == TOKVER_EP11_AES_WITH_HEADER ||
-		     hdr->version == TOKVER_EP11_ECC_WITH_HEADER) &&
-		    is_ep11_keyblob(key + sizeof(struct ep11kblob_header)))
-			rc = ep11_kblob2protkey(card, dom, key, hdr->len,
-						protkey, protkeylen,
-						protkeytype);
-		else if (hdr->type == TOKTYPE_NON_CCA &&
-			 hdr->version == TOKVER_EP11_AES &&
-			 is_ep11_keyblob(key))
-			rc = ep11_kblob2protkey(card, dom, key, hdr->len,
-						protkey, protkeylen,
-						protkeytype);
-		else if (hdr->type == TOKTYPE_CCA_INTERNAL &&
-			 hdr->version == TOKVER_CCA_AES)
-			rc = cca_sec2protkey(card, dom, key, protkey,
-					     protkeylen, protkeytype);
-		else if (hdr->type == TOKTYPE_CCA_INTERNAL &&
-			 hdr->version == TOKVER_CCA_VLSC)
-			rc = cca_cipher2protkey(card, dom, key, protkey,
-						protkeylen, protkeytype);
-		else if (hdr->type == TOKTYPE_CCA_INTERNAL_PKA)
-			rc = cca_ecc2protkey(card, dom, key, protkey,
-					     protkeylen, protkeytype);
-		else
-			return -EINVAL;
+		PKEY_DBF_ERR("%s unknown/unsupported key type %d version %d\n",
+			     __func__, hdr->type, hdr->version);
+		return -EINVAL;
 	}
+}
 
-	return rc;
+/*
+ * In-Kernel function: Transform a key blob (of any type) into a protected key
+ */
+int pkey_key2protkey(const u8 *key, u32 keylen,
+		     u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+{
+	return key2protkey(NULL, 0, key, keylen,
+			   protkey, protkeylen, protkeytype);
 }
+EXPORT_SYMBOL(pkey_key2protkey);
 
 /*
- * File io functions
+ * Ioctl functions
  */
 
 static void *_copy_key_from_user(void __user *ukey, size_t keylen)
@@ -1347,13 +448,16 @@ static void *_copy_apqns_from_user(void __user *uapqns, size_t nr_apqns)
 static int pkey_ioctl_genseck(struct pkey_genseck __user *ugs)
 {
 	struct pkey_genseck kgs;
+	u32 keybuflen;
 	int rc;
 
 	if (copy_from_user(&kgs, ugs, sizeof(kgs)))
 		return -EFAULT;
-	rc = cca_genseckey(kgs.cardnr, kgs.domain,
-			   kgs.keytype, kgs.seckey.seckey);
-	pr_debug("%s cca_genseckey()=%d\n", __func__, rc);
+	keybuflen = sizeof(kgs.seckey.seckey);
+	rc = pkey_cca_gen_key(kgs.cardnr, kgs.domain,
+			      kgs.keytype, PKEY_TYPE_CCA_DATA, 0, 0,
+			      kgs.seckey.seckey, &keybuflen);
+	pr_debug("pkey_cca_gen_key()=%d\n", rc);
 	if (!rc && copy_to_user(ugs, &kgs, sizeof(kgs)))
 		rc = -EFAULT;
 	memzero_explicit(&kgs, sizeof(kgs));
@@ -1364,13 +468,18 @@ static int pkey_ioctl_genseck(struct pkey_genseck __user *ugs)
 static int pkey_ioctl_clr2seck(struct pkey_clr2seck __user *ucs)
 {
 	struct pkey_clr2seck kcs;
+	u32 keybuflen;
 	int rc;
 
 	if (copy_from_user(&kcs, ucs, sizeof(kcs)))
 		return -EFAULT;
-	rc = cca_clr2seckey(kcs.cardnr, kcs.domain, kcs.keytype,
-			    kcs.clrkey.clrkey, kcs.seckey.seckey);
-	pr_debug("%s cca_clr2seckey()=%d\n", __func__, rc);
+	keybuflen = sizeof(kcs.seckey.seckey);
+	rc = pkey_cca_clr2key(kcs.cardnr, kcs.domain,
+			      kcs.keytype, PKEY_TYPE_CCA_DATA, 0, 0,
+			      kcs.clrkey.clrkey,
+			      pkey_keytype_aes_to_size(kcs.keytype),
+			      kcs.seckey.seckey, &keybuflen);
+	pr_debug("pkey_cca_clr2key()=%d\n", rc);
 	if (!rc && copy_to_user(ucs, &kcs, sizeof(kcs)))
 		rc = -EFAULT;
 	memzero_explicit(&kcs, sizeof(kcs));
@@ -1386,10 +495,11 @@ static int pkey_ioctl_sec2protk(struct pkey_sec2protk __user *usp)
 	if (copy_from_user(&ksp, usp, sizeof(ksp)))
 		return -EFAULT;
 	ksp.protkey.len = sizeof(ksp.protkey.protkey);
-	rc = cca_sec2protkey(ksp.cardnr, ksp.domain,
-			     ksp.seckey.seckey, ksp.protkey.protkey,
-			     &ksp.protkey.len, &ksp.protkey.type);
-	pr_debug("%s cca_sec2protkey()=%d\n", __func__, rc);
+	rc = pkey_cca_key2protkey(ksp.cardnr, ksp.domain,
+				  ksp.seckey.seckey, sizeof(ksp.seckey.seckey),
+				  ksp.protkey.protkey,
+				  &ksp.protkey.len, &ksp.protkey.type);
+	pr_debug("pkey_cca_key2protkey()=%d\n", rc);
 	if (!rc && copy_to_user(usp, &ksp, sizeof(ksp)))
 		rc = -EFAULT;
 	memzero_explicit(&ksp, sizeof(ksp));
@@ -1405,10 +515,10 @@ static int pkey_ioctl_clr2protk(struct pkey_clr2protk __user *ucp)
 	if (copy_from_user(&kcp, ucp, sizeof(kcp)))
 		return -EFAULT;
 	kcp.protkey.len = sizeof(kcp.protkey.protkey);
-	rc = pkey_clr2protkey(kcp.keytype, kcp.clrkey.clrkey,
-			      kcp.protkey.protkey,
-			      &kcp.protkey.len, &kcp.protkey.type);
-	pr_debug("%s pkey_clr2protkey()=%d\n", __func__, rc);
+	rc = pkey_pckmo_clr2protkey(kcp.keytype, kcp.clrkey.clrkey,
+				    kcp.protkey.protkey,
+				    &kcp.protkey.len, &kcp.protkey.type);
+	pr_debug("pkey_pckmo_clr2protkey()=%d\n", rc);
 	if (!rc && copy_to_user(ucp, &kcp, sizeof(kcp)))
 		rc = -EFAULT;
 	memzero_explicit(&kcp, sizeof(kcp));
@@ -1419,15 +529,37 @@ static int pkey_ioctl_clr2protk(struct pkey_clr2protk __user *ucp)
 static int pkey_ioctl_findcard(struct pkey_findcard __user *ufc)
 {
 	struct pkey_findcard kfc;
+	struct pkey_apqn *apqns;
+	size_t nr_apqns;
 	int rc;
 
 	if (copy_from_user(&kfc, ufc, sizeof(kfc)))
 		return -EFAULT;
-	rc = cca_findcard(kfc.seckey.seckey,
-			  &kfc.cardnr, &kfc.domain, 1);
-	pr_debug("%s cca_findcard()=%d\n", __func__, rc);
-	if (rc < 0)
+
+	if (!pkey_is_cca_key(kfc.seckey.seckey, sizeof(kfc.seckey.seckey)))
+		return -EINVAL;
+
+	nr_apqns = MAXAPQNSINLIST;
+	apqns = kmalloc_array(nr_apqns, sizeof(struct pkey_apqn), GFP_KERNEL);
+	if (!apqns)
+		return -ENOMEM;
+	rc = pkey_cca_apqns4key(kfc.seckey.seckey,
+				sizeof(kfc.seckey.seckey),
+				PKEY_FLAGS_MATCH_CUR_MKVP,
+				apqns, &nr_apqns);
+	if (rc == -ENODEV)
+		rc = pkey_cca_apqns4key(kfc.seckey.seckey,
+					sizeof(kfc.seckey.seckey),
+					PKEY_FLAGS_MATCH_ALT_MKVP,
+					apqns, &nr_apqns);
+	pr_debug("pkey_cca_apqns4key()=%d\n", rc);
+	if (rc) {
+		kfree(apqns);
 		return rc;
+	}
+	kfc.cardnr = apqns[0].card;
+	kfc.domain = apqns[0].domain;
+	kfree(apqns);
 	if (copy_to_user(ufc, &kfc, sizeof(kfc)))
 		return -EFAULT;
 
@@ -1437,14 +569,38 @@ static int pkey_ioctl_findcard(struct pkey_findcard __user *ufc)
 static int pkey_ioctl_skey2pkey(struct pkey_skey2pkey __user *usp)
 {
 	struct pkey_skey2pkey ksp;
-	int rc;
+	struct pkey_apqn *apqns;
+	size_t nr_apqns;
+	int i, rc;
 
 	if (copy_from_user(&ksp, usp, sizeof(ksp)))
 		return -EFAULT;
+
+	if (!pkey_is_cca_key(ksp.seckey.seckey, sizeof(ksp.seckey.seckey)))
+		return -EINVAL;
+
+	nr_apqns = MAXAPQNSINLIST;
+	apqns = kmalloc_array(nr_apqns, sizeof(struct pkey_apqn), GFP_KERNEL);
+	if (!apqns)
+		return -ENOMEM;
+	rc = pkey_cca_apqns4key(ksp.seckey.seckey, sizeof(ksp.seckey.seckey),
+				0, apqns, &nr_apqns);
+	pr_debug("pkey_cca_apqns4key()=%d\n", rc);
+	if (rc) {
+		kfree(apqns);
+		return rc;
+	}
 	ksp.protkey.len = sizeof(ksp.protkey.protkey);
-	rc = pkey_skey2pkey(ksp.seckey.seckey, ksp.protkey.protkey,
-			    &ksp.protkey.len, &ksp.protkey.type);
-	pr_debug("%s pkey_skey2pkey()=%d\n", __func__, rc);
+	for (rc = -ENODEV, i = 0; rc && i < nr_apqns; i++) {
+		rc = pkey_cca_key2protkey(apqns[i].card, apqns[i].domain,
+					  ksp.seckey.seckey,
+					  sizeof(ksp.seckey.seckey),
+					  ksp.protkey.protkey,
+					  &ksp.protkey.len,
+					  &ksp.protkey.type);
+		pr_debug("pkey_cca_key2protkey()=%d\n", rc);
+	}
+	kfree(apqns);
 	if (!rc && copy_to_user(usp, &ksp, sizeof(ksp)))
 		rc = -EFAULT;
 	memzero_explicit(&ksp, sizeof(ksp));
@@ -1454,14 +610,24 @@ static int pkey_ioctl_skey2pkey(struct pkey_skey2pkey __user *usp)
 
 static int pkey_ioctl_verifykey(struct pkey_verifykey __user *uvk)
 {
+	u32 keytype, keybitsize, flags;
 	struct pkey_verifykey kvk;
 	int rc;
 
 	if (copy_from_user(&kvk, uvk, sizeof(kvk)))
 		return -EFAULT;
-	rc = pkey_verifykey(&kvk.seckey, &kvk.cardnr, &kvk.domain,
-			    &kvk.keysize, &kvk.attributes);
-	pr_debug("%s pkey_verifykey()=%d\n", __func__, rc);
+	kvk.cardnr = 0xFFFF;
+	kvk.domain = 0xFFFF;
+	rc = pkey_cca_verifykey(kvk.seckey.seckey, sizeof(kvk.seckey.seckey),
+				&kvk.cardnr, &kvk.domain,
+				&keytype, &keybitsize, &flags);
+	pr_debug("pkey_cca_verifykey()=%d\n", rc);
+	if (!rc && keytype != PKEY_TYPE_CCA_DATA)
+		rc = -EINVAL;
+	kvk.attributes = PKEY_VERIFY_ATTR_AES;
+	kvk.keysize = (u16)keybitsize;
+	if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
+		kvk.attributes |= PKEY_VERIFY_ATTR_OLD_MKVP;
 	if (!rc && copy_to_user(uvk, &kvk, sizeof(kvk)))
 		rc = -EFAULT;
 	memzero_explicit(&kvk, sizeof(kvk));
@@ -1477,9 +643,9 @@ static int pkey_ioctl_genprotk(struct pkey_genprotk __user *ugp)
 	if (copy_from_user(&kgp, ugp, sizeof(kgp)))
 		return -EFAULT;
 	kgp.protkey.len = sizeof(kgp.protkey.protkey);
-	rc = pkey_genprotkey(kgp.keytype, kgp.protkey.protkey,
-			     &kgp.protkey.len, &kgp.protkey.type);
-	pr_debug("%s pkey_genprotkey()=%d\n", __func__, rc);
+	rc = pkey_pckmo_gen_protkey(kgp.keytype, kgp.protkey.protkey,
+				    &kgp.protkey.len, &kgp.protkey.type);
+	pr_debug("pkey_gen_protkey()=%d\n", rc);
 	if (!rc && copy_to_user(ugp, &kgp, sizeof(kgp)))
 		rc = -EFAULT;
 	memzero_explicit(&kgp, sizeof(kgp));
@@ -1494,9 +660,9 @@ static int pkey_ioctl_verifyprotk(struct pkey_verifyprotk __user *uvp)
 
 	if (copy_from_user(&kvp, uvp, sizeof(kvp)))
 		return -EFAULT;
-	rc = pkey_verifyprotkey(kvp.protkey.protkey,
-				kvp.protkey.len, kvp.protkey.type);
-	pr_debug("%s pkey_verifyprotkey()=%d\n", __func__, rc);
+	rc = pkey_pckmo_verify_protkey(kvp.protkey.protkey,
+				       kvp.protkey.len, kvp.protkey.type);
+	pr_debug("pkey_verify_protkey()=%d\n", rc);
 	memzero_explicit(&kvp, sizeof(kvp));
 
 	return rc;
@@ -1514,9 +680,10 @@ static int pkey_ioctl_kblob2protk(struct pkey_kblob2pkey __user *utp)
 	if (IS_ERR(kkey))
 		return PTR_ERR(kkey);
 	ktp.protkey.len = sizeof(ktp.protkey.protkey);
-	rc = pkey_keyblob2pkey(kkey, ktp.keylen, ktp.protkey.protkey,
-			       &ktp.protkey.len, &ktp.protkey.type);
-	pr_debug("%s pkey_keyblob2pkey()=%d\n", __func__, rc);
+	rc = key2protkey(NULL, 0, kkey, ktp.keylen,
+			 ktp.protkey.protkey, &ktp.protkey.len,
+			 &ktp.protkey.type);
+	pr_debug("key2protkey()=%d\n", rc);
 	kfree_sensitive(kkey);
 	if (!rc && copy_to_user(utp, &ktp, sizeof(ktp)))
 		rc = -EFAULT;
@@ -1527,7 +694,7 @@ static int pkey_ioctl_kblob2protk(struct pkey_kblob2pkey __user *utp)
 
 static int pkey_ioctl_genseck2(struct pkey_genseck2 __user *ugs)
 {
-	size_t klen = KEYBLOBBUFSIZE;
+	u32 klen = KEYBLOBBUFSIZE;
 	struct pkey_genseck2 kgs;
 	struct pkey_apqn *apqns;
 	u8 *kkey;
@@ -1543,10 +710,10 @@ static int pkey_ioctl_genseck2(struct pkey_genseck2 __user *ugs)
 		kfree(apqns);
 		return -ENOMEM;
 	}
-	rc = pkey_genseckey2(apqns, kgs.apqn_entries,
-			     kgs.type, kgs.size, kgs.keygenflags,
-			     kkey, &klen);
-	pr_debug("%s pkey_genseckey2()=%d\n", __func__, rc);
+	rc = genseck2(apqns, kgs.apqn_entries,
+		      kgs.type, kgs.size, kgs.keygenflags,
+		      kkey, &klen);
+	pr_debug("genseckey2()=%d\n", rc);
 	kfree(apqns);
 	if (rc) {
 		kfree_sensitive(kkey);
@@ -1572,7 +739,7 @@ static int pkey_ioctl_genseck2(struct pkey_genseck2 __user *ugs)
 
 static int pkey_ioctl_clr2seck2(struct pkey_clr2seck2 __user *ucs)
 {
-	size_t klen = KEYBLOBBUFSIZE;
+	u32 klen = KEYBLOBBUFSIZE;
 	struct pkey_clr2seck2 kcs;
 	struct pkey_apqn *apqns;
 	u8 *kkey;
@@ -1591,10 +758,10 @@ static int pkey_ioctl_clr2seck2(struct pkey_clr2seck2 __user *ucs)
 		memzero_explicit(&kcs, sizeof(kcs));
 		return -ENOMEM;
 	}
-	rc = pkey_clr2seckey2(apqns, kcs.apqn_entries,
-			      kcs.type, kcs.size, kcs.keygenflags,
-			      kcs.clrkey.clrkey, kkey, &klen);
-	pr_debug("%s pkey_clr2seckey2()=%d\n", __func__, rc);
+	rc = clr2seckey2(apqns, kcs.apqn_entries,
+			 kcs.type, kcs.size, kcs.keygenflags,
+			 kcs.clrkey.clrkey, kkey, &klen);
+	pr_debug("clr2seckey2()=%d\n", rc);
 	kfree(apqns);
 	if (rc) {
 		kfree_sensitive(kkey);
@@ -1633,10 +800,19 @@ static int pkey_ioctl_verifykey2(struct pkey_verifykey2 __user *uvk)
 	kkey = _copy_key_from_user(kvk.key, kvk.keylen);
 	if (IS_ERR(kkey))
 		return PTR_ERR(kkey);
-	rc = pkey_verifykey2(kkey, kvk.keylen,
-			     &kvk.cardnr, &kvk.domain,
-			     &kvk.type, &kvk.size, &kvk.flags);
-	pr_debug("%s pkey_verifykey2()=%d\n", __func__, rc);
+	if (pkey_is_cca_key(kkey, kvk.keylen)) {
+		rc = pkey_cca_verifykey(kkey, kvk.keylen,
+					&kvk.cardnr, &kvk.domain,
+					&kvk.type, &kvk.size, &kvk.flags);
+		pr_debug("pkey_cca_verifykey()=%d\n", rc);
+	} else if (pkey_is_ep11_key(kkey, kvk.keylen)) {
+		rc = pkey_ep11_verifykey(kkey, kvk.keylen,
+					 &kvk.cardnr, &kvk.domain,
+					 &kvk.type, &kvk.size, &kvk.flags);
+		pr_debug("pkey_ep11_verifykey()=%d\n", rc);
+	} else {
+		rc = -EINVAL;
+	}
 	kfree_sensitive(kkey);
 	if (rc)
 		return rc;
@@ -1664,11 +840,10 @@ static int pkey_ioctl_kblob2protk2(struct pkey_kblob2pkey2 __user *utp)
 		return PTR_ERR(kkey);
 	}
 	ktp.protkey.len = sizeof(ktp.protkey.protkey);
-	rc = pkey_keyblob2pkey2(apqns, ktp.apqn_entries,
-				kkey, ktp.keylen,
-				ktp.protkey.protkey, &ktp.protkey.len,
-				&ktp.protkey.type);
-	pr_debug("%s pkey_keyblob2pkey2()=%d\n", __func__, rc);
+	rc = key2protkey(apqns, ktp.apqn_entries, kkey, ktp.keylen,
+			 ktp.protkey.protkey, &ktp.protkey.len,
+			 &ktp.protkey.type);
+	pr_debug("key2protkey()=%d\n", rc);
 	kfree(apqns);
 	kfree_sensitive(kkey);
 	if (!rc && copy_to_user(utp, &ktp, sizeof(ktp)))
@@ -1701,9 +876,9 @@ static int pkey_ioctl_apqns4k(struct pkey_apqns4key __user *uak)
 		kfree(apqns);
 		return PTR_ERR(kkey);
 	}
-	rc = pkey_apqns4key(kkey, kak.keylen, kak.flags,
-			    apqns, &nr_apqns);
-	pr_debug("%s pkey_apqns4key()=%d\n", __func__, rc);
+	rc = apqns4key(kkey, kak.keylen, kak.flags,
+		       apqns, &nr_apqns);
+	pr_debug("apqns4key()=%d\n", rc);
 	kfree_sensitive(kkey);
 	if (rc && rc != -ENOSPC) {
 		kfree(apqns);
@@ -1747,9 +922,9 @@ static int pkey_ioctl_apqns4kt(struct pkey_apqns4keytype __user *uat)
 		if (!apqns)
 			return -ENOMEM;
 	}
-	rc = pkey_apqns4keytype(kat.type, kat.cur_mkvp, kat.alt_mkvp,
-				kat.flags, apqns, &nr_apqns);
-	pr_debug("%s pkey_apqns4keytype()=%d\n", __func__, rc);
+	rc = apqns4keytype(kat.type, kat.cur_mkvp, kat.alt_mkvp,
+			   kat.flags, apqns, &nr_apqns);
+	pr_debug("apqns4keytype()=%d\n", rc);
 	if (rc && rc != -ENOSPC) {
 		kfree(apqns);
 		return rc;
@@ -1799,10 +974,9 @@ static int pkey_ioctl_kblob2protk3(struct pkey_kblob2pkey3 __user *utp)
 		kfree_sensitive(kkey);
 		return -ENOMEM;
 	}
-	rc = pkey_keyblob2pkey3(apqns, ktp.apqn_entries,
-				kkey, ktp.keylen,
-				protkey, &protkeylen, &ktp.pkeytype);
-	pr_debug("%s pkey_keyblob2pkey3()=%d\n", __func__, rc);
+	rc = key2protkey(apqns, ktp.apqn_entries, kkey, ktp.keylen,
+			 protkey, &protkeylen, &ktp.pkeytype);
+	pr_debug("key2protkey()=%d\n", rc);
 	kfree(apqns);
 	kfree_sensitive(kkey);
 	if (rc) {
@@ -1893,494 +1067,8 @@ static long pkey_unlocked_ioctl(struct file *filp, unsigned int cmd,
 }
 
 /*
- * Sysfs and file io operations
- */
-
-/*
- * Sysfs attribute read function for all protected key binary attributes.
- * The implementation can not deal with partial reads, because a new random
- * protected key blob is generated with each read. In case of partial reads
- * (i.e. off != 0 or count < key blob size) -EINVAL is returned.
- */
-static ssize_t pkey_protkey_aes_attr_read(u32 keytype, bool is_xts, char *buf,
-					  loff_t off, size_t count)
-{
-	struct protaeskeytoken protkeytoken;
-	struct pkey_protkey protkey;
-	int rc;
-
-	if (off != 0 || count < sizeof(protkeytoken))
-		return -EINVAL;
-	if (is_xts)
-		if (count < 2 * sizeof(protkeytoken))
-			return -EINVAL;
-
-	memset(&protkeytoken, 0, sizeof(protkeytoken));
-	protkeytoken.type = TOKTYPE_NON_CCA;
-	protkeytoken.version = TOKVER_PROTECTED_KEY;
-	protkeytoken.keytype = keytype;
-
-	protkey.len = sizeof(protkey.protkey);
-	rc = pkey_genprotkey(protkeytoken.keytype,
-			     protkey.protkey, &protkey.len, &protkey.type);
-	if (rc)
-		return rc;
-
-	protkeytoken.len = protkey.len;
-	memcpy(&protkeytoken.protkey, &protkey.protkey, protkey.len);
-
-	memcpy(buf, &protkeytoken, sizeof(protkeytoken));
-
-	if (is_xts) {
-		/* xts needs a second protected key, reuse protkey struct */
-		protkey.len = sizeof(protkey.protkey);
-		rc = pkey_genprotkey(protkeytoken.keytype,
-				     protkey.protkey, &protkey.len, &protkey.type);
-		if (rc)
-			return rc;
-
-		protkeytoken.len = protkey.len;
-		memcpy(&protkeytoken.protkey, &protkey.protkey, protkey.len);
-
-		memcpy(buf + sizeof(protkeytoken), &protkeytoken,
-		       sizeof(protkeytoken));
-
-		return 2 * sizeof(protkeytoken);
-	}
-
-	return sizeof(protkeytoken);
-}
-
-static ssize_t protkey_aes_128_read(struct file *filp,
-				    struct kobject *kobj,
-				    struct bin_attribute *attr,
-				    char *buf, loff_t off,
-				    size_t count)
-{
-	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_128, false, buf,
-					  off, count);
-}
-
-static ssize_t protkey_aes_192_read(struct file *filp,
-				    struct kobject *kobj,
-				    struct bin_attribute *attr,
-				    char *buf, loff_t off,
-				    size_t count)
-{
-	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_192, false, buf,
-					  off, count);
-}
-
-static ssize_t protkey_aes_256_read(struct file *filp,
-				    struct kobject *kobj,
-				    struct bin_attribute *attr,
-				    char *buf, loff_t off,
-				    size_t count)
-{
-	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_256, false, buf,
-					  off, count);
-}
-
-static ssize_t protkey_aes_128_xts_read(struct file *filp,
-					struct kobject *kobj,
-					struct bin_attribute *attr,
-					char *buf, loff_t off,
-					size_t count)
-{
-	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_128, true, buf,
-					  off, count);
-}
-
-static ssize_t protkey_aes_256_xts_read(struct file *filp,
-					struct kobject *kobj,
-					struct bin_attribute *attr,
-					char *buf, loff_t off,
-					size_t count)
-{
-	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_256, true, buf,
-					  off, count);
-}
-
-static BIN_ATTR_RO(protkey_aes_128, sizeof(struct protaeskeytoken));
-static BIN_ATTR_RO(protkey_aes_192, sizeof(struct protaeskeytoken));
-static BIN_ATTR_RO(protkey_aes_256, sizeof(struct protaeskeytoken));
-static BIN_ATTR_RO(protkey_aes_128_xts, 2 * sizeof(struct protaeskeytoken));
-static BIN_ATTR_RO(protkey_aes_256_xts, 2 * sizeof(struct protaeskeytoken));
-
-static struct bin_attribute *protkey_attrs[] = {
-	&bin_attr_protkey_aes_128,
-	&bin_attr_protkey_aes_192,
-	&bin_attr_protkey_aes_256,
-	&bin_attr_protkey_aes_128_xts,
-	&bin_attr_protkey_aes_256_xts,
-	NULL
-};
-
-static struct attribute_group protkey_attr_group = {
-	.name	   = "protkey",
-	.bin_attrs = protkey_attrs,
-};
-
-/*
- * Sysfs attribute read function for all secure key ccadata binary attributes.
- * The implementation can not deal with partial reads, because a new random
- * protected key blob is generated with each read. In case of partial reads
- * (i.e. off != 0 or count < key blob size) -EINVAL is returned.
- */
-static ssize_t pkey_ccadata_aes_attr_read(u32 keytype, bool is_xts, char *buf,
-					  loff_t off, size_t count)
-{
-	struct pkey_seckey *seckey = (struct pkey_seckey *)buf;
-	int rc;
-
-	if (off != 0 || count < sizeof(struct secaeskeytoken))
-		return -EINVAL;
-	if (is_xts)
-		if (count < 2 * sizeof(struct secaeskeytoken))
-			return -EINVAL;
-
-	rc = cca_genseckey(-1, -1, keytype, seckey->seckey);
-	if (rc)
-		return rc;
-
-	if (is_xts) {
-		seckey++;
-		rc = cca_genseckey(-1, -1, keytype, seckey->seckey);
-		if (rc)
-			return rc;
-
-		return 2 * sizeof(struct secaeskeytoken);
-	}
-
-	return sizeof(struct secaeskeytoken);
-}
-
-static ssize_t ccadata_aes_128_read(struct file *filp,
-				    struct kobject *kobj,
-				    struct bin_attribute *attr,
-				    char *buf, loff_t off,
-				    size_t count)
-{
-	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_128, false, buf,
-					  off, count);
-}
-
-static ssize_t ccadata_aes_192_read(struct file *filp,
-				    struct kobject *kobj,
-				    struct bin_attribute *attr,
-				    char *buf, loff_t off,
-				    size_t count)
-{
-	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_192, false, buf,
-					  off, count);
-}
-
-static ssize_t ccadata_aes_256_read(struct file *filp,
-				    struct kobject *kobj,
-				    struct bin_attribute *attr,
-				    char *buf, loff_t off,
-				    size_t count)
-{
-	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_256, false, buf,
-					  off, count);
-}
-
-static ssize_t ccadata_aes_128_xts_read(struct file *filp,
-					struct kobject *kobj,
-					struct bin_attribute *attr,
-					char *buf, loff_t off,
-					size_t count)
-{
-	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_128, true, buf,
-					  off, count);
-}
-
-static ssize_t ccadata_aes_256_xts_read(struct file *filp,
-					struct kobject *kobj,
-					struct bin_attribute *attr,
-					char *buf, loff_t off,
-					size_t count)
-{
-	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_256, true, buf,
-					  off, count);
-}
-
-static BIN_ATTR_RO(ccadata_aes_128, sizeof(struct secaeskeytoken));
-static BIN_ATTR_RO(ccadata_aes_192, sizeof(struct secaeskeytoken));
-static BIN_ATTR_RO(ccadata_aes_256, sizeof(struct secaeskeytoken));
-static BIN_ATTR_RO(ccadata_aes_128_xts, 2 * sizeof(struct secaeskeytoken));
-static BIN_ATTR_RO(ccadata_aes_256_xts, 2 * sizeof(struct secaeskeytoken));
-
-static struct bin_attribute *ccadata_attrs[] = {
-	&bin_attr_ccadata_aes_128,
-	&bin_attr_ccadata_aes_192,
-	&bin_attr_ccadata_aes_256,
-	&bin_attr_ccadata_aes_128_xts,
-	&bin_attr_ccadata_aes_256_xts,
-	NULL
-};
-
-static struct attribute_group ccadata_attr_group = {
-	.name	   = "ccadata",
-	.bin_attrs = ccadata_attrs,
-};
-
-#define CCACIPHERTOKENSIZE	(sizeof(struct cipherkeytoken) + 80)
-
-/*
- * Sysfs attribute read function for all secure key ccacipher binary attributes.
- * The implementation can not deal with partial reads, because a new random
- * secure key blob is generated with each read. In case of partial reads
- * (i.e. off != 0 or count < key blob size) -EINVAL is returned.
- */
-static ssize_t pkey_ccacipher_aes_attr_read(enum pkey_key_size keybits,
-					    bool is_xts, char *buf, loff_t off,
-					    size_t count)
-{
-	size_t keysize = CCACIPHERTOKENSIZE;
-	u32 nr_apqns, *apqns = NULL;
-	int i, rc, card, dom;
-
-	if (off != 0 || count < CCACIPHERTOKENSIZE)
-		return -EINVAL;
-	if (is_xts)
-		if (count < 2 * CCACIPHERTOKENSIZE)
-			return -EINVAL;
-
-	/* build a list of apqns able to generate an cipher key */
-	rc = cca_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,
-			   ZCRYPT_CEX6, 0, 0, 0, 0);
-	if (rc)
-		return rc;
-
-	memset(buf, 0, is_xts ? 2 * keysize : keysize);
-
-	/* simple try all apqns from the list */
-	for (i = 0, rc = -ENODEV; i < nr_apqns; i++) {
-		card = apqns[i] >> 16;
-		dom = apqns[i] & 0xFFFF;
-		rc = cca_gencipherkey(card, dom, keybits, 0, buf, &keysize);
-		if (rc == 0)
-			break;
-	}
-	if (rc)
-		return rc;
-
-	if (is_xts) {
-		keysize = CCACIPHERTOKENSIZE;
-		buf += CCACIPHERTOKENSIZE;
-		rc = cca_gencipherkey(card, dom, keybits, 0, buf, &keysize);
-		if (rc == 0)
-			return 2 * CCACIPHERTOKENSIZE;
-	}
-
-	return CCACIPHERTOKENSIZE;
-}
-
-static ssize_t ccacipher_aes_128_read(struct file *filp,
-				      struct kobject *kobj,
-				      struct bin_attribute *attr,
-				      char *buf, loff_t off,
-				      size_t count)
-{
-	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_128, false, buf,
-					    off, count);
-}
-
-static ssize_t ccacipher_aes_192_read(struct file *filp,
-				      struct kobject *kobj,
-				      struct bin_attribute *attr,
-				      char *buf, loff_t off,
-				      size_t count)
-{
-	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_192, false, buf,
-					    off, count);
-}
-
-static ssize_t ccacipher_aes_256_read(struct file *filp,
-				      struct kobject *kobj,
-				      struct bin_attribute *attr,
-				      char *buf, loff_t off,
-				      size_t count)
-{
-	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_256, false, buf,
-					    off, count);
-}
-
-static ssize_t ccacipher_aes_128_xts_read(struct file *filp,
-					  struct kobject *kobj,
-					  struct bin_attribute *attr,
-					  char *buf, loff_t off,
-					  size_t count)
-{
-	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_128, true, buf,
-					    off, count);
-}
-
-static ssize_t ccacipher_aes_256_xts_read(struct file *filp,
-					  struct kobject *kobj,
-					  struct bin_attribute *attr,
-					  char *buf, loff_t off,
-					  size_t count)
-{
-	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_256, true, buf,
-					    off, count);
-}
-
-static BIN_ATTR_RO(ccacipher_aes_128, CCACIPHERTOKENSIZE);
-static BIN_ATTR_RO(ccacipher_aes_192, CCACIPHERTOKENSIZE);
-static BIN_ATTR_RO(ccacipher_aes_256, CCACIPHERTOKENSIZE);
-static BIN_ATTR_RO(ccacipher_aes_128_xts, 2 * CCACIPHERTOKENSIZE);
-static BIN_ATTR_RO(ccacipher_aes_256_xts, 2 * CCACIPHERTOKENSIZE);
-
-static struct bin_attribute *ccacipher_attrs[] = {
-	&bin_attr_ccacipher_aes_128,
-	&bin_attr_ccacipher_aes_192,
-	&bin_attr_ccacipher_aes_256,
-	&bin_attr_ccacipher_aes_128_xts,
-	&bin_attr_ccacipher_aes_256_xts,
-	NULL
-};
-
-static struct attribute_group ccacipher_attr_group = {
-	.name	   = "ccacipher",
-	.bin_attrs = ccacipher_attrs,
-};
-
-/*
- * Sysfs attribute read function for all ep11 aes key binary attributes.
- * The implementation can not deal with partial reads, because a new random
- * secure key blob is generated with each read. In case of partial reads
- * (i.e. off != 0 or count < key blob size) -EINVAL is returned.
- * This function and the sysfs attributes using it provide EP11 key blobs
- * padded to the upper limit of MAXEP11AESKEYBLOBSIZE which is currently
- * 336 bytes.
+ * File io operations
  */
-static ssize_t pkey_ep11_aes_attr_read(enum pkey_key_size keybits,
-				       bool is_xts, char *buf, loff_t off,
-				       size_t count)
-{
-	size_t keysize = MAXEP11AESKEYBLOBSIZE;
-	u32 nr_apqns, *apqns = NULL;
-	int i, rc, card, dom;
-
-	if (off != 0 || count < MAXEP11AESKEYBLOBSIZE)
-		return -EINVAL;
-	if (is_xts)
-		if (count < 2 * MAXEP11AESKEYBLOBSIZE)
-			return -EINVAL;
-
-	/* build a list of apqns able to generate an cipher key */
-	rc = ep11_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,
-			    ZCRYPT_CEX7,
-			    ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4,
-			    NULL);
-	if (rc)
-		return rc;
-
-	memset(buf, 0, is_xts ? 2 * keysize : keysize);
-
-	/* simple try all apqns from the list */
-	for (i = 0, rc = -ENODEV; i < nr_apqns; i++) {
-		card = apqns[i] >> 16;
-		dom = apqns[i] & 0xFFFF;
-		rc = ep11_genaeskey(card, dom, keybits, 0, buf, &keysize,
-				    PKEY_TYPE_EP11_AES);
-		if (rc == 0)
-			break;
-	}
-	if (rc)
-		return rc;
-
-	if (is_xts) {
-		keysize = MAXEP11AESKEYBLOBSIZE;
-		buf += MAXEP11AESKEYBLOBSIZE;
-		rc = ep11_genaeskey(card, dom, keybits, 0, buf, &keysize,
-				    PKEY_TYPE_EP11_AES);
-		if (rc == 0)
-			return 2 * MAXEP11AESKEYBLOBSIZE;
-	}
-
-	return MAXEP11AESKEYBLOBSIZE;
-}
-
-static ssize_t ep11_aes_128_read(struct file *filp,
-				 struct kobject *kobj,
-				 struct bin_attribute *attr,
-				 char *buf, loff_t off,
-				 size_t count)
-{
-	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_128, false, buf,
-				       off, count);
-}
-
-static ssize_t ep11_aes_192_read(struct file *filp,
-				 struct kobject *kobj,
-				 struct bin_attribute *attr,
-				 char *buf, loff_t off,
-				 size_t count)
-{
-	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_192, false, buf,
-				       off, count);
-}
-
-static ssize_t ep11_aes_256_read(struct file *filp,
-				 struct kobject *kobj,
-				 struct bin_attribute *attr,
-				 char *buf, loff_t off,
-				 size_t count)
-{
-	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_256, false, buf,
-				       off, count);
-}
-
-static ssize_t ep11_aes_128_xts_read(struct file *filp,
-				     struct kobject *kobj,
-				     struct bin_attribute *attr,
-				     char *buf, loff_t off,
-				     size_t count)
-{
-	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_128, true, buf,
-				       off, count);
-}
-
-static ssize_t ep11_aes_256_xts_read(struct file *filp,
-				     struct kobject *kobj,
-				     struct bin_attribute *attr,
-				     char *buf, loff_t off,
-				     size_t count)
-{
-	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_256, true, buf,
-				       off, count);
-}
-
-static BIN_ATTR_RO(ep11_aes_128, MAXEP11AESKEYBLOBSIZE);
-static BIN_ATTR_RO(ep11_aes_192, MAXEP11AESKEYBLOBSIZE);
-static BIN_ATTR_RO(ep11_aes_256, MAXEP11AESKEYBLOBSIZE);
-static BIN_ATTR_RO(ep11_aes_128_xts, 2 * MAXEP11AESKEYBLOBSIZE);
-static BIN_ATTR_RO(ep11_aes_256_xts, 2 * MAXEP11AESKEYBLOBSIZE);
-
-static struct bin_attribute *ep11_attrs[] = {
-	&bin_attr_ep11_aes_128,
-	&bin_attr_ep11_aes_192,
-	&bin_attr_ep11_aes_256,
-	&bin_attr_ep11_aes_128_xts,
-	&bin_attr_ep11_aes_256_xts,
-	NULL
-};
-
-static struct attribute_group ep11_attr_group = {
-	.name	   = "ep11",
-	.bin_attrs = ep11_attrs,
-};
-
-static const struct attribute_group *pkey_attr_groups[] = {
-	&protkey_attr_group,
-	&ccadata_attr_group,
-	&ccacipher_attr_group,
-	&ep11_attr_group,
-	NULL,
-};
 
 static const struct file_operations pkey_fops = {
 	.owner		= THIS_MODULE,
diff --git a/drivers/s390/crypto/pkey_base.h b/drivers/s390/crypto/pkey_base.h
new file mode 100644
index 000000000000..f714d42969b6
--- /dev/null
+++ b/drivers/s390/crypto/pkey_base.h
@@ -0,0 +1,162 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright IBM Corp. 2024
+ *
+ * Pkey base: debug feature, defines and structs
+ * common to all pkey code.
+ */
+
+#ifndef _PKEY_BASE_H_
+#define _PKEY_BASE_H_
+
+#include <linux/types.h>
+#include <asm/debug.h>
+#include <asm/pkey.h>
+
+/*
+ * pkey debug feature
+ */
+
+extern debug_info_t *pkey_dbf_info;
+
+#define PKEY_DBF_INFO(...) debug_sprintf_event(pkey_dbf_info, 5, ##__VA_ARGS__)
+#define PKEY_DBF_WARN(...) debug_sprintf_event(pkey_dbf_info, 4, ##__VA_ARGS__)
+#define PKEY_DBF_ERR(...)  debug_sprintf_event(pkey_dbf_info, 3, ##__VA_ARGS__)
+
+/*
+ * common defines and common structs
+ */
+
+#define KEYBLOBBUFSIZE 8192	/* key buffer size used for internal processing */
+#define MINKEYBLOBBUFSIZE (sizeof(struct keytoken_header))
+#define PROTKEYBLOBBUFSIZE 256	/* protected key buffer size used internal */
+#define MAXAPQNSINLIST 64	/* max 64 apqns within a apqn list */
+#define AES_WK_VP_SIZE 32	/* Size of WK VP block appended to a prot key */
+
+/* inside view of a protected key token (only type 0x00 version 0x01) */
+struct protaeskeytoken {
+	u8  type;     /* 0x00 for PAES specific key tokens */
+	u8  res0[3];
+	u8  version;  /* should be 0x01 for protected AES key token */
+	u8  res1[3];
+	u32 keytype;  /* key type, one of the PKEY_KEYTYPE values */
+	u32 len;      /* bytes actually stored in protkey[] */
+	u8  protkey[MAXPROTKEYSIZE]; /* the protected key blob */
+} __packed;
+
+/* inside view of a clear key token (type 0x00 version 0x02) */
+struct clearkeytoken {
+	u8  type;	/* 0x00 for PAES specific key tokens */
+	u8  res0[3];
+	u8  version;	/* 0x02 for clear key token */
+	u8  res1[3];
+	u32 keytype;	/* key type, one of the PKEY_KEYTYPE_* values */
+	u32 len;	/* bytes actually stored in clearkey[] */
+	u8  clearkey[]; /* clear key value */
+} __packed;
+
+/* helper function which translates the PKEY_KEYTYPE_AES_* to their keysize */
+static inline u32 pkey_keytype_aes_to_size(u32 keytype)
+{
+	switch (keytype) {
+	case PKEY_KEYTYPE_AES_128:
+		return 16;
+	case PKEY_KEYTYPE_AES_192:
+		return 24;
+	case PKEY_KEYTYPE_AES_256:
+		return 32;
+	default:
+		return 0;
+	}
+}
+
+/* helper function which translates AES key bit size into PKEY_KEYTYPE_AES_* */
+static inline u32 pkey_aes_bitsize_to_keytype(u32 keybitsize)
+{
+	switch (keybitsize) {
+	case 128:
+		return PKEY_KEYTYPE_AES_128;
+	case 192:
+		return PKEY_KEYTYPE_AES_192;
+	case 256:
+		return PKEY_KEYTYPE_AES_256;
+	default:
+		return 0;
+	}
+}
+
+/*
+ * pkey_cca.c:
+ */
+
+bool pkey_is_cca_key(const u8 *key, u32 keylen);
+bool pkey_is_cca_keytype(enum pkey_key_type);
+int pkey_cca_key2protkey(u16 card, u16 dom,
+			 const u8 *key, u32 keylen,
+			 u8 *protkey, u32 *protkeylen, u32 *protkeytype);
+int pkey_cca_gen_key(u16 card, u16 dom,
+		     u32 keytype, u32 keysubtype,
+		     u32 keybitsize, u32 flags,
+		     u8 *keybuf, u32 *keybuflen);
+int pkey_cca_clr2key(u16 card, u16 dom,
+		     u32 keytype, u32 keysubtype,
+		     u32 keybitsize, u32 flags,
+		     const u8 *clrkey, u32 clrkeylen,
+		     u8 *keybuf, u32 *keybuflen);
+int pkey_cca_verifykey(const u8 *key, u32 keylen,
+		       u16 *card, u16 *dom,
+		       u32 *keytype, u32 *keybitsize, u32 *flags);
+int pkey_cca_apqns4key(const u8 *key, u32 keylen, u32 flags,
+		       struct pkey_apqn *apqns, size_t *nr_apqns);
+int pkey_cca_apqns4type(enum pkey_key_type ktype,
+			u8 cur_mkvp[32], u8 alt_mkvp[32], u32 flags,
+			struct pkey_apqn *apqns, size_t *nr_apqns);
+
+/*
+ * pkey_ep11.c:
+ */
+
+bool pkey_is_ep11_key(const u8 *key, u32 keylen);
+bool pkey_is_ep11_keytype(enum pkey_key_type);
+int pkey_ep11_key2protkey(u16 card, u16 dom,
+			  const u8 *key, u32 keylen,
+			  u8 *protkey, u32 *protkeylen, u32 *protkeytype);
+int pkey_ep11_gen_key(u16 card, u16 dom,
+		      u32 keytype, u32 keysubtype,
+		      u32 keybitsize, u32 flags,
+		      u8 *keybuf, u32 *keybuflen);
+int pkey_ep11_clr2key(u16 card, u16 dom,
+		      u32 keytype, u32 keysubtype,
+		      u32 keybitsize, u32 flags,
+		      const u8 *clrkey, u32 clrkeylen,
+		      u8 *keybuf, u32 *keybuflen);
+int pkey_ep11_verifykey(const u8 *key, u32 keylen,
+			u16 *card, u16 *dom,
+			u32 *keytype, u32 *keybitsize, u32 *flags);
+int pkey_ep11_apqns4key(const u8 *key, u32 keylen, u32 flags,
+			struct pkey_apqn *apqns, size_t *nr_apqns);
+int pkey_ep11_apqns4type(enum pkey_key_type ktype,
+			 u8 cur_mkvp[32], u8 alt_mkvp[32], u32 flags,
+			 struct pkey_apqn *apqns, size_t *nr_apqns);
+
+/*
+ * pkey_pckmo.c:
+ */
+
+bool pkey_is_pckmo_key(const u8 *key, u32 keylen);
+int pkey_pckmo_key2protkey(const u8 *key, u32 keylen,
+			   u8 *protkey, u32 *protkeylen, u32 *protkeytype);
+int pkey_pckmo_gen_protkey(u32 keytype,
+			   u8 *protkey, u32 *protkeylen, u32 *protkeytype);
+int pkey_pckmo_clr2protkey(u32 keytype, const u8 *clrkey,
+			   u8 *protkey, u32 *protkeylen, u32 *protkeytype);
+int pkey_pckmo_verify_protkey(const u8 *protkey, u32 protkeylen,
+			      u32 protkeytype);
+
+/*
+ * pkey_sysfs.c:
+ */
+
+extern const struct attribute_group *pkey_attr_groups[];
+
+#endif /* _PKEY_BASE_H_ */
diff --git a/drivers/s390/crypto/pkey_cca.c b/drivers/s390/crypto/pkey_cca.c
new file mode 100644
index 000000000000..65e520d7a864
--- /dev/null
+++ b/drivers/s390/crypto/pkey_cca.c
@@ -0,0 +1,453 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  pkey cca specific code
+ *
+ *  Copyright IBM Corp. 2024
+ */
+
+#define KMSG_COMPONENT "pkey"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
+#include "zcrypt_api.h"
+#include "zcrypt_ccamisc.h"
+
+#include "pkey_base.h"
+
+/*
+ * Check key blob for known and supported CCA key.
+ */
+bool pkey_is_cca_key(const u8 *key, u32 keylen)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+
+	if (keylen < sizeof(*hdr))
+		return false;
+
+	switch (hdr->type) {
+	case TOKTYPE_CCA_INTERNAL:
+		switch (hdr->version) {
+		case TOKVER_CCA_AES:
+		case TOKVER_CCA_VLSC:
+			return true;
+		default:
+			return false;
+		}
+	case TOKTYPE_CCA_INTERNAL_PKA:
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool pkey_is_cca_keytype(enum pkey_key_type key_type)
+{
+	switch (key_type) {
+	case PKEY_TYPE_CCA_DATA:
+	case PKEY_TYPE_CCA_CIPHER:
+	case PKEY_TYPE_CCA_ECC:
+		return true;
+	default:
+		return false;
+	}
+}
+
+int pkey_cca_key2protkey(u16 card, u16 dom,
+			 const u8 *key, u32 keylen,
+			 u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+	int rc;
+
+	if (keylen < sizeof(*hdr))
+		return -EINVAL;
+
+	zcrypt_wait_api_operational();
+
+	if (hdr->type == TOKTYPE_CCA_INTERNAL &&
+	    hdr->version == TOKVER_CCA_AES) {
+		/* CCA AES data key */
+		if (keylen != sizeof(struct secaeskeytoken))
+			return -EINVAL;
+		if (cca_check_secaeskeytoken(pkey_dbf_info, 3, key, 0))
+			return -EINVAL;
+		rc = cca_sec2protkey(card, dom, key, protkey,
+				     protkeylen, protkeytype);
+	} else if (hdr->type == TOKTYPE_CCA_INTERNAL &&
+		   hdr->version == TOKVER_CCA_VLSC) {
+		/* CCA AES cipher key */
+		if (keylen < hdr->len || keylen > MAXCCAVLSCTOKENSIZE)
+			return -EINVAL;
+		if (cca_check_secaescipherkey(pkey_dbf_info,
+					      3, key, 0, 1))
+			return -EINVAL;
+		rc = cca_cipher2protkey(card, dom, key, protkey,
+					protkeylen, protkeytype);
+	} else if (hdr->type == TOKTYPE_CCA_INTERNAL_PKA) {
+		/* CCA ECC (private) key */
+		if (keylen < sizeof(struct eccprivkeytoken))
+			return -EINVAL;
+		if (cca_check_sececckeytoken(pkey_dbf_info, 3, key, keylen, 1))
+			return -EINVAL;
+		rc = cca_ecc2protkey(card, dom, key, protkey,
+				     protkeylen, protkeytype);
+	} else {
+		PKEY_DBF_ERR("%s unknown/unsupported blob type %d version %d\n",
+			     __func__, hdr->type, hdr->version);
+		rc = -EINVAL;
+	}
+
+	pr_debug("card=%d dom=%d rc=%d\n", card, dom, rc);
+	return rc;
+}
+
+/*
+ * Generate CCA secure key.
+ * As of now only CCA AES Data or Cipher secure keys are
+ * supported.
+ * keytype is one of the PKEY_KEYTYPE_* constants,
+ * subtype may be 0 or PKEY_TYPE_CCA_DATA or PKEY_TYPE_CCA_CIPHER,
+ * keybitsize is the bit size of the key (may be 0 for
+ * keytype PKEY_KEYTYPE_AES_*).
+ */
+int pkey_cca_gen_key(u16 card, u16 dom,
+		     u32 keytype, u32 subtype,
+		     u32 keybitsize, u32 flags,
+		     u8 *keybuf, u32 *keybuflen)
+{
+	int len, rc;
+
+	/* check keytype, subtype, keybitsize */
+	switch (keytype) {
+	case PKEY_KEYTYPE_AES_128:
+	case PKEY_KEYTYPE_AES_192:
+	case PKEY_KEYTYPE_AES_256:
+		len = pkey_keytype_aes_to_size(keytype);
+		if (keybitsize && keybitsize != 8 * len) {
+			PKEY_DBF_ERR("%s unknown/unsupported keybitsize %d\n",
+				     __func__, keybitsize);
+			return -EINVAL;
+		}
+		keybitsize = 8 * len;
+		switch (subtype) {
+		case 0:
+		case PKEY_TYPE_CCA_DATA:
+		case PKEY_TYPE_CCA_CIPHER:
+			break;
+		default:
+			PKEY_DBF_ERR("%s unknown/unsupported subtype %d\n",
+				     __func__, subtype);
+			return -EINVAL;
+		}
+		break;
+	default:
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %d\n",
+			     __func__, keytype);
+		return -EINVAL;
+	}
+
+	zcrypt_wait_api_operational();
+
+	if (subtype == PKEY_TYPE_CCA_CIPHER) {
+		rc = cca_gencipherkey(card, dom, keybitsize, flags,
+				      keybuf, keybuflen);
+	} else {
+		/* 0 or PKEY_TYPE_CCA_DATA */
+		rc = cca_genseckey(card, dom, keybitsize, keybuf);
+		*keybuflen = (rc ? 0 : SECKEYBLOBSIZE);
+	}
+
+	pr_debug("card=%d dom=%d rc=%d\n", card, dom, rc);
+	return rc;
+}
+
+/*
+ * Generate CCA secure key with given clear key value.
+ * As of now only CCA AES Data or Cipher secure keys are
+ * supported.
+ * keytype is one of the PKEY_KEYTYPE_* constants,
+ * subtype may be 0 or PKEY_TYPE_CCA_DATA or PKEY_TYPE_CCA_CIPHER,
+ * keybitsize is the bit size of the key (may be 0 for
+ * keytype PKEY_KEYTYPE_AES_*).
+ */
+int pkey_cca_clr2key(u16 card, u16 dom,
+		     u32 keytype, u32 subtype,
+		     u32 keybitsize, u32 flags,
+		     const u8 *clrkey, u32 clrkeylen,
+		     u8 *keybuf, u32 *keybuflen)
+{
+	int len, rc;
+
+	/* check keytype, subtype, clrkeylen, keybitsize */
+	switch (keytype) {
+	case PKEY_KEYTYPE_AES_128:
+	case PKEY_KEYTYPE_AES_192:
+	case PKEY_KEYTYPE_AES_256:
+		len = pkey_keytype_aes_to_size(keytype);
+		if (keybitsize && keybitsize != 8 * len) {
+			PKEY_DBF_ERR("%s unknown/unsupported keybitsize %d\n",
+				     __func__, keybitsize);
+			return -EINVAL;
+		}
+		keybitsize = 8 * len;
+		if (clrkeylen != len) {
+			PKEY_DBF_ERR("%s invalid clear key len %d != %d\n",
+				     __func__, clrkeylen, len);
+			return -EINVAL;
+		}
+		switch (subtype) {
+		case 0:
+		case PKEY_TYPE_CCA_DATA:
+		case PKEY_TYPE_CCA_CIPHER:
+			break;
+		default:
+			PKEY_DBF_ERR("%s unknown/unsupported subtype %d\n",
+				     __func__, subtype);
+			return -EINVAL;
+		}
+		break;
+	default:
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %d\n",
+			     __func__, keytype);
+		return -EINVAL;
+	}
+
+	zcrypt_wait_api_operational();
+
+	if (subtype == PKEY_TYPE_CCA_CIPHER) {
+		rc = cca_clr2cipherkey(card, dom, keybitsize,
+				       flags, clrkey, keybuf, keybuflen);
+	} else {
+		/* 0 or PKEY_TYPE_CCA_DATA */
+		rc = cca_clr2seckey(card, dom, keybitsize,
+				    clrkey, keybuf);
+		*keybuflen = (rc ? 0 : SECKEYBLOBSIZE);
+	}
+
+	pr_debug("card=%d dom=%d rc=%d\n", card, dom, rc);
+	return rc;
+}
+
+int pkey_cca_verifykey(const u8 *key, u32 keylen,
+		       u16 *card, u16 *dom,
+		       u32 *keytype, u32 *keybitsize, u32 *flags)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+	u32 nr_apqns, *apqns = NULL;
+	int rc;
+
+	if (keylen < sizeof(*hdr))
+		return -EINVAL;
+
+	zcrypt_wait_api_operational();
+
+	if (hdr->type == TOKTYPE_CCA_INTERNAL &&
+	    hdr->version == TOKVER_CCA_AES) {
+		struct secaeskeytoken *t = (struct secaeskeytoken *)key;
+
+		rc = cca_check_secaeskeytoken(pkey_dbf_info, 3, key, 0);
+		if (rc)
+			goto out;
+		*keytype = PKEY_TYPE_CCA_DATA;
+		*keybitsize = t->bitsize;
+		rc = cca_findcard2(&apqns, &nr_apqns, *card, *dom,
+				   ZCRYPT_CEX3C, AES_MK_SET,
+				   t->mkvp, 0, 1);
+		if (!rc)
+			*flags = PKEY_FLAGS_MATCH_CUR_MKVP;
+		if (rc == -ENODEV) {
+			rc = cca_findcard2(&apqns, &nr_apqns, *card, *dom,
+					   ZCRYPT_CEX3C, AES_MK_SET,
+					   0, t->mkvp, 1);
+			if (!rc)
+				*flags = PKEY_FLAGS_MATCH_ALT_MKVP;
+		}
+		if (rc)
+			goto out;
+
+		*card = ((struct pkey_apqn *)apqns)->card;
+		*dom = ((struct pkey_apqn *)apqns)->domain;
+
+	} else if (hdr->type == TOKTYPE_CCA_INTERNAL &&
+		   hdr->version == TOKVER_CCA_VLSC) {
+		struct cipherkeytoken *t = (struct cipherkeytoken *)key;
+
+		rc = cca_check_secaescipherkey(pkey_dbf_info, 3, key, 0, 1);
+		if (rc)
+			goto out;
+		*keytype = PKEY_TYPE_CCA_CIPHER;
+		*keybitsize = PKEY_SIZE_UNKNOWN;
+		if (!t->plfver && t->wpllen == 512)
+			*keybitsize = PKEY_SIZE_AES_128;
+		else if (!t->plfver && t->wpllen == 576)
+			*keybitsize = PKEY_SIZE_AES_192;
+		else if (!t->plfver && t->wpllen == 640)
+			*keybitsize = PKEY_SIZE_AES_256;
+		rc = cca_findcard2(&apqns, &nr_apqns, *card, *dom,
+				   ZCRYPT_CEX6, AES_MK_SET,
+				   t->mkvp0, 0, 1);
+		if (!rc)
+			*flags = PKEY_FLAGS_MATCH_CUR_MKVP;
+		if (rc == -ENODEV) {
+			rc = cca_findcard2(&apqns, &nr_apqns, *card, *dom,
+					   ZCRYPT_CEX6, AES_MK_SET,
+					   0, t->mkvp0, 1);
+			if (!rc)
+				*flags = PKEY_FLAGS_MATCH_ALT_MKVP;
+		}
+		if (rc)
+			goto out;
+
+		*card = ((struct pkey_apqn *)apqns)->card;
+		*dom = ((struct pkey_apqn *)apqns)->domain;
+
+	} else {
+		/* unknown/unsupported key blob */
+		rc = -EINVAL;
+	}
+
+out:
+	kfree(apqns);
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
+
+int pkey_cca_apqns4key(const u8 *key, u32 keylen, u32 flags,
+		       struct pkey_apqn *apqns, size_t *nr_apqns)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+	u32 _nr_apqns, *_apqns = NULL;
+	int rc;
+
+	if (!flags)
+		flags = PKEY_FLAGS_MATCH_CUR_MKVP | PKEY_FLAGS_MATCH_ALT_MKVP;
+
+	if (keylen < sizeof(struct keytoken_header))
+		return -EINVAL;
+
+	zcrypt_wait_api_operational();
+
+	if (hdr->type == TOKTYPE_CCA_INTERNAL) {
+		u64 cur_mkvp = 0, old_mkvp = 0;
+		int minhwtype = ZCRYPT_CEX3C;
+
+		if (hdr->version == TOKVER_CCA_AES) {
+			struct secaeskeytoken *t = (struct secaeskeytoken *)key;
+
+			if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
+				cur_mkvp = t->mkvp;
+			if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
+				old_mkvp = t->mkvp;
+		} else if (hdr->version == TOKVER_CCA_VLSC) {
+			struct cipherkeytoken *t = (struct cipherkeytoken *)key;
+
+			minhwtype = ZCRYPT_CEX6;
+			if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
+				cur_mkvp = t->mkvp0;
+			if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
+				old_mkvp = t->mkvp0;
+		} else {
+			/* unknown CCA internal token type */
+			return -EINVAL;
+		}
+		rc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
+				   minhwtype, AES_MK_SET,
+				   cur_mkvp, old_mkvp, 1);
+		if (rc)
+			goto out;
+
+	} else if (hdr->type == TOKTYPE_CCA_INTERNAL_PKA) {
+		struct eccprivkeytoken *t = (struct eccprivkeytoken *)key;
+		u64 cur_mkvp = 0, old_mkvp = 0;
+
+		if (t->secid == 0x20) {
+			if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
+				cur_mkvp = t->mkvp;
+			if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
+				old_mkvp = t->mkvp;
+		} else {
+			/* unknown CCA internal 2 token type */
+			return -EINVAL;
+		}
+		rc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
+				   ZCRYPT_CEX7, APKA_MK_SET,
+				   cur_mkvp, old_mkvp, 1);
+		if (rc)
+			goto out;
+
+	} else {
+		PKEY_DBF_ERR("%s unknown/unsupported blob type %d version %d\n",
+			     __func__, hdr->type, hdr->version);
+		return -EINVAL;
+	}
+
+	if (apqns) {
+		if (*nr_apqns < _nr_apqns)
+			rc = -ENOSPC;
+		else
+			memcpy(apqns, _apqns, _nr_apqns * sizeof(u32));
+	}
+	*nr_apqns = _nr_apqns;
+
+out:
+	kfree(_apqns);
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
+
+int pkey_cca_apqns4type(enum pkey_key_type ktype,
+			u8 cur_mkvp[32], u8 alt_mkvp[32], u32 flags,
+			struct pkey_apqn *apqns, size_t *nr_apqns)
+{
+	u32 _nr_apqns, *_apqns = NULL;
+	int rc;
+
+	zcrypt_wait_api_operational();
+
+	if (ktype == PKEY_TYPE_CCA_DATA || ktype == PKEY_TYPE_CCA_CIPHER) {
+		u64 cur_mkvp = 0, old_mkvp = 0;
+		int minhwtype = ZCRYPT_CEX3C;
+
+		if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
+			cur_mkvp = *((u64 *)cur_mkvp);
+		if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
+			old_mkvp = *((u64 *)alt_mkvp);
+		if (ktype == PKEY_TYPE_CCA_CIPHER)
+			minhwtype = ZCRYPT_CEX6;
+		rc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
+				   minhwtype, AES_MK_SET,
+				   cur_mkvp, old_mkvp, 1);
+		if (rc)
+			goto out;
+
+	} else if (ktype == PKEY_TYPE_CCA_ECC) {
+		u64 cur_mkvp = 0, old_mkvp = 0;
+
+		if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
+			cur_mkvp = *((u64 *)cur_mkvp);
+		if (flags & PKEY_FLAGS_MATCH_ALT_MKVP)
+			old_mkvp = *((u64 *)alt_mkvp);
+		rc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
+				   ZCRYPT_CEX7, APKA_MK_SET,
+				   cur_mkvp, old_mkvp, 1);
+		if (rc)
+			goto out;
+
+	} else {
+		PKEY_DBF_ERR("%s unknown/unsupported key type %d",
+			     __func__, (int)ktype);
+		return -EINVAL;
+	}
+
+	if (apqns) {
+		if (*nr_apqns < _nr_apqns)
+			rc = -ENOSPC;
+		else
+			memcpy(apqns, _apqns, _nr_apqns * sizeof(u32));
+	}
+	*nr_apqns = _nr_apqns;
+
+out:
+	kfree(_apqns);
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
diff --git a/drivers/s390/crypto/pkey_ep11.c b/drivers/s390/crypto/pkey_ep11.c
new file mode 100644
index 000000000000..fdc9de43a6c1
--- /dev/null
+++ b/drivers/s390/crypto/pkey_ep11.c
@@ -0,0 +1,406 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  pkey ep11 specific code
+ *
+ *  Copyright IBM Corp. 2024
+ */
+
+#define KMSG_COMPONENT "pkey"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
+#include "zcrypt_api.h"
+#include "zcrypt_ccamisc.h"
+#include "zcrypt_ep11misc.h"
+
+#include "pkey_base.h"
+
+/*
+ * Check key blob for known and supported EP11 key.
+ */
+bool pkey_is_ep11_key(const u8 *key, u32 keylen)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+
+	if (keylen < sizeof(*hdr))
+		return false;
+
+	switch (hdr->type) {
+	case TOKTYPE_NON_CCA:
+		switch (hdr->version) {
+		case TOKVER_EP11_AES:
+		case TOKVER_EP11_AES_WITH_HEADER:
+		case TOKVER_EP11_ECC_WITH_HEADER:
+			return true;
+		default:
+			return false;
+		}
+	default:
+		return false;
+	}
+}
+
+bool pkey_is_ep11_keytype(enum pkey_key_type key_type)
+{
+	switch (key_type) {
+	case PKEY_TYPE_EP11:
+	case PKEY_TYPE_EP11_AES:
+	case PKEY_TYPE_EP11_ECC:
+		return true;
+	default:
+		return false;
+	}
+}
+
+int pkey_ep11_key2protkey(u16 card, u16 dom,
+			  const u8 *key, u32 keylen,
+			  u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+	int rc;
+
+	if (keylen < sizeof(*hdr))
+		return -EINVAL;
+
+	zcrypt_wait_api_operational();
+
+	if (hdr->type == TOKTYPE_NON_CCA &&
+	    hdr->version == TOKVER_EP11_AES_WITH_HEADER &&
+	    is_ep11_keyblob(key + sizeof(struct ep11kblob_header))) {
+		/* EP11 AES key blob with header */
+		if (ep11_check_aes_key_with_hdr(pkey_dbf_info,
+						3, key, keylen, 1))
+			return -EINVAL;
+		rc = ep11_kblob2protkey(card, dom, key, hdr->len,
+					protkey, protkeylen,
+					protkeytype);
+	} else if (hdr->type == TOKTYPE_NON_CCA &&
+		   hdr->version == TOKVER_EP11_ECC_WITH_HEADER &&
+		   is_ep11_keyblob(key + sizeof(struct ep11kblob_header))) {
+		/* EP11 ECC key blob with header */
+		if (ep11_check_ecc_key_with_hdr(pkey_dbf_info,
+						3, key, keylen, 1))
+			return -EINVAL;
+		rc = ep11_kblob2protkey(card, dom, key, hdr->len,
+					protkey, protkeylen,
+					protkeytype);
+	} else if (hdr->type == TOKTYPE_NON_CCA &&
+		   hdr->version == TOKVER_EP11_AES &&
+		   is_ep11_keyblob(key)) {
+		/* EP11 AES key blob with header in session field */
+		if (ep11_check_aes_key(pkey_dbf_info, 3, key, keylen, 1))
+			return -EINVAL;
+		rc = ep11_kblob2protkey(card, dom, key, hdr->len,
+					protkey, protkeylen,
+					protkeytype);
+	} else {
+		PKEY_DBF_ERR("%s unknown/unsupported blob type %d version %d\n",
+			     __func__, hdr->type, hdr->version);
+		return -EINVAL;
+	}
+
+	pr_debug("card=%d dom=%d rc=%d\n", card, dom, rc);
+	return rc;
+}
+
+/*
+ * Generate EP11 secure key.
+ * As of now only EP11 AES secure keys are supported.
+ * keytype is one of the PKEY_KEYTYPE_* constants,
+ * subtype may be PKEY_TYPE_EP11 or PKEY_TYPE_EP11_AES
+ * or 0 (results in subtype PKEY_TYPE_EP11_AES),
+ * keybitsize is the bit size of the key (may be 0 for
+ * keytype PKEY_KEYTYPE_AES_*).
+ */
+int pkey_ep11_gen_key(u16 card, u16 dom,
+		      u32 keytype, u32 subtype,
+		      u32 keybitsize, u32 flags,
+		      u8 *keybuf, u32 *keybuflen)
+{
+	int len, rc;
+
+	/* check keytype, subtype, keybitsize */
+	switch (keytype) {
+	case PKEY_KEYTYPE_AES_128:
+	case PKEY_KEYTYPE_AES_192:
+	case PKEY_KEYTYPE_AES_256:
+		len = pkey_keytype_aes_to_size(keytype);
+		if (keybitsize && keybitsize != 8 * len) {
+			PKEY_DBF_ERR("%s unknown/unsupported keybitsize %d\n",
+				     __func__, keybitsize);
+			return -EINVAL;
+		}
+		keybitsize = 8 * len;
+		switch (subtype) {
+		case 0:
+			subtype = PKEY_TYPE_EP11_AES;
+			break;
+		case PKEY_TYPE_EP11:
+		case PKEY_TYPE_EP11_AES:
+			break;
+		default:
+			PKEY_DBF_ERR("%s unknown/unsupported subtype %d\n",
+				     __func__, subtype);
+			return -EINVAL;
+		}
+		break;
+	default:
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %d\n",
+			     __func__, keytype);
+		return -EINVAL;
+	}
+
+	zcrypt_wait_api_operational();
+
+	rc = ep11_genaeskey(card, dom, keybitsize, flags,
+			    keybuf, keybuflen, subtype);
+
+	pr_debug("card=%d dom=%d rc=%d\n", card, dom, rc);
+	return rc;
+}
+
+/*
+ * Generate EP11 secure key with given clear key value.
+ * As of now only EP11 AES secure keys are supported.
+ * keytype is one of the PKEY_KEYTYPE_* constants,
+ * subtype may be PKEY_TYPE_EP11 or PKEY_TYPE_EP11_AES
+ * or 0 (assumes PKEY_TYPE_EP11_AES then).
+ * keybitsize is the bit size of the key (may be 0 for
+ * keytype PKEY_KEYTYPE_AES_*).
+ */
+int pkey_ep11_clr2key(u16 card, u16 dom,
+		      u32 keytype, u32 subtype,
+		      u32 keybitsize, u32 flags,
+		      const u8 *clrkey, u32 clrkeylen,
+		      u8 *keybuf, u32 *keybuflen)
+{
+	int len, rc;
+
+	/* check keytype, subtype, clrkeylen, keybitsize */
+	switch (keytype) {
+	case PKEY_KEYTYPE_AES_128:
+	case PKEY_KEYTYPE_AES_192:
+	case PKEY_KEYTYPE_AES_256:
+		len = pkey_keytype_aes_to_size(keytype);
+		if (keybitsize && keybitsize != 8 * len) {
+			PKEY_DBF_ERR("%s unknown/unsupported keybitsize %d\n",
+				     __func__, keybitsize);
+			return -EINVAL;
+		}
+		keybitsize = 8 * len;
+		if (clrkeylen != len) {
+			PKEY_DBF_ERR("%s invalid clear key len %d != %d\n",
+				     __func__, clrkeylen, len);
+			return -EINVAL;
+		}
+		switch (subtype) {
+		case 0:
+			subtype = PKEY_TYPE_EP11_AES;
+			break;
+		case PKEY_TYPE_EP11:
+		case PKEY_TYPE_EP11_AES:
+			break;
+		default:
+			PKEY_DBF_ERR("%s unknown/unsupported subtype %d\n",
+				     __func__, subtype);
+			return -EINVAL;
+		}
+		break;
+	default:
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %d\n",
+			     __func__, keytype);
+		return -EINVAL;
+	}
+
+	zcrypt_wait_api_operational();
+
+	rc = ep11_clr2keyblob(card, dom, keybitsize, flags,
+			      clrkey, keybuf, keybuflen, subtype);
+
+	pr_debug("card=%d dom=%d rc=%d\n", card, dom, rc);
+	return rc;
+}
+
+int pkey_ep11_verifykey(const u8 *key, u32 keylen,
+			u16 *card, u16 *dom,
+			u32 *keytype, u32 *keybitsize, u32 *flags)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+	u32 nr_apqns, *apqns = NULL;
+	int rc;
+
+	if (keylen < sizeof(*hdr))
+		return -EINVAL;
+
+	zcrypt_wait_api_operational();
+
+	if (hdr->type == TOKTYPE_NON_CCA &&
+	    hdr->version == TOKVER_EP11_AES) {
+		struct ep11keyblob *kb = (struct ep11keyblob *)key;
+		int api;
+
+		rc = ep11_check_aes_key(pkey_dbf_info, 3, key, keylen, 1);
+		if (rc)
+			goto out;
+		*keytype = PKEY_TYPE_EP11;
+		*keybitsize = kb->head.bitlen;
+
+		api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
+		rc = ep11_findcard2(&apqns, &nr_apqns, *card, *dom,
+				    ZCRYPT_CEX7, api,
+				    ep11_kb_wkvp(key, keylen));
+		if (rc)
+			goto out;
+
+		*flags = PKEY_FLAGS_MATCH_CUR_MKVP;
+
+		*card = ((struct pkey_apqn *)apqns)->card;
+		*dom = ((struct pkey_apqn *)apqns)->domain;
+
+	} else if (hdr->type == TOKTYPE_NON_CCA &&
+		   hdr->version == TOKVER_EP11_AES_WITH_HEADER) {
+		struct ep11kblob_header *kh = (struct ep11kblob_header *)key;
+		int api;
+
+		rc = ep11_check_aes_key_with_hdr(pkey_dbf_info,
+						 3, key, keylen, 1);
+		if (rc)
+			goto out;
+		*keytype = PKEY_TYPE_EP11_AES;
+		*keybitsize = kh->bitlen;
+
+		api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
+		rc = ep11_findcard2(&apqns, &nr_apqns, *card, *dom,
+				    ZCRYPT_CEX7, api,
+				    ep11_kb_wkvp(key, keylen));
+		if (rc)
+			goto out;
+
+		*flags = PKEY_FLAGS_MATCH_CUR_MKVP;
+
+		*card = ((struct pkey_apqn *)apqns)->card;
+		*dom = ((struct pkey_apqn *)apqns)->domain;
+
+	} else {
+		/* unknown/unsupported key blob */
+		rc = -EINVAL;
+	}
+
+out:
+	kfree(apqns);
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
+
+int pkey_ep11_apqns4key(const u8 *key, u32 keylen, u32 flags,
+			struct pkey_apqn *apqns, size_t *nr_apqns)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+	u32 _nr_apqns, *_apqns = NULL;
+	int rc;
+
+	if (!flags)
+		flags = PKEY_FLAGS_MATCH_CUR_MKVP;
+
+	if (keylen < sizeof(struct keytoken_header) || flags == 0)
+		return -EINVAL;
+
+	zcrypt_wait_api_operational();
+
+	if (hdr->type == TOKTYPE_NON_CCA &&
+	    (hdr->version == TOKVER_EP11_AES_WITH_HEADER ||
+	     hdr->version == TOKVER_EP11_ECC_WITH_HEADER) &&
+	    is_ep11_keyblob(key + sizeof(struct ep11kblob_header))) {
+		struct ep11keyblob *kb = (struct ep11keyblob *)
+			(key + sizeof(struct ep11kblob_header));
+		int minhwtype = 0, api = 0;
+
+		if (flags != PKEY_FLAGS_MATCH_CUR_MKVP)
+			return -EINVAL;
+		if (kb->attr & EP11_BLOB_PKEY_EXTRACTABLE) {
+			minhwtype = ZCRYPT_CEX7;
+			api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
+		}
+		rc = ep11_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
+				    minhwtype, api, kb->wkvp);
+		if (rc)
+			goto out;
+
+	} else if (hdr->type == TOKTYPE_NON_CCA &&
+		   hdr->version == TOKVER_EP11_AES &&
+		   is_ep11_keyblob(key)) {
+		struct ep11keyblob *kb = (struct ep11keyblob *)key;
+		int minhwtype = 0, api = 0;
+
+		if (flags != PKEY_FLAGS_MATCH_CUR_MKVP)
+			return -EINVAL;
+		if (kb->attr & EP11_BLOB_PKEY_EXTRACTABLE) {
+			minhwtype = ZCRYPT_CEX7;
+			api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
+		}
+		rc = ep11_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
+				    minhwtype, api, kb->wkvp);
+		if (rc)
+			goto out;
+
+	} else {
+		PKEY_DBF_ERR("%s unknown/unsupported blob type %d version %d\n",
+			     __func__, hdr->type, hdr->version);
+		return -EINVAL;
+	}
+
+	if (apqns) {
+		if (*nr_apqns < _nr_apqns)
+			rc = -ENOSPC;
+		else
+			memcpy(apqns, _apqns, _nr_apqns * sizeof(u32));
+	}
+	*nr_apqns = _nr_apqns;
+
+out:
+	kfree(_apqns);
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
+
+int pkey_ep11_apqns4type(enum pkey_key_type ktype,
+			 u8 cur_mkvp[32], u8 alt_mkvp[32], u32 flags,
+			 struct pkey_apqn *apqns, size_t *nr_apqns)
+{
+	u32 _nr_apqns, *_apqns = NULL;
+	int rc;
+
+	zcrypt_wait_api_operational();
+
+	if (ktype == PKEY_TYPE_EP11 ||
+	    ktype == PKEY_TYPE_EP11_AES ||
+	    ktype == PKEY_TYPE_EP11_ECC) {
+		u8 *wkvp = NULL;
+		int api;
+
+		if (flags & PKEY_FLAGS_MATCH_CUR_MKVP)
+			wkvp = cur_mkvp;
+		api = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;
+		rc = ep11_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,
+				    ZCRYPT_CEX7, api, wkvp);
+		if (rc)
+			goto out;
+
+	} else {
+		PKEY_DBF_ERR("%s unknown/unsupported key type %d\n",
+			     __func__, (int)ktype);
+		return -EINVAL;
+	}
+
+	if (apqns) {
+		if (*nr_apqns < _nr_apqns)
+			rc = -ENOSPC;
+		else
+			memcpy(apqns, _apqns, _nr_apqns * sizeof(u32));
+	}
+	*nr_apqns = _nr_apqns;
+
+out:
+	kfree(_apqns);
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
diff --git a/drivers/s390/crypto/pkey_pckmo.c b/drivers/s390/crypto/pkey_pckmo.c
new file mode 100644
index 000000000000..30a9d2f64853
--- /dev/null
+++ b/drivers/s390/crypto/pkey_pckmo.c
@@ -0,0 +1,346 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  pkey pckmo specific code
+ *
+ *  Copyright IBM Corp. 2024
+ */
+
+#define KMSG_COMPONENT "pkey"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
+#include <asm/cpacf.h>
+#include <crypto/aes.h>
+#include <linux/random.h>
+
+#include "zcrypt_api.h"
+#include "zcrypt_ccamisc.h"
+
+#include "pkey_base.h"
+
+/*
+ * Check key blob for known and supported here.
+ */
+bool pkey_is_pckmo_key(const u8 *key, u32 keylen)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+	struct clearkeytoken *t = (struct clearkeytoken *)key;
+
+	if (keylen < sizeof(*hdr))
+		return false;
+
+	switch (hdr->type) {
+	case TOKTYPE_NON_CCA:
+		switch (hdr->version) {
+		case TOKVER_CLEAR_KEY:
+			switch (t->keytype) {
+			case PKEY_KEYTYPE_AES_128:
+			case PKEY_KEYTYPE_AES_192:
+			case PKEY_KEYTYPE_AES_256:
+			case PKEY_KEYTYPE_ECC_P256:
+			case PKEY_KEYTYPE_ECC_P384:
+			case PKEY_KEYTYPE_ECC_P521:
+			case PKEY_KEYTYPE_ECC_ED25519:
+			case PKEY_KEYTYPE_ECC_ED448:
+				return true;
+			default:
+				return false;
+			}
+		case TOKVER_PROTECTED_KEY:
+			return true;
+		default:
+			return false;
+		}
+	default:
+		return false;
+	}
+}
+
+int pkey_pckmo_key2protkey(const u8 *key, u32 keylen,
+			   u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+{
+	struct keytoken_header *hdr = (struct keytoken_header *)key;
+	int rc = -EINVAL;
+
+	if (keylen < sizeof(*hdr))
+		return -EINVAL;
+	if (hdr->type != TOKTYPE_NON_CCA)
+		return -EINVAL;
+
+	switch (hdr->version) {
+	case TOKVER_PROTECTED_KEY: {
+		struct protaeskeytoken *t;
+
+		if (keylen != sizeof(struct protaeskeytoken))
+			goto out;
+		t = (struct protaeskeytoken *)key;
+		rc = pkey_pckmo_verify_protkey(t->protkey, t->len,
+					       t->keytype);
+		if (rc)
+			goto out;
+		memcpy(protkey, t->protkey, t->len);
+		*protkeylen = t->len;
+		*protkeytype = t->keytype;
+		break;
+	}
+	case TOKVER_CLEAR_KEY: {
+		struct clearkeytoken *t = (struct clearkeytoken *)key;
+		u32 keysize = 0;
+
+		if (keylen < sizeof(struct clearkeytoken) ||
+		    keylen != sizeof(*t) + t->len)
+			goto out;
+		switch (t->keytype) {
+		case PKEY_KEYTYPE_AES_128:
+		case PKEY_KEYTYPE_AES_192:
+		case PKEY_KEYTYPE_AES_256:
+			keysize = pkey_keytype_aes_to_size(t->keytype);
+			break;
+		case PKEY_KEYTYPE_ECC_P256:
+			keysize = 32;
+			break;
+		case PKEY_KEYTYPE_ECC_P384:
+			keysize = 48;
+			break;
+		case PKEY_KEYTYPE_ECC_P521:
+			keysize = 80;
+			break;
+		case PKEY_KEYTYPE_ECC_ED25519:
+			keysize = 32;
+			break;
+		case PKEY_KEYTYPE_ECC_ED448:
+			keysize = 64;
+			break;
+		default:
+			break;
+		}
+		if (!keysize) {
+			PKEY_DBF_ERR("%s clear key token: unknown keytype %u\n",
+				     __func__, t->keytype);
+			goto out;
+		}
+		if (t->len != keysize) {
+			PKEY_DBF_ERR("%s clear key token: invalid key len %u\n",
+				     __func__, t->len);
+			goto out;
+		}
+		rc = pkey_pckmo_clr2protkey(t->keytype, t->clearkey,
+					    protkey, protkeylen, protkeytype);
+		break;
+	}
+	default:
+		PKEY_DBF_ERR("%s unknown non-CCA token version %d\n",
+			     __func__, hdr->version);
+		break;
+	}
+
+out:
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
+
+/*
+ * Generate a random protected key.
+ * Currently only the generation of AES protected keys
+ * is supported.
+ */
+int pkey_pckmo_gen_protkey(u32 keytype, u8 *protkey,
+			   u32 *protkeylen, u32 *protkeytype)
+{
+	u8 clrkey[32];
+	int keysize;
+	int rc;
+
+	keysize = pkey_keytype_aes_to_size(keytype);
+	if (!keysize) {
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %d\n", __func__,
+			     keytype);
+		return -EINVAL;
+	}
+
+	/* generate a dummy random clear key */
+	get_random_bytes(clrkey, keysize);
+
+	/* convert it to a dummy protected key */
+	rc = pkey_pckmo_clr2protkey(keytype, clrkey,
+				    protkey, protkeylen, protkeytype);
+	if (rc)
+		goto out;
+
+	/* replace the key part of the protected key with random bytes */
+	get_random_bytes(protkey, keysize);
+
+out:
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
+
+/*
+ * Create a protected key from a clear key value via PCKMO instruction.
+ */
+int pkey_pckmo_clr2protkey(u32 keytype, const u8 *clrkey,
+			   u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+{
+	/* mask of available pckmo subfunctions */
+	static cpacf_mask_t pckmo_functions;
+
+	int keysize, rc = -EINVAL;
+	u8 paramblock[112];
+	u32 pkeytype;
+	long fc;
+
+	switch (keytype) {
+	case PKEY_KEYTYPE_AES_128:
+		/* 16 byte key, 32 byte aes wkvp, total 48 bytes */
+		keysize = 16;
+		pkeytype = keytype;
+		fc = CPACF_PCKMO_ENC_AES_128_KEY;
+		break;
+	case PKEY_KEYTYPE_AES_192:
+		/* 24 byte key, 32 byte aes wkvp, total 56 bytes */
+		keysize = 24;
+		pkeytype = keytype;
+		fc = CPACF_PCKMO_ENC_AES_192_KEY;
+		break;
+	case PKEY_KEYTYPE_AES_256:
+		/* 32 byte key, 32 byte aes wkvp, total 64 bytes */
+		keysize = 32;
+		pkeytype = keytype;
+		fc = CPACF_PCKMO_ENC_AES_256_KEY;
+		break;
+	case PKEY_KEYTYPE_ECC_P256:
+		/* 32 byte key, 32 byte aes wkvp, total 64 bytes */
+		keysize = 32;
+		pkeytype = PKEY_KEYTYPE_ECC;
+		fc = CPACF_PCKMO_ENC_ECC_P256_KEY;
+		break;
+	case PKEY_KEYTYPE_ECC_P384:
+		/* 48 byte key, 32 byte aes wkvp, total 80 bytes */
+		keysize = 48;
+		pkeytype = PKEY_KEYTYPE_ECC;
+		fc = CPACF_PCKMO_ENC_ECC_P384_KEY;
+		break;
+	case PKEY_KEYTYPE_ECC_P521:
+		/* 80 byte key, 32 byte aes wkvp, total 112 bytes */
+		keysize = 80;
+		pkeytype = PKEY_KEYTYPE_ECC;
+		fc = CPACF_PCKMO_ENC_ECC_P521_KEY;
+		break;
+	case PKEY_KEYTYPE_ECC_ED25519:
+		/* 32 byte key, 32 byte aes wkvp, total 64 bytes */
+		keysize = 32;
+		pkeytype = PKEY_KEYTYPE_ECC;
+		fc = CPACF_PCKMO_ENC_ECC_ED25519_KEY;
+		break;
+	case PKEY_KEYTYPE_ECC_ED448:
+		/* 64 byte key, 32 byte aes wkvp, total 96 bytes */
+		keysize = 64;
+		pkeytype = PKEY_KEYTYPE_ECC;
+		fc = CPACF_PCKMO_ENC_ECC_ED448_KEY;
+		break;
+	default:
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %u\n",
+			     __func__, keytype);
+		goto out;
+	}
+
+	if (*protkeylen < keysize + AES_WK_VP_SIZE) {
+		PKEY_DBF_ERR("%s prot key buffer size too small: %u < %d\n",
+			     __func__, *protkeylen, keysize + AES_WK_VP_SIZE);
+		goto out;
+	}
+
+	/* Did we already check for PCKMO ? */
+	if (!pckmo_functions.bytes[0]) {
+		/* no, so check now */
+		if (!cpacf_query(CPACF_PCKMO, &pckmo_functions)) {
+			PKEY_DBF_ERR("%s cpacf_query() failed\n", __func__);
+			rc = -ENODEV;
+			goto out;
+		}
+	}
+	/* check for the pckmo subfunction we need now */
+	if (!cpacf_test_func(&pckmo_functions, fc)) {
+		PKEY_DBF_ERR("%s pckmo functions not available\n", __func__);
+		rc = -ENODEV;
+		goto out;
+	}
+
+	/* prepare param block */
+	memset(paramblock, 0, sizeof(paramblock));
+	memcpy(paramblock, clrkey, keysize);
+
+	/* call the pckmo instruction */
+	cpacf_pckmo(fc, paramblock);
+
+	/* copy created protected key to key buffer including the wkvp block */
+	*protkeylen = keysize + AES_WK_VP_SIZE;
+	memcpy(protkey, paramblock, *protkeylen);
+	*protkeytype = pkeytype;
+
+	rc = 0;
+
+out:
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
+
+/*
+ * Verify a protected key blob.
+ * Currently only AES protected keys are supported.
+ */
+int pkey_pckmo_verify_protkey(const u8 *protkey, u32 protkeylen,
+			      u32 protkeytype)
+{
+	struct {
+		u8 iv[AES_BLOCK_SIZE];
+		u8 key[MAXPROTKEYSIZE];
+	} param;
+	u8 null_msg[AES_BLOCK_SIZE];
+	u8 dest_buf[AES_BLOCK_SIZE];
+	unsigned int k, pkeylen;
+	unsigned long fc;
+	int rc = -EINVAL;
+
+	switch (protkeytype) {
+	case PKEY_KEYTYPE_AES_128:
+		pkeylen = 16 + AES_WK_VP_SIZE;
+		fc = CPACF_KMC_PAES_128;
+		break;
+	case PKEY_KEYTYPE_AES_192:
+		pkeylen = 24 + AES_WK_VP_SIZE;
+		fc = CPACF_KMC_PAES_192;
+		break;
+	case PKEY_KEYTYPE_AES_256:
+		pkeylen = 32 + AES_WK_VP_SIZE;
+		fc = CPACF_KMC_PAES_256;
+		break;
+	default:
+		PKEY_DBF_ERR("%s unknown/unsupported keytype %u\n", __func__,
+			     protkeytype);
+		goto out;
+	}
+	if (protkeylen != pkeylen) {
+		PKEY_DBF_ERR("%s invalid protected key size %u for keytype %u\n",
+			     __func__, protkeylen, protkeytype);
+		goto out;
+	}
+
+	memset(null_msg, 0, sizeof(null_msg));
+
+	memset(param.iv, 0, sizeof(param.iv));
+	memcpy(param.key, protkey, protkeylen);
+
+	k = cpacf_kmc(fc | CPACF_ENCRYPT, &param, null_msg, dest_buf,
+		      sizeof(null_msg));
+	if (k != sizeof(null_msg)) {
+		PKEY_DBF_ERR("%s protected key is not valid\n", __func__);
+		rc = -EKEYREJECTED;
+		goto out;
+	}
+
+	rc = 0;
+
+out:
+	pr_debug("rc=%d\n", rc);
+	return rc;
+}
diff --git a/drivers/s390/crypto/pkey_sysfs.c b/drivers/s390/crypto/pkey_sysfs.c
new file mode 100644
index 000000000000..727293fbf331
--- /dev/null
+++ b/drivers/s390/crypto/pkey_sysfs.c
@@ -0,0 +1,506 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  pkey module sysfs related functions
+ *
+ *  Copyright IBM Corp. 2024
+ */
+
+#define KMSG_COMPONENT "pkey"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
+#include <asm/pkey.h>
+#include <linux/sysfs.h>
+
+#include "zcrypt_api.h"
+#include "zcrypt_ccamisc.h"
+#include "zcrypt_ep11misc.h"
+
+#include "pkey_base.h"
+
+/*
+ * Sysfs attribute read function for all protected key binary attributes.
+ * The implementation can not deal with partial reads, because a new random
+ * protected key blob is generated with each read. In case of partial reads
+ * (i.e. off != 0 or count < key blob size) -EINVAL is returned.
+ */
+static ssize_t pkey_protkey_aes_attr_read(u32 keytype, bool is_xts, char *buf,
+					  loff_t off, size_t count)
+{
+	struct protaeskeytoken protkeytoken;
+	struct pkey_protkey protkey;
+	int rc;
+
+	if (off != 0 || count < sizeof(protkeytoken))
+		return -EINVAL;
+	if (is_xts)
+		if (count < 2 * sizeof(protkeytoken))
+			return -EINVAL;
+
+	memset(&protkeytoken, 0, sizeof(protkeytoken));
+	protkeytoken.type = TOKTYPE_NON_CCA;
+	protkeytoken.version = TOKVER_PROTECTED_KEY;
+	protkeytoken.keytype = keytype;
+
+	protkey.len = sizeof(protkey.protkey);
+	rc = pkey_pckmo_gen_protkey(protkeytoken.keytype,
+				    protkey.protkey, &protkey.len,
+				    &protkey.type);
+	if (rc)
+		return rc;
+
+	protkeytoken.len = protkey.len;
+	memcpy(&protkeytoken.protkey, &protkey.protkey, protkey.len);
+
+	memcpy(buf, &protkeytoken, sizeof(protkeytoken));
+
+	if (is_xts) {
+		/* xts needs a second protected key, reuse protkey struct */
+		protkey.len = sizeof(protkey.protkey);
+		rc = pkey_pckmo_gen_protkey(protkeytoken.keytype,
+					    protkey.protkey, &protkey.len,
+					    &protkey.type);
+		if (rc)
+			return rc;
+
+		protkeytoken.len = protkey.len;
+		memcpy(&protkeytoken.protkey, &protkey.protkey, protkey.len);
+
+		memcpy(buf + sizeof(protkeytoken), &protkeytoken,
+		       sizeof(protkeytoken));
+
+		return 2 * sizeof(protkeytoken);
+	}
+
+	return sizeof(protkeytoken);
+}
+
+static ssize_t protkey_aes_128_read(struct file *filp,
+				    struct kobject *kobj,
+				    struct bin_attribute *attr,
+				    char *buf, loff_t off,
+				    size_t count)
+{
+	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_128, false, buf,
+					  off, count);
+}
+
+static ssize_t protkey_aes_192_read(struct file *filp,
+				    struct kobject *kobj,
+				    struct bin_attribute *attr,
+				    char *buf, loff_t off,
+				    size_t count)
+{
+	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_192, false, buf,
+					  off, count);
+}
+
+static ssize_t protkey_aes_256_read(struct file *filp,
+				    struct kobject *kobj,
+				    struct bin_attribute *attr,
+				    char *buf, loff_t off,
+				    size_t count)
+{
+	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_256, false, buf,
+					  off, count);
+}
+
+static ssize_t protkey_aes_128_xts_read(struct file *filp,
+					struct kobject *kobj,
+					struct bin_attribute *attr,
+					char *buf, loff_t off,
+					size_t count)
+{
+	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_128, true, buf,
+					  off, count);
+}
+
+static ssize_t protkey_aes_256_xts_read(struct file *filp,
+					struct kobject *kobj,
+					struct bin_attribute *attr,
+					char *buf, loff_t off,
+					size_t count)
+{
+	return pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_256, true, buf,
+					  off, count);
+}
+
+static BIN_ATTR_RO(protkey_aes_128, sizeof(struct protaeskeytoken));
+static BIN_ATTR_RO(protkey_aes_192, sizeof(struct protaeskeytoken));
+static BIN_ATTR_RO(protkey_aes_256, sizeof(struct protaeskeytoken));
+static BIN_ATTR_RO(protkey_aes_128_xts, 2 * sizeof(struct protaeskeytoken));
+static BIN_ATTR_RO(protkey_aes_256_xts, 2 * sizeof(struct protaeskeytoken));
+
+static struct bin_attribute *protkey_attrs[] = {
+	&bin_attr_protkey_aes_128,
+	&bin_attr_protkey_aes_192,
+	&bin_attr_protkey_aes_256,
+	&bin_attr_protkey_aes_128_xts,
+	&bin_attr_protkey_aes_256_xts,
+	NULL
+};
+
+static struct attribute_group protkey_attr_group = {
+	.name	   = "protkey",
+	.bin_attrs = protkey_attrs,
+};
+
+/*
+ * Sysfs attribute read function for all secure key ccadata binary attributes.
+ * The implementation can not deal with partial reads, because a new random
+ * protected key blob is generated with each read. In case of partial reads
+ * (i.e. off != 0 or count < key blob size) -EINVAL is returned.
+ */
+static ssize_t pkey_ccadata_aes_attr_read(u32 keytype, bool is_xts, char *buf,
+					  loff_t off, size_t count)
+{
+	struct pkey_seckey *seckey = (struct pkey_seckey *)buf;
+	int rc;
+
+	if (off != 0 || count < sizeof(struct secaeskeytoken))
+		return -EINVAL;
+	if (is_xts)
+		if (count < 2 * sizeof(struct secaeskeytoken))
+			return -EINVAL;
+
+	rc = cca_genseckey(-1, -1, keytype, seckey->seckey);
+	if (rc)
+		return rc;
+
+	if (is_xts) {
+		seckey++;
+		rc = cca_genseckey(-1, -1, keytype, seckey->seckey);
+		if (rc)
+			return rc;
+
+		return 2 * sizeof(struct secaeskeytoken);
+	}
+
+	return sizeof(struct secaeskeytoken);
+}
+
+static ssize_t ccadata_aes_128_read(struct file *filp,
+				    struct kobject *kobj,
+				    struct bin_attribute *attr,
+				    char *buf, loff_t off,
+				    size_t count)
+{
+	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_128, false, buf,
+					  off, count);
+}
+
+static ssize_t ccadata_aes_192_read(struct file *filp,
+				    struct kobject *kobj,
+				    struct bin_attribute *attr,
+				    char *buf, loff_t off,
+				    size_t count)
+{
+	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_192, false, buf,
+					  off, count);
+}
+
+static ssize_t ccadata_aes_256_read(struct file *filp,
+				    struct kobject *kobj,
+				    struct bin_attribute *attr,
+				    char *buf, loff_t off,
+				    size_t count)
+{
+	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_256, false, buf,
+					  off, count);
+}
+
+static ssize_t ccadata_aes_128_xts_read(struct file *filp,
+					struct kobject *kobj,
+					struct bin_attribute *attr,
+					char *buf, loff_t off,
+					size_t count)
+{
+	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_128, true, buf,
+					  off, count);
+}
+
+static ssize_t ccadata_aes_256_xts_read(struct file *filp,
+					struct kobject *kobj,
+					struct bin_attribute *attr,
+					char *buf, loff_t off,
+					size_t count)
+{
+	return pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_256, true, buf,
+					  off, count);
+}
+
+static BIN_ATTR_RO(ccadata_aes_128, sizeof(struct secaeskeytoken));
+static BIN_ATTR_RO(ccadata_aes_192, sizeof(struct secaeskeytoken));
+static BIN_ATTR_RO(ccadata_aes_256, sizeof(struct secaeskeytoken));
+static BIN_ATTR_RO(ccadata_aes_128_xts, 2 * sizeof(struct secaeskeytoken));
+static BIN_ATTR_RO(ccadata_aes_256_xts, 2 * sizeof(struct secaeskeytoken));
+
+static struct bin_attribute *ccadata_attrs[] = {
+	&bin_attr_ccadata_aes_128,
+	&bin_attr_ccadata_aes_192,
+	&bin_attr_ccadata_aes_256,
+	&bin_attr_ccadata_aes_128_xts,
+	&bin_attr_ccadata_aes_256_xts,
+	NULL
+};
+
+static struct attribute_group ccadata_attr_group = {
+	.name	   = "ccadata",
+	.bin_attrs = ccadata_attrs,
+};
+
+#define CCACIPHERTOKENSIZE	(sizeof(struct cipherkeytoken) + 80)
+
+/*
+ * Sysfs attribute read function for all secure key ccacipher binary attributes.
+ * The implementation can not deal with partial reads, because a new random
+ * secure key blob is generated with each read. In case of partial reads
+ * (i.e. off != 0 or count < key blob size) -EINVAL is returned.
+ */
+static ssize_t pkey_ccacipher_aes_attr_read(enum pkey_key_size keybits,
+					    bool is_xts, char *buf, loff_t off,
+					    size_t count)
+{
+	u32 keysize = CCACIPHERTOKENSIZE;
+	u32 nr_apqns, *apqns = NULL;
+	int i, rc, card, dom;
+
+	if (off != 0 || count < CCACIPHERTOKENSIZE)
+		return -EINVAL;
+	if (is_xts)
+		if (count < 2 * CCACIPHERTOKENSIZE)
+			return -EINVAL;
+
+	/* build a list of apqns able to generate an cipher key */
+	rc = cca_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,
+			   ZCRYPT_CEX6, 0, 0, 0, 0);
+	if (rc)
+		return rc;
+
+	memset(buf, 0, is_xts ? 2 * keysize : keysize);
+
+	/* simple try all apqns from the list */
+	for (i = 0, rc = -ENODEV; i < nr_apqns; i++) {
+		card = apqns[i] >> 16;
+		dom = apqns[i] & 0xFFFF;
+		rc = cca_gencipherkey(card, dom, keybits, 0, buf, &keysize);
+		if (rc == 0)
+			break;
+	}
+	if (rc)
+		return rc;
+
+	if (is_xts) {
+		keysize = CCACIPHERTOKENSIZE;
+		buf += CCACIPHERTOKENSIZE;
+		rc = cca_gencipherkey(card, dom, keybits, 0, buf, &keysize);
+		if (rc == 0)
+			return 2 * CCACIPHERTOKENSIZE;
+	}
+
+	return CCACIPHERTOKENSIZE;
+}
+
+static ssize_t ccacipher_aes_128_read(struct file *filp,
+				      struct kobject *kobj,
+				      struct bin_attribute *attr,
+				      char *buf, loff_t off,
+				      size_t count)
+{
+	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_128, false, buf,
+					    off, count);
+}
+
+static ssize_t ccacipher_aes_192_read(struct file *filp,
+				      struct kobject *kobj,
+				      struct bin_attribute *attr,
+				      char *buf, loff_t off,
+				      size_t count)
+{
+	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_192, false, buf,
+					    off, count);
+}
+
+static ssize_t ccacipher_aes_256_read(struct file *filp,
+				      struct kobject *kobj,
+				      struct bin_attribute *attr,
+				      char *buf, loff_t off,
+				      size_t count)
+{
+	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_256, false, buf,
+					    off, count);
+}
+
+static ssize_t ccacipher_aes_128_xts_read(struct file *filp,
+					  struct kobject *kobj,
+					  struct bin_attribute *attr,
+					  char *buf, loff_t off,
+					  size_t count)
+{
+	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_128, true, buf,
+					    off, count);
+}
+
+static ssize_t ccacipher_aes_256_xts_read(struct file *filp,
+					  struct kobject *kobj,
+					  struct bin_attribute *attr,
+					  char *buf, loff_t off,
+					  size_t count)
+{
+	return pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_256, true, buf,
+					    off, count);
+}
+
+static BIN_ATTR_RO(ccacipher_aes_128, CCACIPHERTOKENSIZE);
+static BIN_ATTR_RO(ccacipher_aes_192, CCACIPHERTOKENSIZE);
+static BIN_ATTR_RO(ccacipher_aes_256, CCACIPHERTOKENSIZE);
+static BIN_ATTR_RO(ccacipher_aes_128_xts, 2 * CCACIPHERTOKENSIZE);
+static BIN_ATTR_RO(ccacipher_aes_256_xts, 2 * CCACIPHERTOKENSIZE);
+
+static struct bin_attribute *ccacipher_attrs[] = {
+	&bin_attr_ccacipher_aes_128,
+	&bin_attr_ccacipher_aes_192,
+	&bin_attr_ccacipher_aes_256,
+	&bin_attr_ccacipher_aes_128_xts,
+	&bin_attr_ccacipher_aes_256_xts,
+	NULL
+};
+
+static struct attribute_group ccacipher_attr_group = {
+	.name	   = "ccacipher",
+	.bin_attrs = ccacipher_attrs,
+};
+
+/*
+ * Sysfs attribute read function for all ep11 aes key binary attributes.
+ * The implementation can not deal with partial reads, because a new random
+ * secure key blob is generated with each read. In case of partial reads
+ * (i.e. off != 0 or count < key blob size) -EINVAL is returned.
+ * This function and the sysfs attributes using it provide EP11 key blobs
+ * padded to the upper limit of MAXEP11AESKEYBLOBSIZE which is currently
+ * 336 bytes.
+ */
+static ssize_t pkey_ep11_aes_attr_read(enum pkey_key_size keybits,
+				       bool is_xts, char *buf, loff_t off,
+				       size_t count)
+{
+	u32 keysize = MAXEP11AESKEYBLOBSIZE;
+	u32 nr_apqns, *apqns = NULL;
+	int i, rc, card, dom;
+
+	if (off != 0 || count < MAXEP11AESKEYBLOBSIZE)
+		return -EINVAL;
+	if (is_xts)
+		if (count < 2 * MAXEP11AESKEYBLOBSIZE)
+			return -EINVAL;
+
+	/* build a list of apqns able to generate an cipher key */
+	rc = ep11_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,
+			    ZCRYPT_CEX7,
+			    ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4,
+			    NULL);
+	if (rc)
+		return rc;
+
+	memset(buf, 0, is_xts ? 2 * keysize : keysize);
+
+	/* simple try all apqns from the list */
+	for (i = 0, rc = -ENODEV; i < nr_apqns; i++) {
+		card = apqns[i] >> 16;
+		dom = apqns[i] & 0xFFFF;
+		rc = ep11_genaeskey(card, dom, keybits, 0, buf, &keysize,
+				    PKEY_TYPE_EP11_AES);
+		if (rc == 0)
+			break;
+	}
+	if (rc)
+		return rc;
+
+	if (is_xts) {
+		keysize = MAXEP11AESKEYBLOBSIZE;
+		buf += MAXEP11AESKEYBLOBSIZE;
+		rc = ep11_genaeskey(card, dom, keybits, 0, buf, &keysize,
+				    PKEY_TYPE_EP11_AES);
+		if (rc == 0)
+			return 2 * MAXEP11AESKEYBLOBSIZE;
+	}
+
+	return MAXEP11AESKEYBLOBSIZE;
+}
+
+static ssize_t ep11_aes_128_read(struct file *filp,
+				 struct kobject *kobj,
+				 struct bin_attribute *attr,
+				 char *buf, loff_t off,
+				 size_t count)
+{
+	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_128, false, buf,
+				       off, count);
+}
+
+static ssize_t ep11_aes_192_read(struct file *filp,
+				 struct kobject *kobj,
+				 struct bin_attribute *attr,
+				 char *buf, loff_t off,
+				 size_t count)
+{
+	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_192, false, buf,
+				       off, count);
+}
+
+static ssize_t ep11_aes_256_read(struct file *filp,
+				 struct kobject *kobj,
+				 struct bin_attribute *attr,
+				 char *buf, loff_t off,
+				 size_t count)
+{
+	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_256, false, buf,
+				       off, count);
+}
+
+static ssize_t ep11_aes_128_xts_read(struct file *filp,
+				     struct kobject *kobj,
+				     struct bin_attribute *attr,
+				     char *buf, loff_t off,
+				     size_t count)
+{
+	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_128, true, buf,
+				       off, count);
+}
+
+static ssize_t ep11_aes_256_xts_read(struct file *filp,
+				     struct kobject *kobj,
+				     struct bin_attribute *attr,
+				     char *buf, loff_t off,
+				     size_t count)
+{
+	return pkey_ep11_aes_attr_read(PKEY_SIZE_AES_256, true, buf,
+				       off, count);
+}
+
+static BIN_ATTR_RO(ep11_aes_128, MAXEP11AESKEYBLOBSIZE);
+static BIN_ATTR_RO(ep11_aes_192, MAXEP11AESKEYBLOBSIZE);
+static BIN_ATTR_RO(ep11_aes_256, MAXEP11AESKEYBLOBSIZE);
+static BIN_ATTR_RO(ep11_aes_128_xts, 2 * MAXEP11AESKEYBLOBSIZE);
+static BIN_ATTR_RO(ep11_aes_256_xts, 2 * MAXEP11AESKEYBLOBSIZE);
+
+static struct bin_attribute *ep11_attrs[] = {
+	&bin_attr_ep11_aes_128,
+	&bin_attr_ep11_aes_192,
+	&bin_attr_ep11_aes_256,
+	&bin_attr_ep11_aes_128_xts,
+	&bin_attr_ep11_aes_256_xts,
+	NULL
+};
+
+static struct attribute_group ep11_attr_group = {
+	.name	   = "ep11",
+	.bin_attrs = ep11_attrs,
+};
+
+const struct attribute_group *pkey_attr_groups[] = {
+	&protkey_attr_group,
+	&ccadata_attr_group,
+	&ccacipher_attr_group,
+	&ep11_attr_group,
+	NULL,
+};
diff --git a/drivers/s390/crypto/zcrypt_ccamisc.c b/drivers/s390/crypto/zcrypt_ccamisc.c
index 7bef2cc4e461..43a27cb3db84 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.c
+++ b/drivers/s390/crypto/zcrypt_ccamisc.c
@@ -172,7 +172,7 @@ EXPORT_SYMBOL(cca_check_secaescipherkey);
  * key token. Returns 0 on success or errno value on failure.
  */
 int cca_check_sececckeytoken(debug_info_t *dbg, int dbflvl,
-			     const u8 *token, size_t keysize,
+			     const u8 *token, u32 keysize,
 			     int checkcpacfexport)
 {
 	struct eccprivkeytoken *t = (struct eccprivkeytoken *)token;
@@ -187,7 +187,7 @@ int cca_check_sececckeytoken(debug_info_t *dbg, int dbflvl,
 	}
 	if (t->len > keysize) {
 		if (dbg)
-			DBF("%s token check failed, len %d > keysize %zu\n",
+			DBF("%s token check failed, len %d > keysize %u\n",
 			    __func__, (int)t->len, keysize);
 		return -EINVAL;
 	}
@@ -737,7 +737,7 @@ static const u8 aes_cipher_key_skeleton[] = {
  * Generate (random) CCA AES CIPHER secure key.
  */
 int cca_gencipherkey(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,
-		     u8 *keybuf, size_t *keybufsize)
+		     u8 *keybuf, u32 *keybufsize)
 {
 	int rc;
 	u8 *mem, *ptr;
@@ -1085,7 +1085,7 @@ static int _ip_cprb_helper(u16 cardnr, u16 domain,
  * Build CCA AES CIPHER secure key with a given clear key value.
  */
 int cca_clr2cipherkey(u16 card, u16 dom, u32 keybitsize, u32 keygenflags,
-		      const u8 *clrkey, u8 *keybuf, size_t *keybufsize)
+		      const u8 *clrkey, u8 *keybuf, u32 *keybufsize)
 {
 	int rc;
 	u8 *token;
diff --git a/drivers/s390/crypto/zcrypt_ccamisc.h b/drivers/s390/crypto/zcrypt_ccamisc.h
index 5ddf02f965f9..aed7e8384542 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.h
+++ b/drivers/s390/crypto/zcrypt_ccamisc.h
@@ -153,7 +153,7 @@ int cca_check_secaescipherkey(debug_info_t *dbg, int dbflvl,
  * key token. Returns 0 on success or errno value on failure.
  */
 int cca_check_sececckeytoken(debug_info_t *dbg, int dbflvl,
-			     const u8 *token, size_t keysize,
+			     const u8 *token, u32 keysize,
 			     int checkcpacfexport);
 
 /*
@@ -178,7 +178,7 @@ int cca_sec2protkey(u16 cardnr, u16 domain,
  * Generate (random) CCA AES CIPHER secure key.
  */
 int cca_gencipherkey(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,
-		     u8 *keybuf, size_t *keybufsize);
+		     u8 *keybuf, u32 *keybufsize);
 
 /*
  * Derive proteced key from CCA AES cipher secure key.
@@ -190,7 +190,7 @@ int cca_cipher2protkey(u16 cardnr, u16 domain, const u8 *ckey,
  * Build CCA AES CIPHER secure key with a given clear key value.
  */
 int cca_clr2cipherkey(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,
-		      const u8 *clrkey, u8 *keybuf, size_t *keybufsize);
+		      const u8 *clrkey, u8 *keybuf, u32 *keybufsize);
 
 /*
  * Derive proteced key from CCA ECC secure private key.
diff --git a/drivers/s390/crypto/zcrypt_ep11misc.c b/drivers/s390/crypto/zcrypt_ep11misc.c
index b43db17a4e0e..cb7e6da43602 100644
--- a/drivers/s390/crypto/zcrypt_ep11misc.c
+++ b/drivers/s390/crypto/zcrypt_ep11misc.c
@@ -203,7 +203,7 @@ static int ep11_kb_decode(const u8 *kb, size_t kblen,
  * For valid ep11 keyblobs, returns a reference to the wrappingkey verification
  * pattern. Otherwise NULL.
  */
-const u8 *ep11_kb_wkvp(const u8 *keyblob, size_t keybloblen)
+const u8 *ep11_kb_wkvp(const u8 *keyblob, u32 keybloblen)
 {
 	struct ep11keyblob *kb;
 
@@ -217,7 +217,7 @@ EXPORT_SYMBOL(ep11_kb_wkvp);
  * Simple check if the key blob is a valid EP11 AES key blob with header.
  */
 int ep11_check_aes_key_with_hdr(debug_info_t *dbg, int dbflvl,
-				const u8 *key, size_t keylen, int checkcpacfexp)
+				const u8 *key, u32 keylen, int checkcpacfexp)
 {
 	struct ep11kblob_header *hdr = (struct ep11kblob_header *)key;
 	struct ep11keyblob *kb = (struct ep11keyblob *)(key + sizeof(*hdr));
@@ -225,7 +225,7 @@ int ep11_check_aes_key_with_hdr(debug_info_t *dbg, int dbflvl,
 #define DBF(...) debug_sprintf_event(dbg, dbflvl, ##__VA_ARGS__)
 
 	if (keylen < sizeof(*hdr) + sizeof(*kb)) {
-		DBF("%s key check failed, keylen %zu < %zu\n",
+		DBF("%s key check failed, keylen %u < %zu\n",
 		    __func__, keylen, sizeof(*hdr) + sizeof(*kb));
 		return -EINVAL;
 	}
@@ -250,7 +250,7 @@ int ep11_check_aes_key_with_hdr(debug_info_t *dbg, int dbflvl,
 	}
 	if (hdr->len > keylen) {
 		if (dbg)
-			DBF("%s key check failed, header len %d keylen %zu mismatch\n",
+			DBF("%s key check failed, header len %d keylen %u mismatch\n",
 			    __func__, (int)hdr->len, keylen);
 		return -EINVAL;
 	}
@@ -284,7 +284,7 @@ EXPORT_SYMBOL(ep11_check_aes_key_with_hdr);
  * Simple check if the key blob is a valid EP11 ECC key blob with header.
  */
 int ep11_check_ecc_key_with_hdr(debug_info_t *dbg, int dbflvl,
-				const u8 *key, size_t keylen, int checkcpacfexp)
+				const u8 *key, u32 keylen, int checkcpacfexp)
 {
 	struct ep11kblob_header *hdr = (struct ep11kblob_header *)key;
 	struct ep11keyblob *kb = (struct ep11keyblob *)(key + sizeof(*hdr));
@@ -292,7 +292,7 @@ int ep11_check_ecc_key_with_hdr(debug_info_t *dbg, int dbflvl,
 #define DBF(...) debug_sprintf_event(dbg, dbflvl, ##__VA_ARGS__)
 
 	if (keylen < sizeof(*hdr) + sizeof(*kb)) {
-		DBF("%s key check failed, keylen %zu < %zu\n",
+		DBF("%s key check failed, keylen %u < %zu\n",
 		    __func__, keylen, sizeof(*hdr) + sizeof(*kb));
 		return -EINVAL;
 	}
@@ -317,7 +317,7 @@ int ep11_check_ecc_key_with_hdr(debug_info_t *dbg, int dbflvl,
 	}
 	if (hdr->len > keylen) {
 		if (dbg)
-			DBF("%s key check failed, header len %d keylen %zu mismatch\n",
+			DBF("%s key check failed, header len %d keylen %u mismatch\n",
 			    __func__, (int)hdr->len, keylen);
 		return -EINVAL;
 	}
@@ -352,14 +352,14 @@ EXPORT_SYMBOL(ep11_check_ecc_key_with_hdr);
  * the header in the session field (old style EP11 AES key).
  */
 int ep11_check_aes_key(debug_info_t *dbg, int dbflvl,
-		       const u8 *key, size_t keylen, int checkcpacfexp)
+		       const u8 *key, u32 keylen, int checkcpacfexp)
 {
 	struct ep11keyblob *kb = (struct ep11keyblob *)key;
 
 #define DBF(...) debug_sprintf_event(dbg, dbflvl, ##__VA_ARGS__)
 
 	if (keylen < sizeof(*kb)) {
-		DBF("%s key check failed, keylen %zu < %zu\n",
+		DBF("%s key check failed, keylen %u < %zu\n",
 		    __func__, keylen, sizeof(*kb));
 		return -EINVAL;
 	}
@@ -378,7 +378,7 @@ int ep11_check_aes_key(debug_info_t *dbg, int dbflvl,
 	}
 	if (kb->head.len > keylen) {
 		if (dbg)
-			DBF("%s key check failed, header len %d keylen %zu mismatch\n",
+			DBF("%s key check failed, header len %d keylen %u mismatch\n",
 			    __func__, (int)kb->head.len, keylen);
 		return -EINVAL;
 	}
@@ -932,7 +932,7 @@ static int _ep11_genaeskey(u16 card, u16 domain,
 }
 
 int ep11_genaeskey(u16 card, u16 domain, u32 keybitsize, u32 keygenflags,
-		   u8 *keybuf, size_t *keybufsize, u32 keybufver)
+		   u8 *keybuf, u32 *keybufsize, u32 keybufver)
 {
 	struct ep11kblob_header *hdr;
 	size_t hdr_size, pl_size;
@@ -1256,7 +1256,7 @@ static int ep11_unwrapkey(u16 card, u16 domain,
 			  const u8 *enckey, size_t enckeysize,
 			  u32 mech, const u8 *iv,
 			  u32 keybitsize, u32 keygenflags,
-			  u8 *keybuf, size_t *keybufsize,
+			  u8 *keybuf, u32 *keybufsize,
 			  u8 keybufver)
 {
 	struct ep11kblob_header *hdr;
@@ -1412,7 +1412,7 @@ static int _ep11_wrapkey(u16 card, u16 domain,
 }
 
 int ep11_clr2keyblob(u16 card, u16 domain, u32 keybitsize, u32 keygenflags,
-		     const u8 *clrkey, u8 *keybuf, size_t *keybufsize,
+		     const u8 *clrkey, u8 *keybuf, u32 *keybufsize,
 		     u32 keytype)
 {
 	int rc;
@@ -1471,7 +1471,7 @@ int ep11_clr2keyblob(u16 card, u16 domain, u32 keybitsize, u32 keygenflags,
 EXPORT_SYMBOL(ep11_clr2keyblob);
 
 int ep11_kblob2protkey(u16 card, u16 dom,
-		       const u8 *keyblob, size_t keybloblen,
+		       const u8 *keyblob, u32 keybloblen,
 		       u8 *protkey, u32 *protkeylen, u32 *protkeytype)
 {
 	struct ep11kblob_header *hdr;
diff --git a/drivers/s390/crypto/zcrypt_ep11misc.h b/drivers/s390/crypto/zcrypt_ep11misc.h
index 9d17fd5228a7..9f1bdffdec68 100644
--- a/drivers/s390/crypto/zcrypt_ep11misc.h
+++ b/drivers/s390/crypto/zcrypt_ep11misc.h
@@ -54,7 +54,7 @@ static inline bool is_ep11_keyblob(const u8 *key)
  * For valid ep11 keyblobs, returns a reference to the wrappingkey verification
  * pattern. Otherwise NULL.
  */
-const u8 *ep11_kb_wkvp(const u8 *kblob, size_t kbloblen);
+const u8 *ep11_kb_wkvp(const u8 *kblob, u32 kbloblen);
 
 /*
  * Simple check if the key blob is a valid EP11 AES key blob with header.
@@ -63,7 +63,7 @@ const u8 *ep11_kb_wkvp(const u8 *kblob, size_t kbloblen);
  * Returns 0 on success or errno value on failure.
  */
 int ep11_check_aes_key_with_hdr(debug_info_t *dbg, int dbflvl,
-				const u8 *key, size_t keylen, int checkcpacfexp);
+				const u8 *key, u32 keylen, int checkcpacfexp);
 
 /*
  * Simple check if the key blob is a valid EP11 ECC key blob with header.
@@ -72,7 +72,7 @@ int ep11_check_aes_key_with_hdr(debug_info_t *dbg, int dbflvl,
  * Returns 0 on success or errno value on failure.
  */
 int ep11_check_ecc_key_with_hdr(debug_info_t *dbg, int dbflvl,
-				const u8 *key, size_t keylen, int checkcpacfexp);
+				const u8 *key, u32 keylen, int checkcpacfexp);
 
 /*
  * Simple check if the key blob is a valid EP11 AES key blob with
@@ -82,7 +82,7 @@ int ep11_check_ecc_key_with_hdr(debug_info_t *dbg, int dbflvl,
  * Returns 0 on success or errno value on failure.
  */
 int ep11_check_aes_key(debug_info_t *dbg, int dbflvl,
-		       const u8 *key, size_t keylen, int checkcpacfexp);
+		       const u8 *key, u32 keylen, int checkcpacfexp);
 
 /* EP11 card info struct */
 struct ep11_card_info {
@@ -115,13 +115,13 @@ int ep11_get_domain_info(u16 card, u16 domain, struct ep11_domain_info *info);
  * Generate (random) EP11 AES secure key.
  */
 int ep11_genaeskey(u16 card, u16 domain, u32 keybitsize, u32 keygenflags,
-		   u8 *keybuf, size_t *keybufsize, u32 keybufver);
+		   u8 *keybuf, u32 *keybufsize, u32 keybufver);
 
 /*
  * Generate EP11 AES secure key with given clear key value.
  */
 int ep11_clr2keyblob(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,
-		     const u8 *clrkey, u8 *keybuf, size_t *keybufsize,
+		     const u8 *clrkey, u8 *keybuf, u32 *keybufsize,
 		     u32 keytype);
 
 /*
@@ -149,7 +149,7 @@ int ep11_findcard2(u32 **apqns, u32 *nr_apqns, u16 cardnr, u16 domain,
 /*
  * Derive proteced key from EP11 key blob (AES and ECC keys).
  */
-int ep11_kblob2protkey(u16 card, u16 dom, const u8 *key, size_t keylen,
+int ep11_kblob2protkey(u16 card, u16 dom, const u8 *key, u32 keylen,
 		       u8 *protkey, u32 *protkeylen, u32 *protkeytype);
 
 void zcrypt_ep11misc_exit(void);

