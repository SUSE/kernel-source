From 439217c4eed97eb8f1e6077357d31f32dcd8d3d4 Mon Sep 17 00:00:00 2001
From: Nicolai Stange <nstange@suse.de>
Date: Mon, 10 Mar 2025 13:21:48 +0100
References: jsc#PED-12225
Patch-mainline: Submitted, netdev ML 2025-03-10
Subject: [PATCH v1 3/4] ipv6: sr: factor seg6_hmac_init_algo()'s per-algo code
 into separate function

In order to prepare for ignoring certain instantiation failures and
continue with the remaining supported algorithms, factor the per-algo
initialization code into a separate function:
- rename seg6_hmac_init_algo() to seg6_hmac_init_algos() and
- move its per-algo initialization code into a new function,
  seg6_hmac_init_algo().

This is a refactoring only, there is no change in behaviour.

Signed-off-by: Nicolai Stange <nstange@suse.de>
---
 net/ipv6/seg6_hmac.c |   78 ++++++++++++++++++++++++++++-----------------------
 1 file changed, 44 insertions(+), 34 deletions(-)

--- a/net/ipv6/seg6_hmac.c
+++ b/net/ipv6/seg6_hmac.c
@@ -380,51 +380,61 @@ static void seg6_hmac_free_algo(struct s
 	}
 }
 
-static int seg6_hmac_init_algo(void)
+static int seg6_hmac_init_algo(struct seg6_hmac_algo *algo)
 {
-	struct seg6_hmac_algo *algo;
-	struct crypto_shash *tfm;
+	struct crypto_shash *tfm, **p_tfm;
 	struct shash_desc *shash;
-	int i, alg_count, cpu;
+	int cpu, shsize;
 	int ret = -ENOMEM;
 
-	alg_count = ARRAY_SIZE(hmac_algos);
+	algo->tfms = alloc_percpu(struct crypto_shash *);
+	if (!algo->tfms)
+		goto error_out;
+
+	for_each_possible_cpu(cpu) {
+		tfm = crypto_alloc_shash(algo->name, 0, 0);
+		if (IS_ERR(tfm)) {
+			ret = PTR_ERR(tfm);
+			goto error_out;
+		}
+		p_tfm = per_cpu_ptr(algo->tfms, cpu);
+		*p_tfm = tfm;
+	}
 
-	for (i = 0; i < alg_count; i++) {
-		struct crypto_shash **p_tfm;
-		int shsize;
+	p_tfm = raw_cpu_ptr(algo->tfms);
+	tfm = *p_tfm;
 
-		algo = &hmac_algos[i];
-		algo->tfms = alloc_percpu(struct crypto_shash *);
-		if (!algo->tfms)
+	shsize = sizeof(*shash) + crypto_shash_descsize(tfm);
+
+	algo->shashs = alloc_percpu(struct shash_desc *);
+	if (!algo->shashs)
+		goto error_out;
+
+	for_each_possible_cpu(cpu) {
+		shash = kzalloc_node(shsize, GFP_KERNEL,
+				     cpu_to_node(cpu));
+		if (!shash)
 			goto error_out;
+		*per_cpu_ptr(algo->shashs, cpu) = shash;
+	}
 
-		for_each_possible_cpu(cpu) {
-			tfm = crypto_alloc_shash(algo->name, 0, 0);
-			if (IS_ERR(tfm)) {
-				ret = PTR_ERR(tfm);
-				goto error_out;
-			}
-			p_tfm = per_cpu_ptr(algo->tfms, cpu);
-			*p_tfm = tfm;
-		}
+	return 0;
 
-		p_tfm = raw_cpu_ptr(algo->tfms);
-		tfm = *p_tfm;
+error_out:
+	seg6_hmac_free_algo(algo);
+	return ret;
+}
 
-		shsize = sizeof(*shash) + crypto_shash_descsize(tfm);
+static int seg6_hmac_init_algos(void)
+{
+	int i, alg_count;
+	int ret;
 
-		algo->shashs = alloc_percpu(struct shash_desc *);
-		if (!algo->shashs)
+	alg_count = ARRAY_SIZE(hmac_algos);
+	for (i = 0; i < alg_count; i++) {
+		ret = seg6_hmac_init_algo(&hmac_algos[i]);
+		if (ret)
 			goto error_out;
-
-		for_each_possible_cpu(cpu) {
-			shash = kzalloc_node(shsize, GFP_KERNEL,
-					     cpu_to_node(cpu));
-			if (!shash)
-				goto error_out;
-			*per_cpu_ptr(algo->shashs, cpu) = shash;
-		}
 	}
 
 	return 0;
@@ -436,7 +446,7 @@ error_out:
 
 int __init seg6_hmac_init(void)
 {
-	return seg6_hmac_init_algo();
+	return seg6_hmac_init_algos();
 }
 
 int __net_init seg6_hmac_net_init(struct net *net)
