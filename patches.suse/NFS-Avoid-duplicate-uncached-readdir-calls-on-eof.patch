From: Trond Myklebust <trond.myklebust@hammerspace.com>
Date: Tue, 18 Jan 2022 22:10:52 -0500
Subject: [PATCH] NFS: Avoid duplicate uncached readdir calls on eof
Git-commit: e1d2699b96793d19388e302fa095e0da2c145701
Patch-mainline: v5.17
References: git-fixes

If we've reached the end of the directory, then cache that information
in the context so that we don't need to do an uncached readdir in order
to rediscover that fact.

Fixes: 794092c57f89 ("NFS: Do uncached readdir when we're seeking a cookie in an empty page cache")
Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
Acked-by: NeilBrown <neilb@suse.com>

---
 fs/nfs/dir.c           |   19 ++++++++++++++-----
 include/linux/nfs_fs.h |    1 +
 2 files changed, 15 insertions(+), 5 deletions(-)

--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -79,6 +79,7 @@ static struct nfs_open_dir_context *allo
 		ctx->dir_cookie = 0;
 		ctx->dup_cookie = 0;
 		ctx->page_index = 0;
+		ctx->eof = false;
 		spin_lock(&dir->i_lock);
 		if (list_empty(&nfsi->open_files) &&
 		    (nfsi->cache_validity & NFS_INO_DATA_INVAL_DEFER))
@@ -163,6 +164,7 @@ typedef struct nfs_readdir_descriptor {
 	unsigned int	cache_entry_index;
 	signed char duped;
 	bool plus;
+	bool eob;
 	bool eof;
 } nfs_readdir_descriptor_t;
 
@@ -946,7 +948,7 @@ int nfs_do_filldir(nfs_readdir_descripto
 		ent = &array->array[i];
 		if (!dir_emit(desc->ctx, ent->string.name, ent->string.len,
 		    nfs_compat_user_ino64(ent->ino), ent->d_type)) {
-			desc->eof = true;
+			desc->eob = true;
 			break;
 		}
 		if (i < (array->size-1))
@@ -961,7 +963,7 @@ int nfs_do_filldir(nfs_readdir_descripto
 			desc->duped = 1;
 	}
 	if (array->page_is_eof)
-		desc->eof = true;
+		desc->eof = !desc->eob;
 
 	kunmap(desc->page);
 	dfprintk(DIRCACHE, "NFS: nfs_do_filldir() filling ended @ cookie %Lu; returning = %d\n",
@@ -1006,7 +1008,7 @@ int uncached_readdir(nfs_readdir_descrip
 
 	status = nfs_readdir_xdr_to_array(desc, arrays, sz, inode);
 
-	for (i = 0; !desc->eof && i < sz && arrays[i]; i++) {
+	for (i = 0; !desc->eob && i < sz && arrays[i]; i++) {
 		desc->page = arrays[i];
 		status = nfs_do_filldir(desc);
 	}
@@ -1065,8 +1067,14 @@ static int nfs_readdir(struct file *file
 	desc->duped = dir_ctx->duped;
 	page_index = dir_ctx->page_index;
 	desc->attr_gencount = dir_ctx->attr_gencount;
+	desc->eof = dir_ctx->eof;
 	spin_unlock(&file->f_lock);
 
+	if (desc->eof) {
+		res = 0;
+		goto out_free;
+	}
+
 	if (test_and_clear_bit(NFS_INO_FORCE_READDIR, &nfsi->flags) &&
 	    list_is_singular(&nfsi->open_files))
 		invalidate_mapping_pages(inode->i_mapping, page_index + 1, -1);
@@ -1100,7 +1108,7 @@ static int nfs_readdir(struct file *file
 		nfs_readdir_page_unlock_and_put_cached(desc);
 		if (res < 0)
 			break;
-	} while (!desc->eof);
+	} while (!desc->eob && !desc->eof);
 
 	spin_lock(&file->f_lock);
 	dir_ctx->dir_cookie = desc->dir_cookie;
@@ -1110,7 +1118,7 @@ static int nfs_readdir(struct file *file
 	dir_ctx->eof = desc->eof;
 	dir_ctx->page_index = desc->page_index;
 	spin_unlock(&file->f_lock);
-
+out_free:
 	kfree(desc);
 
 out:
@@ -1153,6 +1161,7 @@ static loff_t nfs_llseek_dir(struct file
 		else
 			dir_ctx->dir_cookie = 0;
 		dir_ctx->duped = 0;
+		dir_ctx->eof = false;
 	}
 	inode_unlock(inode);
 	return offset;
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -96,6 +96,7 @@ struct nfs_open_dir_context {
 	__u64 dup_cookie;
 	pgoff_t page_index;
 	signed char duped;
+	bool eof;
 };
 
 /*
