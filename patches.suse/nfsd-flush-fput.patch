From: NeilBrown <neilb@suse.com>
Subject: Call flush_delayed_fput() from nfsd main-loop
References: bsc#1217408
Patch-mainline: Never, more general solution is being pursured.

If final __fput() is slow for files closed by nfsd, the
delayed_fput_list can grow without bound with files being added faster
than they can be removed.  Instead the slowness should be reflected in
nfsd throughput so that it can be seen for what it is and not exhaust
memory.

So call flush_delayed_fput() from the nfsd main loop.  This ensure nfsd
cannot add more files to the list without first removing any that are
there, so the list cannot grow without bound.

Signed-off-by: NeilBrown <neilb@suse.de>

---
 fs/file_table.c  |    1 +
 fs/nfsd/nfssvc.c |    1 +
 2 files changed, 2 insertions(+)

--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -328,6 +328,7 @@ void flush_delayed_fput(void)
 {
 	delayed_fput(NULL);
 }
+EXPORT_SYMBOL_GPL(flush_delayed_fput);
 
 static DECLARE_DELAYED_WORK(delayed_fput_work, delayed_fput);
 
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -895,6 +895,7 @@ nfsd(void *vrqstp)
 		validate_process_creds();
 		svc_process(rqstp);
 		validate_process_creds();
+		flush_delayed_fput();
 	}
 
 	/* Clear signals before calling svc_exit_thread() */
