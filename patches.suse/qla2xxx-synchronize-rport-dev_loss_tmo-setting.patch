From: Hannes Reinecke <hare@suse.de>
Date: Wed, 9 Jun 2021 11:49:56 +0200
Subject: qla2xxx: synchronize rport dev_loss_tmo setting
Patch-mainline: Queued in subsystem maintainer repository
Git-commit: baea0e833f7612483dcb2351240da19f0d0bc011
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi.git
References: bsc#1182470 bsc#1185486 bsc#1189158

Currently, the dev_loss_tmo setting is only ever used for SCSI
devices. This patch reshuffles initialisation such that the SCSI
remote ports are registered before the NVMe ones, allowing the
dev_loss_tmo setting to be synchronized between SCSI and NVMe.

Signed-off-by: Hannes Reinecke <hare@suse.de>
Signed-off-by: Daniel Wagner <dwagner@suse.de>
[lkp: Do not depend on nvme_fc_set_remoteport_devloss() for !NVME_FC]
Reported-by: kernel test robot <lkp@intel.com>
---
 https://lore.kernel.org/linux-scsi/20211214111139.52503-1-dwagner@suse.de/

 drivers/scsi/qla2xxx/qla_attr.c |    6 ++++++
 drivers/scsi/qla2xxx/qla_init.c |   10 +++-------
 drivers/scsi/qla2xxx/qla_nvme.c |    5 ++++-
 3 files changed, 13 insertions(+), 8 deletions(-)

--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -2696,7 +2696,13 @@ qla2x00_get_starget_port_id(struct scsi_
 static inline void
 qla2x00_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)
 {
+	fc_port_t *fcport = *(fc_port_t **)rport->dd_data;
+
 	rport->dev_loss_tmo = timeout ? timeout : 1;
+
+	if (IS_ENABLED(CONFIG_NVME_FC) && fcport && fcport->nvme_remote_port)
+		nvme_fc_set_remoteport_devloss(fcport->nvme_remote_port,
+					       rport->dev_loss_tmo);
 }
 
 static void
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -5771,13 +5771,6 @@ qla2x00_update_fcport(scsi_qla_host_t *v
 
 	qla2x00_dfs_create_rport(vha, fcport);
 
-	if (NVME_TARGET(vha->hw, fcport)) {
-		qla_nvme_register_remote(vha, fcport);
-		qla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_COMPLETE);
-		qla2x00_set_fcport_state(fcport, FCS_ONLINE);
-		return;
-	}
-
 	qla24xx_update_fcport_fcp_prio(vha, fcport);
 
 	switch (vha->host->active_mode) {
@@ -5799,6 +5792,9 @@ qla2x00_update_fcport(scsi_qla_host_t *v
 		break;
 	}
 
+	if (NVME_TARGET(vha->hw, fcport))
+		qla_nvme_register_remote(vha, fcport);
+
 	qla2x00_set_fcport_state(fcport, FCS_ONLINE);
 
 	if (IS_IIDMA_CAPABLE(vha->hw) && vha->hw->flags.gpsc_supported) {
--- a/drivers/scsi/qla2xxx/qla_nvme.c
+++ b/drivers/scsi/qla2xxx/qla_nvme.c
@@ -42,7 +42,7 @@ int qla_nvme_register_remote(struct scsi
 	req.port_name = wwn_to_u64(fcport->port_name);
 	req.node_name = wwn_to_u64(fcport->node_name);
 	req.port_role = 0;
-	req.dev_loss_tmo = 0;
+	req.dev_loss_tmo = fcport->dev_loss_tmo;
 
 	if (fcport->nvme_prli_service_param & NVME_PRLI_SP_INITIATOR)
 		req.port_role = FC_PORT_ROLE_NVME_INITIATOR;
@@ -69,6 +69,9 @@ int qla_nvme_register_remote(struct scsi
 		return ret;
 	}
 
+	nvme_fc_set_remoteport_devloss(fcport->nvme_remote_port,
+				       fcport->dev_loss_tmo);
+
 	if (fcport->nvme_prli_service_param & NVME_PRLI_SP_SLER)
 		ql_log(ql_log_info, vha, 0x212a,
 		       "PortID:%06x Supports SLER\n", req.port_id);
