From 2761bb9a31f1b863037547d73dc6aac1461ceab6 Mon Sep 17 00:00:00 2001
From: Arunpravin Paneer Selvam <Arunpravin.PaneerSelvam@amd.com>
Date: Mon, 11 Nov 2024 12:43:07 +0530
Subject: drm/amdgpu: Modify userq signal/wait struct field names
Mime-version: 1.0
Content-type: text/plain; charset=UTF-8
Content-transfer-encoding: 8bit
Git-commit: 2761bb9a31f1b863037547d73dc6aac1461ceab6
Patch-mainline: v6.16-rc1
References: jsc#PED-13979 jsc#PED-14039 jsc#PED-14046 jsc#PED-14211 jsc#PED-14333 jsc#PED-14487 jsc#PED-14488 jsc#PED-14497 jsc#PED-14499 jsc#PED-15868

Modify kernel UAPI userq signal/wait struct field names and
description corresponding to the libdrm UAPI review comments.

libdrm MR: https://gitlab.freedesktop.org/mesa/drm/-/merge_requests/392

Signed-off-by: Arunpravin Paneer Selvam <Arunpravin.PaneerSelvam@amd.com>
Reviewed-by: Christian KÃ¶nig <christian.koenig@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>

---
 .../gpu/drm/amd/amdgpu/amdgpu_userq_fence.c   |  20 ++--
 include/uapi/drm/amdgpu_drm.h                 | 102 +++++++-----------
 2 files changed, 46 insertions(+), 76 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_userq_fence.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_userq_fence.c
index 85af0d520092..6157a540c929 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_userq_fence.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_userq_fence.c
@@ -400,7 +400,7 @@ int amdgpu_userq_signal_ioctl(struct drm_device *dev, void *data,
 	u64 wptr;
 
 	num_syncobj_handles = args->num_syncobj_handles;
-	syncobj_handles = memdup_user(u64_to_user_ptr(args->syncobj_handles_array),
+	syncobj_handles = memdup_user(u64_to_user_ptr(args->syncobj_handles),
 				      sizeof(u32) * num_syncobj_handles);
 	if (IS_ERR(syncobj_handles))
 		return PTR_ERR(syncobj_handles);
@@ -420,7 +420,7 @@ int amdgpu_userq_signal_ioctl(struct drm_device *dev, void *data,
 		}
 	}
 
-	num_read_bo_handles = args->num_read_bo_handles;
+	num_read_bo_handles = args->num_bo_read_handles;
 	bo_handles_read = memdup_user(u64_to_user_ptr(args->bo_read_handles),
 				      sizeof(u32) * num_read_bo_handles);
 	if (IS_ERR(bo_handles_read)) {
@@ -443,7 +443,7 @@ int amdgpu_userq_signal_ioctl(struct drm_device *dev, void *data,
 		}
 	}
 
-	num_write_bo_handles = args->num_write_bo_handles;
+	num_write_bo_handles = args->num_bo_write_handles;
 	bo_handles_write = memdup_user(u64_to_user_ptr(args->bo_write_handles),
 				       sizeof(u32) * num_write_bo_handles);
 	if (IS_ERR(bo_handles_write)) {
@@ -558,23 +558,23 @@ int amdgpu_userq_wait_ioctl(struct drm_device *dev, void *data,
 			    struct drm_file *filp)
 {
 	u32 *syncobj_handles, *timeline_points, *timeline_handles, *bo_handles_read, *bo_handles_write;
-	u32 num_syncobj, num_read_bo_handles, num_write_bo_handles, num_points;
+	u32 num_syncobj, num_read_bo_handles, num_write_bo_handles;
 	struct drm_amdgpu_userq_fence_info *fence_info = NULL;
 	struct drm_amdgpu_userq_wait *wait_info = data;
 	struct drm_gem_object **gobj_write;
 	struct drm_gem_object **gobj_read;
 	struct dma_fence **fences = NULL;
+	u16 num_points, num_fences = 0;
 	int r, i, rentry, wentry, cnt;
 	struct drm_exec exec;
-	u64 num_fences = 0;
 
-	num_read_bo_handles = wait_info->num_read_bo_handles;
+	num_read_bo_handles = wait_info->num_bo_read_handles;
 	bo_handles_read = memdup_user(u64_to_user_ptr(wait_info->bo_read_handles),
 				      sizeof(u32) * num_read_bo_handles);
 	if (IS_ERR(bo_handles_read))
 		return PTR_ERR(bo_handles_read);
 
-	num_write_bo_handles = wait_info->num_write_bo_handles;
+	num_write_bo_handles = wait_info->num_bo_write_handles;
 	bo_handles_write = memdup_user(u64_to_user_ptr(wait_info->bo_write_handles),
 				       sizeof(u32) * num_write_bo_handles);
 	if (IS_ERR(bo_handles_write)) {
@@ -583,14 +583,14 @@ int amdgpu_userq_wait_ioctl(struct drm_device *dev, void *data,
 	}
 
 	num_syncobj = wait_info->num_syncobj_handles;
-	syncobj_handles = memdup_user(u64_to_user_ptr(wait_info->syncobj_handles_array),
+	syncobj_handles = memdup_user(u64_to_user_ptr(wait_info->syncobj_handles),
 				      sizeof(u32) * num_syncobj);
 	if (IS_ERR(syncobj_handles)) {
 		r = PTR_ERR(syncobj_handles);
 		goto free_bo_handles_write;
 	}
 
-	num_points = wait_info->num_points;
+	num_points = wait_info->num_syncobj_timeline_handles;
 	timeline_handles = memdup_user(u64_to_user_ptr(wait_info->syncobj_timeline_handles),
 				       sizeof(u32) * num_points);
 	if (IS_ERR(timeline_handles)) {
@@ -858,7 +858,7 @@ int amdgpu_userq_wait_ioctl(struct drm_device *dev, void *data,
 
 		wait_info->num_fences = cnt;
 		/* Copy userq fence info to user space */
-		if (copy_to_user(u64_to_user_ptr(wait_info->userq_fence_info),
+		if (copy_to_user(u64_to_user_ptr(wait_info->out_fences),
 				 fence_info, wait_info->num_fences * sizeof(*fence_info))) {
 			r = -EFAULT;
 			goto free_fences;
diff --git a/include/uapi/drm/amdgpu_drm.h b/include/uapi/drm/amdgpu_drm.h
index 6158496cc1d0..72dc16dbca7f 100644
--- a/include/uapi/drm/amdgpu_drm.h
+++ b/include/uapi/drm/amdgpu_drm.h
@@ -453,27 +453,17 @@ struct drm_amdgpu_userq_signal {
 	 * to retrieve the WPTR.
 	 */
 	__u32	queue_id;
+	__u32	pad;
 	/**
-	 * @flags: flags to indicate special function for userq fence creation.
-	 * Unused for now.
-	 */
-	__u32	flags;
-	/**
-	 * @syncobj_handles_array: An array of syncobj handles used by the userq fence
-	 * creation IOCTL to install the created dma_fence object which can be
-	 * utilized by userspace to explicitly synchronize GPU commands.
+	 * @syncobj_handles: The list of syncobj handles submitted by the user queue
+	 * job to be signaled.
 	 */
-	__u64	syncobj_handles_array;
+	__u64	syncobj_handles;
 	/**
 	 * @num_syncobj_handles: A count that represents the number of syncobj handles in
-	 * @syncobj_handles_array.
+	 * @syncobj_handles.
 	 */
 	__u64	num_syncobj_handles;
-	/**
-	 * @syncobj_point: A given point on the timeline to be signaled.
-	 * Unused for now.
-	 */
-	__u64	syncobj_point;
 	/**
 	 * @bo_read_handles: The list of BO handles that the submitted user queue job
 	 * is using for read only. This will update BO fences in the kernel.
@@ -485,20 +475,15 @@ struct drm_amdgpu_userq_signal {
 	 */
 	__u64	bo_write_handles;
 	/**
-	 * @num_read_bo_handles: A count that represents the number of read BO handles in
+	 * @num_bo_read_handles: A count that represents the number of read BO handles in
 	 * @bo_read_handles.
 	 */
-	__u32	num_read_bo_handles;
+	__u32	num_bo_read_handles;
 	/**
-	 * @num_write_bo_handles: A count that represents the number of write BO handles in
+	 * @num_bo_write_handles: A count that represents the number of write BO handles in
 	 * @bo_write_handles.
 	 */
-	__u32	num_write_bo_handles;
-	/**
-	 * @bo_flags: flags to indicate BOs synchronize for READ or WRITE
-	 */
-	__u32	bo_flags;
-	__u32	pad;
+	__u32	num_bo_write_handles;
 };
 
 struct drm_amdgpu_userq_fence_info {
@@ -517,38 +502,18 @@ struct drm_amdgpu_userq_fence_info {
 
 struct drm_amdgpu_userq_wait {
 	/**
-	 * @waitq_id: Queue handle used to retrieve the queue information to store
-	 * the fence driver references in the wait user queue structure.
-	 */
-	__u32	waitq_id;
-	/**
-	 * @flags: flags to specify special function for userq wait information.
-	 * Unused for now.
-	 */
-	__u32	flags;
-	/**
-	 * @bo_wait_flags: flags to define the BOs for READ or WRITE to store the
-	 * matching fence wait info pair in @userq_fence_info.
-	 */
-	__u32	bo_wait_flags;
-	/**
-	 * @num_points: A count that represents the number of timeline syncobj handles in
-	 * syncobj_handles_array.
-	 */
-	__u32	num_points;
-	/**
-	 * @syncobj_handles_array: An array of syncobj handles defined to get the
-	 * fence wait information of every syncobj handles in the array.
+	 * @syncobj_handles: The list of syncobj handles submitted by the user queue
+	 * job to get the va/value pairs.
 	 */
-	__u64	syncobj_handles_array;
+	__u64	syncobj_handles;
 	/**
-	 * @syncobj_timeline_handles: An array of timeline syncobj handles defined to get the
-	 * fence wait information of every timeline syncobj handles in the array.
+	 * @syncobj_timeline_handles: The list of timeline syncobj handles submitted by
+	 * the user queue job to get the va/value pairs at given @syncobj_timeline_points.
 	 */
-	__u64   syncobj_timeline_handles;
+	__u64	syncobj_timeline_handles;
 	/**
-	 * @syncobj_timeline_points: An array of timeline syncobj points defined to get the
-	 * fence wait points of every timeline syncobj handles in the syncobj_handles_array.
+	 * @syncobj_timeline_points: The list of timeline syncobj points submitted by the
+	 * user queue job for the corresponding @syncobj_timeline_handles.
 	 */
 	__u64	syncobj_timeline_points;
 	/**
@@ -561,32 +526,37 @@ struct drm_amdgpu_userq_wait {
 	 * job to get the va/value pairs.
 	 */
 	__u64	bo_write_handles;
+	/**
+	 * @num_syncobj_timeline_handles: A count that represents the number of timeline
+	 * syncobj handles in @syncobj_timeline_handles.
+	 */
+	__u16	num_syncobj_timeline_handles;
+	/**
+	 * @num_fences: This field can be used both as input and output. As input it defines
+	 * the maximum number of fences that can be returned and as output it will specify
+	 * how many fences were actually returned from the ioctl.
+	 */
+	__u16	num_fences;
 	/**
 	 * @num_syncobj_handles: A count that represents the number of syncobj handles in
-	 * @syncobj_handles_array.
+	 * @syncobj_handles.
 	 */
 	__u32	num_syncobj_handles;
 	/**
-	 * @num_read_bo_handles: A count that represents the number of read BO handles in
+	 * @num_bo_read_handles: A count that represents the number of read BO handles in
 	 * @bo_read_handles.
 	 */
-	__u32	num_read_bo_handles;
+	__u32	num_bo_read_handles;
 	/**
-	 * @num_write_bo_handles: A count that represents the number of write BO handles in
+	 * @num_bo_write_handles: A count that represents the number of write BO handles in
 	 * @bo_write_handles.
 	 */
-	__u32	num_write_bo_handles;
-	__u32	pad;
-	/**
-	 * @userq_fence_info: An array of fence information (va and value) pair of each
-	 * objects stored in @syncobj_handles_array and @bo_handles_array.
-	 */
-	__u64	userq_fence_info;
+	__u32	num_bo_write_handles;
 	/**
-	 * @num_fences: A count that represents the number of actual fences installed in
-	 * each syncobj and bo handles.
+	 * @out_fences: The field is a return value from the ioctl containing the list of
+	 * address/value pairs to wait for.
 	 */
-	__u64	num_fences;
+	__u64	out_fences;
 };
 
 /* vm ioctl */
-- 
2.52.0

