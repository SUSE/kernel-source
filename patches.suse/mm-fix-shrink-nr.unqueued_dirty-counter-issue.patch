From 0a29cf6bfff5faf42de686af3e246a080f105462 Mon Sep 17 00:00:00 2001
From: Zhiguo Jiang <justinjiang@vivo.com>
Date: Fri, 12 Jan 2024 01:23:52 +0000
Subject: [PATCH] mm: fix shrink nr.unqueued_dirty counter issue

From c4a28bacea326a9fe5ee133a7d1836b7929354eb Mon Sep 17 00:00:00 2001

References: bsc#1241169 (MM functional and performance backports)
Patch-mainline: v6.13-rc1
Git-commit: bbc251f30ef312343fec3f5c0591ce01078c2bb9

It is needed to ensure sc->nr.unqueued_dirty > 0, which can avoid setting
PGDAT_DIRTY flag when sc->nr.unqueued_dirty and sc->nr.file_taken are both
zero.

Link: https://lkml.kernel.org/r/20240112012353.1387-1-justinjiang@vivo.com
Signed-off-by: Zhiguo Jiang <justinjiang@vivo.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Mel Gorman <mgorman@suse.de>

---
 mm/vmscan.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/mm/vmscan.c b/mm/vmscan.c
index 77d015d5db0c..c7d8413566aa 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6001,7 +6001,8 @@ static void shrink_node(pg_data_t *pgdat, struct scan_control *sc)
 			set_bit(PGDAT_WRITEBACK, &pgdat->flags);
 
 		/* Allow kswapd to start writing pages during reclaim.*/
-		if (sc->nr.unqueued_dirty == sc->nr.file_taken)
+		if (sc->nr.unqueued_dirty &&
+			sc->nr.unqueued_dirty == sc->nr.file_taken)
 			set_bit(PGDAT_DIRTY, &pgdat->flags);
 
 		/*
