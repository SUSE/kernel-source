From 5a47ac0041678d3d610b3ac724bca8c4bda2ddff Mon Sep 17 00:00:00 2001
From: Hans de Goede <hdegoede@redhat.com>
Date: Sun, 21 Nov 2021 20:11:25 +0100
Subject: [PATCH] platform/x86: thinkpad_acpi: Simplify dytc_version handling
Git-commit: 5a47ac0041678d3d610b3ac724bca8c4bda2ddff
Patch-mainline: v5.17-rc1
References: bsc#1210050

The only reason the proxysensor code needs dytc_version handling is for
proxsensor_attr_is_visible() and that will only ever get called after
all the subdrv init() callbacks have run.

tpacpi_dytc_profile_init() already calls DYTC_CMD_QUERY and is the
primary consumer of dytc_version, so simply let tpacpi_dytc_profile_init()
set dytc_version and remove the now no longer necessary dytc_get_version()
helper and its calls.

Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
Tested-by: Mark Pearson <mpearson@lenovo.com>
Signed-off-by: Hans de Goede <hdegoede@redhat.com>
Link: https://lore.kernel.org/r/20211121191129.256713-4-hdegoede@redhat.com
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/platform/x86/thinkpad_acpi.c | 47 +++-------------------------
 1 file changed, 5 insertions(+), 42 deletions(-)

diff --git a/drivers/platform/x86/thinkpad_acpi.c b/drivers/platform/x86/thinkpad_acpi.c
index c5613399453a..724a0e966c58 100644
--- a/drivers/platform/x86/thinkpad_acpi.c
+++ b/drivers/platform/x86/thinkpad_acpi.c
@@ -9742,33 +9742,6 @@ static int dytc_command(int command, int *output)
 	return 0;
 }
 
-static int dytc_get_version(void)
-{
-	int err, output;
-
-	/* Check if we've been called before - and just return cached value */
-	if (dytc_version)
-		return dytc_version;
-
-	/* Otherwise query DYTC and extract version information */
-	err = dytc_command(DYTC_CMD_QUERY, &output);
-	/*
-	 * If support isn't available (ENODEV) then don't return an error
-	 * and don't create the sysfs group
-	 */
-	if (err == -ENODEV)
-		return 0;
-	/* For all other errors we can flag the failure */
-	if (err)
-		return err;
-
-	/* Check DYTC is enabled and supports mode setting */
-	if (output & BIT(DYTC_QUERY_ENABLE_BIT))
-		dytc_version = (output >> DYTC_QUERY_REV_BIT) & 0xF;
-
-	return 0;
-}
-
 static int lapsensor_get(bool *present, bool *state)
 {
 	int output, err;
@@ -9865,7 +9838,7 @@ static umode_t proxsensor_attr_is_visible(struct kobject *kobj,
 		 * Platforms before DYTC version 5 claim to have a lap sensor,
 		 * but it doesn't work, so we ignore them.
 		 */
-		if (!has_lapsensor ||  dytc_version < 5)
+		if (!has_lapsensor || dytc_version < 5)
 			return 0;
 	} else if (attr == &dev_attr_palmsensor.attr) {
 		if (!has_palmsensor)
@@ -9882,7 +9855,7 @@ static const struct attribute_group proxsensor_attr_group = {
 
 static int tpacpi_proxsensor_init(struct ibm_init_struct *iibm)
 {
-	int palm_err, lap_err, err;
+	int palm_err, lap_err;
 
 	palm_err = palmsensor_get(&has_palmsensor, &palm_state);
 	lap_err = lapsensor_get(&has_lapsensor, &lap_state);
@@ -9895,13 +9868,6 @@ static int tpacpi_proxsensor_init(struct ibm_init_struct *iibm)
 	if (lap_err && (lap_err != -ENODEV))
 		return lap_err;
 
-	/* Check if we know the DYTC version, if we don't then get it */
-	if (!dytc_version) {
-		err = dytc_get_version();
-		if (err)
-			return err;
-	}
-
 	return 0;
 }
 
@@ -10127,12 +10093,9 @@ static int tpacpi_dytc_profile_init(struct ibm_init_struct *iibm)
 	if (err)
 		return err;
 
-	/* Check if we know the DYTC version, if we don't then get it */
-	if (!dytc_version) {
-		err = dytc_get_version();
-		if (err)
-			return err;
-	}
+	if (output & BIT(DYTC_QUERY_ENABLE_BIT))
+		dytc_version = (output >> DYTC_QUERY_REV_BIT) & 0xF;
+
 	/* Check DYTC is enabled and supports mode setting */
 	if (dytc_version >= 5) {
 		dbg_printk(TPACPI_DBG_INIT,
-- 
2.35.3

