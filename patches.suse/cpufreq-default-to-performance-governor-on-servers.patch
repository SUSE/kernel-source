From: Giovanni Gherdovich <ggherdovich@suse.cz>
Date: Thu, 19 Jun 2025 17:44:59 +0200
Subject: cpufreq: Default to performance governor on servers
Patch-mainline: never, upstream favors power efficiency over performance
References: jsc#PED-13111

For server deployments it's important to offer the best performance
out-of-the-box (fresh installation). On the other hand, on personal
computing devices we prefer to use a power-efficient frequency scaling
policy.

Use the field "preferred power management profile" field from the FADT
ACPI table to discriminate between these cases.

Since Device Tree doesn't offer a similar classification, those
systems aren't covered by this change; note, however, that modern Arm
servers are likely to support ACPI.

Signed-off-by: Giovanni Gherdovich <ggherdovich@suse.cz>
---
 drivers/cpufreq/amd-pstate.c          |    3 --
 drivers/cpufreq/cpufreq.c             |    7 +++++-
 drivers/cpufreq/cpufreq_performance.c |    5 ++++
 drivers/cpufreq/intel_pstate.c        |    7 ++++--
 include/linux/cpufreq.h               |   38 ++++++++++++++++++++++++++++++++++
 5 files changed, 55 insertions(+), 5 deletions(-)

--- a/drivers/cpufreq/amd-pstate.c
+++ b/drivers/cpufreq/amd-pstate.c
@@ -1501,8 +1501,7 @@ static int amd_pstate_epp_cpu_init(struc
 	 * Set the policy to provide a valid fallback value in case
 	 * the default cpufreq governor is neither powersave nor performance.
 	 */
-	if (amd_pstate_acpi_pm_profile_server() ||
-	    amd_pstate_acpi_pm_profile_undefined()) {
+	if (cpufreq_should_get_performance_governor()) {
 		policy->policy = CPUFREQ_POLICY_PERFORMANCE;
 		cpudata->epp_default = amd_pstate_get_epp(cpudata);
 	} else {
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -3048,12 +3048,17 @@ EXPORT_SYMBOL_GPL(cpufreq_unregister_dri
 
 static int __init cpufreq_core_init(void)
 {
-	struct cpufreq_governor *gov = cpufreq_default_governor();
+	struct cpufreq_governor *gov;
 	struct device *dev_root;
 
 	if (cpufreq_disabled())
 		return -ENODEV;
 
+	if (cpufreq_should_get_performance_governor())
+		gov = cpufreq_get_performance_governor();
+	else
+		gov = cpufreq_default_governor();
+
 	dev_root = bus_get_dev_root(&cpu_subsys);
 	if (dev_root) {
 		cpufreq_global_kobject = kobject_create_and_add("cpufreq", &dev_root->kobj);
--- a/drivers/cpufreq/cpufreq_performance.c
+++ b/drivers/cpufreq/cpufreq_performance.c
@@ -24,6 +24,11 @@ static struct cpufreq_governor cpufreq_g
 	.limits		= cpufreq_gov_performance_limits,
 };
 
+struct cpufreq_governor *cpufreq_get_performance_governor(void)
+{
+	return &cpufreq_gov_performance;
+}
+
 #ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE
 struct cpufreq_governor *cpufreq_default_governor(void)
 {
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@ -3038,10 +3038,13 @@ static int intel_pstate_cpu_init(struct
 		return ret;
 
 	/*
-	 * Set the policy to powersave to provide a valid fallback value in case
+	 * Set the policy to provide a valid fallback value in case
 	 * the default cpufreq governor is neither powersave nor performance.
 	 */
-	policy->policy = CPUFREQ_POLICY_POWERSAVE;
+	if (cpufreq_should_get_performance_governor())
+		policy->policy = CPUFREQ_POLICY_PERFORMANCE;
+	else
+		policy->policy = CPUFREQ_POLICY_POWERSAVE;
 
 	if (hwp_active) {
 		struct cpudata *cpu = all_cpu_data[policy->cpu];
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -643,6 +643,7 @@ module_exit(__governor##_exit)
 
 struct cpufreq_governor *cpufreq_default_governor(void);
 struct cpufreq_governor *cpufreq_fallback_governor(void);
+struct cpufreq_governor *cpufreq_get_performance_governor(void);
 
 static inline void cpufreq_policy_apply_limits(struct cpufreq_policy *policy)
 {
@@ -1214,4 +1215,41 @@ static inline void cpufreq_register_em_w
 	dev_pm_opp_of_register_em(get_cpu_device(policy->cpu),
 				  policy->related_cpus);
 }
+
+#ifdef CONFIG_ACPI
+#include <linux/acpi.h>
+static inline bool cpufreq_should_get_performance_governor(void)
+{
+	if (!acpi_disabled && acpi_os_get_root_pointer()) {
+		switch (acpi_gbl_FADT.preferred_profile) {
+		case PM_ENTERPRISE_SERVER:
+		case PM_SOHO_SERVER:
+		case PM_PERFORMANCE_SERVER:
+		case PM_UNSPECIFIED:
+			return true;
+		}
+
+		if (acpi_gbl_FADT.preferred_profile >= NR_PM_PROFILES)
+			return true;
+
+		/* Non-server power management profiles */
+		return false;
+	}
+
+	/* Systems without ACPI support; non-server Arm essentially */
+	return false;
+}
+#else
+/**
+ * !CONFIG_ACPI means s390 or ppc64le.
+ * On the former, SLES doesn't do frequency scaling as it's virtualized.
+ * On the latter, bare metal ppc64le SLES installations are possible but
+ * uncommon. In any case, giving them the performance governor is the
+ * safest option.
+ */
+static inline bool cpufreq_should_get_performance_governor(void)
+{
+	return true;
+}
+#endif
 #endif /* _LINUX_CPUFREQ_H */
