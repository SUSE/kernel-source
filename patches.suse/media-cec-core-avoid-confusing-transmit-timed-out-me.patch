From: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date: Thu, 2 May 2024 13:38:44 +0200
Subject: [PATCH] media: cec: core: avoid confusing "transmit timed out" message
Message-ID: <70b13fcf5d43b567595fd7d4b25157ae793ab09c.1714649924.git.hverkuil-cisco@xs4all.nl>
Patch-mainline: Submitted, linux-media ML
References: CVE-2024-23848 bsc#1219104

If, when waiting for a transmit to finish, the wait is interrupted,
then you might get a "transmit timed out" message, even though the
transmit was interrupted and did not actually time out.

Set transmit_in_progress_aborted to true if the
wait_for_completion_killable() call was interrupted and ensure
that the transmit is properly marked as ABORTED.

Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Reported-by: Yang, Chenyuan <cy54@illinois.edu>
Fixes: 590a8e564c6ef ("media: cec: abort if the current transmit was canceled")
Closes: https://lore.kernel.org/linux-media/PH7PR11MB57688E64ADE4FE82E658D86DA09EA@PH7PR11MB5768.namprd11.prod.outlook.com/
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/media/cec/core/cec-adap.c |   15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

--- a/drivers/media/cec/core/cec-adap.c
+++ b/drivers/media/cec/core/cec-adap.c
@@ -501,6 +501,15 @@ int cec_thread_func(void *_adap)
 			goto unlock;
 		}
 
+		if (adap->transmit_in_progress &&
+		    adap->transmit_in_progress_aborted) {
+			if (adap->transmitting)
+				cec_data_cancel(adap->transmitting,
+						CEC_TX_STATUS_ABORTED);
+			adap->transmit_in_progress = false;
+			adap->transmit_in_progress_aborted = false;
+			goto unlock;
+		}
 		if (adap->transmit_in_progress && timeout) {
 			/*
 			 * If we timeout, then log that. Normally this does
@@ -756,6 +765,7 @@ int cec_transmit_msg_fh(struct cec_adapt
 {
 	struct cec_data *data;
 	bool is_raw = msg_is_raw(msg);
+	int err;
 
 	if (adap->devnode.unregistered)
 		return -ENODEV;
@@ -918,10 +928,13 @@ int cec_transmit_msg_fh(struct cec_adapt
 	 * Release the lock and wait, retake the lock afterwards.
 	 */
 	mutex_unlock(&adap->lock);
-	wait_for_completion_killable(&data->c);
+	err = wait_for_completion_killable(&data->c);
 	cancel_delayed_work_sync(&data->work);
 	mutex_lock(&adap->lock);
 
+	if (err)
+		adap->transmit_in_progress_aborted = true;
+
 	/* Cancel the transmit if it was interrupted */
 	if (!data->completed)
 		cec_data_cancel(data, CEC_TX_STATUS_ABORTED);
