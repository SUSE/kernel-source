From a654b354b8cb3143b4e363ddc28704991cd762da Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date: Mon, 10 Jun 2024 10:18:51 +0200
Subject: [PATCH] crypto: qat - make adf_ctl_class constant
Git-commit: a654b354b8cb3143b4e363ddc28704991cd762da
Patch-mainline: v6.11-rc1
References: jsc#PED-9963 jsc#PED-12416

Now that the driver core allows for struct class to be in read-only
memory, we should make all 'class' structures declared at build time
placing them into read-only memory, instead of having to be dynamically
allocated at runtime.

Cc: Giovanni Cabiddu <giovanni.cabiddu@intel.com>
Cc: Herbert Xu <herbert@gondor.apana.org.au>
Cc: "David S. Miller" <davem@davemloft.net>
Cc: Adam Guerin <adam.guerin@intel.com>
Cc: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Cc: Tom Zanussi <tom.zanussi@linux.intel.com>
Cc: Shashank Gupta <shashank.gupta@intel.com>
Cc: qat-linux@intel.com
Cc: linux-crypto@vger.kernel.org
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Reviewed-by: Giovanni Cabiddu <giovanni.cabiddu@intel.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Acked-by: Torsten Duwe <duwe@suse.de>

---
 .../crypto/intel/qat/qat_common/adf_ctl_drv.c | 21 +++++++++++--------
 1 file changed, 12 insertions(+), 9 deletions(-)

diff --git a/drivers/crypto/intel/qat/qat_common/adf_ctl_drv.c b/drivers/crypto/intel/qat/qat_common/adf_ctl_drv.c
index 29c4422f243c6..26a1662fafbb0 100644
--- a/drivers/crypto/intel/qat/qat_common/adf_ctl_drv.c
+++ b/drivers/crypto/intel/qat/qat_common/adf_ctl_drv.c
@@ -31,19 +31,22 @@ static const struct file_operations adf_ctl_ops = {
 	.compat_ioctl = compat_ptr_ioctl,
 };
 
+static const struct class adf_ctl_class = {
+	.name = DEVICE_NAME,
+};
+
 struct adf_ctl_drv_info {
 	unsigned int major;
 	struct cdev drv_cdev;
-	struct class *drv_class;
 };
 
 static struct adf_ctl_drv_info adf_ctl_drv;
 
 static void adf_chr_drv_destroy(void)
 {
-	device_destroy(adf_ctl_drv.drv_class, MKDEV(adf_ctl_drv.major, 0));
+	device_destroy(&adf_ctl_class, MKDEV(adf_ctl_drv.major, 0));
 	cdev_del(&adf_ctl_drv.drv_cdev);
-	class_destroy(adf_ctl_drv.drv_class);
+	class_unregister(&adf_ctl_class);
 	unregister_chrdev_region(MKDEV(adf_ctl_drv.major, 0), 1);
 }
 
@@ -51,17 +54,17 @@ static int adf_chr_drv_create(void)
 {
 	dev_t dev_id;
 	struct device *drv_device;
+	int ret;
 
 	if (alloc_chrdev_region(&dev_id, 0, 1, DEVICE_NAME)) {
 		pr_err("QAT: unable to allocate chrdev region\n");
 		return -EFAULT;
 	}
 
-	adf_ctl_drv.drv_class = class_create(DEVICE_NAME);
-	if (IS_ERR(adf_ctl_drv.drv_class)) {
-		pr_err("QAT: class_create failed for adf_ctl\n");
+	ret = class_register(&adf_ctl_class);
+	if (ret)
 		goto err_chrdev_unreg;
-	}
+
 	adf_ctl_drv.major = MAJOR(dev_id);
 	cdev_init(&adf_ctl_drv.drv_cdev, &adf_ctl_ops);
 	if (cdev_add(&adf_ctl_drv.drv_cdev, dev_id, 1)) {
@@ -69,7 +72,7 @@ static int adf_chr_drv_create(void)
 		goto err_class_destr;
 	}
 
-	drv_device = device_create(adf_ctl_drv.drv_class, NULL,
+	drv_device = device_create(&adf_ctl_class, NULL,
 				   MKDEV(adf_ctl_drv.major, 0),
 				   NULL, DEVICE_NAME);
 	if (IS_ERR(drv_device)) {
@@ -80,7 +83,7 @@ static int adf_chr_drv_create(void)
 err_cdev_del:
 	cdev_del(&adf_ctl_drv.drv_cdev);
 err_class_destr:
-	class_destroy(adf_ctl_drv.drv_class);
+	class_unregister(&adf_ctl_class);
 err_chrdev_unreg:
 	unregister_chrdev_region(dev_id, 1);
 	return -EFAULT;
-- 
2.43.0

