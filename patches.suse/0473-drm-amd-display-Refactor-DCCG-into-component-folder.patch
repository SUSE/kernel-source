From d59c9e128e9e5b67f4e476b5fbf610920a005669 Mon Sep 17 00:00:00 2001
From: Revalla Hari Krishna <harikrishna.revalla@amd.com>
Date: Mon, 22 Apr 2024 15:34:02 +0530
Subject: drm/amd/display: Refactor DCCG into component folder
Git-commit: 0a8d25285feb68608acdf778983ee5f4d72707e8
Patch-mainline: v6.11-rc1
References: jsc#PED-9898 jsc#PED-10191 jsc#PED-10197 jsc#PED-10226 jsc#PED-10237 jsc#PED-10340 jsc#PED-10852 jsc#PED-11022

[why]
cleaning up the code refactor requires dccg to be in its own component.

[how]
move all files under newly created dccg folder and fixing the
makefiles.

Reviewed-by: Martin Leung <martin.leung@amd.com>
Acked-by: Tom Chung <chiahsuan.chung@amd.com>
Signed-off-by: Revalla Hari Krishna <harikrishna.revalla@amd.com>
Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/amd/display/Makefile          |    1 +
 drivers/gpu/drm/amd/display/dc/Makefile       |    2 +-
 drivers/gpu/drm/amd/display/dc/dccg/Makefile  |   98 ++
 .../amd/display/dc/dccg/dcn20/dcn20_dccg.c    |  176 +++
 .../amd/display/dc/dccg/dcn20/dcn20_dccg.h    |  455 +++++++
 .../amd/display/dc/dccg/dcn201/dcn201_dccg.c  |   85 ++
 .../amd/display/dc/dccg/dcn201/dcn201_dccg.h  |   37 +
 .../amd/display/dc/dccg/dcn21/dcn21_dccg.c    |  132 +++
 .../amd/display/dc/dccg/dcn21/dcn21_dccg.h    |   36 +
 .../amd/display/dc/dccg/dcn30/dcn30_dccg.c    |  103 ++
 .../amd/display/dc/dccg/dcn30/dcn30_dccg.h    |   66 ++
 .../amd/display/dc/dccg/dcn301/dcn301_dccg.c  |   78 ++
 .../amd/display/dc/dccg/dcn301/dcn301_dccg.h  |   59 +
 .../amd/display/dc/dccg/dcn302/dcn302_dccg.h  |   41 +
 .../amd/display/dc/dccg/dcn303/dcn303_dccg.h  |   64 +
 .../amd/display/dc/dccg/dcn31/dcn31_dccg.c    |  755 ++++++++++++
 .../amd/display/dc/dccg/dcn31/dcn31_dccg.h    |  239 ++++
 .../amd/display/dc/dccg/dcn314/dcn314_dccg.c  |  404 +++++++
 .../amd/display/dc/dccg/dcn314/dcn314_dccg.h  |  212 ++++
 .../amd/display/dc/dccg/dcn32/dcn32_dccg.c    |  373 ++++++
 .../amd/display/dc/dccg/dcn32/dcn32_dccg.h    |  125 ++
 .../amd/display/dc/dccg/dcn35/dcn35_dccg.c    | 1051 +++++++++++++++++
 .../amd/display/dc/dccg/dcn35/dcn35_dccg.h    |  246 ++++
 drivers/gpu/drm/amd/display/dc/dcn20/Makefile |    2 +-
 .../gpu/drm/amd/display/dc/dcn20/dcn20_dccg.c |  176 ---
 .../gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h |  455 -------
 .../gpu/drm/amd/display/dc/dcn201/Makefile    |    2 +-
 .../drm/amd/display/dc/dcn201/dcn201_dccg.c   |   85 --
 .../drm/amd/display/dc/dcn201/dcn201_dccg.h   |   37 -
 drivers/gpu/drm/amd/display/dc/dcn21/Makefile |    2 +-
 .../gpu/drm/amd/display/dc/dcn21/dcn21_dccg.c |  132 ---
 .../gpu/drm/amd/display/dc/dcn21/dcn21_dccg.h |   36 -
 drivers/gpu/drm/amd/display/dc/dcn30/Makefile |    1 -
 .../gpu/drm/amd/display/dc/dcn30/dcn30_dccg.c |  103 --
 .../gpu/drm/amd/display/dc/dcn30/dcn30_dccg.h |   66 --
 .../gpu/drm/amd/display/dc/dcn301/Makefile    |    3 +-
 .../drm/amd/display/dc/dcn301/dcn301_dccg.c   |   78 --
 .../drm/amd/display/dc/dcn301/dcn301_dccg.h   |   59 -
 .../drm/amd/display/dc/dcn302/dcn302_dccg.h   |   41 -
 .../drm/amd/display/dc/dcn303/dcn303_dccg.h   |   64 -
 drivers/gpu/drm/amd/display/dc/dcn31/Makefile |    2 +-
 .../gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c |  755 ------------
 .../gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h |  239 ----
 .../gpu/drm/amd/display/dc/dcn314/Makefile    |    2 +-
 .../drm/amd/display/dc/dcn314/dcn314_dccg.c   |  404 -------
 .../drm/amd/display/dc/dcn314/dcn314_dccg.h   |  212 ----
 drivers/gpu/drm/amd/display/dc/dcn32/Makefile |    3 +-
 .../gpu/drm/amd/display/dc/dcn32/dcn32_dccg.c |  373 ------
 .../gpu/drm/amd/display/dc/dcn32/dcn32_dccg.h |  125 --
 drivers/gpu/drm/amd/display/dc/dcn35/Makefile |    2 +-
 .../gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c | 1051 -----------------
 .../gpu/drm/amd/display/dc/dcn35/dcn35_dccg.h |  246 ----
 52 files changed, 4845 insertions(+), 4749 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/Makefile
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn20/dcn20_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn20/dcn20_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn201/dcn201_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn201/dcn201_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn21/dcn21_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn21/dcn21_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn30/dcn30_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn30/dcn30_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn301/dcn301_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn301/dcn301_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn302/dcn302_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn303/dcn303_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn31/dcn31_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn31/dcn31_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn314/dcn314_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn314/dcn314_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn32/dcn32_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn32/dcn32_dccg.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn35/dcn35_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dccg/dcn35/dcn35_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn201/dcn201_dccg.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn201/dcn201_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn21/dcn21_dccg.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn21/dcn21_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dccg.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn301/dcn301_dccg.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn301/dcn301_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn302/dcn302_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn303/dcn303_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn314/dcn314_dccg.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn314/dcn314_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dccg.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dccg.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.h

diff --git a/drivers/gpu/drm/amd/display/Makefile b/drivers/gpu/drm/amd/display/Makefile
index 839e71aa7d0c..641073fd7e33 100644
--- a/drivers/gpu/drm/amd/display/Makefile
+++ b/drivers/gpu/drm/amd/display/Makefile
@@ -35,6 +35,7 @@ subdir-ccflags-y += -I$(FULL_AMD_DISPLAY_PATH)/dc/dsc
 subdir-ccflags-y += -I$(FULL_AMD_DISPLAY_PATH)/dc/optc
 subdir-ccflags-y += -I$(FULL_AMD_DISPLAY_PATH)/dc/dpp
 subdir-ccflags-y += -I$(FULL_AMD_DISPLAY_PATH)/dc/hubbub
+subdir-ccflags-y += -I$(FULL_AMD_DISPLAY_PATH)/dc/dccg
 subdir-ccflags-y += -I$(FULL_AMD_DISPLAY_PATH)/modules/inc
 subdir-ccflags-y += -I$(FULL_AMD_DISPLAY_PATH)/modules/freesync
 subdir-ccflags-y += -I$(FULL_AMD_DISPLAY_PATH)/modules/color
diff --git a/drivers/gpu/drm/amd/display/dc/Makefile b/drivers/gpu/drm/amd/display/dc/Makefile
index f1b0b1f66fb0..e0c67f4b9063 100644
--- a/drivers/gpu/drm/amd/display/dc/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/Makefile
@@ -22,7 +22,7 @@
 #
 # Makefile for Display Core (dc) component.
 
-DC_LIBS = basics bios dml clk_mgr dce gpio hwss irq link virtual dsc resource optc dpp hubbub
+DC_LIBS = basics bios dml clk_mgr dce gpio hwss irq link virtual dsc resource optc dpp hubbub dccg
 
 ifdef CONFIG_DRM_AMD_DC_FP
 
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/Makefile b/drivers/gpu/drm/amd/display/dc/dccg/Makefile
new file mode 100644
index 000000000000..bfdce98768f1
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/Makefile
@@ -0,0 +1,98 @@
+
+# Copyright 2022 Advanced Micro Devices, Inc.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files (the "Software"),
+# to deal in the Software without restriction, including without limitation
+# the rights to use, copy, modify, merge, publish, distribute, sublicense,
+# and/or sell copies of the Software, and to permit persons to whom the
+# Software is furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+# THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+# OTHER DEALINGS IN THE SOFTWARE.
+#
+# Makefile for the 'dccg' sub-component of DAL.
+#
+ifdef CONFIG_DRM_AMD_DC_FP
+###############################################################################
+# DCN
+###############################################################################
+
+DCCG_DCN20 = dcn20_dccg.o
+
+AMD_DAL_DCCG_DCN20 = $(addprefix $(AMDDALPATH)/dc/dccg/dcn20/,$(DCCG_DCN20))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCCG_DCN20)
+
+###############################################################################
+
+DCCG_DCN201 = dcn201_dccg.o
+
+AMD_DAL_DCCG_DCN201 = $(addprefix $(AMDDALPATH)/dc/dccg/dcn201/,$(DCCG_DCN201))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCCG_DCN201)
+
+###############################################################################
+
+DCCG_DCN21 = dcn21_dccg.o
+
+AMD_DAL_DCCG_DCN21 = $(addprefix $(AMDDALPATH)/dc/dccg/dcn21/,$(DCCG_DCN21))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCCG_DCN21)
+
+###############################################################################
+DCCG_DCN30 = dcn30_dccg.o
+
+AMD_DAL_DCCG_DCN30 = $(addprefix $(AMDDALPATH)/dc/dccg/dcn30/,$(DCCG_DCN30))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCCG_DCN30)
+
+###############################################################################
+DCCG_DCN301 = dcn301_dccg.o
+
+AMD_DAL_DCCG_DCN301 = $(addprefix $(AMDDALPATH)/dc/dccg/dcn301/,$(DCCG_DCN301))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCCG_DCN301)
+
+###############################################################################
+
+DCCG_DCN31 = dcn31_dccg.o
+
+AMD_DAL_DCCG_DCN31 = $(addprefix $(AMDDALPATH)/dc/dccg/dcn31/,$(DCCG_DCN31))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCCG_DCN31)
+
+###############################################################################
+
+DCCG_DCN314 = dcn314_dccg.o
+
+AMD_DAL_DCCG_DCN314 = $(addprefix $(AMDDALPATH)/dc/dccg/dcn314/,$(DCCG_DCN314))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCCG_DCN314)
+
+###############################################################################
+
+DCCG_DCN32 = dcn32_dccg.o
+
+AMD_DAL_DCCG_DCN32 = $(addprefix $(AMDDALPATH)/dc/dccg/dcn32/,$(DCCG_DCN32))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCCG_DCN32)
+
+###############################################################################
+
+DCCG_DCN35 = dcn35_dccg.o
+
+AMD_DAL_DCCG_DCN35 = $(addprefix $(AMDDALPATH)/dc/dccg/dcn35/,$(DCCG_DCN35))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCCG_DCN35)
+
+###############################################################################
+endif
\ No newline at end of file
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn20/dcn20_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn20/dcn20_dccg.c
new file mode 100644
index 000000000000..5999b2da3a01
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn20/dcn20_dccg.c
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include <linux/slab.h>
+
+#include "reg_helper.h"
+#include "core_types.h"
+#include "dcn20_dccg.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+void dccg2_update_dpp_dto(struct dccg *dccg, int dpp_inst, int req_dppclk)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (dccg->ref_dppclk && req_dppclk) {
+		int ref_dppclk = dccg->ref_dppclk;
+		int modulo, phase;
+
+		// phase / modulo = dpp pipe clk / dpp global clk
+		modulo = 0xff;   // use FF at the end
+		phase = ((modulo * req_dppclk) + ref_dppclk - 1) / ref_dppclk;
+
+		if (phase > 0xff) {
+			ASSERT(false);
+			phase = 0xff;
+		}
+
+		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
+				DPPCLK0_DTO_PHASE, phase,
+				DPPCLK0_DTO_MODULO, modulo);
+		REG_UPDATE(DPPCLK_DTO_CTRL,
+				DPPCLK_DTO_ENABLE[dpp_inst], 1);
+	} else {
+		REG_UPDATE(DPPCLK_DTO_CTRL,
+				DPPCLK_DTO_ENABLE[dpp_inst], 0);
+	}
+
+	dccg->pipe_dppclk_khz[dpp_inst] = req_dppclk;
+}
+
+void dccg2_get_dccg_ref_freq(struct dccg *dccg,
+		unsigned int xtalin_freq_inKhz,
+		unsigned int *dccg_ref_freq_inKhz)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	uint32_t clk_en = 0;
+	uint32_t clk_sel = 0;
+
+	REG_GET_2(REFCLK_CNTL, REFCLK_CLOCK_EN, &clk_en, REFCLK_SRC_SEL, &clk_sel);
+
+	if (clk_en != 0) {
+		// DCN20 has never been validated for non-xtalin as reference
+		// frequency.  There's actually no way for DC to determine what
+		// frequency a non-xtalin source is.
+		ASSERT_CRITICAL(false);
+	}
+
+	*dccg_ref_freq_inKhz = xtalin_freq_inKhz;
+
+	return;
+}
+
+void dccg2_set_fifo_errdet_ovr_en(struct dccg *dccg,
+		bool en)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE(DISPCLK_FREQ_CHANGE_CNTL,
+			DCCG_FIFO_ERRDET_OVR_EN, en ? 1 : 0);
+}
+
+void dccg2_otg_add_pixel(struct dccg *dccg,
+		uint32_t otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[otg_inst],
+			OTG_ADD_PIXEL[otg_inst], 0,
+			OTG_DROP_PIXEL[otg_inst], 0);
+	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
+			OTG_ADD_PIXEL[otg_inst], 1);
+}
+
+void dccg2_otg_drop_pixel(struct dccg *dccg,
+		uint32_t otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[otg_inst],
+			OTG_ADD_PIXEL[otg_inst], 0,
+			OTG_DROP_PIXEL[otg_inst], 0);
+	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
+			OTG_DROP_PIXEL[otg_inst], 1);
+}
+
+void dccg2_init(struct dccg *dccg)
+{
+}
+
+static const struct dccg_funcs dccg2_funcs = {
+	.update_dpp_dto = dccg2_update_dpp_dto,
+	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
+	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
+	.otg_add_pixel = dccg2_otg_add_pixel,
+	.otg_drop_pixel = dccg2_otg_drop_pixel,
+	.dccg_init = dccg2_init
+};
+
+struct dccg *dccg2_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_ATOMIC);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg2_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
+
+void dcn_dccg_destroy(struct dccg **dccg)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(*dccg);
+
+	kfree(dccg_dcn);
+	*dccg = NULL;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn20/dcn20_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn20/dcn20_dccg.h
new file mode 100644
index 000000000000..1e0292861244
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn20/dcn20_dccg.h
@@ -0,0 +1,455 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN20_DCCG_H__
+#define __DCN20_DCCG_H__
+
+#include "dccg.h"
+
+#define DCCG_COMMON_REG_LIST_DCN_BASE() \
+	SR(DPPCLK_DTO_CTRL),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 2),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 3),\
+	SR(REFCLK_CNTL),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 0),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 1),\
+	SR(DISPCLK_FREQ_CHANGE_CNTL)
+
+#define DCCG_REG_LIST_DCN2() \
+	DCCG_COMMON_REG_LIST_DCN_BASE(),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 4),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 5),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 2),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 3),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 4),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 5)
+
+#define DCCG_SF(reg_name, field_name, post_fix)\
+	.field_name = reg_name ## __ ## field_name ## post_fix
+
+#define DCCG_SFI(reg_name, field_name, field_prefix, inst, post_fix)\
+	.field_prefix ## _ ## field_name[inst] = reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
+
+#define DCCG_SFII(block, reg_name, field_prefix, field_name, inst, post_fix)\
+	.field_prefix ## _ ## field_name[inst] = block ## inst ## _ ## reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
+
+#define DCCG_COMMON_MASK_SH_LIST_DCN_COMMON_BASE(mask_sh) \
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(REFCLK_CNTL, REFCLK_CLOCK_EN, mask_sh),\
+	DCCG_SF(REFCLK_CNTL, REFCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_STEP_DELAY, mask_sh),\
+	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_STEP_SIZE, mask_sh),\
+	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_FREQ_RAMP_DONE, mask_sh),\
+	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_MAX_ERRDET_CYCLES, mask_sh),\
+	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_RESET, mask_sh),\
+	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_STATE, mask_sh),\
+	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_OVR_EN, mask_sh),\
+	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_CHG_FWD_CORR_DISABLE, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 1, mask_sh)
+
+
+
+
+#define DCCG_MASK_SH_LIST_DCN2(mask_sh) \
+	DCCG_COMMON_MASK_SH_LIST_DCN_COMMON_BASE(mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 4, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 4, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 5, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 5, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 4, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 5, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 4, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 5, mask_sh)
+
+#define DCCG_MASK_SH_LIST_DCN2_1(mask_sh) \
+	DCCG_COMMON_MASK_SH_LIST_DCN_COMMON_BASE(mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 4, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 4, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 5, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 5, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 3, mask_sh)
+
+
+#define DCCG_REG_FIELD_LIST(type) \
+	type DPPCLK0_DTO_PHASE;\
+	type DPPCLK0_DTO_MODULO;\
+	type DPPCLK_DTO_ENABLE[6];\
+	type DPPCLK_DTO_DB_EN[6];\
+	type REFCLK_CLOCK_EN;\
+	type REFCLK_SRC_SEL;\
+	type DISPCLK_STEP_DELAY;\
+	type DISPCLK_STEP_SIZE;\
+	type DISPCLK_FREQ_RAMP_DONE;\
+	type DISPCLK_MAX_ERRDET_CYCLES;\
+	type DCCG_FIFO_ERRDET_RESET;\
+	type DCCG_FIFO_ERRDET_STATE;\
+	type DCCG_FIFO_ERRDET_OVR_EN;\
+	type DISPCLK_CHG_FWD_CORR_DISABLE;\
+	type DISPCLK_FREQ_CHANGE_CNTL;\
+	type OTG_ADD_PIXEL[MAX_PIPES];\
+	type OTG_DROP_PIXEL[MAX_PIPES];
+
+#define DCCG3_REG_FIELD_LIST(type) \
+	type HDMICHARCLK0_EN;\
+	type HDMICHARCLK0_SRC_SEL;\
+	type PHYASYMCLK_FORCE_EN;\
+	type PHYASYMCLK_FORCE_SRC_SEL;\
+	type PHYBSYMCLK_FORCE_EN;\
+	type PHYBSYMCLK_FORCE_SRC_SEL;\
+	type PHYCSYMCLK_FORCE_EN;\
+	type PHYCSYMCLK_FORCE_SRC_SEL;
+
+#define DCCG31_REG_FIELD_LIST(type) \
+	type PHYDSYMCLK_FORCE_EN;\
+	type PHYDSYMCLK_FORCE_SRC_SEL;\
+	type PHYESYMCLK_FORCE_EN;\
+	type PHYESYMCLK_FORCE_SRC_SEL;\
+	type DPSTREAMCLK_PIPE0_EN;\
+	type DPSTREAMCLK_PIPE1_EN;\
+	type DPSTREAMCLK_PIPE2_EN;\
+	type DPSTREAMCLK_PIPE3_EN;\
+	type HDMISTREAMCLK0_SRC_SEL;\
+	type HDMISTREAMCLK0_DTO_FORCE_DIS;\
+	type SYMCLK32_SE0_SRC_SEL;\
+	type SYMCLK32_SE1_SRC_SEL;\
+	type SYMCLK32_SE2_SRC_SEL;\
+	type SYMCLK32_SE3_SRC_SEL;\
+	type SYMCLK32_SE0_EN;\
+	type SYMCLK32_SE1_EN;\
+	type SYMCLK32_SE2_EN;\
+	type SYMCLK32_SE3_EN;\
+	type SYMCLK32_LE0_SRC_SEL;\
+	type SYMCLK32_LE1_SRC_SEL;\
+	type SYMCLK32_LE0_EN;\
+	type SYMCLK32_LE1_EN;\
+	type DTBCLK_DTO_ENABLE[MAX_PIPES];\
+	type DTBCLKDTO_ENABLE_STATUS[MAX_PIPES];\
+	type PIPE_DTO_SRC_SEL[MAX_PIPES];\
+	type DTBCLK_DTO_DIV[MAX_PIPES];\
+	type DCCG_AUDIO_DTO_SEL;\
+	type DCCG_AUDIO_DTO0_SOURCE_SEL;\
+	type DENTIST_DISPCLK_CHG_MODE;\
+	type DSCCLK0_DTO_PHASE;\
+	type DSCCLK0_DTO_MODULO;\
+	type DSCCLK1_DTO_PHASE;\
+	type DSCCLK1_DTO_MODULO;\
+	type DSCCLK2_DTO_PHASE;\
+	type DSCCLK2_DTO_MODULO;\
+	type DSCCLK0_DTO_ENABLE;\
+	type DSCCLK1_DTO_ENABLE;\
+	type DSCCLK2_DTO_ENABLE;\
+	type SYMCLK32_ROOT_SE0_GATE_DISABLE;\
+	type SYMCLK32_ROOT_SE1_GATE_DISABLE;\
+	type SYMCLK32_ROOT_SE2_GATE_DISABLE;\
+	type SYMCLK32_ROOT_SE3_GATE_DISABLE;\
+	type SYMCLK32_SE0_GATE_DISABLE;\
+	type SYMCLK32_SE1_GATE_DISABLE;\
+	type SYMCLK32_SE2_GATE_DISABLE;\
+	type SYMCLK32_SE3_GATE_DISABLE;\
+	type SYMCLK32_ROOT_LE0_GATE_DISABLE;\
+	type SYMCLK32_ROOT_LE1_GATE_DISABLE;\
+	type SYMCLK32_LE0_GATE_DISABLE;\
+	type SYMCLK32_LE1_GATE_DISABLE;\
+	type DPSTREAMCLK_ROOT_GATE_DISABLE;\
+	type DPSTREAMCLK_GATE_DISABLE;\
+	type HDMISTREAMCLK0_DTO_PHASE;\
+	type HDMISTREAMCLK0_DTO_MODULO;\
+	type HDMICHARCLK0_GATE_DISABLE;\
+	type HDMICHARCLK0_ROOT_GATE_DISABLE; \
+	type PHYASYMCLK_GATE_DISABLE; \
+	type PHYBSYMCLK_GATE_DISABLE; \
+	type PHYCSYMCLK_GATE_DISABLE; \
+	type PHYDSYMCLK_GATE_DISABLE; \
+	type PHYESYMCLK_GATE_DISABLE;
+
+#define DCCG314_REG_FIELD_LIST(type) \
+	type DSCCLK3_DTO_PHASE;\
+	type DSCCLK3_DTO_MODULO;\
+	type DSCCLK3_DTO_ENABLE;\
+	type DENTIST_DISPCLK_RDIVIDER;\
+	type DENTIST_DISPCLK_WDIVIDER;
+
+#define DCCG32_REG_FIELD_LIST(type) \
+	type DPSTREAMCLK0_EN;\
+	type DPSTREAMCLK1_EN;\
+	type DPSTREAMCLK2_EN;\
+	type DPSTREAMCLK3_EN;\
+	type DPSTREAMCLK0_SRC_SEL;\
+	type DPSTREAMCLK1_SRC_SEL;\
+	type DPSTREAMCLK2_SRC_SEL;\
+	type DPSTREAMCLK3_SRC_SEL;\
+	type HDMISTREAMCLK0_EN;\
+	type OTG0_PIXEL_RATE_DIVK1;\
+	type OTG0_PIXEL_RATE_DIVK2;\
+	type OTG1_PIXEL_RATE_DIVK1;\
+	type OTG1_PIXEL_RATE_DIVK2;\
+	type OTG2_PIXEL_RATE_DIVK1;\
+	type OTG2_PIXEL_RATE_DIVK2;\
+	type OTG3_PIXEL_RATE_DIVK1;\
+	type OTG3_PIXEL_RATE_DIVK2;\
+	type DTBCLK_P0_SRC_SEL;\
+	type DTBCLK_P0_EN;\
+	type DTBCLK_P1_SRC_SEL;\
+	type DTBCLK_P1_EN;\
+	type DTBCLK_P2_SRC_SEL;\
+	type DTBCLK_P2_EN;\
+	type DTBCLK_P3_SRC_SEL;\
+	type DTBCLK_P3_EN;\
+	type DENTIST_DISPCLK_CHG_DONE;
+
+#define DCCG35_REG_FIELD_LIST(type) \
+	type DPPCLK0_EN;\
+	type DPPCLK1_EN;\
+	type DPPCLK2_EN;\
+	type DPPCLK3_EN;\
+	type DSCCLK0_EN;\
+	type DSCCLK1_EN;\
+	type DSCCLK2_EN;\
+	type DSCCLK3_EN;\
+	type DISPCLK_DCCG_GATE_DISABLE;\
+	type DCCG_GLOBAL_FGCG_REP_DIS; \
+	type PHYASYMCLK_EN;\
+	type PHYASYMCLK_SRC_SEL;\
+	type PHYBSYMCLK_EN;\
+	type PHYBSYMCLK_SRC_SEL;\
+	type PHYCSYMCLK_EN;\
+	type PHYCSYMCLK_SRC_SEL;\
+	type PHYDSYMCLK_EN;\
+	type PHYDSYMCLK_SRC_SEL;\
+	type PHYESYMCLK_EN;\
+	type PHYESYMCLK_SRC_SEL;\
+	type PHYASYMCLK_ROOT_GATE_DISABLE;\
+	type PHYBSYMCLK_ROOT_GATE_DISABLE;\
+	type PHYCSYMCLK_ROOT_GATE_DISABLE;\
+	type PHYDSYMCLK_ROOT_GATE_DISABLE;\
+	type PHYESYMCLK_ROOT_GATE_DISABLE;\
+	type HDMISTREAMCLK0_GATE_DISABLE;\
+	type HDMISTREAMCLK1_GATE_DISABLE;\
+	type HDMISTREAMCLK2_GATE_DISABLE;\
+	type HDMISTREAMCLK3_GATE_DISABLE;\
+	type HDMISTREAMCLK4_GATE_DISABLE;\
+	type HDMISTREAMCLK5_GATE_DISABLE;\
+	type SYMCLKA_CLOCK_ENABLE;\
+	type SYMCLKB_CLOCK_ENABLE;\
+	type SYMCLKC_CLOCK_ENABLE;\
+	type SYMCLKD_CLOCK_ENABLE;\
+	type SYMCLKE_CLOCK_ENABLE;\
+	type SYMCLKA_FE_EN;\
+	type SYMCLKB_FE_EN;\
+	type SYMCLKC_FE_EN;\
+	type SYMCLKD_FE_EN;\
+	type SYMCLKE_FE_EN;\
+	type SYMCLKA_SRC_SEL;\
+	type SYMCLKB_SRC_SEL;\
+	type SYMCLKC_SRC_SEL;\
+	type SYMCLKD_SRC_SEL;\
+	type SYMCLKE_SRC_SEL;\
+	type SYMCLKA_FE_SRC_SEL;\
+	type SYMCLKB_FE_SRC_SEL;\
+	type SYMCLKC_FE_SRC_SEL;\
+	type SYMCLKD_FE_SRC_SEL;\
+	type SYMCLKE_FE_SRC_SEL;\
+	type DTBCLK_P0_GATE_DISABLE;\
+	type DTBCLK_P1_GATE_DISABLE;\
+	type DTBCLK_P2_GATE_DISABLE;\
+	type DTBCLK_P3_GATE_DISABLE;\
+	type DSCCLK0_ROOT_GATE_DISABLE;\
+	type DSCCLK1_ROOT_GATE_DISABLE;\
+	type DSCCLK2_ROOT_GATE_DISABLE;\
+	type DSCCLK3_ROOT_GATE_DISABLE;\
+	type SYMCLKA_FE_ROOT_GATE_DISABLE;\
+	type SYMCLKB_FE_ROOT_GATE_DISABLE;\
+	type SYMCLKC_FE_ROOT_GATE_DISABLE;\
+	type SYMCLKD_FE_ROOT_GATE_DISABLE;\
+	type SYMCLKE_FE_ROOT_GATE_DISABLE;\
+	type DPPCLK0_ROOT_GATE_DISABLE;\
+	type DPPCLK1_ROOT_GATE_DISABLE;\
+	type DPPCLK2_ROOT_GATE_DISABLE;\
+	type DPPCLK3_ROOT_GATE_DISABLE;\
+	type HDMISTREAMCLK0_ROOT_GATE_DISABLE;\
+	type SYMCLKA_ROOT_GATE_DISABLE;\
+	type SYMCLKB_ROOT_GATE_DISABLE;\
+	type SYMCLKC_ROOT_GATE_DISABLE;\
+	type SYMCLKD_ROOT_GATE_DISABLE;\
+	type SYMCLKE_ROOT_GATE_DISABLE;\
+	type PHYA_REFCLK_ROOT_GATE_DISABLE;\
+	type PHYB_REFCLK_ROOT_GATE_DISABLE;\
+	type PHYC_REFCLK_ROOT_GATE_DISABLE;\
+	type PHYD_REFCLK_ROOT_GATE_DISABLE;\
+	type PHYE_REFCLK_ROOT_GATE_DISABLE;\
+	type DPSTREAMCLK0_ROOT_GATE_DISABLE;\
+	type DPSTREAMCLK1_ROOT_GATE_DISABLE;\
+	type DPSTREAMCLK2_ROOT_GATE_DISABLE;\
+	type DPSTREAMCLK3_ROOT_GATE_DISABLE;\
+	type DPSTREAMCLK0_GATE_DISABLE;\
+	type DPSTREAMCLK1_GATE_DISABLE;\
+	type DPSTREAMCLK2_GATE_DISABLE;\
+	type DPSTREAMCLK3_GATE_DISABLE;\
+
+#define DCCG401_REG_FIELD_LIST(type) \
+	type OTG0_TMDS_PIXEL_RATE_DIV;\
+	type DPDTO0_INT;\
+	type OTG1_TMDS_PIXEL_RATE_DIV;\
+	type DPDTO1_INT;\
+	type OTG2_TMDS_PIXEL_RATE_DIV;\
+	type DPDTO2_INT;\
+	type OTG3_TMDS_PIXEL_RATE_DIV;\
+	type DPDTO3_INT;\
+	type SYMCLK32_ROOT_LE2_GATE_DISABLE;\
+	type SYMCLK32_ROOT_LE3_GATE_DISABLE;\
+	type SYMCLK32_LE2_GATE_DISABLE;\
+	type SYMCLK32_LE3_GATE_DISABLE;\
+	type SYMCLK32_LE2_SRC_SEL;\
+	type SYMCLK32_LE3_SRC_SEL;\
+	type SYMCLK32_LE2_EN;\
+	type SYMCLK32_LE3_EN;\
+	type DP_DTO_ENABLE[MAX_PIPES];\
+	type DSCCLK0_DTO_DB_EN;\
+	type DSCCLK1_DTO_DB_EN;\
+	type DSCCLK2_DTO_DB_EN;\
+	type DSCCLK3_DTO_DB_EN;
+
+struct dccg_shift {
+	DCCG_REG_FIELD_LIST(uint8_t)
+	DCCG3_REG_FIELD_LIST(uint8_t)
+	DCCG31_REG_FIELD_LIST(uint8_t)
+	DCCG314_REG_FIELD_LIST(uint8_t)
+	DCCG32_REG_FIELD_LIST(uint8_t)
+	DCCG35_REG_FIELD_LIST(uint8_t)
+	DCCG401_REG_FIELD_LIST(uint8_t)
+};
+
+struct dccg_mask {
+	DCCG_REG_FIELD_LIST(uint32_t)
+	DCCG3_REG_FIELD_LIST(uint32_t)
+	DCCG31_REG_FIELD_LIST(uint32_t)
+	DCCG314_REG_FIELD_LIST(uint32_t)
+	DCCG32_REG_FIELD_LIST(uint32_t)
+	DCCG35_REG_FIELD_LIST(uint32_t)
+	DCCG401_REG_FIELD_LIST(uint32_t)
+};
+
+struct dccg_registers {
+	uint32_t DPPCLK_DTO_CTRL;
+	uint32_t DPPCLK_DTO_PARAM[6];
+	uint32_t REFCLK_CNTL;
+	uint32_t DISPCLK_FREQ_CHANGE_CNTL;
+	uint32_t OTG_PIXEL_RATE_CNTL[MAX_PIPES];
+	uint32_t HDMICHARCLK_CLOCK_CNTL[6];
+	uint32_t PHYASYMCLK_CLOCK_CNTL;
+	uint32_t PHYBSYMCLK_CLOCK_CNTL;
+	uint32_t PHYCSYMCLK_CLOCK_CNTL;
+	uint32_t PHYDSYMCLK_CLOCK_CNTL;
+	uint32_t PHYESYMCLK_CLOCK_CNTL;
+	uint32_t DTBCLK_DTO_MODULO[MAX_PIPES];
+	uint32_t DTBCLK_DTO_PHASE[MAX_PIPES];
+	uint32_t DCCG_AUDIO_DTBCLK_DTO_MODULO;
+	uint32_t DCCG_AUDIO_DTBCLK_DTO_PHASE;
+	uint32_t DCCG_AUDIO_DTO_SOURCE;
+	uint32_t DPSTREAMCLK_CNTL;
+	uint32_t HDMISTREAMCLK_CNTL;
+	uint32_t SYMCLK32_SE_CNTL;
+	uint32_t SYMCLK32_LE_CNTL;
+	uint32_t DENTIST_DISPCLK_CNTL;
+	uint32_t DSCCLK_DTO_CTRL;
+	uint32_t DSCCLK0_DTO_PARAM;
+	uint32_t DSCCLK1_DTO_PARAM;
+	uint32_t DSCCLK2_DTO_PARAM;
+	uint32_t DSCCLK3_DTO_PARAM;
+	uint32_t DPSTREAMCLK_ROOT_GATE_DISABLE;
+	uint32_t DPSTREAMCLK_GATE_DISABLE;
+	uint32_t DCCG_GATE_DISABLE_CNTL;
+	uint32_t DCCG_GATE_DISABLE_CNTL2;
+	uint32_t DCCG_GATE_DISABLE_CNTL3;
+	uint32_t HDMISTREAMCLK0_DTO_PARAM;
+	uint32_t DCCG_GATE_DISABLE_CNTL4;
+	uint32_t OTG_PIXEL_RATE_DIV;
+	uint32_t DTBCLK_P_CNTL;
+	uint32_t DPPCLK_CTRL;
+	uint32_t DCCG_GATE_DISABLE_CNTL5;
+	uint32_t DCCG_GATE_DISABLE_CNTL6;
+	uint32_t DCCG_GLOBAL_FGCG_REP_CNTL;
+	uint32_t SYMCLKA_CLOCK_ENABLE;
+	uint32_t SYMCLKB_CLOCK_ENABLE;
+	uint32_t SYMCLKC_CLOCK_ENABLE;
+	uint32_t SYMCLKD_CLOCK_ENABLE;
+	uint32_t SYMCLKE_CLOCK_ENABLE;
+	uint32_t DP_DTO_MODULO[MAX_PIPES];
+	uint32_t DP_DTO_PHASE[MAX_PIPES];
+};
+
+struct dcn_dccg {
+	struct dccg base;
+	const struct dccg_registers *regs;
+	const struct dccg_shift *dccg_shift;
+	const struct dccg_mask *dccg_mask;
+};
+
+void dccg2_update_dpp_dto(struct dccg *dccg, int dpp_inst, int req_dppclk);
+
+void dccg2_get_dccg_ref_freq(struct dccg *dccg,
+		unsigned int xtalin_freq_inKhz,
+		unsigned int *dccg_ref_freq_inKhz);
+
+void dccg2_set_fifo_errdet_ovr_en(struct dccg *dccg,
+		bool en);
+void dccg2_otg_add_pixel(struct dccg *dccg,
+		uint32_t otg_inst);
+void dccg2_otg_drop_pixel(struct dccg *dccg,
+		uint32_t otg_inst);
+
+
+void dccg2_init(struct dccg *dccg);
+
+struct dccg *dccg2_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+void dcn_dccg_destroy(struct dccg **dccg);
+
+#endif //__DCN20_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn201/dcn201_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn201/dcn201_dccg.c
new file mode 100644
index 000000000000..9a3402148fde
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn201/dcn201_dccg.c
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dcn201_dccg.h"
+
+#include "reg_helper.h"
+#include "core_types.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+static void dccg201_update_dpp_dto(struct dccg *dccg, int dpp_inst,
+				   int req_dppclk)
+{
+	/* vbios handles it */
+}
+
+static const struct dccg_funcs dccg201_funcs = {
+	.update_dpp_dto = dccg201_update_dpp_dto,
+	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
+	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
+	.otg_add_pixel = dccg2_otg_add_pixel,
+	.otg_drop_pixel = dccg2_otg_drop_pixel,
+	.dccg_init = dccg2_init
+};
+
+struct dccg *dccg201_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg201_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn201/dcn201_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn201/dcn201_dccg.h
new file mode 100644
index 000000000000..80888b0484fb
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn201/dcn201_dccg.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN201_DCCG_H__
+#define __DCN201_DCCG_H__
+
+#include "dcn20/dcn20_dccg.h"
+
+struct dccg *dccg201_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+#endif //__DCN201_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn21/dcn21_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn21/dcn21_dccg.c
new file mode 100644
index 000000000000..d07c04458d31
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn21/dcn21_dccg.c
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "core_types.h"
+#include "dcn20/dcn20_dccg.h"
+#include "dcn21_dccg.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+static void dccg21_update_dpp_dto(struct dccg *dccg, int dpp_inst, int req_dppclk)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (dccg->ref_dppclk) {
+		int ref_dppclk = dccg->ref_dppclk;
+		int modulo = ref_dppclk / 10000;
+		int phase;
+
+		if (req_dppclk) {
+			/*
+			 * program DPP DTO phase and modulo as below
+			 * phase = ceiling(dpp_pipe_clk_mhz / 10)
+			 * module = trunc(dpp_global_clk_mhz / 10)
+			 *
+			 * storing frequencies in registers allow dmcub fw
+			 * to run time lower clocks when possible for power saving
+			 *
+			 * ceiling phase and truncate modulo guarentees the divided
+			 * down per pipe dpp clock has high enough frequency
+			 */
+			phase = (req_dppclk + 9999) / 10000;
+
+			if (phase > modulo) {
+				/* phase > modulo result in screen corruption
+				 * ie phase = 30, mod = 29 for 4k@60 HDMI
+				 * in these case we don't want pipe clock to be divided
+				 */
+				phase = modulo;
+			}
+		} else {
+			/*
+			 *  set phase to 10 if dpp isn't used to
+			 *  prevent hard hang if access dpp register
+			 *  on unused pipe
+			 *
+			 *  DTO should be on to divide down un-used
+			 *  pipe clock for power saving
+			 */
+			phase = 10;
+		}
+
+		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
+				DPPCLK0_DTO_PHASE, phase,
+				DPPCLK0_DTO_MODULO, modulo);
+
+		REG_UPDATE(DPPCLK_DTO_CTRL,
+				DPPCLK_DTO_ENABLE[dpp_inst], 1);
+	}
+
+	dccg->pipe_dppclk_khz[dpp_inst] = req_dppclk;
+}
+
+
+static const struct dccg_funcs dccg21_funcs = {
+	.update_dpp_dto = dccg21_update_dpp_dto,
+	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
+	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
+	.otg_add_pixel = dccg2_otg_add_pixel,
+	.otg_drop_pixel = dccg2_otg_drop_pixel,
+	.dccg_init = dccg2_init
+};
+
+struct dccg *dccg21_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg21_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn21/dcn21_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn21/dcn21_dccg.h
new file mode 100644
index 000000000000..b7efa777ec73
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn21/dcn21_dccg.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN21_DCCG_H__
+#define __DCN21_DCCG_H__
+
+struct dccg *dccg21_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+
+#endif /* __DCN21_DCCG_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn30/dcn30_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn30/dcn30_dccg.c
new file mode 100644
index 000000000000..d445dfefc047
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn30/dcn30_dccg.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2020 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "core_types.h"
+#include "dcn30_dccg.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+
+static const struct dccg_funcs dccg3_funcs = {
+	.update_dpp_dto = dccg2_update_dpp_dto,
+	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
+	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
+	.otg_add_pixel = dccg2_otg_add_pixel,
+	.otg_drop_pixel = dccg2_otg_drop_pixel,
+	.dccg_init = dccg2_init
+};
+
+struct dccg *dccg3_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg3_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
+
+struct dccg *dccg30_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg3_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn30/dcn30_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn30/dcn30_dccg.h
new file mode 100644
index 000000000000..3f1da7f3a91c
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn30/dcn30_dccg.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2020 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN30_DCCG_H__
+#define __DCN30_DCCG_H__
+
+#include "dcn20/dcn20_dccg.h"
+
+
+#define DCCG_REG_LIST_DCN30() \
+	DCCG_REG_LIST_DCN2(),\
+	DCCG_SRII(CLOCK_CNTL, HDMICHARCLK, 0),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 2),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 3),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 4),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 5),\
+	SR(PHYASYMCLK_CLOCK_CNTL),\
+	SR(PHYBSYMCLK_CLOCK_CNTL),\
+	SR(PHYCSYMCLK_CLOCK_CNTL)
+
+#define DCCG_MASK_SH_LIST_DCN3(mask_sh) \
+	DCCG_MASK_SH_LIST_DCN2(mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_SRC_SEL, mask_sh),\
+
+struct dccg *dccg3_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+struct dccg *dccg30_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+#endif //__DCN30_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn301/dcn301_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn301/dcn301_dccg.c
new file mode 100644
index 000000000000..97e9be87afd9
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn301/dcn301_dccg.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2020 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "core_types.h"
+#include "dcn301_dccg.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+static const struct dccg_funcs dccg301_funcs = {
+	.update_dpp_dto = dccg2_update_dpp_dto,
+	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
+	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
+	.otg_add_pixel = dccg2_otg_add_pixel,
+	.otg_drop_pixel = dccg2_otg_drop_pixel,
+	.dccg_init = dccg2_init
+};
+
+struct dccg *dccg301_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg301_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
+
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn301/dcn301_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn301/dcn301_dccg.h
new file mode 100644
index 000000000000..067e49cb238e
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn301/dcn301_dccg.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2020 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN301_DCCG_H__
+#define __DCN301_DCCG_H__
+
+#include "dcn20/dcn20_dccg.h"
+
+#define DCCG_REG_LIST_DCN301() \
+	SR(DPPCLK_DTO_CTRL),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 2),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 3),\
+	SR(REFCLK_CNTL)
+
+#define DCCG_MASK_SH_LIST_DCN301(mask_sh) \
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(REFCLK_CNTL, REFCLK_CLOCK_EN, mask_sh),\
+	DCCG_SF(REFCLK_CNTL, REFCLK_SRC_SEL, mask_sh)
+
+struct dccg *dccg301_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+#endif //__DCN301_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn302/dcn302_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn302/dcn302_dccg.h
new file mode 100644
index 000000000000..c884dde1bb25
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn302/dcn302_dccg.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2020 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN302_DCCG_H__
+#define __DCN302_DCCG_H__
+
+#include "dcn30/dcn30_dccg.h"
+
+
+#define DCCG_REG_LIST_DCN3_02() \
+	DCCG_COMMON_REG_LIST_DCN_BASE(),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 4)
+
+#define DCCG_MASK_SH_LIST_DCN3_02(mask_sh) \
+	DCCG_COMMON_MASK_SH_LIST_DCN_COMMON_BASE(mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 4, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 4, mask_sh)
+
+#endif //__DCN302_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn303/dcn303_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn303/dcn303_dccg.h
new file mode 100644
index 000000000000..2e12fb643005
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn303/dcn303_dccg.h
@@ -0,0 +1,64 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright (C) 2021 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ */
+
+#ifndef __DCN303_DCCG_H__
+#define __DCN303_DCCG_H__
+
+#include "dcn30/dcn30_dccg.h"
+
+
+#define DCCG_REG_LIST_DCN3_03() \
+	SR(DPPCLK_DTO_CTRL),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
+	SR(REFCLK_CNTL),\
+	SR(DISPCLK_FREQ_CHANGE_CNTL),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 0),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 1)
+
+
+#define DCCG_MASK_SH_LIST_DCN3_03(mask_sh) \
+		DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
+		DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
+		DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
+		DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
+		DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
+		DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
+		DCCG_SF(REFCLK_CNTL, REFCLK_CLOCK_EN, mask_sh),\
+		DCCG_SF(REFCLK_CNTL, REFCLK_SRC_SEL, mask_sh),\
+		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_STEP_DELAY, mask_sh),\
+		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_STEP_SIZE, mask_sh),\
+		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_FREQ_RAMP_DONE, mask_sh),\
+		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_MAX_ERRDET_CYCLES, mask_sh),\
+		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_RESET, mask_sh),\
+		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_STATE, mask_sh),\
+		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_OVR_EN, mask_sh),\
+		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_CHG_FWD_CORR_DISABLE, mask_sh),\
+		DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
+		DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
+		DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 0, mask_sh),\
+		DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 1, mask_sh)
+
+#endif //__DCN303_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn31/dcn31_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn31/dcn31_dccg.c
new file mode 100644
index 000000000000..8664f0c4c9b7
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn31/dcn31_dccg.c
@@ -0,0 +1,755 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "core_types.h"
+#include "dcn31_dccg.h"
+#include "dal_asic_id.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+void dccg31_update_dpp_dto(struct dccg *dccg, int dpp_inst, int req_dppclk)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (dccg->dpp_clock_gated[dpp_inst]) {
+		/*
+		 * Do not update the DPPCLK DTO if the clock is stopped.
+		 * It is treated the same as if the pipe itself were in PG.
+		 */
+		return;
+	}
+
+	if (dccg->ref_dppclk && req_dppclk) {
+		int ref_dppclk = dccg->ref_dppclk;
+		int modulo, phase;
+
+		// phase / modulo = dpp pipe clk / dpp global clk
+		modulo = 0xff;   // use FF at the end
+		phase = ((modulo * req_dppclk) + ref_dppclk - 1) / ref_dppclk;
+
+		if (phase > 0xff) {
+			ASSERT(false);
+			phase = 0xff;
+		}
+
+		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
+				DPPCLK0_DTO_PHASE, phase,
+				DPPCLK0_DTO_MODULO, modulo);
+		REG_UPDATE(DPPCLK_DTO_CTRL,
+				DPPCLK_DTO_ENABLE[dpp_inst], 1);
+	} else {
+		REG_UPDATE(DPPCLK_DTO_CTRL,
+				DPPCLK_DTO_ENABLE[dpp_inst], 0);
+	}
+	dccg->pipe_dppclk_khz[dpp_inst] = req_dppclk;
+}
+
+static enum phyd32clk_clock_source get_phy_mux_symclk(
+		struct dcn_dccg *dccg_dcn,
+		enum phyd32clk_clock_source src)
+{
+	if (dccg_dcn->base.ctx->asic_id.chip_family == FAMILY_YELLOW_CARP &&
+			dccg_dcn->base.ctx->asic_id.hw_internal_rev == YELLOW_CARP_B0) {
+		if (src == PHYD32CLKC)
+			src = PHYD32CLKF;
+		if (src == PHYD32CLKD)
+			src = PHYD32CLKG;
+	}
+	return src;
+}
+
+static void dccg31_enable_dpstreamclk(struct dccg *dccg, int otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* enabled to select one of the DTBCLKs for pipe */
+	switch (otg_inst) {
+	case 0:
+		REG_UPDATE(DPSTREAMCLK_CNTL,
+				DPSTREAMCLK_PIPE0_EN, 1);
+		break;
+	case 1:
+		REG_UPDATE(DPSTREAMCLK_CNTL,
+				DPSTREAMCLK_PIPE1_EN, 1);
+		break;
+	case 2:
+		REG_UPDATE(DPSTREAMCLK_CNTL,
+				DPSTREAMCLK_PIPE2_EN, 1);
+		break;
+	case 3:
+		REG_UPDATE(DPSTREAMCLK_CNTL,
+				DPSTREAMCLK_PIPE3_EN, 1);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
+		REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+			DPSTREAMCLK_GATE_DISABLE, 1,
+			DPSTREAMCLK_ROOT_GATE_DISABLE, 1);
+}
+
+static void dccg31_disable_dpstreamclk(struct dccg *dccg, int otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
+		REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+				DPSTREAMCLK_ROOT_GATE_DISABLE, 0,
+				DPSTREAMCLK_GATE_DISABLE, 0);
+
+	switch (otg_inst) {
+	case 0:
+		REG_UPDATE(DPSTREAMCLK_CNTL,
+				DPSTREAMCLK_PIPE0_EN, 0);
+		break;
+	case 1:
+		REG_UPDATE(DPSTREAMCLK_CNTL,
+				DPSTREAMCLK_PIPE1_EN, 0);
+		break;
+	case 2:
+		REG_UPDATE(DPSTREAMCLK_CNTL,
+				DPSTREAMCLK_PIPE2_EN, 0);
+		break;
+	case 3:
+		REG_UPDATE(DPSTREAMCLK_CNTL,
+				DPSTREAMCLK_PIPE3_EN, 0);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+void dccg31_set_dpstreamclk(
+		struct dccg *dccg,
+		enum streamclk_source src,
+		int otg_inst,
+		int dp_hpo_inst)
+{
+	if (src == REFCLK)
+		dccg31_disable_dpstreamclk(dccg, otg_inst);
+	else
+		dccg31_enable_dpstreamclk(dccg, otg_inst);
+}
+
+void dccg31_enable_symclk32_se(
+		struct dccg *dccg,
+		int hpo_se_inst,
+		enum phyd32clk_clock_source phyd32clk)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	phyd32clk = get_phy_mux_symclk(dccg_dcn, phyd32clk);
+
+	/* select one of the PHYD32CLKs as the source for symclk32_se */
+	switch (hpo_se_inst) {
+	case 0:
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE0_GATE_DISABLE, 1,
+					SYMCLK32_ROOT_SE0_GATE_DISABLE, 1);
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE0_SRC_SEL, phyd32clk,
+				SYMCLK32_SE0_EN, 1);
+		break;
+	case 1:
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE1_GATE_DISABLE, 1,
+					SYMCLK32_ROOT_SE1_GATE_DISABLE, 1);
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE1_SRC_SEL, phyd32clk,
+				SYMCLK32_SE1_EN, 1);
+		break;
+	case 2:
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE2_GATE_DISABLE, 1,
+					SYMCLK32_ROOT_SE2_GATE_DISABLE, 1);
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE2_SRC_SEL, phyd32clk,
+				SYMCLK32_SE2_EN, 1);
+		break;
+	case 3:
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE3_GATE_DISABLE, 1,
+					SYMCLK32_ROOT_SE3_GATE_DISABLE, 1);
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE3_SRC_SEL, phyd32clk,
+				SYMCLK32_SE3_EN, 1);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+void dccg31_disable_symclk32_se(
+		struct dccg *dccg,
+		int hpo_se_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* set refclk as the source for symclk32_se */
+	switch (hpo_se_inst) {
+	case 0:
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE0_SRC_SEL, 0,
+				SYMCLK32_SE0_EN, 0);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE0_GATE_DISABLE, 0,
+					SYMCLK32_ROOT_SE0_GATE_DISABLE, 0);
+		break;
+	case 1:
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE1_SRC_SEL, 0,
+				SYMCLK32_SE1_EN, 0);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE1_GATE_DISABLE, 0,
+					SYMCLK32_ROOT_SE1_GATE_DISABLE, 0);
+		break;
+	case 2:
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE2_SRC_SEL, 0,
+				SYMCLK32_SE2_EN, 0);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE2_GATE_DISABLE, 0,
+					SYMCLK32_ROOT_SE2_GATE_DISABLE, 0);
+		break;
+	case 3:
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE3_SRC_SEL, 0,
+				SYMCLK32_SE3_EN, 0);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE3_GATE_DISABLE, 0,
+					SYMCLK32_ROOT_SE3_GATE_DISABLE, 0);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+void dccg31_enable_symclk32_le(
+		struct dccg *dccg,
+		int hpo_le_inst,
+		enum phyd32clk_clock_source phyd32clk)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	phyd32clk = get_phy_mux_symclk(dccg_dcn, phyd32clk);
+
+	/* select one of the PHYD32CLKs as the source for symclk32_le */
+	switch (hpo_le_inst) {
+	case 0:
+		REG_UPDATE_2(SYMCLK32_LE_CNTL,
+				SYMCLK32_LE0_SRC_SEL, phyd32clk,
+				SYMCLK32_LE0_EN, 1);
+		break;
+	case 1:
+		REG_UPDATE_2(SYMCLK32_LE_CNTL,
+				SYMCLK32_LE1_SRC_SEL, phyd32clk,
+				SYMCLK32_LE1_EN, 1);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+void dccg31_disable_symclk32_le(
+		struct dccg *dccg,
+		int hpo_le_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* set refclk as the source for symclk32_le */
+	switch (hpo_le_inst) {
+	case 0:
+		REG_UPDATE_2(SYMCLK32_LE_CNTL,
+				SYMCLK32_LE0_SRC_SEL, 0,
+				SYMCLK32_LE0_EN, 0);
+		break;
+	case 1:
+		REG_UPDATE_2(SYMCLK32_LE_CNTL,
+				SYMCLK32_LE1_SRC_SEL, 0,
+				SYMCLK32_LE1_EN, 0);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+void dccg31_set_symclk32_le_root_clock_gating(
+		struct dccg *dccg,
+		int hpo_le_inst,
+		bool enable)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
+		return;
+
+	switch (hpo_le_inst) {
+	case 0:
+		REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+				SYMCLK32_LE0_GATE_DISABLE, enable ? 1 : 0,
+				SYMCLK32_ROOT_LE0_GATE_DISABLE, enable ? 1 : 0);
+		break;
+	case 1:
+		REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
+				SYMCLK32_LE1_GATE_DISABLE, enable ? 1 : 0,
+				SYMCLK32_ROOT_LE1_GATE_DISABLE, enable ? 1 : 0);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+void dccg31_disable_dscclk(struct dccg *dccg, int inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+		return;
+	//DTO must be enabled to generate a 0 Hz clock output
+	switch (inst) {
+	case 0:
+		REG_UPDATE(DSCCLK_DTO_CTRL,
+				DSCCLK0_DTO_ENABLE, 1);
+		REG_UPDATE_2(DSCCLK0_DTO_PARAM,
+				DSCCLK0_DTO_PHASE, 0,
+				DSCCLK0_DTO_MODULO, 1);
+		break;
+	case 1:
+		REG_UPDATE(DSCCLK_DTO_CTRL,
+				DSCCLK1_DTO_ENABLE, 1);
+		REG_UPDATE_2(DSCCLK1_DTO_PARAM,
+				DSCCLK1_DTO_PHASE, 0,
+				DSCCLK1_DTO_MODULO, 1);
+		break;
+	case 2:
+		REG_UPDATE(DSCCLK_DTO_CTRL,
+				DSCCLK2_DTO_ENABLE, 1);
+		REG_UPDATE_2(DSCCLK2_DTO_PARAM,
+				DSCCLK2_DTO_PHASE, 0,
+				DSCCLK2_DTO_MODULO, 1);
+		break;
+	case 3:
+		if (REG(DSCCLK3_DTO_PARAM)) {
+			REG_UPDATE(DSCCLK_DTO_CTRL,
+					DSCCLK3_DTO_ENABLE, 1);
+			REG_UPDATE_2(DSCCLK3_DTO_PARAM,
+					DSCCLK3_DTO_PHASE, 0,
+					DSCCLK3_DTO_MODULO, 1);
+		}
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+void dccg31_enable_dscclk(struct dccg *dccg, int inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+		return;
+	//Disable DTO
+	switch (inst) {
+	case 0:
+		REG_UPDATE_2(DSCCLK0_DTO_PARAM,
+				DSCCLK0_DTO_PHASE, 0,
+				DSCCLK0_DTO_MODULO, 0);
+		REG_UPDATE(DSCCLK_DTO_CTRL,
+				DSCCLK0_DTO_ENABLE, 0);
+		break;
+	case 1:
+		REG_UPDATE_2(DSCCLK1_DTO_PARAM,
+				DSCCLK1_DTO_PHASE, 0,
+				DSCCLK1_DTO_MODULO, 0);
+		REG_UPDATE(DSCCLK_DTO_CTRL,
+				DSCCLK1_DTO_ENABLE, 0);
+		break;
+	case 2:
+		REG_UPDATE_2(DSCCLK2_DTO_PARAM,
+				DSCCLK2_DTO_PHASE, 0,
+				DSCCLK2_DTO_MODULO, 0);
+		REG_UPDATE(DSCCLK_DTO_CTRL,
+				DSCCLK2_DTO_ENABLE, 0);
+		break;
+	case 3:
+		if (REG(DSCCLK3_DTO_PARAM)) {
+			REG_UPDATE(DSCCLK_DTO_CTRL,
+					DSCCLK3_DTO_ENABLE, 0);
+			REG_UPDATE_2(DSCCLK3_DTO_PARAM,
+					DSCCLK3_DTO_PHASE, 0,
+					DSCCLK3_DTO_MODULO, 0);
+		}
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+void dccg31_set_physymclk(
+		struct dccg *dccg,
+		int phy_inst,
+		enum physymclk_clock_source clk_src,
+		bool force_enable)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* Force PHYSYMCLK on and Select phyd32clk as the source of clock which is output to PHY through DCIO */
+	switch (phy_inst) {
+	case 0:
+		if (force_enable) {
+			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
+					PHYASYMCLK_FORCE_EN, 1,
+					PHYASYMCLK_FORCE_SRC_SEL, clk_src);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYASYMCLK_GATE_DISABLE, 1);
+		} else {
+			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
+					PHYASYMCLK_FORCE_EN, 0,
+					PHYASYMCLK_FORCE_SRC_SEL, 0);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYASYMCLK_GATE_DISABLE, 0);
+		}
+		break;
+	case 1:
+		if (force_enable) {
+			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
+					PHYBSYMCLK_FORCE_EN, 1,
+					PHYBSYMCLK_FORCE_SRC_SEL, clk_src);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYBSYMCLK_GATE_DISABLE, 1);
+		} else {
+			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
+					PHYBSYMCLK_FORCE_EN, 0,
+					PHYBSYMCLK_FORCE_SRC_SEL, 0);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYBSYMCLK_GATE_DISABLE, 0);
+		}
+		break;
+	case 2:
+		if (force_enable) {
+			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
+					PHYCSYMCLK_FORCE_EN, 1,
+					PHYCSYMCLK_FORCE_SRC_SEL, clk_src);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYCSYMCLK_GATE_DISABLE, 1);
+		} else {
+			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
+					PHYCSYMCLK_FORCE_EN, 0,
+					PHYCSYMCLK_FORCE_SRC_SEL, 0);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYCSYMCLK_GATE_DISABLE, 0);
+		}
+		break;
+	case 3:
+		if (force_enable) {
+			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
+					PHYDSYMCLK_FORCE_EN, 1,
+					PHYDSYMCLK_FORCE_SRC_SEL, clk_src);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYDSYMCLK_GATE_DISABLE, 1);
+		} else {
+			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
+					PHYDSYMCLK_FORCE_EN, 0,
+					PHYDSYMCLK_FORCE_SRC_SEL, 0);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYDSYMCLK_GATE_DISABLE, 0);
+		}
+		break;
+	case 4:
+		if (force_enable) {
+			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
+					PHYESYMCLK_FORCE_EN, 1,
+					PHYESYMCLK_FORCE_SRC_SEL, clk_src);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYESYMCLK_GATE_DISABLE, 1);
+		} else {
+			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
+					PHYESYMCLK_FORCE_EN, 0,
+					PHYESYMCLK_FORCE_SRC_SEL, 0);
+			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+					PHYESYMCLK_GATE_DISABLE, 0);
+		}
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+/* Controls the generation of pixel valid for OTG in (OTG -> HPO case) */
+void dccg31_set_dtbclk_dto(
+		struct dccg *dccg,
+		const struct dtbclk_dto_params *params)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	int req_dtbclk_khz = params->pixclk_khz;
+	uint32_t dtbdto_div;
+
+	/* Mode	                DTBDTO Rate       DTBCLK_DTO<x>_DIV Register
+	 * ODM 4:1 combine      pixel rate/4      2
+	 * ODM 2:1 combine      pixel rate/2      4
+	 * non-DSC 4:2:0 mode   pixel rate/2      4
+	 * DSC native 4:2:0     pixel rate/2      4
+	 * DSC native 4:2:2     pixel rate/2      4
+	 * Other modes          pixel rate        8
+	 */
+	if (params->num_odm_segments == 4) {
+		dtbdto_div = 2;
+		req_dtbclk_khz = params->pixclk_khz / 4;
+	} else if ((params->num_odm_segments == 2) ||
+			(params->timing->pixel_encoding == PIXEL_ENCODING_YCBCR420) ||
+			(params->timing->flags.DSC && params->timing->pixel_encoding == PIXEL_ENCODING_YCBCR422
+					&& !params->timing->dsc_cfg.ycbcr422_simple)) {
+		dtbdto_div = 4;
+		req_dtbclk_khz = params->pixclk_khz / 2;
+	} else
+		dtbdto_div = 8;
+
+	if (params->ref_dtbclk_khz && req_dtbclk_khz) {
+		uint32_t modulo, phase;
+
+		// phase / modulo = dtbclk / dtbclk ref
+		modulo = params->ref_dtbclk_khz * 1000;
+		phase = div_u64((((unsigned long long)modulo * req_dtbclk_khz) + params->ref_dtbclk_khz - 1),
+				params->ref_dtbclk_khz);
+
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLK_DTO_DIV[params->otg_inst], dtbdto_div);
+
+		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);
+		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);
+
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLK_DTO_ENABLE[params->otg_inst], 1);
+
+		REG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,
+				1, 100);
+
+		/* The recommended programming sequence to enable DTBCLK DTO to generate
+		 * valid pixel HPO DPSTREAM ENCODER, specifies that DTO source select should
+		 * be set only after DTO is enabled
+		 */
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				PIPE_DTO_SRC_SEL[params->otg_inst], 1);
+	} else {
+		REG_UPDATE_3(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLK_DTO_ENABLE[params->otg_inst], 0,
+				PIPE_DTO_SRC_SEL[params->otg_inst], 0,
+				DTBCLK_DTO_DIV[params->otg_inst], dtbdto_div);
+
+		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);
+		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);
+	}
+}
+
+void dccg31_set_audio_dtbclk_dto(
+		struct dccg *dccg,
+		const struct dtbclk_dto_params *params)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (params->ref_dtbclk_khz && params->req_audio_dtbclk_khz) {
+		uint32_t modulo, phase;
+
+		// phase / modulo = dtbclk / dtbclk ref
+		modulo = params->ref_dtbclk_khz * 1000;
+		phase = div_u64((((unsigned long long)modulo * params->req_audio_dtbclk_khz) + params->ref_dtbclk_khz - 1),
+			params->ref_dtbclk_khz);
+
+
+		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_MODULO, modulo);
+		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_PHASE, phase);
+
+		//REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
+		//		DCCG_AUDIO_DTBCLK_DTO_USE_512FBR_DTO, 1);
+
+		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
+				DCCG_AUDIO_DTO_SEL, 4);  //  04 - DCCG_AUDIO_DTO_SEL_AUDIO_DTO_DTBCLK
+	} else {
+		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_PHASE, 0);
+		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_MODULO, 0);
+
+		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
+				DCCG_AUDIO_DTO_SEL, 3);  //  03 - DCCG_AUDIO_DTO_SEL_NO_AUDIO_DTO
+	}
+}
+
+void dccg31_get_dccg_ref_freq(struct dccg *dccg,
+		unsigned int xtalin_freq_inKhz,
+		unsigned int *dccg_ref_freq_inKhz)
+{
+	/*
+	 * Assume refclk is sourced from xtalin
+	 * expect 24MHz
+	 */
+	*dccg_ref_freq_inKhz = xtalin_freq_inKhz;
+	return;
+}
+
+void dccg31_set_dispclk_change_mode(
+	struct dccg *dccg,
+	enum dentist_dispclk_change_mode change_mode)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_MODE,
+		   change_mode == DISPCLK_CHANGE_MODE_RAMPING ? 2 : 0);
+}
+
+void dccg31_init(struct dccg *dccg)
+{
+	/* Set HPO stream encoder to use refclk to avoid case where PHY is
+	 * disabled and SYMCLK32 for HPO SE is sourced from PHYD32CLK which
+	 * will cause DCN to hang.
+	 */
+	dccg31_disable_symclk32_se(dccg, 0);
+	dccg31_disable_symclk32_se(dccg, 1);
+	dccg31_disable_symclk32_se(dccg, 2);
+	dccg31_disable_symclk32_se(dccg, 3);
+
+	dccg31_set_symclk32_le_root_clock_gating(dccg, 0, false);
+	dccg31_set_symclk32_le_root_clock_gating(dccg, 1, false);
+
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
+		dccg31_disable_dpstreamclk(dccg, 0);
+		dccg31_disable_dpstreamclk(dccg, 1);
+		dccg31_disable_dpstreamclk(dccg, 2);
+		dccg31_disable_dpstreamclk(dccg, 3);
+	}
+
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk) {
+		dccg31_set_physymclk(dccg, 0, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
+		dccg31_set_physymclk(dccg, 1, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
+		dccg31_set_physymclk(dccg, 2, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
+		dccg31_set_physymclk(dccg, 3, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
+		dccg31_set_physymclk(dccg, 4, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
+	}
+}
+
+void dccg31_otg_add_pixel(struct dccg *dccg,
+				 uint32_t otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
+			OTG_ADD_PIXEL[otg_inst], 1);
+}
+
+void dccg31_otg_drop_pixel(struct dccg *dccg,
+				  uint32_t otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
+			OTG_DROP_PIXEL[otg_inst], 1);
+}
+
+static const struct dccg_funcs dccg31_funcs = {
+	.update_dpp_dto = dccg31_update_dpp_dto,
+	.get_dccg_ref_freq = dccg31_get_dccg_ref_freq,
+	.dccg_init = dccg31_init,
+	.set_dpstreamclk = dccg31_set_dpstreamclk,
+	.enable_symclk32_se = dccg31_enable_symclk32_se,
+	.disable_symclk32_se = dccg31_disable_symclk32_se,
+	.enable_symclk32_le = dccg31_enable_symclk32_le,
+	.disable_symclk32_le = dccg31_disable_symclk32_le,
+	.set_physymclk = dccg31_set_physymclk,
+	.set_dtbclk_dto = dccg31_set_dtbclk_dto,
+	.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,
+	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
+	.otg_add_pixel = dccg31_otg_add_pixel,
+	.otg_drop_pixel = dccg31_otg_drop_pixel,
+	.set_dispclk_change_mode = dccg31_set_dispclk_change_mode,
+	.disable_dsc = dccg31_disable_dscclk,
+	.enable_dsc = dccg31_enable_dscclk,
+};
+
+struct dccg *dccg31_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg31_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn31/dcn31_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn31/dcn31_dccg.h
new file mode 100644
index 000000000000..e3be0bab4007
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn31/dcn31_dccg.h
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN31_DCCG_H__
+#define __DCN31_DCCG_H__
+
+#include "dcn30/dcn30_dccg.h"
+
+#define DCCG_REG_LIST_DCN31() \
+	SR(DPPCLK_DTO_CTRL),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 2),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 3),\
+	DCCG_SRII(CLOCK_CNTL, HDMICHARCLK, 0),\
+	SR(PHYASYMCLK_CLOCK_CNTL),\
+	SR(PHYBSYMCLK_CLOCK_CNTL),\
+	SR(PHYCSYMCLK_CLOCK_CNTL),\
+	SR(PHYDSYMCLK_CLOCK_CNTL),\
+	SR(PHYESYMCLK_CLOCK_CNTL),\
+	SR(DPSTREAMCLK_CNTL),\
+	SR(HDMISTREAMCLK_CNTL),\
+	SR(SYMCLK32_SE_CNTL),\
+	SR(SYMCLK32_LE_CNTL),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 0),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 1),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 2),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 3),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 0),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 1),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 2),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 3),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 0),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 1),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 2),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 3),\
+	SR(DCCG_AUDIO_DTBCLK_DTO_MODULO),\
+	SR(DCCG_AUDIO_DTBCLK_DTO_PHASE),\
+	SR(DCCG_AUDIO_DTO_SOURCE),\
+	SR(DENTIST_DISPCLK_CNTL),\
+	SR(DSCCLK0_DTO_PARAM),\
+	SR(DSCCLK1_DTO_PARAM),\
+	SR(DSCCLK2_DTO_PARAM),\
+	SR(DSCCLK_DTO_CTRL),\
+	SR(DCCG_GATE_DISABLE_CNTL2),\
+	SR(DCCG_GATE_DISABLE_CNTL3),\
+	SR(HDMISTREAMCLK0_DTO_PARAM)
+
+
+#define DCCG_MASK_SH_LIST_DCN31(mask_sh) \
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE0_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE1_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE2_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE3_EN, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_DTO_FORCE_DIS, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_EN, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_MODE, mask_sh), \
+	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_MODULO, mask_sh),\
+	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_MODULO, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK0_DTO_ENABLE, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK1_DTO_ENABLE, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK2_DTO_ENABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYASYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYBSYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYCSYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYDSYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYESYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, DPSTREAMCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, DPSTREAMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE2_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE3_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_MODULO, mask_sh)
+
+
+struct dccg *dccg31_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+void dccg31_init(struct dccg *dccg);
+
+void dccg31_enable_symclk32_se(
+		struct dccg *dccg,
+		int hpo_se_inst,
+		enum phyd32clk_clock_source phyd32clk);
+
+void dccg31_disable_symclk32_se(
+		struct dccg *dccg,
+		int hpo_se_inst);
+
+void dccg31_enable_symclk32_le(
+		struct dccg *dccg,
+		int hpo_le_inst,
+		enum phyd32clk_clock_source phyd32clk);
+
+void dccg31_disable_symclk32_le(
+		struct dccg *dccg,
+		int hpo_le_inst);
+
+void dccg31_set_symclk32_le_root_clock_gating(
+		struct dccg *dccg,
+		int hpo_le_inst,
+		bool enable);
+
+void dccg31_set_physymclk(
+		struct dccg *dccg,
+		int phy_inst,
+		enum physymclk_clock_source clk_src,
+		bool force_enable);
+
+void dccg31_set_audio_dtbclk_dto(
+		struct dccg *dccg,
+		const struct dtbclk_dto_params *params);
+
+void dccg31_update_dpp_dto(
+	struct dccg *dccg,
+	int dpp_inst,
+	int req_dppclk);
+
+void dccg31_get_dccg_ref_freq(
+	struct dccg *dccg,
+	unsigned int xtalin_freq_inKhz,
+	unsigned int *dccg_ref_freq_inKhz);
+
+void dccg31_set_dpstreamclk(
+	struct dccg *dccg,
+	enum streamclk_source src,
+	int otg_inst,
+	int dp_hpo_inst);
+
+void dccg31_set_dtbclk_dto(
+		struct dccg *dccg,
+		const struct dtbclk_dto_params *params);
+
+void dccg31_otg_add_pixel(
+	struct dccg *dccg,
+	uint32_t otg_inst);
+
+void dccg31_otg_drop_pixel(
+	struct dccg *dccg,
+	uint32_t otg_inst);
+
+void dccg31_set_dispclk_change_mode(
+	struct dccg *dccg,
+	enum dentist_dispclk_change_mode change_mode);
+
+void dccg31_disable_dscclk(struct dccg *dccg, int inst);
+
+void dccg31_enable_dscclk(struct dccg *dccg, int inst);
+
+#endif //__DCN31_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn314/dcn314_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn314/dcn314_dccg.c
new file mode 100644
index 000000000000..17a1174b8d80
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn314/dcn314_dccg.c
@@ -0,0 +1,404 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright 2022 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "core_types.h"
+
+#include "dcn31/dcn31_dccg.h"
+#include "dcn314_dccg.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+static void dccg314_trigger_dio_fifo_resync(
+	struct dccg *dccg)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	uint32_t dispclk_rdivider_value = 0;
+
+	REG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, &dispclk_rdivider_value);
+	REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, dispclk_rdivider_value);
+}
+
+static void dccg314_get_pixel_rate_div(
+		struct dccg *dccg,
+		uint32_t otg_inst,
+		enum pixel_rate_div *k1,
+		enum pixel_rate_div *k2)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	uint32_t val_k1 = PIXEL_RATE_DIV_NA, val_k2 = PIXEL_RATE_DIV_NA;
+
+	*k1 = PIXEL_RATE_DIV_NA;
+	*k2 = PIXEL_RATE_DIV_NA;
+
+	switch (otg_inst) {
+	case 0:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG0_PIXEL_RATE_DIVK1, &val_k1,
+			OTG0_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	case 1:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG1_PIXEL_RATE_DIVK1, &val_k1,
+			OTG1_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	case 2:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG2_PIXEL_RATE_DIVK1, &val_k1,
+			OTG2_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	case 3:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG3_PIXEL_RATE_DIVK1, &val_k1,
+			OTG3_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	*k1 = (enum pixel_rate_div)val_k1;
+	*k2 = (enum pixel_rate_div)val_k2;
+}
+
+static void dccg314_set_pixel_rate_div(
+		struct dccg *dccg,
+		uint32_t otg_inst,
+		enum pixel_rate_div k1,
+		enum pixel_rate_div k2)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	enum pixel_rate_div cur_k1 = PIXEL_RATE_DIV_NA, cur_k2 = PIXEL_RATE_DIV_NA;
+
+	// Don't program 0xF into the register field. Not valid since
+	// K1 / K2 field is only 1 / 2 bits wide
+	if (k1 == PIXEL_RATE_DIV_NA || k2 == PIXEL_RATE_DIV_NA) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	dccg314_get_pixel_rate_div(dccg, otg_inst, &cur_k1, &cur_k2);
+	if (k1 == cur_k1 && k2 == cur_k2)
+		return;
+
+	switch (otg_inst) {
+	case 0:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG0_PIXEL_RATE_DIVK1, k1,
+				OTG0_PIXEL_RATE_DIVK2, k2);
+		break;
+	case 1:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG1_PIXEL_RATE_DIVK1, k1,
+				OTG1_PIXEL_RATE_DIVK2, k2);
+		break;
+	case 2:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG2_PIXEL_RATE_DIVK1, k1,
+				OTG2_PIXEL_RATE_DIVK2, k2);
+		break;
+	case 3:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG3_PIXEL_RATE_DIVK1, k1,
+				OTG3_PIXEL_RATE_DIVK2, k2);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+static void dccg314_set_dtbclk_p_src(
+		struct dccg *dccg,
+		enum streamclk_source src,
+		uint32_t otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	uint32_t p_src_sel = 0; /* selects dprefclk */
+
+	if (src == DTBCLK0)
+		p_src_sel = 2;  /* selects dtbclk0 */
+
+	switch (otg_inst) {
+	case 0:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P0_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P0_SRC_SEL, p_src_sel,
+					DTBCLK_P0_EN, 1);
+		break;
+	case 1:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P1_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P1_SRC_SEL, p_src_sel,
+					DTBCLK_P1_EN, 1);
+		break;
+	case 2:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P2_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P2_SRC_SEL, p_src_sel,
+					DTBCLK_P2_EN, 1);
+		break;
+	case 3:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P3_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P3_SRC_SEL, p_src_sel,
+					DTBCLK_P3_EN, 1);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+}
+
+/* Controls the generation of pixel valid for OTG in (OTG -> HPO case) */
+static void dccg314_set_dtbclk_dto(
+		struct dccg *dccg,
+		const struct dtbclk_dto_params *params)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	/* DTO Output Rate / Pixel Rate = 1/4 */
+	int req_dtbclk_khz = params->pixclk_khz / 4;
+
+	if (params->ref_dtbclk_khz && req_dtbclk_khz) {
+		uint32_t modulo, phase;
+
+		// phase / modulo = dtbclk / dtbclk ref
+		modulo = params->ref_dtbclk_khz * 1000;
+		phase = req_dtbclk_khz * 1000;
+
+		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);
+		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);
+
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLK_DTO_ENABLE[params->otg_inst], 1);
+
+		REG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,
+				1, 100);
+
+		/* program OTG_PIXEL_RATE_DIV for DIVK1 and DIVK2 fields */
+		dccg314_set_pixel_rate_div(dccg, params->otg_inst, PIXEL_RATE_DIV_BY_1, PIXEL_RATE_DIV_BY_1);
+
+		/* The recommended programming sequence to enable DTBCLK DTO to generate
+		 * valid pixel HPO DPSTREAM ENCODER, specifies that DTO source select should
+		 * be set only after DTO is enabled
+		 */
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				PIPE_DTO_SRC_SEL[params->otg_inst], 2);
+	} else {
+		REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLK_DTO_ENABLE[params->otg_inst], 0,
+				PIPE_DTO_SRC_SEL[params->otg_inst], 1);
+
+		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);
+		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);
+	}
+}
+
+void dccg314_set_dpstreamclk(
+		struct dccg *dccg,
+		enum streamclk_source src,
+		int otg_inst,
+		int dp_hpo_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* set the dtbclk_p source */
+	dccg314_set_dtbclk_p_src(dccg, src, otg_inst);
+
+	/* enabled to select one of the DTBCLKs for pipe */
+	switch (dp_hpo_inst) {
+	case 0:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL,
+					DPSTREAMCLK0_EN, (src == REFCLK) ? 0 : 1,
+					DPSTREAMCLK0_SRC_SEL, otg_inst);
+		break;
+	case 1:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL,
+					DPSTREAMCLK1_EN, (src == REFCLK) ? 0 : 1,
+					DPSTREAMCLK1_SRC_SEL, otg_inst);
+		break;
+	case 2:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL,
+					DPSTREAMCLK2_EN, (src == REFCLK) ? 0 : 1,
+					DPSTREAMCLK2_SRC_SEL, otg_inst);
+		break;
+	case 3:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL,
+					DPSTREAMCLK3_EN, (src == REFCLK) ? 0 : 1,
+					DPSTREAMCLK3_SRC_SEL, otg_inst);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+static void dccg314_init(struct dccg *dccg)
+{
+	int otg_inst;
+
+	/* Set HPO stream encoder to use refclk to avoid case where PHY is
+	 * disabled and SYMCLK32 for HPO SE is sourced from PHYD32CLK which
+	 * will cause DCN to hang.
+	 */
+	for (otg_inst = 0; otg_inst < 4; otg_inst++)
+		dccg31_disable_symclk32_se(dccg, otg_inst);
+
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
+		for (otg_inst = 0; otg_inst < 2; otg_inst++)
+			dccg31_disable_symclk32_le(dccg, otg_inst);
+
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
+		for (otg_inst = 0; otg_inst < 4; otg_inst++)
+			dccg314_set_dpstreamclk(dccg, REFCLK, otg_inst,
+						otg_inst);
+
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+		for (otg_inst = 0; otg_inst < 5; otg_inst++)
+			dccg31_set_physymclk(dccg, otg_inst,
+					     PHYSYMCLK_FORCE_SRC_SYMCLK, false);
+}
+
+static void dccg314_set_valid_pixel_rate(
+		struct dccg *dccg,
+		int ref_dtbclk_khz,
+		int otg_inst,
+		int pixclk_khz)
+{
+	struct dtbclk_dto_params dto_params = {0};
+
+	dto_params.ref_dtbclk_khz = ref_dtbclk_khz;
+	dto_params.otg_inst = otg_inst;
+	dto_params.pixclk_khz = pixclk_khz;
+
+	dccg314_set_dtbclk_dto(dccg, &dto_params);
+}
+
+static void dccg314_dpp_root_clock_control(
+		struct dccg *dccg,
+		unsigned int dpp_inst,
+		bool clock_on)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (dccg->dpp_clock_gated[dpp_inst] != clock_on)
+		return;
+
+	if (clock_on) {
+		/* turn off the DTO and leave phase/modulo at max */
+		REG_UPDATE(DPPCLK_DTO_CTRL, DPPCLK_DTO_ENABLE[dpp_inst], 0);
+		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
+			  DPPCLK0_DTO_PHASE, 0xFF,
+			  DPPCLK0_DTO_MODULO, 0xFF);
+	} else {
+		/* turn on the DTO to generate a 0hz clock */
+		REG_UPDATE(DPPCLK_DTO_CTRL, DPPCLK_DTO_ENABLE[dpp_inst], 1);
+		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
+			  DPPCLK0_DTO_PHASE, 0,
+			  DPPCLK0_DTO_MODULO, 1);
+	}
+
+	dccg->dpp_clock_gated[dpp_inst] = !clock_on;
+}
+
+static const struct dccg_funcs dccg314_funcs = {
+	.update_dpp_dto = dccg31_update_dpp_dto,
+	.dpp_root_clock_control = dccg314_dpp_root_clock_control,
+	.get_dccg_ref_freq = dccg31_get_dccg_ref_freq,
+	.dccg_init = dccg314_init,
+	.set_dpstreamclk = dccg314_set_dpstreamclk,
+	.enable_symclk32_se = dccg31_enable_symclk32_se,
+	.disable_symclk32_se = dccg31_disable_symclk32_se,
+	.enable_symclk32_le = dccg31_enable_symclk32_le,
+	.disable_symclk32_le = dccg31_disable_symclk32_le,
+	.set_symclk32_le_root_clock_gating = dccg31_set_symclk32_le_root_clock_gating,
+	.set_physymclk = dccg31_set_physymclk,
+	.set_dtbclk_dto = dccg314_set_dtbclk_dto,
+	.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,
+	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
+	.otg_add_pixel = dccg31_otg_add_pixel,
+	.otg_drop_pixel = dccg31_otg_drop_pixel,
+	.set_dispclk_change_mode = dccg31_set_dispclk_change_mode,
+	.disable_dsc = dccg31_disable_dscclk,
+	.enable_dsc = dccg31_enable_dscclk,
+	.set_pixel_rate_div = dccg314_set_pixel_rate_div,
+	.trigger_dio_fifo_resync = dccg314_trigger_dio_fifo_resync,
+	.set_valid_pixel_rate = dccg314_set_valid_pixel_rate,
+	.set_dtbclk_p_src = dccg314_set_dtbclk_p_src
+};
+
+struct dccg *dccg314_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg314_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn314/dcn314_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn314/dcn314_dccg.h
new file mode 100644
index 000000000000..60ea1d248deb
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn314/dcn314_dccg.h
@@ -0,0 +1,212 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright 2022 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN314_DCCG_H__
+#define __DCN314_DCCG_H__
+
+#include "dcn31/dcn31_dccg.h"
+
+#define DCCG_SFII(block, reg_name, field_prefix, field_name, inst, post_fix)\
+	.field_prefix ## _ ## field_name[inst] = block ## inst ## _ ## reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
+
+
+#define DCCG_REG_LIST_DCN314() \
+	SR(DPPCLK_DTO_CTRL),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 2),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 3),\
+	DCCG_SRII(CLOCK_CNTL, HDMICHARCLK, 0),\
+	SR(PHYASYMCLK_CLOCK_CNTL),\
+	SR(PHYBSYMCLK_CLOCK_CNTL),\
+	SR(PHYCSYMCLK_CLOCK_CNTL),\
+	SR(PHYDSYMCLK_CLOCK_CNTL),\
+	SR(PHYESYMCLK_CLOCK_CNTL),\
+	SR(DPSTREAMCLK_CNTL),\
+	SR(HDMISTREAMCLK_CNTL),\
+	SR(SYMCLK32_SE_CNTL),\
+	SR(SYMCLK32_LE_CNTL),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 0),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 1),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 2),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 3),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 0),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 1),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 2),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 3),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 0),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 1),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 2),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 3),\
+	SR(DCCG_AUDIO_DTBCLK_DTO_MODULO),\
+	SR(DCCG_AUDIO_DTBCLK_DTO_PHASE),\
+	SR(DCCG_AUDIO_DTO_SOURCE),\
+	SR(DENTIST_DISPCLK_CNTL),\
+	SR(DSCCLK0_DTO_PARAM),\
+	SR(DSCCLK1_DTO_PARAM),\
+	SR(DSCCLK2_DTO_PARAM),\
+	SR(DSCCLK3_DTO_PARAM),\
+	SR(DSCCLK_DTO_CTRL),\
+	SR(DCCG_GATE_DISABLE_CNTL2),\
+	SR(DCCG_GATE_DISABLE_CNTL3),\
+	SR(HDMISTREAMCLK0_DTO_PARAM),\
+	SR(OTG_PIXEL_RATE_DIV),\
+	SR(DTBCLK_P_CNTL),\
+	SR(DCCG_AUDIO_DTO_SOURCE)
+
+#define DCCG_MASK_SH_LIST_DCN314_COMMON(mask_sh) \
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_SRC_SEL, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_EN, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_EN, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_EN, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_EN, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_EN, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_EN, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_MODE, mask_sh),\
+	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_MODULO, mask_sh),\
+	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_MODULO, mask_sh),\
+	DCCG_SF(DSCCLK3_DTO_PARAM, DSCCLK3_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK3_DTO_PARAM, DSCCLK3_DTO_MODULO, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE2_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE3_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE2_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE3_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_LE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_LE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_MODULO, mask_sh)
+
+#define DCCG_MASK_SH_LIST_DCN314(mask_sh) \
+	DCCG_MASK_SH_LIST_DCN314_COMMON(mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_DTO_FORCE_DIS, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK0_DTO_ENABLE, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK1_DTO_ENABLE, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK2_DTO_ENABLE, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK3_DTO_ENABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYASYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYBSYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYCSYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYDSYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYESYMCLK_GATE_DISABLE, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, mask_sh)
+
+struct dccg *dccg314_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+void dccg314_set_dpstreamclk(
+		struct dccg *dccg,
+		enum streamclk_source src,
+		int otg_inst,
+		int dp_hpo_inst);
+
+#endif //__DCN314_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn32/dcn32_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn32/dcn32_dccg.c
new file mode 100644
index 000000000000..56385cede113
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn32/dcn32_dccg.c
@@ -0,0 +1,373 @@
+/*
+ * Copyright 2021 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "core_types.h"
+#include "dcn32_dccg.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+static void dccg32_trigger_dio_fifo_resync(
+	struct dccg *dccg)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	uint32_t dispclk_rdivider_value = 0;
+
+	REG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, &dispclk_rdivider_value);
+
+	/* Not valid for the WDIVIDER to be set to 0 */
+	if (dispclk_rdivider_value != 0)
+		REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, dispclk_rdivider_value);
+}
+
+static void dccg32_get_pixel_rate_div(
+		struct dccg *dccg,
+		uint32_t otg_inst,
+		enum pixel_rate_div *k1,
+		enum pixel_rate_div *k2)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	uint32_t val_k1 = PIXEL_RATE_DIV_NA, val_k2 = PIXEL_RATE_DIV_NA;
+
+	*k1 = PIXEL_RATE_DIV_NA;
+	*k2 = PIXEL_RATE_DIV_NA;
+
+	switch (otg_inst) {
+	case 0:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG0_PIXEL_RATE_DIVK1, &val_k1,
+			OTG0_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	case 1:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG1_PIXEL_RATE_DIVK1, &val_k1,
+			OTG1_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	case 2:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG2_PIXEL_RATE_DIVK1, &val_k1,
+			OTG2_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	case 3:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG3_PIXEL_RATE_DIVK1, &val_k1,
+			OTG3_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	*k1 = (enum pixel_rate_div)val_k1;
+	*k2 = (enum pixel_rate_div)val_k2;
+}
+
+static void dccg32_set_pixel_rate_div(
+		struct dccg *dccg,
+		uint32_t otg_inst,
+		enum pixel_rate_div k1,
+		enum pixel_rate_div k2)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	enum pixel_rate_div cur_k1 = PIXEL_RATE_DIV_NA, cur_k2 = PIXEL_RATE_DIV_NA;
+
+	// Don't program 0xF into the register field. Not valid since
+	// K1 / K2 field is only 1 / 2 bits wide
+	if (k1 == PIXEL_RATE_DIV_NA || k2 == PIXEL_RATE_DIV_NA) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	dccg32_get_pixel_rate_div(dccg, otg_inst, &cur_k1, &cur_k2);
+	if (k1 == cur_k1 && k2 == cur_k2)
+		return;
+
+	switch (otg_inst) {
+	case 0:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG0_PIXEL_RATE_DIVK1, k1,
+				OTG0_PIXEL_RATE_DIVK2, k2);
+		break;
+	case 1:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG1_PIXEL_RATE_DIVK1, k1,
+				OTG1_PIXEL_RATE_DIVK2, k2);
+		break;
+	case 2:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG2_PIXEL_RATE_DIVK1, k1,
+				OTG2_PIXEL_RATE_DIVK2, k2);
+		break;
+	case 3:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG3_PIXEL_RATE_DIVK1, k1,
+				OTG3_PIXEL_RATE_DIVK2, k2);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+static void dccg32_set_dtbclk_p_src(
+		struct dccg *dccg,
+		enum streamclk_source src,
+		uint32_t otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	uint32_t p_src_sel = 0; /* selects dprefclk */
+	if (src == DTBCLK0)
+		p_src_sel = 2;  /* selects dtbclk0 */
+
+	switch (otg_inst) {
+	case 0:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P0_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P0_SRC_SEL, p_src_sel,
+					DTBCLK_P0_EN, 1);
+		break;
+	case 1:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P1_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P1_SRC_SEL, p_src_sel,
+					DTBCLK_P1_EN, 1);
+		break;
+	case 2:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P2_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P2_SRC_SEL, p_src_sel,
+					DTBCLK_P2_EN, 1);
+		break;
+	case 3:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P3_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P3_SRC_SEL, p_src_sel,
+					DTBCLK_P3_EN, 1);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+}
+
+/* Controls the generation of pixel valid for OTG in (OTG -> HPO case) */
+static void dccg32_set_dtbclk_dto(
+		struct dccg *dccg,
+		const struct dtbclk_dto_params *params)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	/* DTO Output Rate / Pixel Rate = 1/4 */
+	int req_dtbclk_khz = params->pixclk_khz / 4;
+
+	if (params->ref_dtbclk_khz && req_dtbclk_khz) {
+		uint32_t modulo, phase;
+
+		// phase / modulo = dtbclk / dtbclk ref
+		modulo = params->ref_dtbclk_khz * 1000;
+		phase = req_dtbclk_khz * 1000;
+
+		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);
+		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);
+
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLK_DTO_ENABLE[params->otg_inst], 1);
+
+		REG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,
+				1, 100);
+
+		/* program OTG_PIXEL_RATE_DIV for DIVK1 and DIVK2 fields */
+		dccg32_set_pixel_rate_div(dccg, params->otg_inst, PIXEL_RATE_DIV_BY_1, PIXEL_RATE_DIV_BY_1);
+
+		/* The recommended programming sequence to enable DTBCLK DTO to generate
+		 * valid pixel HPO DPSTREAM ENCODER, specifies that DTO source select should
+		 * be set only after DTO is enabled
+		 */
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				PIPE_DTO_SRC_SEL[params->otg_inst], 2);
+	} else {
+		REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLK_DTO_ENABLE[params->otg_inst], 0,
+				PIPE_DTO_SRC_SEL[params->otg_inst], params->is_hdmi ? 0 : 1);
+		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);
+		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);
+	}
+}
+
+static void dccg32_set_valid_pixel_rate(
+		struct dccg *dccg,
+		int ref_dtbclk_khz,
+		int otg_inst,
+		int pixclk_khz)
+{
+	struct dtbclk_dto_params dto_params = {0};
+
+	dto_params.ref_dtbclk_khz = ref_dtbclk_khz;
+	dto_params.otg_inst = otg_inst;
+	dto_params.pixclk_khz = pixclk_khz;
+	dto_params.is_hdmi = true;
+
+	dccg32_set_dtbclk_dto(dccg, &dto_params);
+}
+
+static void dccg32_get_dccg_ref_freq(struct dccg *dccg,
+		unsigned int xtalin_freq_inKhz,
+		unsigned int *dccg_ref_freq_inKhz)
+{
+	/*
+	 * Assume refclk is sourced from xtalin
+	 * expect 100MHz
+	 */
+	*dccg_ref_freq_inKhz = xtalin_freq_inKhz;
+	return;
+}
+
+static void dccg32_set_dpstreamclk(
+		struct dccg *dccg,
+		enum streamclk_source src,
+		int otg_inst,
+		int dp_hpo_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* set the dtbclk_p source */
+	/* always program refclk as DTBCLK. No use-case expected to require DPREFCLK as refclk */
+	dccg32_set_dtbclk_p_src(dccg, DTBCLK0, otg_inst);
+
+	/* enabled to select one of the DTBCLKs for pipe */
+	switch (dp_hpo_inst) {
+	case 0:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL,
+			     DPSTREAMCLK0_EN,
+			     (src == REFCLK) ? 0 : 1, DPSTREAMCLK0_SRC_SEL, otg_inst);
+		break;
+	case 1:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN,
+			     (src == REFCLK) ? 0 : 1, DPSTREAMCLK1_SRC_SEL, otg_inst);
+		break;
+	case 2:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN,
+			     (src == REFCLK) ? 0 : 1, DPSTREAMCLK2_SRC_SEL, otg_inst);
+		break;
+	case 3:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN,
+			     (src == REFCLK) ? 0 : 1, DPSTREAMCLK3_SRC_SEL, otg_inst);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+static void dccg32_otg_add_pixel(struct dccg *dccg,
+		uint32_t otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
+			OTG_ADD_PIXEL[otg_inst], 1);
+}
+
+static void dccg32_otg_drop_pixel(struct dccg *dccg,
+		uint32_t otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
+			OTG_DROP_PIXEL[otg_inst], 1);
+}
+
+static const struct dccg_funcs dccg32_funcs = {
+	.update_dpp_dto = dccg2_update_dpp_dto,
+	.get_dccg_ref_freq = dccg32_get_dccg_ref_freq,
+	.dccg_init = dccg31_init,
+	.set_dpstreamclk = dccg32_set_dpstreamclk,
+	.enable_symclk32_se = dccg31_enable_symclk32_se,
+	.disable_symclk32_se = dccg31_disable_symclk32_se,
+	.enable_symclk32_le = dccg31_enable_symclk32_le,
+	.disable_symclk32_le = dccg31_disable_symclk32_le,
+	.set_physymclk = dccg31_set_physymclk,
+	.set_dtbclk_dto = dccg32_set_dtbclk_dto,
+	.set_valid_pixel_rate = dccg32_set_valid_pixel_rate,
+	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
+	.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,
+	.otg_add_pixel = dccg32_otg_add_pixel,
+	.otg_drop_pixel = dccg32_otg_drop_pixel,
+	.set_pixel_rate_div = dccg32_set_pixel_rate_div,
+	.trigger_dio_fifo_resync = dccg32_trigger_dio_fifo_resync,
+	.set_dtbclk_p_src = dccg32_set_dtbclk_p_src,
+};
+
+struct dccg *dccg32_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg32_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn32/dcn32_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn32/dcn32_dccg.h
new file mode 100644
index 000000000000..cf5508718122
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn32/dcn32_dccg.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2021 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN32_DCCG_H__
+#define __DCN32_DCCG_H__
+
+#include "dcn31/dcn31_dccg.h"
+
+#define DCCG_SFII(block, reg_name, field_prefix, field_name, inst, post_fix)\
+	.field_prefix ## _ ## field_name[inst] = block ## inst ## _ ## reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
+
+#define DCCG_MASK_SH_LIST_DCN32(mask_sh) \
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_SRC_SEL, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_EN, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_DTO_FORCE_DIS, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_EN, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_EN, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_EN, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_EN, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_EN, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_DONE, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, mask_sh)
+
+struct dccg *dccg32_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+#endif //__DCN32_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn35/dcn35_dccg.c b/drivers/gpu/drm/amd/display/dc/dccg/dcn35/dcn35_dccg.c
new file mode 100644
index 000000000000..02ec16bf381f
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn35/dcn35_dccg.c
@@ -0,0 +1,1051 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright 2023 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "reg_helper.h"
+#include "core_types.h"
+#include "dcn35_dccg.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+static void dccg35_trigger_dio_fifo_resync(struct dccg *dccg)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	uint32_t dispclk_rdivider_value = 0;
+
+	REG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, &dispclk_rdivider_value);
+	REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, dispclk_rdivider_value);
+}
+
+static void dcn35_set_dppclk_enable(struct dccg *dccg,
+				 uint32_t dpp_inst, uint32_t enable)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	switch (dpp_inst) {
+	case 0:
+		REG_UPDATE(DPPCLK_CTRL, DPPCLK0_EN, enable);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK0_ROOT_GATE_DISABLE, enable);
+		break;
+	case 1:
+		REG_UPDATE(DPPCLK_CTRL, DPPCLK1_EN, enable);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK1_ROOT_GATE_DISABLE, enable);
+		break;
+	case 2:
+		REG_UPDATE(DPPCLK_CTRL, DPPCLK2_EN, enable);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK2_ROOT_GATE_DISABLE, enable);
+		break;
+	case 3:
+		REG_UPDATE(DPPCLK_CTRL, DPPCLK3_EN, enable);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK3_ROOT_GATE_DISABLE, enable);
+		break;
+	default:
+		break;
+	}
+
+}
+
+static void dccg35_update_dpp_dto(struct dccg *dccg, int dpp_inst,
+				  int req_dppclk)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (dccg->dpp_clock_gated[dpp_inst]) {
+		/*
+		 * Do not update the DPPCLK DTO if the clock is stopped.
+		 */
+		return;
+	}
+
+	if (dccg->ref_dppclk && req_dppclk) {
+		int ref_dppclk = dccg->ref_dppclk;
+		int modulo, phase;
+
+		// phase / modulo = dpp pipe clk / dpp global clk
+		modulo = 0xff;   // use FF at the end
+		phase = ((modulo * req_dppclk) + ref_dppclk - 1) / ref_dppclk;
+
+		if (phase > 0xff) {
+			ASSERT(false);
+			phase = 0xff;
+		}
+
+		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
+				DPPCLK0_DTO_PHASE, phase,
+				DPPCLK0_DTO_MODULO, modulo);
+
+		dcn35_set_dppclk_enable(dccg, dpp_inst, true);
+	} else
+		dcn35_set_dppclk_enable(dccg, dpp_inst, false);
+	dccg->pipe_dppclk_khz[dpp_inst] = req_dppclk;
+}
+
+static void dccg35_set_dppclk_root_clock_gating(struct dccg *dccg,
+		 uint32_t dpp_inst, uint32_t enable)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
+		return;
+
+	switch (dpp_inst) {
+	case 0:
+		REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK0_ROOT_GATE_DISABLE, enable);
+		break;
+	case 1:
+		REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK1_ROOT_GATE_DISABLE, enable);
+		break;
+	case 2:
+		REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK2_ROOT_GATE_DISABLE, enable);
+		break;
+	case 3:
+		REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK3_ROOT_GATE_DISABLE, enable);
+		break;
+	default:
+		break;
+	}
+}
+
+static void dccg35_get_pixel_rate_div(
+		struct dccg *dccg,
+		uint32_t otg_inst,
+		enum pixel_rate_div *k1,
+		enum pixel_rate_div *k2)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	uint32_t val_k1 = PIXEL_RATE_DIV_NA, val_k2 = PIXEL_RATE_DIV_NA;
+
+	*k1 = PIXEL_RATE_DIV_NA;
+	*k2 = PIXEL_RATE_DIV_NA;
+
+	switch (otg_inst) {
+	case 0:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG0_PIXEL_RATE_DIVK1, &val_k1,
+			OTG0_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	case 1:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG1_PIXEL_RATE_DIVK1, &val_k1,
+			OTG1_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	case 2:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG2_PIXEL_RATE_DIVK1, &val_k1,
+			OTG2_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	case 3:
+		REG_GET_2(OTG_PIXEL_RATE_DIV,
+			OTG3_PIXEL_RATE_DIVK1, &val_k1,
+			OTG3_PIXEL_RATE_DIVK2, &val_k2);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	*k1 = (enum pixel_rate_div)val_k1;
+	*k2 = (enum pixel_rate_div)val_k2;
+}
+
+static void dccg35_set_pixel_rate_div(
+		struct dccg *dccg,
+		uint32_t otg_inst,
+		enum pixel_rate_div k1,
+		enum pixel_rate_div k2)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	enum pixel_rate_div cur_k1 = PIXEL_RATE_DIV_NA, cur_k2 = PIXEL_RATE_DIV_NA;
+
+	// Don't program 0xF into the register field. Not valid since
+	// K1 / K2 field is only 1 / 2 bits wide
+	if (k1 == PIXEL_RATE_DIV_NA || k2 == PIXEL_RATE_DIV_NA) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	dccg35_get_pixel_rate_div(dccg, otg_inst, &cur_k1, &cur_k2);
+	if (k1 == cur_k1 && k2 == cur_k2)
+		return;
+
+	switch (otg_inst) {
+	case 0:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG0_PIXEL_RATE_DIVK1, k1,
+				OTG0_PIXEL_RATE_DIVK2, k2);
+		break;
+	case 1:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG1_PIXEL_RATE_DIVK1, k1,
+				OTG1_PIXEL_RATE_DIVK2, k2);
+		break;
+	case 2:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG2_PIXEL_RATE_DIVK1, k1,
+				OTG2_PIXEL_RATE_DIVK2, k2);
+		break;
+	case 3:
+		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
+				OTG3_PIXEL_RATE_DIVK1, k1,
+				OTG3_PIXEL_RATE_DIVK2, k2);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+static void dccg35_set_dtbclk_p_src(
+		struct dccg *dccg,
+		enum streamclk_source src,
+		uint32_t otg_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	uint32_t p_src_sel = 0; /* selects dprefclk */
+	if (src == DTBCLK0)
+		p_src_sel = 2;  /* selects dtbclk0 */
+
+	switch (otg_inst) {
+	case 0:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P0_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P0_SRC_SEL, p_src_sel,
+					DTBCLK_P0_EN, 1);
+		break;
+	case 1:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P1_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P1_SRC_SEL, p_src_sel,
+					DTBCLK_P1_EN, 1);
+		break;
+	case 2:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P2_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P2_SRC_SEL, p_src_sel,
+					DTBCLK_P2_EN, 1);
+		break;
+	case 3:
+		if (src == REFCLK)
+			REG_UPDATE(DTBCLK_P_CNTL,
+					DTBCLK_P3_EN, 0);
+		else
+			REG_UPDATE_2(DTBCLK_P_CNTL,
+					DTBCLK_P3_SRC_SEL, p_src_sel,
+					DTBCLK_P3_EN, 1);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+}
+
+/* Controls the generation of pixel valid for OTG in (OTG -> HPO case) */
+static void dccg35_set_dtbclk_dto(
+		struct dccg *dccg,
+		const struct dtbclk_dto_params *params)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	/* DTO Output Rate / Pixel Rate = 1/4 */
+	int req_dtbclk_khz = params->pixclk_khz / 4;
+
+	if (params->ref_dtbclk_khz && req_dtbclk_khz) {
+		uint32_t modulo, phase;
+
+		switch (params->otg_inst) {
+		case 0:
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P0_GATE_DISABLE, 1);
+			break;
+		case 1:
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P1_GATE_DISABLE, 1);
+			break;
+		case 2:
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P2_GATE_DISABLE, 1);
+			break;
+		case 3:
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P3_GATE_DISABLE, 1);
+			break;
+		}
+
+		// phase / modulo = dtbclk / dtbclk ref
+		modulo = params->ref_dtbclk_khz * 1000;
+		phase = req_dtbclk_khz * 1000;
+
+		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);
+		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);
+
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLK_DTO_ENABLE[params->otg_inst], 1);
+
+		REG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,
+				1, 100);
+
+		/* program OTG_PIXEL_RATE_DIV for DIVK1 and DIVK2 fields */
+		dccg35_set_pixel_rate_div(dccg, params->otg_inst, PIXEL_RATE_DIV_BY_1, PIXEL_RATE_DIV_BY_1);
+
+		/* The recommended programming sequence to enable DTBCLK DTO to generate
+		 * valid pixel HPO DPSTREAM ENCODER, specifies that DTO source select should
+		 * be set only after DTO is enabled
+		 */
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				PIPE_DTO_SRC_SEL[params->otg_inst], 2);
+	} else {
+		switch (params->otg_inst) {
+		case 0:
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P0_GATE_DISABLE, 0);
+			break;
+		case 1:
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P1_GATE_DISABLE, 0);
+			break;
+		case 2:
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P2_GATE_DISABLE, 0);
+			break;
+		case 3:
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P3_GATE_DISABLE, 0);
+			break;
+		}
+
+		REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[params->otg_inst],
+				DTBCLK_DTO_ENABLE[params->otg_inst], 0,
+				PIPE_DTO_SRC_SEL[params->otg_inst], params->is_hdmi ? 0 : 1);
+
+		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);
+		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);
+	}
+}
+
+static void dccg35_set_dpstreamclk(
+		struct dccg *dccg,
+		enum streamclk_source src,
+		int otg_inst,
+		int dp_hpo_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* set the dtbclk_p source */
+	dccg35_set_dtbclk_p_src(dccg, src, otg_inst);
+
+	/* enabled to select one of the DTBCLKs for pipe */
+	switch (dp_hpo_inst) {
+	case 0:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK0_EN,
+				(src == REFCLK) ? 0 : 1, DPSTREAMCLK0_SRC_SEL, otg_inst);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_ROOT_GATE_DISABLE, (src == REFCLK) ? 0 : 1);
+		break;
+	case 1:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN,
+				(src == REFCLK) ? 0 : 1, DPSTREAMCLK1_SRC_SEL, otg_inst);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_ROOT_GATE_DISABLE, (src == REFCLK) ? 0 : 1);
+		break;
+	case 2:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN,
+				(src == REFCLK) ? 0 : 1, DPSTREAMCLK2_SRC_SEL, otg_inst);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_ROOT_GATE_DISABLE, (src == REFCLK) ? 0 : 1);
+		break;
+	case 3:
+		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN,
+				(src == REFCLK) ? 0 : 1, DPSTREAMCLK3_SRC_SEL, otg_inst);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_ROOT_GATE_DISABLE, (src == REFCLK) ? 0 : 1);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+
+static void dccg35_set_dpstreamclk_root_clock_gating(
+		struct dccg *dccg,
+		int dp_hpo_inst,
+		bool enable)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	switch (dp_hpo_inst) {
+	case 0:
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_ROOT_GATE_DISABLE, enable ? 1 : 0);
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_GATE_DISABLE, enable ? 1 : 0);
+		}
+		break;
+	case 1:
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_ROOT_GATE_DISABLE, enable ? 1 : 0);
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_GATE_DISABLE, enable ? 1 : 0);
+		}
+		break;
+	case 2:
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_ROOT_GATE_DISABLE, enable ? 1 : 0);
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_GATE_DISABLE, enable ? 1 : 0);
+		}
+		break;
+	case 3:
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_ROOT_GATE_DISABLE, enable ? 1 : 0);
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_GATE_DISABLE, enable ? 1 : 0);
+		}
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+
+
+static void dccg35_set_physymclk_root_clock_gating(
+		struct dccg *dccg,
+		int phy_inst,
+		bool enable)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
+		return;
+
+	switch (phy_inst) {
+	case 0:
+		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+				PHYASYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
+		break;
+	case 1:
+		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+				PHYBSYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
+		break;
+	case 2:
+		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+				PHYCSYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
+		break;
+	case 3:
+		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+				PHYDSYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
+		break;
+	case 4:
+		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
+				PHYESYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+static void dccg35_set_physymclk(
+		struct dccg *dccg,
+		int phy_inst,
+		enum physymclk_clock_source clk_src,
+		bool force_enable)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* Force PHYSYMCLK on and Select phyd32clk as the source of clock which is output to PHY through DCIO */
+	switch (phy_inst) {
+	case 0:
+		if (force_enable) {
+			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
+					PHYASYMCLK_EN, 1,
+					PHYASYMCLK_SRC_SEL, clk_src);
+		} else {
+			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
+					PHYASYMCLK_EN, 0,
+					PHYASYMCLK_SRC_SEL, 0);
+		}
+		break;
+	case 1:
+		if (force_enable) {
+			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
+					PHYBSYMCLK_EN, 1,
+					PHYBSYMCLK_SRC_SEL, clk_src);
+		} else {
+			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
+					PHYBSYMCLK_EN, 0,
+					PHYBSYMCLK_SRC_SEL, 0);
+		}
+		break;
+	case 2:
+		if (force_enable) {
+			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
+					PHYCSYMCLK_EN, 1,
+					PHYCSYMCLK_SRC_SEL, clk_src);
+		} else {
+			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
+					PHYCSYMCLK_EN, 0,
+					PHYCSYMCLK_SRC_SEL, 0);
+		}
+		break;
+	case 3:
+		if (force_enable) {
+			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
+					PHYDSYMCLK_EN, 1,
+					PHYDSYMCLK_SRC_SEL, clk_src);
+		} else {
+			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
+					PHYDSYMCLK_EN, 0,
+					PHYDSYMCLK_SRC_SEL, 0);
+		}
+		break;
+	case 4:
+		if (force_enable) {
+			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
+					PHYESYMCLK_EN, 1,
+					PHYESYMCLK_SRC_SEL, clk_src);
+		} else {
+			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
+					PHYESYMCLK_EN, 0,
+					PHYESYMCLK_SRC_SEL, 0);
+		}
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+static void dccg35_set_valid_pixel_rate(
+		struct dccg *dccg,
+		int ref_dtbclk_khz,
+		int otg_inst,
+		int pixclk_khz)
+{
+	struct dtbclk_dto_params dto_params = {0};
+
+	dto_params.ref_dtbclk_khz = ref_dtbclk_khz;
+	dto_params.otg_inst = otg_inst;
+	dto_params.pixclk_khz = pixclk_khz;
+	dto_params.is_hdmi = true;
+
+	dccg35_set_dtbclk_dto(dccg, &dto_params);
+}
+
+static void dccg35_dpp_root_clock_control(
+		struct dccg *dccg,
+		unsigned int dpp_inst,
+		bool clock_on)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (dccg->dpp_clock_gated[dpp_inst] == clock_on)
+		return;
+
+	if (clock_on) {
+		/* turn off the DTO and leave phase/modulo at max */
+		dcn35_set_dppclk_enable(dccg, dpp_inst, 1);
+		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
+			  DPPCLK0_DTO_PHASE, 0xFF,
+			  DPPCLK0_DTO_MODULO, 0xFF);
+	} else {
+		dcn35_set_dppclk_enable(dccg, dpp_inst, 0);
+		/* turn on the DTO to generate a 0hz clock */
+		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
+			  DPPCLK0_DTO_PHASE, 0,
+			  DPPCLK0_DTO_MODULO, 1);
+	}
+
+	dccg->dpp_clock_gated[dpp_inst] = !clock_on;
+}
+
+static void dccg35_disable_symclk32_se(
+		struct dccg *dccg,
+		int hpo_se_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* set refclk as the source for symclk32_se */
+	switch (hpo_se_inst) {
+	case 0:
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE0_SRC_SEL, 0,
+				SYMCLK32_SE0_EN, 0);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se) {
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE0_GATE_DISABLE, 0);
+//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
+//					SYMCLK32_ROOT_SE0_GATE_DISABLE, 0);
+		}
+		break;
+	case 1:
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE1_SRC_SEL, 0,
+				SYMCLK32_SE1_EN, 0);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se) {
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE1_GATE_DISABLE, 0);
+//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
+//					SYMCLK32_ROOT_SE1_GATE_DISABLE, 0);
+		}
+		break;
+	case 2:
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE2_SRC_SEL, 0,
+				SYMCLK32_SE2_EN, 0);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se) {
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE2_GATE_DISABLE, 0);
+//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
+//					SYMCLK32_ROOT_SE2_GATE_DISABLE, 0);
+		}
+		break;
+	case 3:
+		REG_UPDATE_2(SYMCLK32_SE_CNTL,
+				SYMCLK32_SE3_SRC_SEL, 0,
+				SYMCLK32_SE3_EN, 0);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se) {
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
+					SYMCLK32_SE3_GATE_DISABLE, 0);
+//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
+//					SYMCLK32_ROOT_SE3_GATE_DISABLE, 0);
+		}
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+void dccg35_init(struct dccg *dccg)
+{
+	int otg_inst;
+	/* Set HPO stream encoder to use refclk to avoid case where PHY is
+	 * disabled and SYMCLK32 for HPO SE is sourced from PHYD32CLK which
+	 * will cause DCN to hang.
+	 */
+	for (otg_inst = 0; otg_inst < 4; otg_inst++)
+		dccg35_disable_symclk32_se(dccg, otg_inst);
+
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
+		for (otg_inst = 0; otg_inst < 2; otg_inst++) {
+			dccg31_disable_symclk32_le(dccg, otg_inst);
+			dccg31_set_symclk32_le_root_clock_gating(dccg, otg_inst, false);
+		}
+
+//	if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+//		for (otg_inst = 0; otg_inst < 4; otg_inst++)
+//			dccg35_disable_symclk_se(dccg, otg_inst, otg_inst);
+
+
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
+		for (otg_inst = 0; otg_inst < 4; otg_inst++) {
+			dccg35_set_dpstreamclk(dccg, REFCLK, otg_inst,
+						otg_inst);
+			dccg35_set_dpstreamclk_root_clock_gating(dccg, otg_inst, false);
+		}
+
+	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
+		for (otg_inst = 0; otg_inst < 4; otg_inst++)
+			dccg35_set_dppclk_root_clock_gating(dccg, otg_inst, 0);
+
+/*
+	dccg35_enable_global_fgcg_rep(
+		dccg, dccg->ctx->dc->debug.enable_fine_grain_clock_gating.bits
+			      .dccg_global_fgcg_rep);*/
+}
+
+void dccg35_enable_global_fgcg_rep(struct dccg *dccg, bool value)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE(DCCG_GLOBAL_FGCG_REP_CNTL, DCCG_GLOBAL_FGCG_REP_DIS, !value);
+}
+
+static void dccg35_enable_dscclk(struct dccg *dccg, int inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	//Disable DTO
+	switch (inst) {
+	case 0:
+		REG_UPDATE_2(DSCCLK0_DTO_PARAM,
+				DSCCLK0_DTO_PHASE, 0,
+				DSCCLK0_DTO_MODULO, 0);
+		REG_UPDATE(DSCCLK_DTO_CTRL,	DSCCLK0_EN, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK0_ROOT_GATE_DISABLE, 1);
+		break;
+	case 1:
+		REG_UPDATE_2(DSCCLK1_DTO_PARAM,
+				DSCCLK1_DTO_PHASE, 0,
+				DSCCLK1_DTO_MODULO, 0);
+		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK1_EN, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK1_ROOT_GATE_DISABLE, 1);
+		break;
+	case 2:
+		REG_UPDATE_2(DSCCLK2_DTO_PARAM,
+				DSCCLK2_DTO_PHASE, 0,
+				DSCCLK2_DTO_MODULO, 0);
+		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK2_EN, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK2_ROOT_GATE_DISABLE, 1);
+		break;
+	case 3:
+		REG_UPDATE_2(DSCCLK3_DTO_PARAM,
+				DSCCLK3_DTO_PHASE, 0,
+				DSCCLK3_DTO_MODULO, 0);
+		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK3_EN, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK3_ROOT_GATE_DISABLE, 1);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+static void dccg35_disable_dscclk(struct dccg *dccg,
+				int inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+		return;
+
+	switch (inst) {
+	case 0:
+		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK0_EN, 0);
+		REG_UPDATE_2(DSCCLK0_DTO_PARAM,
+				DSCCLK0_DTO_PHASE, 0,
+				DSCCLK0_DTO_MODULO, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK0_ROOT_GATE_DISABLE, 0);
+		break;
+	case 1:
+		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK1_EN, 0);
+		REG_UPDATE_2(DSCCLK1_DTO_PARAM,
+				DSCCLK1_DTO_PHASE, 0,
+				DSCCLK1_DTO_MODULO, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK1_ROOT_GATE_DISABLE, 0);
+		break;
+	case 2:
+		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK2_EN, 0);
+		REG_UPDATE_2(DSCCLK2_DTO_PARAM,
+				DSCCLK2_DTO_PHASE, 0,
+				DSCCLK2_DTO_MODULO, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK2_ROOT_GATE_DISABLE, 0);
+		break;
+	case 3:
+		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK3_EN, 0);
+		REG_UPDATE_2(DSCCLK3_DTO_PARAM,
+				DSCCLK3_DTO_PHASE, 0,
+				DSCCLK3_DTO_MODULO, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK3_ROOT_GATE_DISABLE, 0);
+		break;
+	default:
+		return;
+	}
+}
+
+static void dccg35_enable_symclk_se(struct dccg *dccg, uint32_t stream_enc_inst, uint32_t link_enc_inst)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	switch (link_enc_inst) {
+	case 0:
+		REG_UPDATE(SYMCLKA_CLOCK_ENABLE,
+				SYMCLKA_CLOCK_ENABLE, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_ROOT_GATE_DISABLE, 1);
+		break;
+	case 1:
+		REG_UPDATE(SYMCLKB_CLOCK_ENABLE,
+				SYMCLKB_CLOCK_ENABLE, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_ROOT_GATE_DISABLE, 1);
+		break;
+	case 2:
+		REG_UPDATE(SYMCLKC_CLOCK_ENABLE,
+				SYMCLKC_CLOCK_ENABLE, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_ROOT_GATE_DISABLE, 1);
+		break;
+	case 3:
+		REG_UPDATE(SYMCLKD_CLOCK_ENABLE,
+				SYMCLKD_CLOCK_ENABLE, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_ROOT_GATE_DISABLE, 1);
+		break;
+	case 4:
+		REG_UPDATE(SYMCLKE_CLOCK_ENABLE,
+				SYMCLKE_CLOCK_ENABLE, 1);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_ROOT_GATE_DISABLE, 1);
+		break;
+	}
+
+	switch (stream_enc_inst) {
+	case 0:
+		REG_UPDATE_2(SYMCLKA_CLOCK_ENABLE,
+				SYMCLKA_FE_EN, 1,
+				SYMCLKA_FE_SRC_SEL, link_enc_inst);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_FE_ROOT_GATE_DISABLE, 1);
+		break;
+	case 1:
+		REG_UPDATE_2(SYMCLKB_CLOCK_ENABLE,
+				SYMCLKB_FE_EN, 1,
+				SYMCLKB_FE_SRC_SEL, link_enc_inst);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_FE_ROOT_GATE_DISABLE, 1);
+		break;
+	case 2:
+		REG_UPDATE_2(SYMCLKC_CLOCK_ENABLE,
+				SYMCLKC_FE_EN, 1,
+				SYMCLKC_FE_SRC_SEL, link_enc_inst);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_FE_ROOT_GATE_DISABLE, 1);
+		break;
+	case 3:
+		REG_UPDATE_2(SYMCLKD_CLOCK_ENABLE,
+				SYMCLKD_FE_EN, 1,
+				SYMCLKD_FE_SRC_SEL, link_enc_inst);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_FE_ROOT_GATE_DISABLE, 1);
+		break;
+	case 4:
+		REG_UPDATE_2(SYMCLKE_CLOCK_ENABLE,
+				SYMCLKE_FE_EN, 1,
+				SYMCLKE_FE_SRC_SEL, link_enc_inst);
+		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_FE_ROOT_GATE_DISABLE, 1);
+		break;
+	}
+}
+
+/*get other front end connected to this backend*/
+static uint8_t dccg35_get_other_enabled_symclk_fe(struct dccg *dccg, uint32_t stream_enc_inst, uint32_t link_enc_inst)
+{
+	uint8_t num_enabled_symclk_fe = 0;
+	uint32_t be_clk_en = 0, fe_clk_en[5] = {0}, be_clk_sel[5] = {0};
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	switch (link_enc_inst) {
+	case 0:
+		REG_GET_3(SYMCLKA_CLOCK_ENABLE, SYMCLKA_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKA_FE_EN, &fe_clk_en[0],
+				SYMCLKA_FE_SRC_SEL, &be_clk_sel[0]);
+				break;
+	case 1:
+		REG_GET_3(SYMCLKB_CLOCK_ENABLE, SYMCLKB_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKB_FE_EN, &fe_clk_en[1],
+				SYMCLKB_FE_SRC_SEL, &be_clk_sel[1]);
+				break;
+	case 2:
+			REG_GET_3(SYMCLKC_CLOCK_ENABLE, SYMCLKC_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKC_FE_EN, &fe_clk_en[2],
+				SYMCLKC_FE_SRC_SEL, &be_clk_sel[2]);
+				break;
+	case 3:
+			REG_GET_3(SYMCLKD_CLOCK_ENABLE, SYMCLKD_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKD_FE_EN, &fe_clk_en[3],
+				SYMCLKD_FE_SRC_SEL, &be_clk_sel[3]);
+				break;
+	case 4:
+			REG_GET_3(SYMCLKE_CLOCK_ENABLE, SYMCLKE_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKE_FE_EN, &fe_clk_en[4],
+				SYMCLKE_FE_SRC_SEL, &be_clk_sel[4]);
+				break;
+	}
+	if (be_clk_en) {
+	/* for DPMST, this backend could be used by multiple front end.
+	only disable the backend if this stream_enc_ins is the last active stream enc connected to this back_end*/
+		uint8_t i;
+		for (i = 0; i != link_enc_inst && i < sizeof(fe_clk_en); i++) {
+			if (fe_clk_en[i] && be_clk_sel[i] == link_enc_inst)
+				num_enabled_symclk_fe++;
+		}
+	}
+	return num_enabled_symclk_fe;
+}
+
+static void dccg35_disable_symclk_se(struct dccg *dccg, uint32_t stream_enc_inst, uint32_t link_enc_inst)
+{
+	uint8_t num_enabled_symclk_fe = 0;
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	switch (stream_enc_inst) {
+	case 0:
+		REG_UPDATE_2(SYMCLKA_CLOCK_ENABLE,
+				SYMCLKA_FE_EN, 0,
+				SYMCLKA_FE_SRC_SEL, 0);
+//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_FE_ROOT_GATE_DISABLE, 0);
+		break;
+	case 1:
+		REG_UPDATE_2(SYMCLKB_CLOCK_ENABLE,
+				SYMCLKB_FE_EN, 0,
+				SYMCLKB_FE_SRC_SEL, 0);
+//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_FE_ROOT_GATE_DISABLE, 0);
+		break;
+	case 2:
+		REG_UPDATE_2(SYMCLKC_CLOCK_ENABLE,
+				SYMCLKC_FE_EN, 0,
+				SYMCLKC_FE_SRC_SEL, 0);
+//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_FE_ROOT_GATE_DISABLE, 0);
+		break;
+	case 3:
+		REG_UPDATE_2(SYMCLKD_CLOCK_ENABLE,
+				SYMCLKD_FE_EN, 0,
+				SYMCLKD_FE_SRC_SEL, 0);
+//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_FE_ROOT_GATE_DISABLE, 0);
+		break;
+	case 4:
+		REG_UPDATE_2(SYMCLKE_CLOCK_ENABLE,
+				SYMCLKE_FE_EN, 0,
+				SYMCLKE_FE_SRC_SEL, 0);
+//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
+//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_FE_ROOT_GATE_DISABLE, 0);
+		break;
+	}
+
+	/*check other enabled symclk fe */
+	num_enabled_symclk_fe = dccg35_get_other_enabled_symclk_fe(dccg, stream_enc_inst, link_enc_inst);
+	/*only turn off backend clk if other front end attachecd to this backend are all off,
+	 for mst, only turn off the backend if this is the last front end*/
+	if (num_enabled_symclk_fe == 0) {
+		switch (link_enc_inst) {
+		case 0:
+			REG_UPDATE(SYMCLKA_CLOCK_ENABLE,
+					SYMCLKA_CLOCK_ENABLE, 0);
+//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
+//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_ROOT_GATE_DISABLE, 0);
+			break;
+		case 1:
+			REG_UPDATE(SYMCLKB_CLOCK_ENABLE,
+					SYMCLKB_CLOCK_ENABLE, 0);
+//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
+//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_ROOT_GATE_DISABLE, 0);
+			break;
+		case 2:
+			REG_UPDATE(SYMCLKC_CLOCK_ENABLE,
+					SYMCLKC_CLOCK_ENABLE, 0);
+//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
+//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_ROOT_GATE_DISABLE, 0);
+			break;
+		case 3:
+			REG_UPDATE(SYMCLKD_CLOCK_ENABLE,
+					SYMCLKD_CLOCK_ENABLE, 0);
+//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
+//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_ROOT_GATE_DISABLE, 0);
+			break;
+		case 4:
+			REG_UPDATE(SYMCLKE_CLOCK_ENABLE,
+					SYMCLKE_CLOCK_ENABLE, 0);
+//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
+//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_ROOT_GATE_DISABLE, 0);
+			break;
+		}
+	}
+}
+
+static const struct dccg_funcs dccg35_funcs = {
+	.update_dpp_dto = dccg35_update_dpp_dto,
+	.dpp_root_clock_control = dccg35_dpp_root_clock_control,
+	.get_dccg_ref_freq = dccg31_get_dccg_ref_freq,
+	.dccg_init = dccg35_init,
+	.set_dpstreamclk = dccg35_set_dpstreamclk,
+	.set_dpstreamclk_root_clock_gating = dccg35_set_dpstreamclk_root_clock_gating,
+	.enable_symclk32_se = dccg31_enable_symclk32_se,
+	.disable_symclk32_se = dccg35_disable_symclk32_se,
+	.enable_symclk32_le = dccg31_enable_symclk32_le,
+	.disable_symclk32_le = dccg31_disable_symclk32_le,
+	.set_symclk32_le_root_clock_gating = dccg31_set_symclk32_le_root_clock_gating,
+	.set_physymclk = dccg35_set_physymclk,
+	.set_physymclk_root_clock_gating = dccg35_set_physymclk_root_clock_gating,
+	.set_dtbclk_dto = dccg35_set_dtbclk_dto,
+	.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,
+	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
+	.otg_add_pixel = dccg31_otg_add_pixel,
+	.otg_drop_pixel = dccg31_otg_drop_pixel,
+	.set_dispclk_change_mode = dccg31_set_dispclk_change_mode,
+	.disable_dsc = dccg35_disable_dscclk,
+	.enable_dsc = dccg35_enable_dscclk,
+	.set_pixel_rate_div = dccg35_set_pixel_rate_div,
+	.trigger_dio_fifo_resync = dccg35_trigger_dio_fifo_resync,
+	.set_valid_pixel_rate = dccg35_set_valid_pixel_rate,
+	.enable_symclk_se = dccg35_enable_symclk_se,
+	.disable_symclk_se = dccg35_disable_symclk_se,
+	.set_dtbclk_p_src = dccg35_set_dtbclk_p_src,
+};
+
+struct dccg *dccg35_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg35_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dccg/dcn35/dcn35_dccg.h b/drivers/gpu/drm/amd/display/dc/dccg/dcn35/dcn35_dccg.h
new file mode 100644
index 000000000000..1586a45ca3bd
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dccg/dcn35/dcn35_dccg.h
@@ -0,0 +1,246 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright 2023 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __DCN35_DCCG_H__
+#define __DCN35_DCCG_H__
+
+#include "dcn314/dcn314_dccg.h"
+
+#define DCCG_SFII(block, reg_name, field_prefix, field_name, inst, post_fix)\
+	.field_prefix ## _ ## field_name[inst] = block ## inst ## _ ## reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
+
+
+#define DCCG_REG_LIST_DCN35() \
+	DCCG_REG_LIST_DCN314(),\
+	SR(DPPCLK_CTRL),\
+	SR(DCCG_GATE_DISABLE_CNTL4),\
+	SR(DCCG_GATE_DISABLE_CNTL5),\
+	SR(DCCG_GATE_DISABLE_CNTL6),\
+	SR(DCCG_GLOBAL_FGCG_REP_CNTL),\
+	SR(SYMCLKA_CLOCK_ENABLE),\
+	SR(SYMCLKB_CLOCK_ENABLE),\
+	SR(SYMCLKC_CLOCK_ENABLE),\
+	SR(SYMCLKD_CLOCK_ENABLE),\
+	SR(SYMCLKE_CLOCK_ENABLE)
+
+#define DCCG_MASK_SH_LIST_DCN35(mask_sh) \
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
+	DCCG_SF(DPPCLK_CTRL, DPPCLK0_EN, mask_sh),\
+	DCCG_SF(DPPCLK_CTRL, DPPCLK1_EN, mask_sh),\
+	DCCG_SF(DPPCLK_CTRL, DPPCLK2_EN, mask_sh),\
+	DCCG_SF(DPPCLK_CTRL, DPPCLK3_EN, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
+	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_EN, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_EN, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_EN, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_EN, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_SRC_SEL, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_EN, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_SRC_SEL, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK0_EN, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK1_EN, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK2_EN, mask_sh),\
+	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK3_EN, mask_sh),\
+	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_MODULO, mask_sh),\
+	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_MODULO, mask_sh),\
+	DCCG_SF(DSCCLK3_DTO_PARAM, DSCCLK3_DTO_PHASE, mask_sh),\
+	DCCG_SF(DSCCLK3_DTO_PARAM, DSCCLK3_DTO_MODULO, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_EN, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK1, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 3, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_EN, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_EN, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_EN, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_SRC_SEL, mask_sh),\
+	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_EN, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_EN, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_EN, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_EN, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_EN, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_EN, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_SRC_SEL, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_DONE, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYASYMCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYBSYMCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYCSYMCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYDSYMCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYESYMCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GLOBAL_FGCG_REP_CNTL, DCCG_GLOBAL_FGCG_REP_DIS, mask_sh),\
+	DCCG_SF(SYMCLKA_CLOCK_ENABLE, SYMCLKA_CLOCK_ENABLE, mask_sh),\
+	DCCG_SF(SYMCLKB_CLOCK_ENABLE, SYMCLKB_CLOCK_ENABLE, mask_sh),\
+	DCCG_SF(SYMCLKC_CLOCK_ENABLE, SYMCLKC_CLOCK_ENABLE, mask_sh),\
+	DCCG_SF(SYMCLKD_CLOCK_ENABLE, SYMCLKD_CLOCK_ENABLE, mask_sh),\
+	DCCG_SF(SYMCLKE_CLOCK_ENABLE, SYMCLKE_CLOCK_ENABLE, mask_sh),\
+	DCCG_SF(SYMCLKA_CLOCK_ENABLE, SYMCLKA_FE_EN, mask_sh),\
+	DCCG_SF(SYMCLKB_CLOCK_ENABLE, SYMCLKB_FE_EN, mask_sh),\
+	DCCG_SF(SYMCLKC_CLOCK_ENABLE, SYMCLKC_FE_EN, mask_sh),\
+	DCCG_SF(SYMCLKD_CLOCK_ENABLE, SYMCLKD_FE_EN, mask_sh),\
+	DCCG_SF(SYMCLKE_CLOCK_ENABLE, SYMCLKE_FE_EN, mask_sh),\
+	DCCG_SF(SYMCLKA_CLOCK_ENABLE, SYMCLKA_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLKB_CLOCK_ENABLE, SYMCLKB_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLKC_CLOCK_ENABLE, SYMCLKC_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLKD_CLOCK_ENABLE, SYMCLKD_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLKE_CLOCK_ENABLE, SYMCLKE_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLKA_CLOCK_ENABLE, SYMCLKA_FE_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLKB_CLOCK_ENABLE, SYMCLKB_FE_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLKC_CLOCK_ENABLE, SYMCLKC_FE_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLKD_CLOCK_ENABLE, SYMCLKD_FE_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLKE_CLOCK_ENABLE, SYMCLKE_FE_SRC_SEL, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P2_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P3_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DSCCLK0_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DSCCLK1_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DSCCLK2_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DSCCLK3_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_FE_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_FE_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_FE_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_FE_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_FE_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DPPCLK0_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DPPCLK1_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DPPCLK2_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DPPCLK3_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, HDMICHARCLK0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, HDMICHARCLK0_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, HDMISTREAMCLK0_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE2_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE3_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE2_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE3_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_LE0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_LE1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYA_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYB_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYC_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYD_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYE_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_ROOT_GATE_DISABLE, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL, DISPCLK_DCCG_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, HDMISTREAMCLK0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_GATE_DISABLE, mask_sh),\
+	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_GATE_DISABLE, mask_sh),\
+
+struct dccg *dccg35_create(
+		struct dc_context *ctx,
+		const struct dccg_registers *regs,
+		const struct dccg_shift *dccg_shift,
+		const struct dccg_mask *dccg_mask);
+
+void dccg35_init(struct dccg *dccg);
+
+void dccg35_enable_global_fgcg_rep(struct dccg *dccg, bool value);
+
+
+#endif //__DCN35_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/Makefile b/drivers/gpu/drm/amd/display/dc/dcn20/Makefile
index c78f3b0ff4fb..33cbd871eb3a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/Makefile
@@ -3,7 +3,7 @@
 
 DCN20 = dcn20_hubp.o \
 		dcn20_mpc.o dcn20_opp.o dcn20_mmhubbub.o \
-		dcn20_stream_encoder.o dcn20_link_encoder.o dcn20_dccg.o \
+		dcn20_stream_encoder.o dcn20_link_encoder.o \
 		dcn20_vmid.o dcn20_dwb.o dcn20_dwb_scl.o
 
 AMD_DAL_DCN20 = $(addprefix $(AMDDALPATH)/dc/dcn20/,$(DCN20))
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.c
deleted file mode 100644
index 5999b2da3a01..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.c
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright 2018 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include <linux/slab.h>
-
-#include "reg_helper.h"
-#include "core_types.h"
-#include "dcn20_dccg.h"
-
-#define TO_DCN_DCCG(dccg)\
-	container_of(dccg, struct dcn_dccg, base)
-
-#define REG(reg) \
-	(dccg_dcn->regs->reg)
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
-
-#define CTX \
-	dccg_dcn->base.ctx
-#define DC_LOGGER \
-	dccg->ctx->logger
-
-void dccg2_update_dpp_dto(struct dccg *dccg, int dpp_inst, int req_dppclk)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (dccg->ref_dppclk && req_dppclk) {
-		int ref_dppclk = dccg->ref_dppclk;
-		int modulo, phase;
-
-		// phase / modulo = dpp pipe clk / dpp global clk
-		modulo = 0xff;   // use FF at the end
-		phase = ((modulo * req_dppclk) + ref_dppclk - 1) / ref_dppclk;
-
-		if (phase > 0xff) {
-			ASSERT(false);
-			phase = 0xff;
-		}
-
-		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
-				DPPCLK0_DTO_PHASE, phase,
-				DPPCLK0_DTO_MODULO, modulo);
-		REG_UPDATE(DPPCLK_DTO_CTRL,
-				DPPCLK_DTO_ENABLE[dpp_inst], 1);
-	} else {
-		REG_UPDATE(DPPCLK_DTO_CTRL,
-				DPPCLK_DTO_ENABLE[dpp_inst], 0);
-	}
-
-	dccg->pipe_dppclk_khz[dpp_inst] = req_dppclk;
-}
-
-void dccg2_get_dccg_ref_freq(struct dccg *dccg,
-		unsigned int xtalin_freq_inKhz,
-		unsigned int *dccg_ref_freq_inKhz)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	uint32_t clk_en = 0;
-	uint32_t clk_sel = 0;
-
-	REG_GET_2(REFCLK_CNTL, REFCLK_CLOCK_EN, &clk_en, REFCLK_SRC_SEL, &clk_sel);
-
-	if (clk_en != 0) {
-		// DCN20 has never been validated for non-xtalin as reference
-		// frequency.  There's actually no way for DC to determine what
-		// frequency a non-xtalin source is.
-		ASSERT_CRITICAL(false);
-	}
-
-	*dccg_ref_freq_inKhz = xtalin_freq_inKhz;
-
-	return;
-}
-
-void dccg2_set_fifo_errdet_ovr_en(struct dccg *dccg,
-		bool en)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	REG_UPDATE(DISPCLK_FREQ_CHANGE_CNTL,
-			DCCG_FIFO_ERRDET_OVR_EN, en ? 1 : 0);
-}
-
-void dccg2_otg_add_pixel(struct dccg *dccg,
-		uint32_t otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[otg_inst],
-			OTG_ADD_PIXEL[otg_inst], 0,
-			OTG_DROP_PIXEL[otg_inst], 0);
-	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
-			OTG_ADD_PIXEL[otg_inst], 1);
-}
-
-void dccg2_otg_drop_pixel(struct dccg *dccg,
-		uint32_t otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[otg_inst],
-			OTG_ADD_PIXEL[otg_inst], 0,
-			OTG_DROP_PIXEL[otg_inst], 0);
-	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
-			OTG_DROP_PIXEL[otg_inst], 1);
-}
-
-void dccg2_init(struct dccg *dccg)
-{
-}
-
-static const struct dccg_funcs dccg2_funcs = {
-	.update_dpp_dto = dccg2_update_dpp_dto,
-	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
-	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
-	.otg_add_pixel = dccg2_otg_add_pixel,
-	.otg_drop_pixel = dccg2_otg_drop_pixel,
-	.dccg_init = dccg2_init
-};
-
-struct dccg *dccg2_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_ATOMIC);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg2_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
-
-void dcn_dccg_destroy(struct dccg **dccg)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(*dccg);
-
-	kfree(dccg_dcn);
-	*dccg = NULL;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h
deleted file mode 100644
index 1e0292861244..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h
+++ /dev/null
@@ -1,455 +0,0 @@
-/*
- * Copyright 2018 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DCN20_DCCG_H__
-#define __DCN20_DCCG_H__
-
-#include "dccg.h"
-
-#define DCCG_COMMON_REG_LIST_DCN_BASE() \
-	SR(DPPCLK_DTO_CTRL),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 2),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 3),\
-	SR(REFCLK_CNTL),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 0),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 1),\
-	SR(DISPCLK_FREQ_CHANGE_CNTL)
-
-#define DCCG_REG_LIST_DCN2() \
-	DCCG_COMMON_REG_LIST_DCN_BASE(),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 4),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 5),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 2),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 3),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 4),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 5)
-
-#define DCCG_SF(reg_name, field_name, post_fix)\
-	.field_name = reg_name ## __ ## field_name ## post_fix
-
-#define DCCG_SFI(reg_name, field_name, field_prefix, inst, post_fix)\
-	.field_prefix ## _ ## field_name[inst] = reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
-
-#define DCCG_SFII(block, reg_name, field_prefix, field_name, inst, post_fix)\
-	.field_prefix ## _ ## field_name[inst] = block ## inst ## _ ## reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
-
-#define DCCG_COMMON_MASK_SH_LIST_DCN_COMMON_BASE(mask_sh) \
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(REFCLK_CNTL, REFCLK_CLOCK_EN, mask_sh),\
-	DCCG_SF(REFCLK_CNTL, REFCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_STEP_DELAY, mask_sh),\
-	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_STEP_SIZE, mask_sh),\
-	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_FREQ_RAMP_DONE, mask_sh),\
-	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_MAX_ERRDET_CYCLES, mask_sh),\
-	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_RESET, mask_sh),\
-	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_STATE, mask_sh),\
-	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_OVR_EN, mask_sh),\
-	DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_CHG_FWD_CORR_DISABLE, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 1, mask_sh)
-
-
-
-
-#define DCCG_MASK_SH_LIST_DCN2(mask_sh) \
-	DCCG_COMMON_MASK_SH_LIST_DCN_COMMON_BASE(mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 4, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 4, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 5, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 5, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 4, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 5, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 4, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 5, mask_sh)
-
-#define DCCG_MASK_SH_LIST_DCN2_1(mask_sh) \
-	DCCG_COMMON_MASK_SH_LIST_DCN_COMMON_BASE(mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 4, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 4, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 5, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 5, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 3, mask_sh)
-
-
-#define DCCG_REG_FIELD_LIST(type) \
-	type DPPCLK0_DTO_PHASE;\
-	type DPPCLK0_DTO_MODULO;\
-	type DPPCLK_DTO_ENABLE[6];\
-	type DPPCLK_DTO_DB_EN[6];\
-	type REFCLK_CLOCK_EN;\
-	type REFCLK_SRC_SEL;\
-	type DISPCLK_STEP_DELAY;\
-	type DISPCLK_STEP_SIZE;\
-	type DISPCLK_FREQ_RAMP_DONE;\
-	type DISPCLK_MAX_ERRDET_CYCLES;\
-	type DCCG_FIFO_ERRDET_RESET;\
-	type DCCG_FIFO_ERRDET_STATE;\
-	type DCCG_FIFO_ERRDET_OVR_EN;\
-	type DISPCLK_CHG_FWD_CORR_DISABLE;\
-	type DISPCLK_FREQ_CHANGE_CNTL;\
-	type OTG_ADD_PIXEL[MAX_PIPES];\
-	type OTG_DROP_PIXEL[MAX_PIPES];
-
-#define DCCG3_REG_FIELD_LIST(type) \
-	type HDMICHARCLK0_EN;\
-	type HDMICHARCLK0_SRC_SEL;\
-	type PHYASYMCLK_FORCE_EN;\
-	type PHYASYMCLK_FORCE_SRC_SEL;\
-	type PHYBSYMCLK_FORCE_EN;\
-	type PHYBSYMCLK_FORCE_SRC_SEL;\
-	type PHYCSYMCLK_FORCE_EN;\
-	type PHYCSYMCLK_FORCE_SRC_SEL;
-
-#define DCCG31_REG_FIELD_LIST(type) \
-	type PHYDSYMCLK_FORCE_EN;\
-	type PHYDSYMCLK_FORCE_SRC_SEL;\
-	type PHYESYMCLK_FORCE_EN;\
-	type PHYESYMCLK_FORCE_SRC_SEL;\
-	type DPSTREAMCLK_PIPE0_EN;\
-	type DPSTREAMCLK_PIPE1_EN;\
-	type DPSTREAMCLK_PIPE2_EN;\
-	type DPSTREAMCLK_PIPE3_EN;\
-	type HDMISTREAMCLK0_SRC_SEL;\
-	type HDMISTREAMCLK0_DTO_FORCE_DIS;\
-	type SYMCLK32_SE0_SRC_SEL;\
-	type SYMCLK32_SE1_SRC_SEL;\
-	type SYMCLK32_SE2_SRC_SEL;\
-	type SYMCLK32_SE3_SRC_SEL;\
-	type SYMCLK32_SE0_EN;\
-	type SYMCLK32_SE1_EN;\
-	type SYMCLK32_SE2_EN;\
-	type SYMCLK32_SE3_EN;\
-	type SYMCLK32_LE0_SRC_SEL;\
-	type SYMCLK32_LE1_SRC_SEL;\
-	type SYMCLK32_LE0_EN;\
-	type SYMCLK32_LE1_EN;\
-	type DTBCLK_DTO_ENABLE[MAX_PIPES];\
-	type DTBCLKDTO_ENABLE_STATUS[MAX_PIPES];\
-	type PIPE_DTO_SRC_SEL[MAX_PIPES];\
-	type DTBCLK_DTO_DIV[MAX_PIPES];\
-	type DCCG_AUDIO_DTO_SEL;\
-	type DCCG_AUDIO_DTO0_SOURCE_SEL;\
-	type DENTIST_DISPCLK_CHG_MODE;\
-	type DSCCLK0_DTO_PHASE;\
-	type DSCCLK0_DTO_MODULO;\
-	type DSCCLK1_DTO_PHASE;\
-	type DSCCLK1_DTO_MODULO;\
-	type DSCCLK2_DTO_PHASE;\
-	type DSCCLK2_DTO_MODULO;\
-	type DSCCLK0_DTO_ENABLE;\
-	type DSCCLK1_DTO_ENABLE;\
-	type DSCCLK2_DTO_ENABLE;\
-	type SYMCLK32_ROOT_SE0_GATE_DISABLE;\
-	type SYMCLK32_ROOT_SE1_GATE_DISABLE;\
-	type SYMCLK32_ROOT_SE2_GATE_DISABLE;\
-	type SYMCLK32_ROOT_SE3_GATE_DISABLE;\
-	type SYMCLK32_SE0_GATE_DISABLE;\
-	type SYMCLK32_SE1_GATE_DISABLE;\
-	type SYMCLK32_SE2_GATE_DISABLE;\
-	type SYMCLK32_SE3_GATE_DISABLE;\
-	type SYMCLK32_ROOT_LE0_GATE_DISABLE;\
-	type SYMCLK32_ROOT_LE1_GATE_DISABLE;\
-	type SYMCLK32_LE0_GATE_DISABLE;\
-	type SYMCLK32_LE1_GATE_DISABLE;\
-	type DPSTREAMCLK_ROOT_GATE_DISABLE;\
-	type DPSTREAMCLK_GATE_DISABLE;\
-	type HDMISTREAMCLK0_DTO_PHASE;\
-	type HDMISTREAMCLK0_DTO_MODULO;\
-	type HDMICHARCLK0_GATE_DISABLE;\
-	type HDMICHARCLK0_ROOT_GATE_DISABLE; \
-	type PHYASYMCLK_GATE_DISABLE; \
-	type PHYBSYMCLK_GATE_DISABLE; \
-	type PHYCSYMCLK_GATE_DISABLE; \
-	type PHYDSYMCLK_GATE_DISABLE; \
-	type PHYESYMCLK_GATE_DISABLE;
-
-#define DCCG314_REG_FIELD_LIST(type) \
-	type DSCCLK3_DTO_PHASE;\
-	type DSCCLK3_DTO_MODULO;\
-	type DSCCLK3_DTO_ENABLE;\
-	type DENTIST_DISPCLK_RDIVIDER;\
-	type DENTIST_DISPCLK_WDIVIDER;
-
-#define DCCG32_REG_FIELD_LIST(type) \
-	type DPSTREAMCLK0_EN;\
-	type DPSTREAMCLK1_EN;\
-	type DPSTREAMCLK2_EN;\
-	type DPSTREAMCLK3_EN;\
-	type DPSTREAMCLK0_SRC_SEL;\
-	type DPSTREAMCLK1_SRC_SEL;\
-	type DPSTREAMCLK2_SRC_SEL;\
-	type DPSTREAMCLK3_SRC_SEL;\
-	type HDMISTREAMCLK0_EN;\
-	type OTG0_PIXEL_RATE_DIVK1;\
-	type OTG0_PIXEL_RATE_DIVK2;\
-	type OTG1_PIXEL_RATE_DIVK1;\
-	type OTG1_PIXEL_RATE_DIVK2;\
-	type OTG2_PIXEL_RATE_DIVK1;\
-	type OTG2_PIXEL_RATE_DIVK2;\
-	type OTG3_PIXEL_RATE_DIVK1;\
-	type OTG3_PIXEL_RATE_DIVK2;\
-	type DTBCLK_P0_SRC_SEL;\
-	type DTBCLK_P0_EN;\
-	type DTBCLK_P1_SRC_SEL;\
-	type DTBCLK_P1_EN;\
-	type DTBCLK_P2_SRC_SEL;\
-	type DTBCLK_P2_EN;\
-	type DTBCLK_P3_SRC_SEL;\
-	type DTBCLK_P3_EN;\
-	type DENTIST_DISPCLK_CHG_DONE;
-
-#define DCCG35_REG_FIELD_LIST(type) \
-	type DPPCLK0_EN;\
-	type DPPCLK1_EN;\
-	type DPPCLK2_EN;\
-	type DPPCLK3_EN;\
-	type DSCCLK0_EN;\
-	type DSCCLK1_EN;\
-	type DSCCLK2_EN;\
-	type DSCCLK3_EN;\
-	type DISPCLK_DCCG_GATE_DISABLE;\
-	type DCCG_GLOBAL_FGCG_REP_DIS; \
-	type PHYASYMCLK_EN;\
-	type PHYASYMCLK_SRC_SEL;\
-	type PHYBSYMCLK_EN;\
-	type PHYBSYMCLK_SRC_SEL;\
-	type PHYCSYMCLK_EN;\
-	type PHYCSYMCLK_SRC_SEL;\
-	type PHYDSYMCLK_EN;\
-	type PHYDSYMCLK_SRC_SEL;\
-	type PHYESYMCLK_EN;\
-	type PHYESYMCLK_SRC_SEL;\
-	type PHYASYMCLK_ROOT_GATE_DISABLE;\
-	type PHYBSYMCLK_ROOT_GATE_DISABLE;\
-	type PHYCSYMCLK_ROOT_GATE_DISABLE;\
-	type PHYDSYMCLK_ROOT_GATE_DISABLE;\
-	type PHYESYMCLK_ROOT_GATE_DISABLE;\
-	type HDMISTREAMCLK0_GATE_DISABLE;\
-	type HDMISTREAMCLK1_GATE_DISABLE;\
-	type HDMISTREAMCLK2_GATE_DISABLE;\
-	type HDMISTREAMCLK3_GATE_DISABLE;\
-	type HDMISTREAMCLK4_GATE_DISABLE;\
-	type HDMISTREAMCLK5_GATE_DISABLE;\
-	type SYMCLKA_CLOCK_ENABLE;\
-	type SYMCLKB_CLOCK_ENABLE;\
-	type SYMCLKC_CLOCK_ENABLE;\
-	type SYMCLKD_CLOCK_ENABLE;\
-	type SYMCLKE_CLOCK_ENABLE;\
-	type SYMCLKA_FE_EN;\
-	type SYMCLKB_FE_EN;\
-	type SYMCLKC_FE_EN;\
-	type SYMCLKD_FE_EN;\
-	type SYMCLKE_FE_EN;\
-	type SYMCLKA_SRC_SEL;\
-	type SYMCLKB_SRC_SEL;\
-	type SYMCLKC_SRC_SEL;\
-	type SYMCLKD_SRC_SEL;\
-	type SYMCLKE_SRC_SEL;\
-	type SYMCLKA_FE_SRC_SEL;\
-	type SYMCLKB_FE_SRC_SEL;\
-	type SYMCLKC_FE_SRC_SEL;\
-	type SYMCLKD_FE_SRC_SEL;\
-	type SYMCLKE_FE_SRC_SEL;\
-	type DTBCLK_P0_GATE_DISABLE;\
-	type DTBCLK_P1_GATE_DISABLE;\
-	type DTBCLK_P2_GATE_DISABLE;\
-	type DTBCLK_P3_GATE_DISABLE;\
-	type DSCCLK0_ROOT_GATE_DISABLE;\
-	type DSCCLK1_ROOT_GATE_DISABLE;\
-	type DSCCLK2_ROOT_GATE_DISABLE;\
-	type DSCCLK3_ROOT_GATE_DISABLE;\
-	type SYMCLKA_FE_ROOT_GATE_DISABLE;\
-	type SYMCLKB_FE_ROOT_GATE_DISABLE;\
-	type SYMCLKC_FE_ROOT_GATE_DISABLE;\
-	type SYMCLKD_FE_ROOT_GATE_DISABLE;\
-	type SYMCLKE_FE_ROOT_GATE_DISABLE;\
-	type DPPCLK0_ROOT_GATE_DISABLE;\
-	type DPPCLK1_ROOT_GATE_DISABLE;\
-	type DPPCLK2_ROOT_GATE_DISABLE;\
-	type DPPCLK3_ROOT_GATE_DISABLE;\
-	type HDMISTREAMCLK0_ROOT_GATE_DISABLE;\
-	type SYMCLKA_ROOT_GATE_DISABLE;\
-	type SYMCLKB_ROOT_GATE_DISABLE;\
-	type SYMCLKC_ROOT_GATE_DISABLE;\
-	type SYMCLKD_ROOT_GATE_DISABLE;\
-	type SYMCLKE_ROOT_GATE_DISABLE;\
-	type PHYA_REFCLK_ROOT_GATE_DISABLE;\
-	type PHYB_REFCLK_ROOT_GATE_DISABLE;\
-	type PHYC_REFCLK_ROOT_GATE_DISABLE;\
-	type PHYD_REFCLK_ROOT_GATE_DISABLE;\
-	type PHYE_REFCLK_ROOT_GATE_DISABLE;\
-	type DPSTREAMCLK0_ROOT_GATE_DISABLE;\
-	type DPSTREAMCLK1_ROOT_GATE_DISABLE;\
-	type DPSTREAMCLK2_ROOT_GATE_DISABLE;\
-	type DPSTREAMCLK3_ROOT_GATE_DISABLE;\
-	type DPSTREAMCLK0_GATE_DISABLE;\
-	type DPSTREAMCLK1_GATE_DISABLE;\
-	type DPSTREAMCLK2_GATE_DISABLE;\
-	type DPSTREAMCLK3_GATE_DISABLE;\
-
-#define DCCG401_REG_FIELD_LIST(type) \
-	type OTG0_TMDS_PIXEL_RATE_DIV;\
-	type DPDTO0_INT;\
-	type OTG1_TMDS_PIXEL_RATE_DIV;\
-	type DPDTO1_INT;\
-	type OTG2_TMDS_PIXEL_RATE_DIV;\
-	type DPDTO2_INT;\
-	type OTG3_TMDS_PIXEL_RATE_DIV;\
-	type DPDTO3_INT;\
-	type SYMCLK32_ROOT_LE2_GATE_DISABLE;\
-	type SYMCLK32_ROOT_LE3_GATE_DISABLE;\
-	type SYMCLK32_LE2_GATE_DISABLE;\
-	type SYMCLK32_LE3_GATE_DISABLE;\
-	type SYMCLK32_LE2_SRC_SEL;\
-	type SYMCLK32_LE3_SRC_SEL;\
-	type SYMCLK32_LE2_EN;\
-	type SYMCLK32_LE3_EN;\
-	type DP_DTO_ENABLE[MAX_PIPES];\
-	type DSCCLK0_DTO_DB_EN;\
-	type DSCCLK1_DTO_DB_EN;\
-	type DSCCLK2_DTO_DB_EN;\
-	type DSCCLK3_DTO_DB_EN;
-
-struct dccg_shift {
-	DCCG_REG_FIELD_LIST(uint8_t)
-	DCCG3_REG_FIELD_LIST(uint8_t)
-	DCCG31_REG_FIELD_LIST(uint8_t)
-	DCCG314_REG_FIELD_LIST(uint8_t)
-	DCCG32_REG_FIELD_LIST(uint8_t)
-	DCCG35_REG_FIELD_LIST(uint8_t)
-	DCCG401_REG_FIELD_LIST(uint8_t)
-};
-
-struct dccg_mask {
-	DCCG_REG_FIELD_LIST(uint32_t)
-	DCCG3_REG_FIELD_LIST(uint32_t)
-	DCCG31_REG_FIELD_LIST(uint32_t)
-	DCCG314_REG_FIELD_LIST(uint32_t)
-	DCCG32_REG_FIELD_LIST(uint32_t)
-	DCCG35_REG_FIELD_LIST(uint32_t)
-	DCCG401_REG_FIELD_LIST(uint32_t)
-};
-
-struct dccg_registers {
-	uint32_t DPPCLK_DTO_CTRL;
-	uint32_t DPPCLK_DTO_PARAM[6];
-	uint32_t REFCLK_CNTL;
-	uint32_t DISPCLK_FREQ_CHANGE_CNTL;
-	uint32_t OTG_PIXEL_RATE_CNTL[MAX_PIPES];
-	uint32_t HDMICHARCLK_CLOCK_CNTL[6];
-	uint32_t PHYASYMCLK_CLOCK_CNTL;
-	uint32_t PHYBSYMCLK_CLOCK_CNTL;
-	uint32_t PHYCSYMCLK_CLOCK_CNTL;
-	uint32_t PHYDSYMCLK_CLOCK_CNTL;
-	uint32_t PHYESYMCLK_CLOCK_CNTL;
-	uint32_t DTBCLK_DTO_MODULO[MAX_PIPES];
-	uint32_t DTBCLK_DTO_PHASE[MAX_PIPES];
-	uint32_t DCCG_AUDIO_DTBCLK_DTO_MODULO;
-	uint32_t DCCG_AUDIO_DTBCLK_DTO_PHASE;
-	uint32_t DCCG_AUDIO_DTO_SOURCE;
-	uint32_t DPSTREAMCLK_CNTL;
-	uint32_t HDMISTREAMCLK_CNTL;
-	uint32_t SYMCLK32_SE_CNTL;
-	uint32_t SYMCLK32_LE_CNTL;
-	uint32_t DENTIST_DISPCLK_CNTL;
-	uint32_t DSCCLK_DTO_CTRL;
-	uint32_t DSCCLK0_DTO_PARAM;
-	uint32_t DSCCLK1_DTO_PARAM;
-	uint32_t DSCCLK2_DTO_PARAM;
-	uint32_t DSCCLK3_DTO_PARAM;
-	uint32_t DPSTREAMCLK_ROOT_GATE_DISABLE;
-	uint32_t DPSTREAMCLK_GATE_DISABLE;
-	uint32_t DCCG_GATE_DISABLE_CNTL;
-	uint32_t DCCG_GATE_DISABLE_CNTL2;
-	uint32_t DCCG_GATE_DISABLE_CNTL3;
-	uint32_t HDMISTREAMCLK0_DTO_PARAM;
-	uint32_t DCCG_GATE_DISABLE_CNTL4;
-	uint32_t OTG_PIXEL_RATE_DIV;
-	uint32_t DTBCLK_P_CNTL;
-	uint32_t DPPCLK_CTRL;
-	uint32_t DCCG_GATE_DISABLE_CNTL5;
-	uint32_t DCCG_GATE_DISABLE_CNTL6;
-	uint32_t DCCG_GLOBAL_FGCG_REP_CNTL;
-	uint32_t SYMCLKA_CLOCK_ENABLE;
-	uint32_t SYMCLKB_CLOCK_ENABLE;
-	uint32_t SYMCLKC_CLOCK_ENABLE;
-	uint32_t SYMCLKD_CLOCK_ENABLE;
-	uint32_t SYMCLKE_CLOCK_ENABLE;
-	uint32_t DP_DTO_MODULO[MAX_PIPES];
-	uint32_t DP_DTO_PHASE[MAX_PIPES];
-};
-
-struct dcn_dccg {
-	struct dccg base;
-	const struct dccg_registers *regs;
-	const struct dccg_shift *dccg_shift;
-	const struct dccg_mask *dccg_mask;
-};
-
-void dccg2_update_dpp_dto(struct dccg *dccg, int dpp_inst, int req_dppclk);
-
-void dccg2_get_dccg_ref_freq(struct dccg *dccg,
-		unsigned int xtalin_freq_inKhz,
-		unsigned int *dccg_ref_freq_inKhz);
-
-void dccg2_set_fifo_errdet_ovr_en(struct dccg *dccg,
-		bool en);
-void dccg2_otg_add_pixel(struct dccg *dccg,
-		uint32_t otg_inst);
-void dccg2_otg_drop_pixel(struct dccg *dccg,
-		uint32_t otg_inst);
-
-
-void dccg2_init(struct dccg *dccg);
-
-struct dccg *dccg2_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask);
-
-void dcn_dccg_destroy(struct dccg **dccg);
-
-#endif //__DCN20_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn201/Makefile b/drivers/gpu/drm/amd/display/dc/dcn201/Makefile
index ba688bce4951..7b7acadfccf7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn201/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn201/Makefile
@@ -2,7 +2,7 @@
 # Copyright © 2021-2024 Advanced Micro Devices, Inc. All rights reserved.
 
 DCN201 = dcn201_mpc.o dcn201_hubp.o dcn201_opp.o \
-	dcn201_dccg.o dcn201_link_encoder.o
+	dcn201_link_encoder.o
 
 AMD_DAL_DCN201 = $(addprefix $(AMDDALPATH)/dc/dcn201/,$(DCN201))
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn201/dcn201_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn201/dcn201_dccg.c
deleted file mode 100644
index 9a3402148fde..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn201/dcn201_dccg.c
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright 2018 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dcn201_dccg.h"
-
-#include "reg_helper.h"
-#include "core_types.h"
-
-#define TO_DCN_DCCG(dccg)\
-	container_of(dccg, struct dcn_dccg, base)
-
-#define REG(reg) \
-	(dccg_dcn->regs->reg)
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
-
-#define CTX \
-	dccg_dcn->base.ctx
-
-#define DC_LOGGER \
-	dccg->ctx->logger
-
-static void dccg201_update_dpp_dto(struct dccg *dccg, int dpp_inst,
-				   int req_dppclk)
-{
-	/* vbios handles it */
-}
-
-static const struct dccg_funcs dccg201_funcs = {
-	.update_dpp_dto = dccg201_update_dpp_dto,
-	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
-	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
-	.otg_add_pixel = dccg2_otg_add_pixel,
-	.otg_drop_pixel = dccg2_otg_drop_pixel,
-	.dccg_init = dccg2_init
-};
-
-struct dccg *dccg201_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg201_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn201/dcn201_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn201/dcn201_dccg.h
deleted file mode 100644
index 80888b0484fb..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn201/dcn201_dccg.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2018 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DCN201_DCCG_H__
-#define __DCN201_DCCG_H__
-
-#include "dcn20/dcn20_dccg.h"
-
-struct dccg *dccg201_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask);
-
-#endif //__DCN201_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn21/Makefile b/drivers/gpu/drm/amd/display/dc/dcn21/Makefile
index 81d565d84ff0..720f1a463b89 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn21/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn21/Makefile
@@ -2,7 +2,7 @@
 # Copyright © 2019-2024 Advanced Micro Devices, Inc. All rights reserved.
 
 DCN21 = dcn21_hubp.o \
-	 dcn21_link_encoder.o dcn21_dccg.o
+	 dcn21_link_encoder.o
 
 AMD_DAL_DCN21 = $(addprefix $(AMDDALPATH)/dc/dcn21/,$(DCN21))
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn21/dcn21_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn21/dcn21_dccg.c
deleted file mode 100644
index d07c04458d31..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn21/dcn21_dccg.c
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright 2018 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "reg_helper.h"
-#include "core_types.h"
-#include "dcn20/dcn20_dccg.h"
-#include "dcn21_dccg.h"
-
-#define TO_DCN_DCCG(dccg)\
-	container_of(dccg, struct dcn_dccg, base)
-
-#define REG(reg) \
-	(dccg_dcn->regs->reg)
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
-
-#define CTX \
-	dccg_dcn->base.ctx
-#define DC_LOGGER \
-	dccg->ctx->logger
-
-static void dccg21_update_dpp_dto(struct dccg *dccg, int dpp_inst, int req_dppclk)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (dccg->ref_dppclk) {
-		int ref_dppclk = dccg->ref_dppclk;
-		int modulo = ref_dppclk / 10000;
-		int phase;
-
-		if (req_dppclk) {
-			/*
-			 * program DPP DTO phase and modulo as below
-			 * phase = ceiling(dpp_pipe_clk_mhz / 10)
-			 * module = trunc(dpp_global_clk_mhz / 10)
-			 *
-			 * storing frequencies in registers allow dmcub fw
-			 * to run time lower clocks when possible for power saving
-			 *
-			 * ceiling phase and truncate modulo guarentees the divided
-			 * down per pipe dpp clock has high enough frequency
-			 */
-			phase = (req_dppclk + 9999) / 10000;
-
-			if (phase > modulo) {
-				/* phase > modulo result in screen corruption
-				 * ie phase = 30, mod = 29 for 4k@60 HDMI
-				 * in these case we don't want pipe clock to be divided
-				 */
-				phase = modulo;
-			}
-		} else {
-			/*
-			 *  set phase to 10 if dpp isn't used to
-			 *  prevent hard hang if access dpp register
-			 *  on unused pipe
-			 *
-			 *  DTO should be on to divide down un-used
-			 *  pipe clock for power saving
-			 */
-			phase = 10;
-		}
-
-		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
-				DPPCLK0_DTO_PHASE, phase,
-				DPPCLK0_DTO_MODULO, modulo);
-
-		REG_UPDATE(DPPCLK_DTO_CTRL,
-				DPPCLK_DTO_ENABLE[dpp_inst], 1);
-	}
-
-	dccg->pipe_dppclk_khz[dpp_inst] = req_dppclk;
-}
-
-
-static const struct dccg_funcs dccg21_funcs = {
-	.update_dpp_dto = dccg21_update_dpp_dto,
-	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
-	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
-	.otg_add_pixel = dccg2_otg_add_pixel,
-	.otg_drop_pixel = dccg2_otg_drop_pixel,
-	.dccg_init = dccg2_init
-};
-
-struct dccg *dccg21_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg21_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn21/dcn21_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn21/dcn21_dccg.h
deleted file mode 100644
index b7efa777ec73..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn21/dcn21_dccg.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright 2018 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DCN21_DCCG_H__
-#define __DCN21_DCCG_H__
-
-struct dccg *dccg21_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask);
-
-
-#endif /* __DCN21_DCCG_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dcn30/Makefile b/drivers/gpu/drm/amd/display/dc/dcn30/Makefile
index 435979febb79..fb7471435c69 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn30/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn30/Makefile
@@ -24,7 +24,6 @@
 #
 
 DCN30 := dcn30_hubp.o \
-	dcn30_dccg.o \
 	dcn30_mpc.o dcn30_vpg.o \
 	dcn30_afmt.o \
 	dcn30_dio_stream_encoder.o \
diff --git a/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dccg.c
deleted file mode 100644
index d445dfefc047..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dccg.c
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright 2020 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "reg_helper.h"
-#include "core_types.h"
-#include "dcn30_dccg.h"
-
-#define TO_DCN_DCCG(dccg)\
-	container_of(dccg, struct dcn_dccg, base)
-
-#define REG(reg) \
-	(dccg_dcn->regs->reg)
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
-
-#define CTX \
-	dccg_dcn->base.ctx
-#define DC_LOGGER \
-	dccg->ctx->logger
-
-
-static const struct dccg_funcs dccg3_funcs = {
-	.update_dpp_dto = dccg2_update_dpp_dto,
-	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
-	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
-	.otg_add_pixel = dccg2_otg_add_pixel,
-	.otg_drop_pixel = dccg2_otg_drop_pixel,
-	.dccg_init = dccg2_init
-};
-
-struct dccg *dccg3_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg3_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
-
-struct dccg *dccg30_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg3_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dccg.h
deleted file mode 100644
index 3f1da7f3a91c..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dccg.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright 2020 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DCN30_DCCG_H__
-#define __DCN30_DCCG_H__
-
-#include "dcn20/dcn20_dccg.h"
-
-
-#define DCCG_REG_LIST_DCN30() \
-	DCCG_REG_LIST_DCN2(),\
-	DCCG_SRII(CLOCK_CNTL, HDMICHARCLK, 0),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 2),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 3),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 4),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 5),\
-	SR(PHYASYMCLK_CLOCK_CNTL),\
-	SR(PHYBSYMCLK_CLOCK_CNTL),\
-	SR(PHYCSYMCLK_CLOCK_CNTL)
-
-#define DCCG_MASK_SH_LIST_DCN3(mask_sh) \
-	DCCG_MASK_SH_LIST_DCN2(mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_SRC_SEL, mask_sh),\
-
-struct dccg *dccg3_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask);
-
-struct dccg *dccg30_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask);
-
-#endif //__DCN30_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn301/Makefile b/drivers/gpu/drm/amd/display/dc/dcn301/Makefile
index bfda72fa4f42..fadf5e872e38 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn301/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn301/Makefile
@@ -10,8 +10,7 @@
 #
 # Makefile for dcn30.
 
-DCN301 = dcn301_dccg.o \
-		dcn301_dio_link_encoder.o dcn301_panel_cntl.o
+DCN301 = dcn301_dio_link_encoder.o dcn301_panel_cntl.o
 
 AMD_DAL_DCN301 = $(addprefix $(AMDDALPATH)/dc/dcn301/,$(DCN301))
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn301/dcn301_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn301/dcn301_dccg.c
deleted file mode 100644
index 97e9be87afd9..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn301/dcn301_dccg.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2020 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "reg_helper.h"
-#include "core_types.h"
-#include "dcn301_dccg.h"
-
-#define TO_DCN_DCCG(dccg)\
-	container_of(dccg, struct dcn_dccg, base)
-
-#define REG(reg) \
-	(dccg_dcn->regs->reg)
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
-
-#define CTX \
-	dccg_dcn->base.ctx
-#define DC_LOGGER \
-	dccg->ctx->logger
-
-static const struct dccg_funcs dccg301_funcs = {
-	.update_dpp_dto = dccg2_update_dpp_dto,
-	.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,
-	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
-	.otg_add_pixel = dccg2_otg_add_pixel,
-	.otg_drop_pixel = dccg2_otg_drop_pixel,
-	.dccg_init = dccg2_init
-};
-
-struct dccg *dccg301_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg301_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
-
diff --git a/drivers/gpu/drm/amd/display/dc/dcn301/dcn301_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn301/dcn301_dccg.h
deleted file mode 100644
index 067e49cb238e..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn301/dcn301_dccg.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2020 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DCN301_DCCG_H__
-#define __DCN301_DCCG_H__
-
-#include "dcn20/dcn20_dccg.h"
-
-#define DCCG_REG_LIST_DCN301() \
-	SR(DPPCLK_DTO_CTRL),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 2),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 3),\
-	SR(REFCLK_CNTL)
-
-#define DCCG_MASK_SH_LIST_DCN301(mask_sh) \
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(REFCLK_CNTL, REFCLK_CLOCK_EN, mask_sh),\
-	DCCG_SF(REFCLK_CNTL, REFCLK_SRC_SEL, mask_sh)
-
-struct dccg *dccg301_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask);
-
-#endif //__DCN301_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn302/dcn302_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn302/dcn302_dccg.h
deleted file mode 100644
index c884dde1bb25..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn302/dcn302_dccg.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2020 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DCN302_DCCG_H__
-#define __DCN302_DCCG_H__
-
-#include "dcn30/dcn30_dccg.h"
-
-
-#define DCCG_REG_LIST_DCN3_02() \
-	DCCG_COMMON_REG_LIST_DCN_BASE(),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 4)
-
-#define DCCG_MASK_SH_LIST_DCN3_02(mask_sh) \
-	DCCG_COMMON_MASK_SH_LIST_DCN_COMMON_BASE(mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 4, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 4, mask_sh)
-
-#endif //__DCN302_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn303/dcn303_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn303/dcn303_dccg.h
deleted file mode 100644
index 2e12fb643005..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn303/dcn303_dccg.h
+++ /dev/null
@@ -1,64 +0,0 @@
-// SPDX-License-Identifier: MIT
-/*
- * Copyright (C) 2021 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- */
-
-#ifndef __DCN303_DCCG_H__
-#define __DCN303_DCCG_H__
-
-#include "dcn30/dcn30_dccg.h"
-
-
-#define DCCG_REG_LIST_DCN3_03() \
-	SR(DPPCLK_DTO_CTRL),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
-	SR(REFCLK_CNTL),\
-	SR(DISPCLK_FREQ_CHANGE_CNTL),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 0),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 1)
-
-
-#define DCCG_MASK_SH_LIST_DCN3_03(mask_sh) \
-		DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
-		DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
-		DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
-		DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
-		DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
-		DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
-		DCCG_SF(REFCLK_CNTL, REFCLK_CLOCK_EN, mask_sh),\
-		DCCG_SF(REFCLK_CNTL, REFCLK_SRC_SEL, mask_sh),\
-		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_STEP_DELAY, mask_sh),\
-		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_STEP_SIZE, mask_sh),\
-		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_FREQ_RAMP_DONE, mask_sh),\
-		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_MAX_ERRDET_CYCLES, mask_sh),\
-		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_RESET, mask_sh),\
-		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_STATE, mask_sh),\
-		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DCCG_FIFO_ERRDET_OVR_EN, mask_sh),\
-		DCCG_SF(DISPCLK_FREQ_CHANGE_CNTL, DISPCLK_CHG_FWD_CORR_DISABLE, mask_sh),\
-		DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
-		DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
-		DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 0, mask_sh),\
-		DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 1, mask_sh)
-
-#endif //__DCN303_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn31/Makefile b/drivers/gpu/drm/amd/display/dc/dcn31/Makefile
index 9608c1f418ab..7daa2f038c97 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn31/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn31/Makefile
@@ -11,7 +11,7 @@
 # Makefile for dcn31.
 
 DCN31 = dcn31_hubp.o \
-	dcn31_dccg.o dcn31_dio_link_encoder.o dcn31_panel_cntl.o \
+	dcn31_dio_link_encoder.o dcn31_panel_cntl.o \
 	dcn31_apg.o dcn31_hpo_dp_stream_encoder.o dcn31_hpo_dp_link_encoder.o \
 	dcn31_afmt.o dcn31_vpg.o
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c
deleted file mode 100644
index 8664f0c4c9b7..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c
+++ /dev/null
@@ -1,755 +0,0 @@
-/*
- * Copyright 2018 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "reg_helper.h"
-#include "core_types.h"
-#include "dcn31_dccg.h"
-#include "dal_asic_id.h"
-
-#define TO_DCN_DCCG(dccg)\
-	container_of(dccg, struct dcn_dccg, base)
-
-#define REG(reg) \
-	(dccg_dcn->regs->reg)
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
-
-#define CTX \
-	dccg_dcn->base.ctx
-#define DC_LOGGER \
-	dccg->ctx->logger
-
-void dccg31_update_dpp_dto(struct dccg *dccg, int dpp_inst, int req_dppclk)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (dccg->dpp_clock_gated[dpp_inst]) {
-		/*
-		 * Do not update the DPPCLK DTO if the clock is stopped.
-		 * It is treated the same as if the pipe itself were in PG.
-		 */
-		return;
-	}
-
-	if (dccg->ref_dppclk && req_dppclk) {
-		int ref_dppclk = dccg->ref_dppclk;
-		int modulo, phase;
-
-		// phase / modulo = dpp pipe clk / dpp global clk
-		modulo = 0xff;   // use FF at the end
-		phase = ((modulo * req_dppclk) + ref_dppclk - 1) / ref_dppclk;
-
-		if (phase > 0xff) {
-			ASSERT(false);
-			phase = 0xff;
-		}
-
-		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
-				DPPCLK0_DTO_PHASE, phase,
-				DPPCLK0_DTO_MODULO, modulo);
-		REG_UPDATE(DPPCLK_DTO_CTRL,
-				DPPCLK_DTO_ENABLE[dpp_inst], 1);
-	} else {
-		REG_UPDATE(DPPCLK_DTO_CTRL,
-				DPPCLK_DTO_ENABLE[dpp_inst], 0);
-	}
-	dccg->pipe_dppclk_khz[dpp_inst] = req_dppclk;
-}
-
-static enum phyd32clk_clock_source get_phy_mux_symclk(
-		struct dcn_dccg *dccg_dcn,
-		enum phyd32clk_clock_source src)
-{
-	if (dccg_dcn->base.ctx->asic_id.chip_family == FAMILY_YELLOW_CARP &&
-			dccg_dcn->base.ctx->asic_id.hw_internal_rev == YELLOW_CARP_B0) {
-		if (src == PHYD32CLKC)
-			src = PHYD32CLKF;
-		if (src == PHYD32CLKD)
-			src = PHYD32CLKG;
-	}
-	return src;
-}
-
-static void dccg31_enable_dpstreamclk(struct dccg *dccg, int otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	/* enabled to select one of the DTBCLKs for pipe */
-	switch (otg_inst) {
-	case 0:
-		REG_UPDATE(DPSTREAMCLK_CNTL,
-				DPSTREAMCLK_PIPE0_EN, 1);
-		break;
-	case 1:
-		REG_UPDATE(DPSTREAMCLK_CNTL,
-				DPSTREAMCLK_PIPE1_EN, 1);
-		break;
-	case 2:
-		REG_UPDATE(DPSTREAMCLK_CNTL,
-				DPSTREAMCLK_PIPE2_EN, 1);
-		break;
-	case 3:
-		REG_UPDATE(DPSTREAMCLK_CNTL,
-				DPSTREAMCLK_PIPE3_EN, 1);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
-		REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-			DPSTREAMCLK_GATE_DISABLE, 1,
-			DPSTREAMCLK_ROOT_GATE_DISABLE, 1);
-}
-
-static void dccg31_disable_dpstreamclk(struct dccg *dccg, int otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
-		REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-				DPSTREAMCLK_ROOT_GATE_DISABLE, 0,
-				DPSTREAMCLK_GATE_DISABLE, 0);
-
-	switch (otg_inst) {
-	case 0:
-		REG_UPDATE(DPSTREAMCLK_CNTL,
-				DPSTREAMCLK_PIPE0_EN, 0);
-		break;
-	case 1:
-		REG_UPDATE(DPSTREAMCLK_CNTL,
-				DPSTREAMCLK_PIPE1_EN, 0);
-		break;
-	case 2:
-		REG_UPDATE(DPSTREAMCLK_CNTL,
-				DPSTREAMCLK_PIPE2_EN, 0);
-		break;
-	case 3:
-		REG_UPDATE(DPSTREAMCLK_CNTL,
-				DPSTREAMCLK_PIPE3_EN, 0);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-void dccg31_set_dpstreamclk(
-		struct dccg *dccg,
-		enum streamclk_source src,
-		int otg_inst,
-		int dp_hpo_inst)
-{
-	if (src == REFCLK)
-		dccg31_disable_dpstreamclk(dccg, otg_inst);
-	else
-		dccg31_enable_dpstreamclk(dccg, otg_inst);
-}
-
-void dccg31_enable_symclk32_se(
-		struct dccg *dccg,
-		int hpo_se_inst,
-		enum phyd32clk_clock_source phyd32clk)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	phyd32clk = get_phy_mux_symclk(dccg_dcn, phyd32clk);
-
-	/* select one of the PHYD32CLKs as the source for symclk32_se */
-	switch (hpo_se_inst) {
-	case 0:
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE0_GATE_DISABLE, 1,
-					SYMCLK32_ROOT_SE0_GATE_DISABLE, 1);
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE0_SRC_SEL, phyd32clk,
-				SYMCLK32_SE0_EN, 1);
-		break;
-	case 1:
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE1_GATE_DISABLE, 1,
-					SYMCLK32_ROOT_SE1_GATE_DISABLE, 1);
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE1_SRC_SEL, phyd32clk,
-				SYMCLK32_SE1_EN, 1);
-		break;
-	case 2:
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE2_GATE_DISABLE, 1,
-					SYMCLK32_ROOT_SE2_GATE_DISABLE, 1);
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE2_SRC_SEL, phyd32clk,
-				SYMCLK32_SE2_EN, 1);
-		break;
-	case 3:
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE3_GATE_DISABLE, 1,
-					SYMCLK32_ROOT_SE3_GATE_DISABLE, 1);
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE3_SRC_SEL, phyd32clk,
-				SYMCLK32_SE3_EN, 1);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-void dccg31_disable_symclk32_se(
-		struct dccg *dccg,
-		int hpo_se_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	/* set refclk as the source for symclk32_se */
-	switch (hpo_se_inst) {
-	case 0:
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE0_SRC_SEL, 0,
-				SYMCLK32_SE0_EN, 0);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE0_GATE_DISABLE, 0,
-					SYMCLK32_ROOT_SE0_GATE_DISABLE, 0);
-		break;
-	case 1:
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE1_SRC_SEL, 0,
-				SYMCLK32_SE1_EN, 0);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE1_GATE_DISABLE, 0,
-					SYMCLK32_ROOT_SE1_GATE_DISABLE, 0);
-		break;
-	case 2:
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE2_SRC_SEL, 0,
-				SYMCLK32_SE2_EN, 0);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE2_GATE_DISABLE, 0,
-					SYMCLK32_ROOT_SE2_GATE_DISABLE, 0);
-		break;
-	case 3:
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE3_SRC_SEL, 0,
-				SYMCLK32_SE3_EN, 0);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE3_GATE_DISABLE, 0,
-					SYMCLK32_ROOT_SE3_GATE_DISABLE, 0);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-void dccg31_enable_symclk32_le(
-		struct dccg *dccg,
-		int hpo_le_inst,
-		enum phyd32clk_clock_source phyd32clk)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	phyd32clk = get_phy_mux_symclk(dccg_dcn, phyd32clk);
-
-	/* select one of the PHYD32CLKs as the source for symclk32_le */
-	switch (hpo_le_inst) {
-	case 0:
-		REG_UPDATE_2(SYMCLK32_LE_CNTL,
-				SYMCLK32_LE0_SRC_SEL, phyd32clk,
-				SYMCLK32_LE0_EN, 1);
-		break;
-	case 1:
-		REG_UPDATE_2(SYMCLK32_LE_CNTL,
-				SYMCLK32_LE1_SRC_SEL, phyd32clk,
-				SYMCLK32_LE1_EN, 1);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-void dccg31_disable_symclk32_le(
-		struct dccg *dccg,
-		int hpo_le_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	/* set refclk as the source for symclk32_le */
-	switch (hpo_le_inst) {
-	case 0:
-		REG_UPDATE_2(SYMCLK32_LE_CNTL,
-				SYMCLK32_LE0_SRC_SEL, 0,
-				SYMCLK32_LE0_EN, 0);
-		break;
-	case 1:
-		REG_UPDATE_2(SYMCLK32_LE_CNTL,
-				SYMCLK32_LE1_SRC_SEL, 0,
-				SYMCLK32_LE1_EN, 0);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-void dccg31_set_symclk32_le_root_clock_gating(
-		struct dccg *dccg,
-		int hpo_le_inst,
-		bool enable)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
-		return;
-
-	switch (hpo_le_inst) {
-	case 0:
-		REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-				SYMCLK32_LE0_GATE_DISABLE, enable ? 1 : 0,
-				SYMCLK32_ROOT_LE0_GATE_DISABLE, enable ? 1 : 0);
-		break;
-	case 1:
-		REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL3,
-				SYMCLK32_LE1_GATE_DISABLE, enable ? 1 : 0,
-				SYMCLK32_ROOT_LE1_GATE_DISABLE, enable ? 1 : 0);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-void dccg31_disable_dscclk(struct dccg *dccg, int inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-		return;
-	//DTO must be enabled to generate a 0 Hz clock output
-	switch (inst) {
-	case 0:
-		REG_UPDATE(DSCCLK_DTO_CTRL,
-				DSCCLK0_DTO_ENABLE, 1);
-		REG_UPDATE_2(DSCCLK0_DTO_PARAM,
-				DSCCLK0_DTO_PHASE, 0,
-				DSCCLK0_DTO_MODULO, 1);
-		break;
-	case 1:
-		REG_UPDATE(DSCCLK_DTO_CTRL,
-				DSCCLK1_DTO_ENABLE, 1);
-		REG_UPDATE_2(DSCCLK1_DTO_PARAM,
-				DSCCLK1_DTO_PHASE, 0,
-				DSCCLK1_DTO_MODULO, 1);
-		break;
-	case 2:
-		REG_UPDATE(DSCCLK_DTO_CTRL,
-				DSCCLK2_DTO_ENABLE, 1);
-		REG_UPDATE_2(DSCCLK2_DTO_PARAM,
-				DSCCLK2_DTO_PHASE, 0,
-				DSCCLK2_DTO_MODULO, 1);
-		break;
-	case 3:
-		if (REG(DSCCLK3_DTO_PARAM)) {
-			REG_UPDATE(DSCCLK_DTO_CTRL,
-					DSCCLK3_DTO_ENABLE, 1);
-			REG_UPDATE_2(DSCCLK3_DTO_PARAM,
-					DSCCLK3_DTO_PHASE, 0,
-					DSCCLK3_DTO_MODULO, 1);
-		}
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-void dccg31_enable_dscclk(struct dccg *dccg, int inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-		return;
-	//Disable DTO
-	switch (inst) {
-	case 0:
-		REG_UPDATE_2(DSCCLK0_DTO_PARAM,
-				DSCCLK0_DTO_PHASE, 0,
-				DSCCLK0_DTO_MODULO, 0);
-		REG_UPDATE(DSCCLK_DTO_CTRL,
-				DSCCLK0_DTO_ENABLE, 0);
-		break;
-	case 1:
-		REG_UPDATE_2(DSCCLK1_DTO_PARAM,
-				DSCCLK1_DTO_PHASE, 0,
-				DSCCLK1_DTO_MODULO, 0);
-		REG_UPDATE(DSCCLK_DTO_CTRL,
-				DSCCLK1_DTO_ENABLE, 0);
-		break;
-	case 2:
-		REG_UPDATE_2(DSCCLK2_DTO_PARAM,
-				DSCCLK2_DTO_PHASE, 0,
-				DSCCLK2_DTO_MODULO, 0);
-		REG_UPDATE(DSCCLK_DTO_CTRL,
-				DSCCLK2_DTO_ENABLE, 0);
-		break;
-	case 3:
-		if (REG(DSCCLK3_DTO_PARAM)) {
-			REG_UPDATE(DSCCLK_DTO_CTRL,
-					DSCCLK3_DTO_ENABLE, 0);
-			REG_UPDATE_2(DSCCLK3_DTO_PARAM,
-					DSCCLK3_DTO_PHASE, 0,
-					DSCCLK3_DTO_MODULO, 0);
-		}
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-void dccg31_set_physymclk(
-		struct dccg *dccg,
-		int phy_inst,
-		enum physymclk_clock_source clk_src,
-		bool force_enable)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	/* Force PHYSYMCLK on and Select phyd32clk as the source of clock which is output to PHY through DCIO */
-	switch (phy_inst) {
-	case 0:
-		if (force_enable) {
-			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
-					PHYASYMCLK_FORCE_EN, 1,
-					PHYASYMCLK_FORCE_SRC_SEL, clk_src);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYASYMCLK_GATE_DISABLE, 1);
-		} else {
-			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
-					PHYASYMCLK_FORCE_EN, 0,
-					PHYASYMCLK_FORCE_SRC_SEL, 0);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYASYMCLK_GATE_DISABLE, 0);
-		}
-		break;
-	case 1:
-		if (force_enable) {
-			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
-					PHYBSYMCLK_FORCE_EN, 1,
-					PHYBSYMCLK_FORCE_SRC_SEL, clk_src);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYBSYMCLK_GATE_DISABLE, 1);
-		} else {
-			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
-					PHYBSYMCLK_FORCE_EN, 0,
-					PHYBSYMCLK_FORCE_SRC_SEL, 0);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYBSYMCLK_GATE_DISABLE, 0);
-		}
-		break;
-	case 2:
-		if (force_enable) {
-			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
-					PHYCSYMCLK_FORCE_EN, 1,
-					PHYCSYMCLK_FORCE_SRC_SEL, clk_src);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYCSYMCLK_GATE_DISABLE, 1);
-		} else {
-			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
-					PHYCSYMCLK_FORCE_EN, 0,
-					PHYCSYMCLK_FORCE_SRC_SEL, 0);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYCSYMCLK_GATE_DISABLE, 0);
-		}
-		break;
-	case 3:
-		if (force_enable) {
-			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
-					PHYDSYMCLK_FORCE_EN, 1,
-					PHYDSYMCLK_FORCE_SRC_SEL, clk_src);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYDSYMCLK_GATE_DISABLE, 1);
-		} else {
-			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
-					PHYDSYMCLK_FORCE_EN, 0,
-					PHYDSYMCLK_FORCE_SRC_SEL, 0);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYDSYMCLK_GATE_DISABLE, 0);
-		}
-		break;
-	case 4:
-		if (force_enable) {
-			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
-					PHYESYMCLK_FORCE_EN, 1,
-					PHYESYMCLK_FORCE_SRC_SEL, clk_src);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYESYMCLK_GATE_DISABLE, 1);
-		} else {
-			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
-					PHYESYMCLK_FORCE_EN, 0,
-					PHYESYMCLK_FORCE_SRC_SEL, 0);
-			if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-				REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-					PHYESYMCLK_GATE_DISABLE, 0);
-		}
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-/* Controls the generation of pixel valid for OTG in (OTG -> HPO case) */
-void dccg31_set_dtbclk_dto(
-		struct dccg *dccg,
-		const struct dtbclk_dto_params *params)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	int req_dtbclk_khz = params->pixclk_khz;
-	uint32_t dtbdto_div;
-
-	/* Mode	                DTBDTO Rate       DTBCLK_DTO<x>_DIV Register
-	 * ODM 4:1 combine      pixel rate/4      2
-	 * ODM 2:1 combine      pixel rate/2      4
-	 * non-DSC 4:2:0 mode   pixel rate/2      4
-	 * DSC native 4:2:0     pixel rate/2      4
-	 * DSC native 4:2:2     pixel rate/2      4
-	 * Other modes          pixel rate        8
-	 */
-	if (params->num_odm_segments == 4) {
-		dtbdto_div = 2;
-		req_dtbclk_khz = params->pixclk_khz / 4;
-	} else if ((params->num_odm_segments == 2) ||
-			(params->timing->pixel_encoding == PIXEL_ENCODING_YCBCR420) ||
-			(params->timing->flags.DSC && params->timing->pixel_encoding == PIXEL_ENCODING_YCBCR422
-					&& !params->timing->dsc_cfg.ycbcr422_simple)) {
-		dtbdto_div = 4;
-		req_dtbclk_khz = params->pixclk_khz / 2;
-	} else
-		dtbdto_div = 8;
-
-	if (params->ref_dtbclk_khz && req_dtbclk_khz) {
-		uint32_t modulo, phase;
-
-		// phase / modulo = dtbclk / dtbclk ref
-		modulo = params->ref_dtbclk_khz * 1000;
-		phase = div_u64((((unsigned long long)modulo * req_dtbclk_khz) + params->ref_dtbclk_khz - 1),
-				params->ref_dtbclk_khz);
-
-		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLK_DTO_DIV[params->otg_inst], dtbdto_div);
-
-		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);
-		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);
-
-		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLK_DTO_ENABLE[params->otg_inst], 1);
-
-		REG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,
-				1, 100);
-
-		/* The recommended programming sequence to enable DTBCLK DTO to generate
-		 * valid pixel HPO DPSTREAM ENCODER, specifies that DTO source select should
-		 * be set only after DTO is enabled
-		 */
-		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				PIPE_DTO_SRC_SEL[params->otg_inst], 1);
-	} else {
-		REG_UPDATE_3(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLK_DTO_ENABLE[params->otg_inst], 0,
-				PIPE_DTO_SRC_SEL[params->otg_inst], 0,
-				DTBCLK_DTO_DIV[params->otg_inst], dtbdto_div);
-
-		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);
-		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);
-	}
-}
-
-void dccg31_set_audio_dtbclk_dto(
-		struct dccg *dccg,
-		const struct dtbclk_dto_params *params)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (params->ref_dtbclk_khz && params->req_audio_dtbclk_khz) {
-		uint32_t modulo, phase;
-
-		// phase / modulo = dtbclk / dtbclk ref
-		modulo = params->ref_dtbclk_khz * 1000;
-		phase = div_u64((((unsigned long long)modulo * params->req_audio_dtbclk_khz) + params->ref_dtbclk_khz - 1),
-			params->ref_dtbclk_khz);
-
-
-		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_MODULO, modulo);
-		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_PHASE, phase);
-
-		//REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
-		//		DCCG_AUDIO_DTBCLK_DTO_USE_512FBR_DTO, 1);
-
-		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
-				DCCG_AUDIO_DTO_SEL, 4);  //  04 - DCCG_AUDIO_DTO_SEL_AUDIO_DTO_DTBCLK
-	} else {
-		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_PHASE, 0);
-		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_MODULO, 0);
-
-		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
-				DCCG_AUDIO_DTO_SEL, 3);  //  03 - DCCG_AUDIO_DTO_SEL_NO_AUDIO_DTO
-	}
-}
-
-void dccg31_get_dccg_ref_freq(struct dccg *dccg,
-		unsigned int xtalin_freq_inKhz,
-		unsigned int *dccg_ref_freq_inKhz)
-{
-	/*
-	 * Assume refclk is sourced from xtalin
-	 * expect 24MHz
-	 */
-	*dccg_ref_freq_inKhz = xtalin_freq_inKhz;
-	return;
-}
-
-void dccg31_set_dispclk_change_mode(
-	struct dccg *dccg,
-	enum dentist_dispclk_change_mode change_mode)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_MODE,
-		   change_mode == DISPCLK_CHANGE_MODE_RAMPING ? 2 : 0);
-}
-
-void dccg31_init(struct dccg *dccg)
-{
-	/* Set HPO stream encoder to use refclk to avoid case where PHY is
-	 * disabled and SYMCLK32 for HPO SE is sourced from PHYD32CLK which
-	 * will cause DCN to hang.
-	 */
-	dccg31_disable_symclk32_se(dccg, 0);
-	dccg31_disable_symclk32_se(dccg, 1);
-	dccg31_disable_symclk32_se(dccg, 2);
-	dccg31_disable_symclk32_se(dccg, 3);
-
-	dccg31_set_symclk32_le_root_clock_gating(dccg, 0, false);
-	dccg31_set_symclk32_le_root_clock_gating(dccg, 1, false);
-
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
-		dccg31_disable_dpstreamclk(dccg, 0);
-		dccg31_disable_dpstreamclk(dccg, 1);
-		dccg31_disable_dpstreamclk(dccg, 2);
-		dccg31_disable_dpstreamclk(dccg, 3);
-	}
-
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk) {
-		dccg31_set_physymclk(dccg, 0, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
-		dccg31_set_physymclk(dccg, 1, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
-		dccg31_set_physymclk(dccg, 2, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
-		dccg31_set_physymclk(dccg, 3, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
-		dccg31_set_physymclk(dccg, 4, PHYSYMCLK_FORCE_SRC_SYMCLK, false);
-	}
-}
-
-void dccg31_otg_add_pixel(struct dccg *dccg,
-				 uint32_t otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
-			OTG_ADD_PIXEL[otg_inst], 1);
-}
-
-void dccg31_otg_drop_pixel(struct dccg *dccg,
-				  uint32_t otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
-			OTG_DROP_PIXEL[otg_inst], 1);
-}
-
-static const struct dccg_funcs dccg31_funcs = {
-	.update_dpp_dto = dccg31_update_dpp_dto,
-	.get_dccg_ref_freq = dccg31_get_dccg_ref_freq,
-	.dccg_init = dccg31_init,
-	.set_dpstreamclk = dccg31_set_dpstreamclk,
-	.enable_symclk32_se = dccg31_enable_symclk32_se,
-	.disable_symclk32_se = dccg31_disable_symclk32_se,
-	.enable_symclk32_le = dccg31_enable_symclk32_le,
-	.disable_symclk32_le = dccg31_disable_symclk32_le,
-	.set_physymclk = dccg31_set_physymclk,
-	.set_dtbclk_dto = dccg31_set_dtbclk_dto,
-	.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,
-	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
-	.otg_add_pixel = dccg31_otg_add_pixel,
-	.otg_drop_pixel = dccg31_otg_drop_pixel,
-	.set_dispclk_change_mode = dccg31_set_dispclk_change_mode,
-	.disable_dsc = dccg31_disable_dscclk,
-	.enable_dsc = dccg31_enable_dscclk,
-};
-
-struct dccg *dccg31_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg31_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h
deleted file mode 100644
index e3be0bab4007..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright 2018 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DCN31_DCCG_H__
-#define __DCN31_DCCG_H__
-
-#include "dcn30/dcn30_dccg.h"
-
-#define DCCG_REG_LIST_DCN31() \
-	SR(DPPCLK_DTO_CTRL),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 2),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 3),\
-	DCCG_SRII(CLOCK_CNTL, HDMICHARCLK, 0),\
-	SR(PHYASYMCLK_CLOCK_CNTL),\
-	SR(PHYBSYMCLK_CLOCK_CNTL),\
-	SR(PHYCSYMCLK_CLOCK_CNTL),\
-	SR(PHYDSYMCLK_CLOCK_CNTL),\
-	SR(PHYESYMCLK_CLOCK_CNTL),\
-	SR(DPSTREAMCLK_CNTL),\
-	SR(HDMISTREAMCLK_CNTL),\
-	SR(SYMCLK32_SE_CNTL),\
-	SR(SYMCLK32_LE_CNTL),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 0),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 1),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 2),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 3),\
-	DCCG_SRII(MODULO, DTBCLK_DTO, 0),\
-	DCCG_SRII(MODULO, DTBCLK_DTO, 1),\
-	DCCG_SRII(MODULO, DTBCLK_DTO, 2),\
-	DCCG_SRII(MODULO, DTBCLK_DTO, 3),\
-	DCCG_SRII(PHASE, DTBCLK_DTO, 0),\
-	DCCG_SRII(PHASE, DTBCLK_DTO, 1),\
-	DCCG_SRII(PHASE, DTBCLK_DTO, 2),\
-	DCCG_SRII(PHASE, DTBCLK_DTO, 3),\
-	SR(DCCG_AUDIO_DTBCLK_DTO_MODULO),\
-	SR(DCCG_AUDIO_DTBCLK_DTO_PHASE),\
-	SR(DCCG_AUDIO_DTO_SOURCE),\
-	SR(DENTIST_DISPCLK_CNTL),\
-	SR(DSCCLK0_DTO_PARAM),\
-	SR(DSCCLK1_DTO_PARAM),\
-	SR(DSCCLK2_DTO_PARAM),\
-	SR(DSCCLK_DTO_CTRL),\
-	SR(DCCG_GATE_DISABLE_CNTL2),\
-	SR(DCCG_GATE_DISABLE_CNTL3),\
-	SR(HDMISTREAMCLK0_DTO_PARAM)
-
-
-#define DCCG_MASK_SH_LIST_DCN31(mask_sh) \
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE0_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE1_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE2_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE3_EN, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_DTO_FORCE_DIS, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_EN, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
-	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
-	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_MODE, mask_sh), \
-	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_MODULO, mask_sh),\
-	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_MODULO, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK0_DTO_ENABLE, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK1_DTO_ENABLE, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK2_DTO_ENABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYASYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYBSYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYCSYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYDSYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYESYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, DPSTREAMCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, DPSTREAMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE2_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE3_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_MODULO, mask_sh)
-
-
-struct dccg *dccg31_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask);
-
-void dccg31_init(struct dccg *dccg);
-
-void dccg31_enable_symclk32_se(
-		struct dccg *dccg,
-		int hpo_se_inst,
-		enum phyd32clk_clock_source phyd32clk);
-
-void dccg31_disable_symclk32_se(
-		struct dccg *dccg,
-		int hpo_se_inst);
-
-void dccg31_enable_symclk32_le(
-		struct dccg *dccg,
-		int hpo_le_inst,
-		enum phyd32clk_clock_source phyd32clk);
-
-void dccg31_disable_symclk32_le(
-		struct dccg *dccg,
-		int hpo_le_inst);
-
-void dccg31_set_symclk32_le_root_clock_gating(
-		struct dccg *dccg,
-		int hpo_le_inst,
-		bool enable);
-
-void dccg31_set_physymclk(
-		struct dccg *dccg,
-		int phy_inst,
-		enum physymclk_clock_source clk_src,
-		bool force_enable);
-
-void dccg31_set_audio_dtbclk_dto(
-		struct dccg *dccg,
-		const struct dtbclk_dto_params *params);
-
-void dccg31_update_dpp_dto(
-	struct dccg *dccg,
-	int dpp_inst,
-	int req_dppclk);
-
-void dccg31_get_dccg_ref_freq(
-	struct dccg *dccg,
-	unsigned int xtalin_freq_inKhz,
-	unsigned int *dccg_ref_freq_inKhz);
-
-void dccg31_set_dpstreamclk(
-	struct dccg *dccg,
-	enum streamclk_source src,
-	int otg_inst,
-	int dp_hpo_inst);
-
-void dccg31_set_dtbclk_dto(
-		struct dccg *dccg,
-		const struct dtbclk_dto_params *params);
-
-void dccg31_otg_add_pixel(
-	struct dccg *dccg,
-	uint32_t otg_inst);
-
-void dccg31_otg_drop_pixel(
-	struct dccg *dccg,
-	uint32_t otg_inst);
-
-void dccg31_set_dispclk_change_mode(
-	struct dccg *dccg,
-	enum dentist_dispclk_change_mode change_mode);
-
-void dccg31_disable_dscclk(struct dccg *dccg, int inst);
-
-void dccg31_enable_dscclk(struct dccg *dccg, int inst);
-
-#endif //__DCN31_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn314/Makefile b/drivers/gpu/drm/amd/display/dc/dcn314/Makefile
index b134ab05aa71..cac756c75b7f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn314/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn314/Makefile
@@ -10,7 +10,7 @@
 #
 # Makefile for dcn314.
 
-DCN314 = dcn314_dio_stream_encoder.o dcn314_dccg.o
+DCN314 = dcn314_dio_stream_encoder.o
 
 AMD_DAL_DCN314 = $(addprefix $(AMDDALPATH)/dc/dcn314/,$(DCN314))
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn314/dcn314_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn314/dcn314_dccg.c
deleted file mode 100644
index 17a1174b8d80..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn314/dcn314_dccg.c
+++ /dev/null
@@ -1,404 +0,0 @@
-// SPDX-License-Identifier: MIT
-/*
- * Copyright 2022 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "reg_helper.h"
-#include "core_types.h"
-
-#include "dcn31/dcn31_dccg.h"
-#include "dcn314_dccg.h"
-
-#define TO_DCN_DCCG(dccg)\
-	container_of(dccg, struct dcn_dccg, base)
-
-#define REG(reg) \
-	(dccg_dcn->regs->reg)
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
-
-#define CTX \
-	dccg_dcn->base.ctx
-#define DC_LOGGER \
-	dccg->ctx->logger
-
-static void dccg314_trigger_dio_fifo_resync(
-	struct dccg *dccg)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	uint32_t dispclk_rdivider_value = 0;
-
-	REG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, &dispclk_rdivider_value);
-	REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, dispclk_rdivider_value);
-}
-
-static void dccg314_get_pixel_rate_div(
-		struct dccg *dccg,
-		uint32_t otg_inst,
-		enum pixel_rate_div *k1,
-		enum pixel_rate_div *k2)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	uint32_t val_k1 = PIXEL_RATE_DIV_NA, val_k2 = PIXEL_RATE_DIV_NA;
-
-	*k1 = PIXEL_RATE_DIV_NA;
-	*k2 = PIXEL_RATE_DIV_NA;
-
-	switch (otg_inst) {
-	case 0:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG0_PIXEL_RATE_DIVK1, &val_k1,
-			OTG0_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	case 1:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG1_PIXEL_RATE_DIVK1, &val_k1,
-			OTG1_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	case 2:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG2_PIXEL_RATE_DIVK1, &val_k1,
-			OTG2_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	case 3:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG3_PIXEL_RATE_DIVK1, &val_k1,
-			OTG3_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	*k1 = (enum pixel_rate_div)val_k1;
-	*k2 = (enum pixel_rate_div)val_k2;
-}
-
-static void dccg314_set_pixel_rate_div(
-		struct dccg *dccg,
-		uint32_t otg_inst,
-		enum pixel_rate_div k1,
-		enum pixel_rate_div k2)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	enum pixel_rate_div cur_k1 = PIXEL_RATE_DIV_NA, cur_k2 = PIXEL_RATE_DIV_NA;
-
-	// Don't program 0xF into the register field. Not valid since
-	// K1 / K2 field is only 1 / 2 bits wide
-	if (k1 == PIXEL_RATE_DIV_NA || k2 == PIXEL_RATE_DIV_NA) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	dccg314_get_pixel_rate_div(dccg, otg_inst, &cur_k1, &cur_k2);
-	if (k1 == cur_k1 && k2 == cur_k2)
-		return;
-
-	switch (otg_inst) {
-	case 0:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG0_PIXEL_RATE_DIVK1, k1,
-				OTG0_PIXEL_RATE_DIVK2, k2);
-		break;
-	case 1:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG1_PIXEL_RATE_DIVK1, k1,
-				OTG1_PIXEL_RATE_DIVK2, k2);
-		break;
-	case 2:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG2_PIXEL_RATE_DIVK1, k1,
-				OTG2_PIXEL_RATE_DIVK2, k2);
-		break;
-	case 3:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG3_PIXEL_RATE_DIVK1, k1,
-				OTG3_PIXEL_RATE_DIVK2, k2);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-static void dccg314_set_dtbclk_p_src(
-		struct dccg *dccg,
-		enum streamclk_source src,
-		uint32_t otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	uint32_t p_src_sel = 0; /* selects dprefclk */
-
-	if (src == DTBCLK0)
-		p_src_sel = 2;  /* selects dtbclk0 */
-
-	switch (otg_inst) {
-	case 0:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P0_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P0_SRC_SEL, p_src_sel,
-					DTBCLK_P0_EN, 1);
-		break;
-	case 1:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P1_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P1_SRC_SEL, p_src_sel,
-					DTBCLK_P1_EN, 1);
-		break;
-	case 2:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P2_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P2_SRC_SEL, p_src_sel,
-					DTBCLK_P2_EN, 1);
-		break;
-	case 3:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P3_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P3_SRC_SEL, p_src_sel,
-					DTBCLK_P3_EN, 1);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-}
-
-/* Controls the generation of pixel valid for OTG in (OTG -> HPO case) */
-static void dccg314_set_dtbclk_dto(
-		struct dccg *dccg,
-		const struct dtbclk_dto_params *params)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	/* DTO Output Rate / Pixel Rate = 1/4 */
-	int req_dtbclk_khz = params->pixclk_khz / 4;
-
-	if (params->ref_dtbclk_khz && req_dtbclk_khz) {
-		uint32_t modulo, phase;
-
-		// phase / modulo = dtbclk / dtbclk ref
-		modulo = params->ref_dtbclk_khz * 1000;
-		phase = req_dtbclk_khz * 1000;
-
-		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);
-		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);
-
-		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLK_DTO_ENABLE[params->otg_inst], 1);
-
-		REG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,
-				1, 100);
-
-		/* program OTG_PIXEL_RATE_DIV for DIVK1 and DIVK2 fields */
-		dccg314_set_pixel_rate_div(dccg, params->otg_inst, PIXEL_RATE_DIV_BY_1, PIXEL_RATE_DIV_BY_1);
-
-		/* The recommended programming sequence to enable DTBCLK DTO to generate
-		 * valid pixel HPO DPSTREAM ENCODER, specifies that DTO source select should
-		 * be set only after DTO is enabled
-		 */
-		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				PIPE_DTO_SRC_SEL[params->otg_inst], 2);
-	} else {
-		REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLK_DTO_ENABLE[params->otg_inst], 0,
-				PIPE_DTO_SRC_SEL[params->otg_inst], 1);
-
-		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);
-		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);
-	}
-}
-
-void dccg314_set_dpstreamclk(
-		struct dccg *dccg,
-		enum streamclk_source src,
-		int otg_inst,
-		int dp_hpo_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	/* set the dtbclk_p source */
-	dccg314_set_dtbclk_p_src(dccg, src, otg_inst);
-
-	/* enabled to select one of the DTBCLKs for pipe */
-	switch (dp_hpo_inst) {
-	case 0:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL,
-					DPSTREAMCLK0_EN, (src == REFCLK) ? 0 : 1,
-					DPSTREAMCLK0_SRC_SEL, otg_inst);
-		break;
-	case 1:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL,
-					DPSTREAMCLK1_EN, (src == REFCLK) ? 0 : 1,
-					DPSTREAMCLK1_SRC_SEL, otg_inst);
-		break;
-	case 2:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL,
-					DPSTREAMCLK2_EN, (src == REFCLK) ? 0 : 1,
-					DPSTREAMCLK2_SRC_SEL, otg_inst);
-		break;
-	case 3:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL,
-					DPSTREAMCLK3_EN, (src == REFCLK) ? 0 : 1,
-					DPSTREAMCLK3_SRC_SEL, otg_inst);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-static void dccg314_init(struct dccg *dccg)
-{
-	int otg_inst;
-
-	/* Set HPO stream encoder to use refclk to avoid case where PHY is
-	 * disabled and SYMCLK32 for HPO SE is sourced from PHYD32CLK which
-	 * will cause DCN to hang.
-	 */
-	for (otg_inst = 0; otg_inst < 4; otg_inst++)
-		dccg31_disable_symclk32_se(dccg, otg_inst);
-
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
-		for (otg_inst = 0; otg_inst < 2; otg_inst++)
-			dccg31_disable_symclk32_le(dccg, otg_inst);
-
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
-		for (otg_inst = 0; otg_inst < 4; otg_inst++)
-			dccg314_set_dpstreamclk(dccg, REFCLK, otg_inst,
-						otg_inst);
-
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-		for (otg_inst = 0; otg_inst < 5; otg_inst++)
-			dccg31_set_physymclk(dccg, otg_inst,
-					     PHYSYMCLK_FORCE_SRC_SYMCLK, false);
-}
-
-static void dccg314_set_valid_pixel_rate(
-		struct dccg *dccg,
-		int ref_dtbclk_khz,
-		int otg_inst,
-		int pixclk_khz)
-{
-	struct dtbclk_dto_params dto_params = {0};
-
-	dto_params.ref_dtbclk_khz = ref_dtbclk_khz;
-	dto_params.otg_inst = otg_inst;
-	dto_params.pixclk_khz = pixclk_khz;
-
-	dccg314_set_dtbclk_dto(dccg, &dto_params);
-}
-
-static void dccg314_dpp_root_clock_control(
-		struct dccg *dccg,
-		unsigned int dpp_inst,
-		bool clock_on)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (dccg->dpp_clock_gated[dpp_inst] != clock_on)
-		return;
-
-	if (clock_on) {
-		/* turn off the DTO and leave phase/modulo at max */
-		REG_UPDATE(DPPCLK_DTO_CTRL, DPPCLK_DTO_ENABLE[dpp_inst], 0);
-		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
-			  DPPCLK0_DTO_PHASE, 0xFF,
-			  DPPCLK0_DTO_MODULO, 0xFF);
-	} else {
-		/* turn on the DTO to generate a 0hz clock */
-		REG_UPDATE(DPPCLK_DTO_CTRL, DPPCLK_DTO_ENABLE[dpp_inst], 1);
-		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
-			  DPPCLK0_DTO_PHASE, 0,
-			  DPPCLK0_DTO_MODULO, 1);
-	}
-
-	dccg->dpp_clock_gated[dpp_inst] = !clock_on;
-}
-
-static const struct dccg_funcs dccg314_funcs = {
-	.update_dpp_dto = dccg31_update_dpp_dto,
-	.dpp_root_clock_control = dccg314_dpp_root_clock_control,
-	.get_dccg_ref_freq = dccg31_get_dccg_ref_freq,
-	.dccg_init = dccg314_init,
-	.set_dpstreamclk = dccg314_set_dpstreamclk,
-	.enable_symclk32_se = dccg31_enable_symclk32_se,
-	.disable_symclk32_se = dccg31_disable_symclk32_se,
-	.enable_symclk32_le = dccg31_enable_symclk32_le,
-	.disable_symclk32_le = dccg31_disable_symclk32_le,
-	.set_symclk32_le_root_clock_gating = dccg31_set_symclk32_le_root_clock_gating,
-	.set_physymclk = dccg31_set_physymclk,
-	.set_dtbclk_dto = dccg314_set_dtbclk_dto,
-	.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,
-	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
-	.otg_add_pixel = dccg31_otg_add_pixel,
-	.otg_drop_pixel = dccg31_otg_drop_pixel,
-	.set_dispclk_change_mode = dccg31_set_dispclk_change_mode,
-	.disable_dsc = dccg31_disable_dscclk,
-	.enable_dsc = dccg31_enable_dscclk,
-	.set_pixel_rate_div = dccg314_set_pixel_rate_div,
-	.trigger_dio_fifo_resync = dccg314_trigger_dio_fifo_resync,
-	.set_valid_pixel_rate = dccg314_set_valid_pixel_rate,
-	.set_dtbclk_p_src = dccg314_set_dtbclk_p_src
-};
-
-struct dccg *dccg314_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg314_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn314/dcn314_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn314/dcn314_dccg.h
deleted file mode 100644
index 60ea1d248deb..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn314/dcn314_dccg.h
+++ /dev/null
@@ -1,212 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-/*
- * Copyright 2022 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DCN314_DCCG_H__
-#define __DCN314_DCCG_H__
-
-#include "dcn31/dcn31_dccg.h"
-
-#define DCCG_SFII(block, reg_name, field_prefix, field_name, inst, post_fix)\
-	.field_prefix ## _ ## field_name[inst] = block ## inst ## _ ## reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
-
-
-#define DCCG_REG_LIST_DCN314() \
-	SR(DPPCLK_DTO_CTRL),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 2),\
-	DCCG_SRII(DTO_PARAM, DPPCLK, 3),\
-	DCCG_SRII(CLOCK_CNTL, HDMICHARCLK, 0),\
-	SR(PHYASYMCLK_CLOCK_CNTL),\
-	SR(PHYBSYMCLK_CLOCK_CNTL),\
-	SR(PHYCSYMCLK_CLOCK_CNTL),\
-	SR(PHYDSYMCLK_CLOCK_CNTL),\
-	SR(PHYESYMCLK_CLOCK_CNTL),\
-	SR(DPSTREAMCLK_CNTL),\
-	SR(HDMISTREAMCLK_CNTL),\
-	SR(SYMCLK32_SE_CNTL),\
-	SR(SYMCLK32_LE_CNTL),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 0),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 1),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 2),\
-	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 3),\
-	DCCG_SRII(MODULO, DTBCLK_DTO, 0),\
-	DCCG_SRII(MODULO, DTBCLK_DTO, 1),\
-	DCCG_SRII(MODULO, DTBCLK_DTO, 2),\
-	DCCG_SRII(MODULO, DTBCLK_DTO, 3),\
-	DCCG_SRII(PHASE, DTBCLK_DTO, 0),\
-	DCCG_SRII(PHASE, DTBCLK_DTO, 1),\
-	DCCG_SRII(PHASE, DTBCLK_DTO, 2),\
-	DCCG_SRII(PHASE, DTBCLK_DTO, 3),\
-	SR(DCCG_AUDIO_DTBCLK_DTO_MODULO),\
-	SR(DCCG_AUDIO_DTBCLK_DTO_PHASE),\
-	SR(DCCG_AUDIO_DTO_SOURCE),\
-	SR(DENTIST_DISPCLK_CNTL),\
-	SR(DSCCLK0_DTO_PARAM),\
-	SR(DSCCLK1_DTO_PARAM),\
-	SR(DSCCLK2_DTO_PARAM),\
-	SR(DSCCLK3_DTO_PARAM),\
-	SR(DSCCLK_DTO_CTRL),\
-	SR(DCCG_GATE_DISABLE_CNTL2),\
-	SR(DCCG_GATE_DISABLE_CNTL3),\
-	SR(HDMISTREAMCLK0_DTO_PARAM),\
-	SR(OTG_PIXEL_RATE_DIV),\
-	SR(DTBCLK_P_CNTL),\
-	SR(DCCG_AUDIO_DTO_SOURCE)
-
-#define DCCG_MASK_SH_LIST_DCN314_COMMON(mask_sh) \
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_SRC_SEL, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_EN, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_EN, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_EN, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_EN, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_EN, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_EN, mask_sh),\
-	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
-	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_MODE, mask_sh),\
-	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_MODULO, mask_sh),\
-	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_MODULO, mask_sh),\
-	DCCG_SF(DSCCLK3_DTO_PARAM, DSCCLK3_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK3_DTO_PARAM, DSCCLK3_DTO_MODULO, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE2_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE3_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE2_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE3_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_LE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_LE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_MODULO, mask_sh)
-
-#define DCCG_MASK_SH_LIST_DCN314(mask_sh) \
-	DCCG_MASK_SH_LIST_DCN314_COMMON(mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_DTO_FORCE_DIS, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK0_DTO_ENABLE, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK1_DTO_ENABLE, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK2_DTO_ENABLE, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK3_DTO_ENABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYASYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYBSYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYCSYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYDSYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYESYMCLK_GATE_DISABLE, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, mask_sh)
-
-struct dccg *dccg314_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask);
-
-void dccg314_set_dpstreamclk(
-		struct dccg *dccg,
-		enum streamclk_source src,
-		int otg_inst,
-		int dp_hpo_inst);
-
-#endif //__DCN314_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn32/Makefile b/drivers/gpu/drm/amd/display/dc/dcn32/Makefile
index 8a6bc529f376..dd3c4e70bce6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn32/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn32/Makefile
@@ -10,8 +10,7 @@
 #
 # Makefile for dcn32.
 
-DCN32 = dcn32_dccg.o \
-		dcn32_mmhubbub.o dcn32_hubp.o dcn32_mpc.o \
+DCN32 = dcn32_mmhubbub.o dcn32_hubp.o dcn32_mpc.o \
 		dcn32_dio_stream_encoder.o dcn32_dio_link_encoder.o dcn32_resource_helpers.o \
 		dcn32_hpo_dp_link_encoder.o
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dccg.c
deleted file mode 100644
index 56385cede113..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dccg.c
+++ /dev/null
@@ -1,373 +0,0 @@
-/*
- * Copyright 2021 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "reg_helper.h"
-#include "core_types.h"
-#include "dcn32_dccg.h"
-
-#define TO_DCN_DCCG(dccg)\
-	container_of(dccg, struct dcn_dccg, base)
-
-#define REG(reg) \
-	(dccg_dcn->regs->reg)
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
-
-#define CTX \
-	dccg_dcn->base.ctx
-#define DC_LOGGER \
-	dccg->ctx->logger
-
-static void dccg32_trigger_dio_fifo_resync(
-	struct dccg *dccg)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	uint32_t dispclk_rdivider_value = 0;
-
-	REG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, &dispclk_rdivider_value);
-
-	/* Not valid for the WDIVIDER to be set to 0 */
-	if (dispclk_rdivider_value != 0)
-		REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, dispclk_rdivider_value);
-}
-
-static void dccg32_get_pixel_rate_div(
-		struct dccg *dccg,
-		uint32_t otg_inst,
-		enum pixel_rate_div *k1,
-		enum pixel_rate_div *k2)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	uint32_t val_k1 = PIXEL_RATE_DIV_NA, val_k2 = PIXEL_RATE_DIV_NA;
-
-	*k1 = PIXEL_RATE_DIV_NA;
-	*k2 = PIXEL_RATE_DIV_NA;
-
-	switch (otg_inst) {
-	case 0:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG0_PIXEL_RATE_DIVK1, &val_k1,
-			OTG0_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	case 1:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG1_PIXEL_RATE_DIVK1, &val_k1,
-			OTG1_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	case 2:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG2_PIXEL_RATE_DIVK1, &val_k1,
-			OTG2_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	case 3:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG3_PIXEL_RATE_DIVK1, &val_k1,
-			OTG3_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	*k1 = (enum pixel_rate_div)val_k1;
-	*k2 = (enum pixel_rate_div)val_k2;
-}
-
-static void dccg32_set_pixel_rate_div(
-		struct dccg *dccg,
-		uint32_t otg_inst,
-		enum pixel_rate_div k1,
-		enum pixel_rate_div k2)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	enum pixel_rate_div cur_k1 = PIXEL_RATE_DIV_NA, cur_k2 = PIXEL_RATE_DIV_NA;
-
-	// Don't program 0xF into the register field. Not valid since
-	// K1 / K2 field is only 1 / 2 bits wide
-	if (k1 == PIXEL_RATE_DIV_NA || k2 == PIXEL_RATE_DIV_NA) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	dccg32_get_pixel_rate_div(dccg, otg_inst, &cur_k1, &cur_k2);
-	if (k1 == cur_k1 && k2 == cur_k2)
-		return;
-
-	switch (otg_inst) {
-	case 0:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG0_PIXEL_RATE_DIVK1, k1,
-				OTG0_PIXEL_RATE_DIVK2, k2);
-		break;
-	case 1:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG1_PIXEL_RATE_DIVK1, k1,
-				OTG1_PIXEL_RATE_DIVK2, k2);
-		break;
-	case 2:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG2_PIXEL_RATE_DIVK1, k1,
-				OTG2_PIXEL_RATE_DIVK2, k2);
-		break;
-	case 3:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG3_PIXEL_RATE_DIVK1, k1,
-				OTG3_PIXEL_RATE_DIVK2, k2);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-static void dccg32_set_dtbclk_p_src(
-		struct dccg *dccg,
-		enum streamclk_source src,
-		uint32_t otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	uint32_t p_src_sel = 0; /* selects dprefclk */
-	if (src == DTBCLK0)
-		p_src_sel = 2;  /* selects dtbclk0 */
-
-	switch (otg_inst) {
-	case 0:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P0_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P0_SRC_SEL, p_src_sel,
-					DTBCLK_P0_EN, 1);
-		break;
-	case 1:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P1_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P1_SRC_SEL, p_src_sel,
-					DTBCLK_P1_EN, 1);
-		break;
-	case 2:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P2_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P2_SRC_SEL, p_src_sel,
-					DTBCLK_P2_EN, 1);
-		break;
-	case 3:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P3_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P3_SRC_SEL, p_src_sel,
-					DTBCLK_P3_EN, 1);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-}
-
-/* Controls the generation of pixel valid for OTG in (OTG -> HPO case) */
-static void dccg32_set_dtbclk_dto(
-		struct dccg *dccg,
-		const struct dtbclk_dto_params *params)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	/* DTO Output Rate / Pixel Rate = 1/4 */
-	int req_dtbclk_khz = params->pixclk_khz / 4;
-
-	if (params->ref_dtbclk_khz && req_dtbclk_khz) {
-		uint32_t modulo, phase;
-
-		// phase / modulo = dtbclk / dtbclk ref
-		modulo = params->ref_dtbclk_khz * 1000;
-		phase = req_dtbclk_khz * 1000;
-
-		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);
-		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);
-
-		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLK_DTO_ENABLE[params->otg_inst], 1);
-
-		REG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,
-				1, 100);
-
-		/* program OTG_PIXEL_RATE_DIV for DIVK1 and DIVK2 fields */
-		dccg32_set_pixel_rate_div(dccg, params->otg_inst, PIXEL_RATE_DIV_BY_1, PIXEL_RATE_DIV_BY_1);
-
-		/* The recommended programming sequence to enable DTBCLK DTO to generate
-		 * valid pixel HPO DPSTREAM ENCODER, specifies that DTO source select should
-		 * be set only after DTO is enabled
-		 */
-		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				PIPE_DTO_SRC_SEL[params->otg_inst], 2);
-	} else {
-		REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLK_DTO_ENABLE[params->otg_inst], 0,
-				PIPE_DTO_SRC_SEL[params->otg_inst], params->is_hdmi ? 0 : 1);
-		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);
-		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);
-	}
-}
-
-static void dccg32_set_valid_pixel_rate(
-		struct dccg *dccg,
-		int ref_dtbclk_khz,
-		int otg_inst,
-		int pixclk_khz)
-{
-	struct dtbclk_dto_params dto_params = {0};
-
-	dto_params.ref_dtbclk_khz = ref_dtbclk_khz;
-	dto_params.otg_inst = otg_inst;
-	dto_params.pixclk_khz = pixclk_khz;
-	dto_params.is_hdmi = true;
-
-	dccg32_set_dtbclk_dto(dccg, &dto_params);
-}
-
-static void dccg32_get_dccg_ref_freq(struct dccg *dccg,
-		unsigned int xtalin_freq_inKhz,
-		unsigned int *dccg_ref_freq_inKhz)
-{
-	/*
-	 * Assume refclk is sourced from xtalin
-	 * expect 100MHz
-	 */
-	*dccg_ref_freq_inKhz = xtalin_freq_inKhz;
-	return;
-}
-
-static void dccg32_set_dpstreamclk(
-		struct dccg *dccg,
-		enum streamclk_source src,
-		int otg_inst,
-		int dp_hpo_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	/* set the dtbclk_p source */
-	/* always program refclk as DTBCLK. No use-case expected to require DPREFCLK as refclk */
-	dccg32_set_dtbclk_p_src(dccg, DTBCLK0, otg_inst);
-
-	/* enabled to select one of the DTBCLKs for pipe */
-	switch (dp_hpo_inst) {
-	case 0:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL,
-			     DPSTREAMCLK0_EN,
-			     (src == REFCLK) ? 0 : 1, DPSTREAMCLK0_SRC_SEL, otg_inst);
-		break;
-	case 1:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN,
-			     (src == REFCLK) ? 0 : 1, DPSTREAMCLK1_SRC_SEL, otg_inst);
-		break;
-	case 2:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN,
-			     (src == REFCLK) ? 0 : 1, DPSTREAMCLK2_SRC_SEL, otg_inst);
-		break;
-	case 3:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN,
-			     (src == REFCLK) ? 0 : 1, DPSTREAMCLK3_SRC_SEL, otg_inst);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-static void dccg32_otg_add_pixel(struct dccg *dccg,
-		uint32_t otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
-			OTG_ADD_PIXEL[otg_inst], 1);
-}
-
-static void dccg32_otg_drop_pixel(struct dccg *dccg,
-		uint32_t otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	REG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],
-			OTG_DROP_PIXEL[otg_inst], 1);
-}
-
-static const struct dccg_funcs dccg32_funcs = {
-	.update_dpp_dto = dccg2_update_dpp_dto,
-	.get_dccg_ref_freq = dccg32_get_dccg_ref_freq,
-	.dccg_init = dccg31_init,
-	.set_dpstreamclk = dccg32_set_dpstreamclk,
-	.enable_symclk32_se = dccg31_enable_symclk32_se,
-	.disable_symclk32_se = dccg31_disable_symclk32_se,
-	.enable_symclk32_le = dccg31_enable_symclk32_le,
-	.disable_symclk32_le = dccg31_disable_symclk32_le,
-	.set_physymclk = dccg31_set_physymclk,
-	.set_dtbclk_dto = dccg32_set_dtbclk_dto,
-	.set_valid_pixel_rate = dccg32_set_valid_pixel_rate,
-	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
-	.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,
-	.otg_add_pixel = dccg32_otg_add_pixel,
-	.otg_drop_pixel = dccg32_otg_drop_pixel,
-	.set_pixel_rate_div = dccg32_set_pixel_rate_div,
-	.trigger_dio_fifo_resync = dccg32_trigger_dio_fifo_resync,
-	.set_dtbclk_p_src = dccg32_set_dtbclk_p_src,
-};
-
-struct dccg *dccg32_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg32_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dccg.h
deleted file mode 100644
index cf5508718122..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dccg.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright 2021 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DCN32_DCCG_H__
-#define __DCN32_DCCG_H__
-
-#include "dcn31/dcn31_dccg.h"
-
-#define DCCG_SFII(block, reg_name, field_prefix, field_name, inst, post_fix)\
-	.field_prefix ## _ ## field_name[inst] = block ## inst ## _ ## reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
-
-#define DCCG_MASK_SH_LIST_DCN32(mask_sh) \
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_EN, mask_sh),\
-	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_SRC_SEL, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_EN, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_DTO_FORCE_DIS, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_EN, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_EN, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_EN, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_EN, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_EN, mask_sh),\
-	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
-	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_DONE, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, mask_sh)
-
-struct dccg *dccg32_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask);
-
-#endif //__DCN32_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn35/Makefile b/drivers/gpu/drm/amd/display/dc/dcn35/Makefile
index 09fd994ae158..eb70d5f4e90e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn35/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn35/Makefile
@@ -11,7 +11,7 @@
 # Makefile for DCN35.
 
 DCN35 = dcn35_dio_stream_encoder.o \
-	dcn35_dio_link_encoder.o dcn35_dccg.o \
+	dcn35_dio_link_encoder.o \
 	dcn35_hubp.o \
 	dcn35_mmhubbub.o dcn35_opp.o dcn35_pg_cntl.o dcn35_dwb.o
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c
deleted file mode 100644
index 02ec16bf381f..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c
+++ /dev/null
@@ -1,1051 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-/*
- * Copyright 2023 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "reg_helper.h"
-#include "core_types.h"
-#include "dcn35_dccg.h"
-
-#define TO_DCN_DCCG(dccg)\
-	container_of(dccg, struct dcn_dccg, base)
-
-#define REG(reg) \
-	(dccg_dcn->regs->reg)
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
-
-#define CTX \
-	dccg_dcn->base.ctx
-#define DC_LOGGER \
-	dccg->ctx->logger
-
-static void dccg35_trigger_dio_fifo_resync(struct dccg *dccg)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	uint32_t dispclk_rdivider_value = 0;
-
-	REG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, &dispclk_rdivider_value);
-	REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, dispclk_rdivider_value);
-}
-
-static void dcn35_set_dppclk_enable(struct dccg *dccg,
-				 uint32_t dpp_inst, uint32_t enable)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	switch (dpp_inst) {
-	case 0:
-		REG_UPDATE(DPPCLK_CTRL, DPPCLK0_EN, enable);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK0_ROOT_GATE_DISABLE, enable);
-		break;
-	case 1:
-		REG_UPDATE(DPPCLK_CTRL, DPPCLK1_EN, enable);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK1_ROOT_GATE_DISABLE, enable);
-		break;
-	case 2:
-		REG_UPDATE(DPPCLK_CTRL, DPPCLK2_EN, enable);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK2_ROOT_GATE_DISABLE, enable);
-		break;
-	case 3:
-		REG_UPDATE(DPPCLK_CTRL, DPPCLK3_EN, enable);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK3_ROOT_GATE_DISABLE, enable);
-		break;
-	default:
-		break;
-	}
-
-}
-
-static void dccg35_update_dpp_dto(struct dccg *dccg, int dpp_inst,
-				  int req_dppclk)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (dccg->dpp_clock_gated[dpp_inst]) {
-		/*
-		 * Do not update the DPPCLK DTO if the clock is stopped.
-		 */
-		return;
-	}
-
-	if (dccg->ref_dppclk && req_dppclk) {
-		int ref_dppclk = dccg->ref_dppclk;
-		int modulo, phase;
-
-		// phase / modulo = dpp pipe clk / dpp global clk
-		modulo = 0xff;   // use FF at the end
-		phase = ((modulo * req_dppclk) + ref_dppclk - 1) / ref_dppclk;
-
-		if (phase > 0xff) {
-			ASSERT(false);
-			phase = 0xff;
-		}
-
-		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
-				DPPCLK0_DTO_PHASE, phase,
-				DPPCLK0_DTO_MODULO, modulo);
-
-		dcn35_set_dppclk_enable(dccg, dpp_inst, true);
-	} else
-		dcn35_set_dppclk_enable(dccg, dpp_inst, false);
-	dccg->pipe_dppclk_khz[dpp_inst] = req_dppclk;
-}
-
-static void dccg35_set_dppclk_root_clock_gating(struct dccg *dccg,
-		 uint32_t dpp_inst, uint32_t enable)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
-		return;
-
-	switch (dpp_inst) {
-	case 0:
-		REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK0_ROOT_GATE_DISABLE, enable);
-		break;
-	case 1:
-		REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK1_ROOT_GATE_DISABLE, enable);
-		break;
-	case 2:
-		REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK2_ROOT_GATE_DISABLE, enable);
-		break;
-	case 3:
-		REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DPPCLK3_ROOT_GATE_DISABLE, enable);
-		break;
-	default:
-		break;
-	}
-}
-
-static void dccg35_get_pixel_rate_div(
-		struct dccg *dccg,
-		uint32_t otg_inst,
-		enum pixel_rate_div *k1,
-		enum pixel_rate_div *k2)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	uint32_t val_k1 = PIXEL_RATE_DIV_NA, val_k2 = PIXEL_RATE_DIV_NA;
-
-	*k1 = PIXEL_RATE_DIV_NA;
-	*k2 = PIXEL_RATE_DIV_NA;
-
-	switch (otg_inst) {
-	case 0:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG0_PIXEL_RATE_DIVK1, &val_k1,
-			OTG0_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	case 1:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG1_PIXEL_RATE_DIVK1, &val_k1,
-			OTG1_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	case 2:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG2_PIXEL_RATE_DIVK1, &val_k1,
-			OTG2_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	case 3:
-		REG_GET_2(OTG_PIXEL_RATE_DIV,
-			OTG3_PIXEL_RATE_DIVK1, &val_k1,
-			OTG3_PIXEL_RATE_DIVK2, &val_k2);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	*k1 = (enum pixel_rate_div)val_k1;
-	*k2 = (enum pixel_rate_div)val_k2;
-}
-
-static void dccg35_set_pixel_rate_div(
-		struct dccg *dccg,
-		uint32_t otg_inst,
-		enum pixel_rate_div k1,
-		enum pixel_rate_div k2)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	enum pixel_rate_div cur_k1 = PIXEL_RATE_DIV_NA, cur_k2 = PIXEL_RATE_DIV_NA;
-
-	// Don't program 0xF into the register field. Not valid since
-	// K1 / K2 field is only 1 / 2 bits wide
-	if (k1 == PIXEL_RATE_DIV_NA || k2 == PIXEL_RATE_DIV_NA) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	dccg35_get_pixel_rate_div(dccg, otg_inst, &cur_k1, &cur_k2);
-	if (k1 == cur_k1 && k2 == cur_k2)
-		return;
-
-	switch (otg_inst) {
-	case 0:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG0_PIXEL_RATE_DIVK1, k1,
-				OTG0_PIXEL_RATE_DIVK2, k2);
-		break;
-	case 1:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG1_PIXEL_RATE_DIVK1, k1,
-				OTG1_PIXEL_RATE_DIVK2, k2);
-		break;
-	case 2:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG2_PIXEL_RATE_DIVK1, k1,
-				OTG2_PIXEL_RATE_DIVK2, k2);
-		break;
-	case 3:
-		REG_UPDATE_2(OTG_PIXEL_RATE_DIV,
-				OTG3_PIXEL_RATE_DIVK1, k1,
-				OTG3_PIXEL_RATE_DIVK2, k2);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-static void dccg35_set_dtbclk_p_src(
-		struct dccg *dccg,
-		enum streamclk_source src,
-		uint32_t otg_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	uint32_t p_src_sel = 0; /* selects dprefclk */
-	if (src == DTBCLK0)
-		p_src_sel = 2;  /* selects dtbclk0 */
-
-	switch (otg_inst) {
-	case 0:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P0_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P0_SRC_SEL, p_src_sel,
-					DTBCLK_P0_EN, 1);
-		break;
-	case 1:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P1_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P1_SRC_SEL, p_src_sel,
-					DTBCLK_P1_EN, 1);
-		break;
-	case 2:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P2_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P2_SRC_SEL, p_src_sel,
-					DTBCLK_P2_EN, 1);
-		break;
-	case 3:
-		if (src == REFCLK)
-			REG_UPDATE(DTBCLK_P_CNTL,
-					DTBCLK_P3_EN, 0);
-		else
-			REG_UPDATE_2(DTBCLK_P_CNTL,
-					DTBCLK_P3_SRC_SEL, p_src_sel,
-					DTBCLK_P3_EN, 1);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-}
-
-/* Controls the generation of pixel valid for OTG in (OTG -> HPO case) */
-static void dccg35_set_dtbclk_dto(
-		struct dccg *dccg,
-		const struct dtbclk_dto_params *params)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-	/* DTO Output Rate / Pixel Rate = 1/4 */
-	int req_dtbclk_khz = params->pixclk_khz / 4;
-
-	if (params->ref_dtbclk_khz && req_dtbclk_khz) {
-		uint32_t modulo, phase;
-
-		switch (params->otg_inst) {
-		case 0:
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P0_GATE_DISABLE, 1);
-			break;
-		case 1:
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P1_GATE_DISABLE, 1);
-			break;
-		case 2:
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P2_GATE_DISABLE, 1);
-			break;
-		case 3:
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P3_GATE_DISABLE, 1);
-			break;
-		}
-
-		// phase / modulo = dtbclk / dtbclk ref
-		modulo = params->ref_dtbclk_khz * 1000;
-		phase = req_dtbclk_khz * 1000;
-
-		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);
-		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);
-
-		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLK_DTO_ENABLE[params->otg_inst], 1);
-
-		REG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,
-				1, 100);
-
-		/* program OTG_PIXEL_RATE_DIV for DIVK1 and DIVK2 fields */
-		dccg35_set_pixel_rate_div(dccg, params->otg_inst, PIXEL_RATE_DIV_BY_1, PIXEL_RATE_DIV_BY_1);
-
-		/* The recommended programming sequence to enable DTBCLK DTO to generate
-		 * valid pixel HPO DPSTREAM ENCODER, specifies that DTO source select should
-		 * be set only after DTO is enabled
-		 */
-		REG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				PIPE_DTO_SRC_SEL[params->otg_inst], 2);
-	} else {
-		switch (params->otg_inst) {
-		case 0:
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P0_GATE_DISABLE, 0);
-			break;
-		case 1:
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P1_GATE_DISABLE, 0);
-			break;
-		case 2:
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P2_GATE_DISABLE, 0);
-			break;
-		case 3:
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P3_GATE_DISABLE, 0);
-			break;
-		}
-
-		REG_UPDATE_2(OTG_PIXEL_RATE_CNTL[params->otg_inst],
-				DTBCLK_DTO_ENABLE[params->otg_inst], 0,
-				PIPE_DTO_SRC_SEL[params->otg_inst], params->is_hdmi ? 0 : 1);
-
-		REG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);
-		REG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);
-	}
-}
-
-static void dccg35_set_dpstreamclk(
-		struct dccg *dccg,
-		enum streamclk_source src,
-		int otg_inst,
-		int dp_hpo_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	/* set the dtbclk_p source */
-	dccg35_set_dtbclk_p_src(dccg, src, otg_inst);
-
-	/* enabled to select one of the DTBCLKs for pipe */
-	switch (dp_hpo_inst) {
-	case 0:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK0_EN,
-				(src == REFCLK) ? 0 : 1, DPSTREAMCLK0_SRC_SEL, otg_inst);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_ROOT_GATE_DISABLE, (src == REFCLK) ? 0 : 1);
-		break;
-	case 1:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN,
-				(src == REFCLK) ? 0 : 1, DPSTREAMCLK1_SRC_SEL, otg_inst);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_ROOT_GATE_DISABLE, (src == REFCLK) ? 0 : 1);
-		break;
-	case 2:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN,
-				(src == REFCLK) ? 0 : 1, DPSTREAMCLK2_SRC_SEL, otg_inst);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_ROOT_GATE_DISABLE, (src == REFCLK) ? 0 : 1);
-		break;
-	case 3:
-		REG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN,
-				(src == REFCLK) ? 0 : 1, DPSTREAMCLK3_SRC_SEL, otg_inst);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_ROOT_GATE_DISABLE, (src == REFCLK) ? 0 : 1);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-
-static void dccg35_set_dpstreamclk_root_clock_gating(
-		struct dccg *dccg,
-		int dp_hpo_inst,
-		bool enable)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	switch (dp_hpo_inst) {
-	case 0:
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_ROOT_GATE_DISABLE, enable ? 1 : 0);
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_GATE_DISABLE, enable ? 1 : 0);
-		}
-		break;
-	case 1:
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_ROOT_GATE_DISABLE, enable ? 1 : 0);
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_GATE_DISABLE, enable ? 1 : 0);
-		}
-		break;
-	case 2:
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_ROOT_GATE_DISABLE, enable ? 1 : 0);
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_GATE_DISABLE, enable ? 1 : 0);
-		}
-		break;
-	case 3:
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream) {
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_ROOT_GATE_DISABLE, enable ? 1 : 0);
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_GATE_DISABLE, enable ? 1 : 0);
-		}
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-
-
-static void dccg35_set_physymclk_root_clock_gating(
-		struct dccg *dccg,
-		int phy_inst,
-		bool enable)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)
-		return;
-
-	switch (phy_inst) {
-	case 0:
-		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-				PHYASYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
-		break;
-	case 1:
-		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-				PHYBSYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
-		break;
-	case 2:
-		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-				PHYCSYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
-		break;
-	case 3:
-		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-				PHYDSYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
-		break;
-	case 4:
-		REG_UPDATE(DCCG_GATE_DISABLE_CNTL2,
-				PHYESYMCLK_ROOT_GATE_DISABLE, enable ? 1 : 0);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-static void dccg35_set_physymclk(
-		struct dccg *dccg,
-		int phy_inst,
-		enum physymclk_clock_source clk_src,
-		bool force_enable)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	/* Force PHYSYMCLK on and Select phyd32clk as the source of clock which is output to PHY through DCIO */
-	switch (phy_inst) {
-	case 0:
-		if (force_enable) {
-			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
-					PHYASYMCLK_EN, 1,
-					PHYASYMCLK_SRC_SEL, clk_src);
-		} else {
-			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
-					PHYASYMCLK_EN, 0,
-					PHYASYMCLK_SRC_SEL, 0);
-		}
-		break;
-	case 1:
-		if (force_enable) {
-			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
-					PHYBSYMCLK_EN, 1,
-					PHYBSYMCLK_SRC_SEL, clk_src);
-		} else {
-			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
-					PHYBSYMCLK_EN, 0,
-					PHYBSYMCLK_SRC_SEL, 0);
-		}
-		break;
-	case 2:
-		if (force_enable) {
-			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
-					PHYCSYMCLK_EN, 1,
-					PHYCSYMCLK_SRC_SEL, clk_src);
-		} else {
-			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
-					PHYCSYMCLK_EN, 0,
-					PHYCSYMCLK_SRC_SEL, 0);
-		}
-		break;
-	case 3:
-		if (force_enable) {
-			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
-					PHYDSYMCLK_EN, 1,
-					PHYDSYMCLK_SRC_SEL, clk_src);
-		} else {
-			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
-					PHYDSYMCLK_EN, 0,
-					PHYDSYMCLK_SRC_SEL, 0);
-		}
-		break;
-	case 4:
-		if (force_enable) {
-			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
-					PHYESYMCLK_EN, 1,
-					PHYESYMCLK_SRC_SEL, clk_src);
-		} else {
-			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
-					PHYESYMCLK_EN, 0,
-					PHYESYMCLK_SRC_SEL, 0);
-		}
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-static void dccg35_set_valid_pixel_rate(
-		struct dccg *dccg,
-		int ref_dtbclk_khz,
-		int otg_inst,
-		int pixclk_khz)
-{
-	struct dtbclk_dto_params dto_params = {0};
-
-	dto_params.ref_dtbclk_khz = ref_dtbclk_khz;
-	dto_params.otg_inst = otg_inst;
-	dto_params.pixclk_khz = pixclk_khz;
-	dto_params.is_hdmi = true;
-
-	dccg35_set_dtbclk_dto(dccg, &dto_params);
-}
-
-static void dccg35_dpp_root_clock_control(
-		struct dccg *dccg,
-		unsigned int dpp_inst,
-		bool clock_on)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (dccg->dpp_clock_gated[dpp_inst] == clock_on)
-		return;
-
-	if (clock_on) {
-		/* turn off the DTO and leave phase/modulo at max */
-		dcn35_set_dppclk_enable(dccg, dpp_inst, 1);
-		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
-			  DPPCLK0_DTO_PHASE, 0xFF,
-			  DPPCLK0_DTO_MODULO, 0xFF);
-	} else {
-		dcn35_set_dppclk_enable(dccg, dpp_inst, 0);
-		/* turn on the DTO to generate a 0hz clock */
-		REG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,
-			  DPPCLK0_DTO_PHASE, 0,
-			  DPPCLK0_DTO_MODULO, 1);
-	}
-
-	dccg->dpp_clock_gated[dpp_inst] = !clock_on;
-}
-
-static void dccg35_disable_symclk32_se(
-		struct dccg *dccg,
-		int hpo_se_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	/* set refclk as the source for symclk32_se */
-	switch (hpo_se_inst) {
-	case 0:
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE0_SRC_SEL, 0,
-				SYMCLK32_SE0_EN, 0);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se) {
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE0_GATE_DISABLE, 0);
-//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
-//					SYMCLK32_ROOT_SE0_GATE_DISABLE, 0);
-		}
-		break;
-	case 1:
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE1_SRC_SEL, 0,
-				SYMCLK32_SE1_EN, 0);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se) {
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE1_GATE_DISABLE, 0);
-//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
-//					SYMCLK32_ROOT_SE1_GATE_DISABLE, 0);
-		}
-		break;
-	case 2:
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE2_SRC_SEL, 0,
-				SYMCLK32_SE2_EN, 0);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se) {
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE2_GATE_DISABLE, 0);
-//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
-//					SYMCLK32_ROOT_SE2_GATE_DISABLE, 0);
-		}
-		break;
-	case 3:
-		REG_UPDATE_2(SYMCLK32_SE_CNTL,
-				SYMCLK32_SE3_SRC_SEL, 0,
-				SYMCLK32_SE3_EN, 0);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se) {
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
-					SYMCLK32_SE3_GATE_DISABLE, 0);
-//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL3,
-//					SYMCLK32_ROOT_SE3_GATE_DISABLE, 0);
-		}
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-void dccg35_init(struct dccg *dccg)
-{
-	int otg_inst;
-	/* Set HPO stream encoder to use refclk to avoid case where PHY is
-	 * disabled and SYMCLK32 for HPO SE is sourced from PHYD32CLK which
-	 * will cause DCN to hang.
-	 */
-	for (otg_inst = 0; otg_inst < 4; otg_inst++)
-		dccg35_disable_symclk32_se(dccg, otg_inst);
-
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
-		for (otg_inst = 0; otg_inst < 2; otg_inst++) {
-			dccg31_disable_symclk32_le(dccg, otg_inst);
-			dccg31_set_symclk32_le_root_clock_gating(dccg, otg_inst, false);
-		}
-
-//	if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-//		for (otg_inst = 0; otg_inst < 4; otg_inst++)
-//			dccg35_disable_symclk_se(dccg, otg_inst, otg_inst);
-
-
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)
-		for (otg_inst = 0; otg_inst < 4; otg_inst++) {
-			dccg35_set_dpstreamclk(dccg, REFCLK, otg_inst,
-						otg_inst);
-			dccg35_set_dpstreamclk_root_clock_gating(dccg, otg_inst, false);
-		}
-
-	if (dccg->ctx->dc->debug.root_clock_optimization.bits.dpp)
-		for (otg_inst = 0; otg_inst < 4; otg_inst++)
-			dccg35_set_dppclk_root_clock_gating(dccg, otg_inst, 0);
-
-/*
-	dccg35_enable_global_fgcg_rep(
-		dccg, dccg->ctx->dc->debug.enable_fine_grain_clock_gating.bits
-			      .dccg_global_fgcg_rep);*/
-}
-
-void dccg35_enable_global_fgcg_rep(struct dccg *dccg, bool value)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	REG_UPDATE(DCCG_GLOBAL_FGCG_REP_CNTL, DCCG_GLOBAL_FGCG_REP_DIS, !value);
-}
-
-static void dccg35_enable_dscclk(struct dccg *dccg, int inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	//Disable DTO
-	switch (inst) {
-	case 0:
-		REG_UPDATE_2(DSCCLK0_DTO_PARAM,
-				DSCCLK0_DTO_PHASE, 0,
-				DSCCLK0_DTO_MODULO, 0);
-		REG_UPDATE(DSCCLK_DTO_CTRL,	DSCCLK0_EN, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK0_ROOT_GATE_DISABLE, 1);
-		break;
-	case 1:
-		REG_UPDATE_2(DSCCLK1_DTO_PARAM,
-				DSCCLK1_DTO_PHASE, 0,
-				DSCCLK1_DTO_MODULO, 0);
-		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK1_EN, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK1_ROOT_GATE_DISABLE, 1);
-		break;
-	case 2:
-		REG_UPDATE_2(DSCCLK2_DTO_PARAM,
-				DSCCLK2_DTO_PHASE, 0,
-				DSCCLK2_DTO_MODULO, 0);
-		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK2_EN, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK2_ROOT_GATE_DISABLE, 1);
-		break;
-	case 3:
-		REG_UPDATE_2(DSCCLK3_DTO_PARAM,
-				DSCCLK3_DTO_PHASE, 0,
-				DSCCLK3_DTO_MODULO, 0);
-		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK3_EN, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK3_ROOT_GATE_DISABLE, 1);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-}
-
-static void dccg35_disable_dscclk(struct dccg *dccg,
-				int inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	if (!dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-		return;
-
-	switch (inst) {
-	case 0:
-		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK0_EN, 0);
-		REG_UPDATE_2(DSCCLK0_DTO_PARAM,
-				DSCCLK0_DTO_PHASE, 0,
-				DSCCLK0_DTO_MODULO, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK0_ROOT_GATE_DISABLE, 0);
-		break;
-	case 1:
-		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK1_EN, 0);
-		REG_UPDATE_2(DSCCLK1_DTO_PARAM,
-				DSCCLK1_DTO_PHASE, 0,
-				DSCCLK1_DTO_MODULO, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK1_ROOT_GATE_DISABLE, 0);
-		break;
-	case 2:
-		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK2_EN, 0);
-		REG_UPDATE_2(DSCCLK2_DTO_PARAM,
-				DSCCLK2_DTO_PHASE, 0,
-				DSCCLK2_DTO_MODULO, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK2_ROOT_GATE_DISABLE, 0);
-		break;
-	case 3:
-		REG_UPDATE(DSCCLK_DTO_CTRL, DSCCLK3_EN, 0);
-		REG_UPDATE_2(DSCCLK3_DTO_PARAM,
-				DSCCLK3_DTO_PHASE, 0,
-				DSCCLK3_DTO_MODULO, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.dsc)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL6, DSCCLK3_ROOT_GATE_DISABLE, 0);
-		break;
-	default:
-		return;
-	}
-}
-
-static void dccg35_enable_symclk_se(struct dccg *dccg, uint32_t stream_enc_inst, uint32_t link_enc_inst)
-{
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	switch (link_enc_inst) {
-	case 0:
-		REG_UPDATE(SYMCLKA_CLOCK_ENABLE,
-				SYMCLKA_CLOCK_ENABLE, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_ROOT_GATE_DISABLE, 1);
-		break;
-	case 1:
-		REG_UPDATE(SYMCLKB_CLOCK_ENABLE,
-				SYMCLKB_CLOCK_ENABLE, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_ROOT_GATE_DISABLE, 1);
-		break;
-	case 2:
-		REG_UPDATE(SYMCLKC_CLOCK_ENABLE,
-				SYMCLKC_CLOCK_ENABLE, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_ROOT_GATE_DISABLE, 1);
-		break;
-	case 3:
-		REG_UPDATE(SYMCLKD_CLOCK_ENABLE,
-				SYMCLKD_CLOCK_ENABLE, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_ROOT_GATE_DISABLE, 1);
-		break;
-	case 4:
-		REG_UPDATE(SYMCLKE_CLOCK_ENABLE,
-				SYMCLKE_CLOCK_ENABLE, 1);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_ROOT_GATE_DISABLE, 1);
-		break;
-	}
-
-	switch (stream_enc_inst) {
-	case 0:
-		REG_UPDATE_2(SYMCLKA_CLOCK_ENABLE,
-				SYMCLKA_FE_EN, 1,
-				SYMCLKA_FE_SRC_SEL, link_enc_inst);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_FE_ROOT_GATE_DISABLE, 1);
-		break;
-	case 1:
-		REG_UPDATE_2(SYMCLKB_CLOCK_ENABLE,
-				SYMCLKB_FE_EN, 1,
-				SYMCLKB_FE_SRC_SEL, link_enc_inst);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_FE_ROOT_GATE_DISABLE, 1);
-		break;
-	case 2:
-		REG_UPDATE_2(SYMCLKC_CLOCK_ENABLE,
-				SYMCLKC_FE_EN, 1,
-				SYMCLKC_FE_SRC_SEL, link_enc_inst);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_FE_ROOT_GATE_DISABLE, 1);
-		break;
-	case 3:
-		REG_UPDATE_2(SYMCLKD_CLOCK_ENABLE,
-				SYMCLKD_FE_EN, 1,
-				SYMCLKD_FE_SRC_SEL, link_enc_inst);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_FE_ROOT_GATE_DISABLE, 1);
-		break;
-	case 4:
-		REG_UPDATE_2(SYMCLKE_CLOCK_ENABLE,
-				SYMCLKE_FE_EN, 1,
-				SYMCLKE_FE_SRC_SEL, link_enc_inst);
-		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_FE_ROOT_GATE_DISABLE, 1);
-		break;
-	}
-}
-
-/*get other front end connected to this backend*/
-static uint8_t dccg35_get_other_enabled_symclk_fe(struct dccg *dccg, uint32_t stream_enc_inst, uint32_t link_enc_inst)
-{
-	uint8_t num_enabled_symclk_fe = 0;
-	uint32_t be_clk_en = 0, fe_clk_en[5] = {0}, be_clk_sel[5] = {0};
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	switch (link_enc_inst) {
-	case 0:
-		REG_GET_3(SYMCLKA_CLOCK_ENABLE, SYMCLKA_CLOCK_ENABLE, &be_clk_en,
-				SYMCLKA_FE_EN, &fe_clk_en[0],
-				SYMCLKA_FE_SRC_SEL, &be_clk_sel[0]);
-				break;
-	case 1:
-		REG_GET_3(SYMCLKB_CLOCK_ENABLE, SYMCLKB_CLOCK_ENABLE, &be_clk_en,
-				SYMCLKB_FE_EN, &fe_clk_en[1],
-				SYMCLKB_FE_SRC_SEL, &be_clk_sel[1]);
-				break;
-	case 2:
-			REG_GET_3(SYMCLKC_CLOCK_ENABLE, SYMCLKC_CLOCK_ENABLE, &be_clk_en,
-				SYMCLKC_FE_EN, &fe_clk_en[2],
-				SYMCLKC_FE_SRC_SEL, &be_clk_sel[2]);
-				break;
-	case 3:
-			REG_GET_3(SYMCLKD_CLOCK_ENABLE, SYMCLKD_CLOCK_ENABLE, &be_clk_en,
-				SYMCLKD_FE_EN, &fe_clk_en[3],
-				SYMCLKD_FE_SRC_SEL, &be_clk_sel[3]);
-				break;
-	case 4:
-			REG_GET_3(SYMCLKE_CLOCK_ENABLE, SYMCLKE_CLOCK_ENABLE, &be_clk_en,
-				SYMCLKE_FE_EN, &fe_clk_en[4],
-				SYMCLKE_FE_SRC_SEL, &be_clk_sel[4]);
-				break;
-	}
-	if (be_clk_en) {
-	/* for DPMST, this backend could be used by multiple front end.
-	only disable the backend if this stream_enc_ins is the last active stream enc connected to this back_end*/
-		uint8_t i;
-		for (i = 0; i != link_enc_inst && i < sizeof(fe_clk_en); i++) {
-			if (fe_clk_en[i] && be_clk_sel[i] == link_enc_inst)
-				num_enabled_symclk_fe++;
-		}
-	}
-	return num_enabled_symclk_fe;
-}
-
-static void dccg35_disable_symclk_se(struct dccg *dccg, uint32_t stream_enc_inst, uint32_t link_enc_inst)
-{
-	uint8_t num_enabled_symclk_fe = 0;
-	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
-
-	switch (stream_enc_inst) {
-	case 0:
-		REG_UPDATE_2(SYMCLKA_CLOCK_ENABLE,
-				SYMCLKA_FE_EN, 0,
-				SYMCLKA_FE_SRC_SEL, 0);
-//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_FE_ROOT_GATE_DISABLE, 0);
-		break;
-	case 1:
-		REG_UPDATE_2(SYMCLKB_CLOCK_ENABLE,
-				SYMCLKB_FE_EN, 0,
-				SYMCLKB_FE_SRC_SEL, 0);
-//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_FE_ROOT_GATE_DISABLE, 0);
-		break;
-	case 2:
-		REG_UPDATE_2(SYMCLKC_CLOCK_ENABLE,
-				SYMCLKC_FE_EN, 0,
-				SYMCLKC_FE_SRC_SEL, 0);
-//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_FE_ROOT_GATE_DISABLE, 0);
-		break;
-	case 3:
-		REG_UPDATE_2(SYMCLKD_CLOCK_ENABLE,
-				SYMCLKD_FE_EN, 0,
-				SYMCLKD_FE_SRC_SEL, 0);
-//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_FE_ROOT_GATE_DISABLE, 0);
-		break;
-	case 4:
-		REG_UPDATE_2(SYMCLKE_CLOCK_ENABLE,
-				SYMCLKE_FE_EN, 0,
-				SYMCLKE_FE_SRC_SEL, 0);
-//		if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_se)
-//			REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_FE_ROOT_GATE_DISABLE, 0);
-		break;
-	}
-
-	/*check other enabled symclk fe */
-	num_enabled_symclk_fe = dccg35_get_other_enabled_symclk_fe(dccg, stream_enc_inst, link_enc_inst);
-	/*only turn off backend clk if other front end attachecd to this backend are all off,
-	 for mst, only turn off the backend if this is the last front end*/
-	if (num_enabled_symclk_fe == 0) {
-		switch (link_enc_inst) {
-		case 0:
-			REG_UPDATE(SYMCLKA_CLOCK_ENABLE,
-					SYMCLKA_CLOCK_ENABLE, 0);
-//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
-//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_ROOT_GATE_DISABLE, 0);
-			break;
-		case 1:
-			REG_UPDATE(SYMCLKB_CLOCK_ENABLE,
-					SYMCLKB_CLOCK_ENABLE, 0);
-//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
-//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_ROOT_GATE_DISABLE, 0);
-			break;
-		case 2:
-			REG_UPDATE(SYMCLKC_CLOCK_ENABLE,
-					SYMCLKC_CLOCK_ENABLE, 0);
-//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
-//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_ROOT_GATE_DISABLE, 0);
-			break;
-		case 3:
-			REG_UPDATE(SYMCLKD_CLOCK_ENABLE,
-					SYMCLKD_CLOCK_ENABLE, 0);
-//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
-//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_ROOT_GATE_DISABLE, 0);
-			break;
-		case 4:
-			REG_UPDATE(SYMCLKE_CLOCK_ENABLE,
-					SYMCLKE_CLOCK_ENABLE, 0);
-//			if (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)
-//				REG_UPDATE(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_ROOT_GATE_DISABLE, 0);
-			break;
-		}
-	}
-}
-
-static const struct dccg_funcs dccg35_funcs = {
-	.update_dpp_dto = dccg35_update_dpp_dto,
-	.dpp_root_clock_control = dccg35_dpp_root_clock_control,
-	.get_dccg_ref_freq = dccg31_get_dccg_ref_freq,
-	.dccg_init = dccg35_init,
-	.set_dpstreamclk = dccg35_set_dpstreamclk,
-	.set_dpstreamclk_root_clock_gating = dccg35_set_dpstreamclk_root_clock_gating,
-	.enable_symclk32_se = dccg31_enable_symclk32_se,
-	.disable_symclk32_se = dccg35_disable_symclk32_se,
-	.enable_symclk32_le = dccg31_enable_symclk32_le,
-	.disable_symclk32_le = dccg31_disable_symclk32_le,
-	.set_symclk32_le_root_clock_gating = dccg31_set_symclk32_le_root_clock_gating,
-	.set_physymclk = dccg35_set_physymclk,
-	.set_physymclk_root_clock_gating = dccg35_set_physymclk_root_clock_gating,
-	.set_dtbclk_dto = dccg35_set_dtbclk_dto,
-	.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,
-	.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,
-	.otg_add_pixel = dccg31_otg_add_pixel,
-	.otg_drop_pixel = dccg31_otg_drop_pixel,
-	.set_dispclk_change_mode = dccg31_set_dispclk_change_mode,
-	.disable_dsc = dccg35_disable_dscclk,
-	.enable_dsc = dccg35_enable_dscclk,
-	.set_pixel_rate_div = dccg35_set_pixel_rate_div,
-	.trigger_dio_fifo_resync = dccg35_trigger_dio_fifo_resync,
-	.set_valid_pixel_rate = dccg35_set_valid_pixel_rate,
-	.enable_symclk_se = dccg35_enable_symclk_se,
-	.disable_symclk_se = dccg35_disable_symclk_se,
-	.set_dtbclk_p_src = dccg35_set_dtbclk_p_src,
-};
-
-struct dccg *dccg35_create(
-	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *dccg_shift,
-	const struct dccg_mask *dccg_mask)
-{
-	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
-	struct dccg *base;
-
-	if (dccg_dcn == NULL) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	base = &dccg_dcn->base;
-	base->ctx = ctx;
-	base->funcs = &dccg35_funcs;
-
-	dccg_dcn->regs = regs;
-	dccg_dcn->dccg_shift = dccg_shift;
-	dccg_dcn->dccg_mask = dccg_mask;
-
-	return &dccg_dcn->base;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.h
deleted file mode 100644
index 1586a45ca3bd..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.h
+++ /dev/null
@@ -1,246 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-/*
- * Copyright 2023 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __DCN35_DCCG_H__
-#define __DCN35_DCCG_H__
-
-#include "dcn314/dcn314_dccg.h"
-
-#define DCCG_SFII(block, reg_name, field_prefix, field_name, inst, post_fix)\
-	.field_prefix ## _ ## field_name[inst] = block ## inst ## _ ## reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
-
-
-#define DCCG_REG_LIST_DCN35() \
-	DCCG_REG_LIST_DCN314(),\
-	SR(DPPCLK_CTRL),\
-	SR(DCCG_GATE_DISABLE_CNTL4),\
-	SR(DCCG_GATE_DISABLE_CNTL5),\
-	SR(DCCG_GATE_DISABLE_CNTL6),\
-	SR(DCCG_GLOBAL_FGCG_REP_CNTL),\
-	SR(SYMCLKA_CLOCK_ENABLE),\
-	SR(SYMCLKB_CLOCK_ENABLE),\
-	SR(SYMCLKC_CLOCK_ENABLE),\
-	SR(SYMCLKD_CLOCK_ENABLE),\
-	SR(SYMCLKE_CLOCK_ENABLE)
-
-#define DCCG_MASK_SH_LIST_DCN35(mask_sh) \
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
-	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
-	DCCG_SF(DPPCLK_CTRL, DPPCLK0_EN, mask_sh),\
-	DCCG_SF(DPPCLK_CTRL, DPPCLK1_EN, mask_sh),\
-	DCCG_SF(DPPCLK_CTRL, DPPCLK2_EN, mask_sh),\
-	DCCG_SF(DPPCLK_CTRL, DPPCLK3_EN, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_EN, mask_sh),\
-	DCCG_SF(HDMICHARCLK0_CLOCK_CNTL, HDMICHARCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_EN, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_EN, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_EN, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_EN, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK1_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK2_SRC_SEL, mask_sh),\
-	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK3_SRC_SEL, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_EN, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK_CNTL, HDMISTREAMCLK0_SRC_SEL, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK0_EN, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK1_EN, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK2_EN, mask_sh),\
-	DCCG_SF(DSCCLK_DTO_CTRL, DSCCLK3_EN, mask_sh),\
-	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK0_DTO_PARAM, DSCCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK1_DTO_PARAM, DSCCLK1_DTO_MODULO, mask_sh),\
-	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK2_DTO_PARAM, DSCCLK2_DTO_MODULO, mask_sh),\
-	DCCG_SF(DSCCLK3_DTO_PARAM, DSCCLK3_DTO_PHASE, mask_sh),\
-	DCCG_SF(DSCCLK3_DTO_PARAM, DSCCLK3_DTO_MODULO, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_EN, mask_sh),\
-	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_EN, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 3, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, ADD_PIXEL, 3, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG0_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG1_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG2_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK1, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SF(OTG_PIXEL_RATE_DIV, OTG3_PIXEL_RATE_DIVK2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 0, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 1, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 2, mask_sh),\
-	DCCG_SFII(OTG, PIXEL_RATE_CNTL, OTG, DROP_PIXEL, 3, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P0_EN, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P1_EN, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P2_EN, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_SRC_SEL, mask_sh),\
-	DCCG_SF(DTBCLK_P_CNTL, DTBCLK_P3_EN, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_EN, mask_sh),\
-	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_EN, mask_sh),\
-	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_EN, mask_sh),\
-	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_EN, mask_sh),\
-	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_EN, mask_sh),\
-	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_SRC_SEL, mask_sh),\
-	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
-	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_DONE, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, mask_sh),\
-	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYASYMCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYBSYMCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYCSYMCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYDSYMCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, PHYESYMCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GLOBAL_FGCG_REP_CNTL, DCCG_GLOBAL_FGCG_REP_DIS, mask_sh),\
-	DCCG_SF(SYMCLKA_CLOCK_ENABLE, SYMCLKA_CLOCK_ENABLE, mask_sh),\
-	DCCG_SF(SYMCLKB_CLOCK_ENABLE, SYMCLKB_CLOCK_ENABLE, mask_sh),\
-	DCCG_SF(SYMCLKC_CLOCK_ENABLE, SYMCLKC_CLOCK_ENABLE, mask_sh),\
-	DCCG_SF(SYMCLKD_CLOCK_ENABLE, SYMCLKD_CLOCK_ENABLE, mask_sh),\
-	DCCG_SF(SYMCLKE_CLOCK_ENABLE, SYMCLKE_CLOCK_ENABLE, mask_sh),\
-	DCCG_SF(SYMCLKA_CLOCK_ENABLE, SYMCLKA_FE_EN, mask_sh),\
-	DCCG_SF(SYMCLKB_CLOCK_ENABLE, SYMCLKB_FE_EN, mask_sh),\
-	DCCG_SF(SYMCLKC_CLOCK_ENABLE, SYMCLKC_FE_EN, mask_sh),\
-	DCCG_SF(SYMCLKD_CLOCK_ENABLE, SYMCLKD_FE_EN, mask_sh),\
-	DCCG_SF(SYMCLKE_CLOCK_ENABLE, SYMCLKE_FE_EN, mask_sh),\
-	DCCG_SF(SYMCLKA_CLOCK_ENABLE, SYMCLKA_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLKB_CLOCK_ENABLE, SYMCLKB_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLKC_CLOCK_ENABLE, SYMCLKC_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLKD_CLOCK_ENABLE, SYMCLKD_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLKE_CLOCK_ENABLE, SYMCLKE_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLKA_CLOCK_ENABLE, SYMCLKA_FE_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLKB_CLOCK_ENABLE, SYMCLKB_FE_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLKC_CLOCK_ENABLE, SYMCLKC_FE_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLKD_CLOCK_ENABLE, SYMCLKD_FE_SRC_SEL, mask_sh),\
-	DCCG_SF(SYMCLKE_CLOCK_ENABLE, SYMCLKE_FE_SRC_SEL, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P2_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DTBCLK_P3_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DSCCLK0_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DSCCLK1_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DSCCLK2_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DSCCLK3_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_FE_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_FE_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_FE_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_FE_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_FE_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DPPCLK0_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DPPCLK1_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DPPCLK2_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, DPPCLK3_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL2, HDMICHARCLK0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, HDMICHARCLK0_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL6, HDMISTREAMCLK0_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKA_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKB_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKC_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKD_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, SYMCLKE_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE2_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_SE3_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_ROOT_LE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE2_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_SE3_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_LE0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, SYMCLK32_LE1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYA_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYB_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYC_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYD_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL4, PHYE_REFCLK_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_ROOT_GATE_DISABLE, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_PHASE, mask_sh),\
-	DCCG_SF(HDMISTREAMCLK0_DTO_PARAM, HDMISTREAMCLK0_DTO_MODULO, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL, DISPCLK_DCCG_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL3, HDMISTREAMCLK0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK0_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK1_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK2_GATE_DISABLE, mask_sh),\
-	DCCG_SF(DCCG_GATE_DISABLE_CNTL5, DPSTREAMCLK3_GATE_DISABLE, mask_sh),\
-
-struct dccg *dccg35_create(
-		struct dc_context *ctx,
-		const struct dccg_registers *regs,
-		const struct dccg_shift *dccg_shift,
-		const struct dccg_mask *dccg_mask);
-
-void dccg35_init(struct dccg *dccg);
-
-void dccg35_enable_global_fgcg_rep(struct dccg *dccg, bool value);
-
-
-#endif //__DCN35_DCCG_H__
-- 
2.46.1

