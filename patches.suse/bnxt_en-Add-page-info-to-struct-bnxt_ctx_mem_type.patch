From: Michael Chan <michael.chan@broadcom.com>
Date: Mon, 20 Nov 2023 15:43:56 -0800
Subject: bnxt_en: Add page info to struct bnxt_ctx_mem_type
Patch-mainline: v6.8-rc1
Git-commit: 035c57615982897da32bdbf311cd025001468f90
References: jsc#PED-7574

This will further improve the organization of the bnxt_ctx_mem_info
structure by moving the standalone page info structures into the
bnxt_ctx_mem_type array.  Add the allocation and free logic first and
the next patch will migrate to use the new infrastructure.

Reviewed-by: Somnath Kotur <somnath.kotur@broadcom.com>
Signed-off-by: Michael Chan <michael.chan@broadcom.com>
Link: https://lore.kernel.org/r/20231120234405.194542-5-michael.chan@broadcom.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/broadcom/bnxt/bnxt.c |   31 ++++++++++++++++++++++++++++++
 drivers/net/ethernet/broadcom/bnxt/bnxt.h |    1 
 2 files changed, 32 insertions(+)

--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -7202,6 +7202,27 @@ static void bnxt_init_ctx_initializer(st
 		ctxm->init_value = 0;
 }
 
+static int bnxt_alloc_all_ctx_pg_info(struct bnxt *bp, int ctx_max)
+{
+	struct bnxt_ctx_mem_info *ctx = bp->ctx;
+	u16 type;
+
+	for (type = 0; type < ctx_max; type++) {
+		struct bnxt_ctx_mem_type *ctxm = &ctx->ctx_arr[type];
+		int n = 1;
+
+		if (!ctxm->max_entries)
+			continue;
+
+		if (ctxm->instance_bmap)
+			n = hweight32(ctxm->instance_bmap);
+		ctxm->pg_info = kcalloc(n, sizeof(*ctxm->pg_info), GFP_KERNEL);
+		if (!ctxm->pg_info)
+			return -ENOMEM;
+	}
+	return 0;
+}
+
 static int bnxt_hwrm_func_backing_store_qcaps(struct bnxt *bp)
 {
 	struct hwrm_func_backing_store_qcaps_output *resp;
@@ -7313,6 +7334,7 @@ static int bnxt_hwrm_func_backing_store_
 		}
 		for (i = 0; i < tqm_rings; i++, ctx_pg++)
 			ctx->tqm_mem[i] = ctx_pg;
+		rc = bnxt_alloc_all_ctx_pg_info(bp, BNXT_CTX_MAX);
 	} else {
 		rc = 0;
 	}
@@ -7579,6 +7601,7 @@ static void bnxt_free_ctx_pg_tbls(struct
 void bnxt_free_ctx_mem(struct bnxt *bp)
 {
 	struct bnxt_ctx_mem_info *ctx = bp->ctx;
+	u16 type;
 	int i;
 
 	if (!ctx)
@@ -7598,6 +7621,14 @@ void bnxt_free_ctx_mem(struct bnxt *bp)
 	bnxt_free_ctx_pg_tbls(bp, &ctx->cq_mem);
 	bnxt_free_ctx_pg_tbls(bp, &ctx->srq_mem);
 	bnxt_free_ctx_pg_tbls(bp, &ctx->qp_mem);
+
+	for (type = 0; type < BNXT_CTX_MAX; type++) {
+		struct bnxt_ctx_mem_type *ctxm = &ctx->ctx_arr[type];
+
+		kfree(ctxm->pg_info);
+		ctxm->pg_info = NULL;
+	}
+
 	ctx->flags &= ~BNXT_CTX_FLAG_INITED;
 	kfree(ctx);
 	bp->ctx = NULL;
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -1579,6 +1579,7 @@ struct bnxt_ctx_mem_type {
 		};
 		u32	split[BNXT_MAX_SPLIT_ENTRY];
 	};
+	struct bnxt_ctx_pg_info	*pg_info;
 };
 
 #define BNXT_CTX_MRAV_AV_SPLIT_ENTRY	0
