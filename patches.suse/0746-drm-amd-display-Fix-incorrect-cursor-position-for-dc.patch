From fc09898c7346845ba4f01897bdea049f35e4966e Mon Sep 17 00:00:00 2001
From: Sridevi <sarvinde@amd.com>
Date: Fri, 26 Apr 2024 18:06:26 -0400
Subject: drm/amd/display: Fix incorrect cursor position for dcn401
Git-commit: c2edec1676ca40abf40d1d895765a6cf801decba
Patch-mainline: v6.11-rc1
References: jsc#PED-9898 jsc#PED-10191 jsc#PED-10197 jsc#PED-10226 jsc#PED-10237 jsc#PED-10340 jsc#PED-10852 jsc#PED-11022

[Why]
Incorrect cursor position calculation in some scenarios.  Also for
mirror and rotation cases.

[How]
Fix for incorrect cursor position.  Added new test scenarios for diags
cursor test.  Updated CRC for few of the diags cursor test scenarios.

Reviewed-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
Signed-off-by: Sridevi <sarvinde@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c | 18 +++++++----
 .../amd/display/dc/hwss/dcn401/dcn401_hwseq.c | 30 +++++++++++++------
 2 files changed, 34 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c
index a54b9089f15d..aef73bd1221a 100644
--- a/drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_cm.c
@@ -185,15 +185,23 @@ void dpp401_set_cursor_position(
 		rec_y_offset = y_pos - (cursor_height - y_hotspot);
 	}
 
-	if (rec_x_offset >= (int)param->recout.width)
-		cur_en = 0;  /* not visible beyond right edge*/
+	if (param->rotation == ROTATION_ANGLE_0 && !param->mirror) {
+		if (rec_x_offset >= (int)param->recout.width)
+			cur_en = 0;  /* not visible beyond right edge*/
+
+		if (rec_y_offset >= (int)param->recout.height)
+			cur_en = 0;  /* not visible beyond bottom edge*/
+	} else {
+		if (rec_x_offset > (int)param->recout.width)
+			cur_en = 0;  /* not visible beyond right edge*/
+
+		if (rec_y_offset > (int)param->recout.height)
+			cur_en = 0;  /* not visible beyond bottom edge*/
+	}
 
 	if (rec_x_offset + cursor_width <= 0)
 		cur_en = 0;  /* not visible beyond left edge*/
 
-	if (rec_y_offset >= (int)param->recout.height)
-		cur_en = 0;  /* not visible beyond bottom edge*/
-
 	if (rec_y_offset + cursor_height <= 0)
 		cur_en = 0;  /* not visible beyond top edge*/
 
diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
index f5333a095adb..407a45a3ae2c 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dcn401/dcn401_hwseq.c
@@ -1126,14 +1126,14 @@ void dcn401_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	 */
 
 	if (param.rotation == ROTATION_ANGLE_90 || param.rotation == ROTATION_ANGLE_270) {
-		x_pos = x_pos * pipe_ctx->stream->dst.width /
+		x_pos = pipe_ctx->stream->dst.x + x_pos * pipe_ctx->stream->dst.width /
 			pipe_ctx->stream->src.height;
-		y_pos = y_pos * pipe_ctx->stream->dst.height /
+		y_pos = pipe_ctx->stream->dst.y + y_pos * pipe_ctx->stream->dst.height /
 			pipe_ctx->stream->src.width;
 	} else {
-		x_pos = x_pos * pipe_ctx->stream->dst.width /
+		x_pos = pipe_ctx->stream->dst.x + x_pos * pipe_ctx->stream->dst.width /
 			pipe_ctx->stream->src.width;
-		y_pos = y_pos * pipe_ctx->stream->dst.height /
+		y_pos = pipe_ctx->stream->dst.y + y_pos * pipe_ctx->stream->dst.height /
 			pipe_ctx->stream->src.height;
 	}
 
@@ -1225,10 +1225,15 @@ void dcn401_set_cursor_position(struct pipe_ctx *pipe_ctx)
 			}
 		}
 	} else if (param.rotation == ROTATION_ANGLE_90) {
-		uint32_t temp_y = pos_cpy.y;
+		if (!param.mirror) {
+			uint32_t temp_y = pos_cpy.y;
+
+			pos_cpy.y = pipe_ctx->plane_res.scl_data.recout.height - pos_cpy.x;
+			pos_cpy.x = temp_y - prev_odm_width;
+		} else {
+			swap(pos_cpy.x, pos_cpy.y);
+		}
 
-		pos_cpy.y = pipe_ctx->plane_res.scl_data.recout.height - pos_cpy.x;
-		pos_cpy.x = temp_y - prev_odm_width;
 	} else if (param.rotation == ROTATION_ANGLE_270) {
 		// Swap axis and mirror vertically
 		uint32_t temp_x = pos_cpy.x;
@@ -1279,8 +1284,15 @@ void dcn401_set_cursor_position(struct pipe_ctx *pipe_ctx)
 				pos_cpy.y = temp_x;
 			}
 		} else {
-			pos_cpy.x = pipe_ctx->plane_res.scl_data.recout.width - pos_cpy.y;
-			pos_cpy.y = temp_x;
+			if (param.mirror) {
+				swap(pos_cpy.x, pos_cpy.y);
+
+				pos_cpy.x = pipe_ctx->plane_res.scl_data.recout.width - pos_cpy.x + 2 * pipe_ctx->plane_res.scl_data.recout.x;
+				pos_cpy.y = (2 * pipe_ctx->plane_res.scl_data.recout.y) + pipe_ctx->plane_res.scl_data.recout.height - pos_cpy.y;
+			} else {
+				pos_cpy.x = pipe_ctx->plane_res.scl_data.recout.width - pos_cpy.y;
+				pos_cpy.y = temp_x;
+			}
 		}
 	} else if (param.rotation == ROTATION_ANGLE_180) {
 		// Mirror horizontally and vertically
-- 
2.46.1

