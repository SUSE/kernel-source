From: Maxim Mikityanskiy <maximmi@nvidia.com>
Date: Tue, 6 Apr 2021 18:58:30 +0300
Subject: net/mlx5e: Create struct mlx5e_rss_params_hash
Patch-mainline: v5.15-rc1
Git-commit: 6fe5ff2c77805f1a3a4abf226087bf9ce1299371
References: jsc#SLE-19253

This commit introduces a new struct to store RSS hash parameters: hash
function and hash key. The existing usages are changed to use the new
struct.

Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h  |    8 ++++++--
 drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c |   18 ++++++++----------
 drivers/net/ethernet/mellanox/mlx5/core/en_main.c    |   14 +++++++-------
 drivers/net/ethernet/mellanox/mlx5/core/en_tc.c      |    2 +-
 4 files changed, 22 insertions(+), 20 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rx_res.h
@@ -10,11 +10,15 @@
 
 #define MLX5E_MAX_NUM_CHANNELS (MLX5E_INDIR_RQT_SIZE / 2)
 
+struct mlx5e_rss_params_hash {
+	u8 hfunc;
+	u8 toeplitz_hash_key[40];
+};
+
 struct mlx5e_rss_params {
+	struct mlx5e_rss_params_hash hash;
 	struct mlx5e_rss_params_indir indir;
 	u32 rx_hash_fields[MLX5E_NUM_INDIR_TIRS];
-	u8 toeplitz_hash_key[40];
-	u8 hfunc;
 };
 
 struct mlx5e_tir {
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@ -1172,7 +1172,7 @@ static int mlx5e_set_link_ksettings(stru
 
 u32 mlx5e_ethtool_get_rxfh_key_size(struct mlx5e_priv *priv)
 {
-	return sizeof(priv->rx_res->rss_params.toeplitz_hash_key);
+	return sizeof(priv->rx_res->rss_params.hash.toeplitz_hash_key);
 }
 
 static u32 mlx5e_get_rxfh_key_size(struct net_device *netdev)
@@ -1206,11 +1206,10 @@ int mlx5e_get_rxfh(struct net_device *ne
 		memcpy(indir, rss->indir.table, sizeof(rss->indir.table));
 
 	if (key)
-		memcpy(key, rss->toeplitz_hash_key,
-		       sizeof(rss->toeplitz_hash_key));
+		memcpy(key, rss->hash.toeplitz_hash_key, sizeof(rss->hash.toeplitz_hash_key));
 
 	if (hfunc)
-		*hfunc = rss->hfunc;
+		*hfunc = rss->hash.hfunc;
 
 	return 0;
 }
@@ -1238,8 +1237,8 @@ int mlx5e_set_rxfh(struct net_device *de
 
 	rss = &priv->rx_res->rss_params;
 
-	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != rss->hfunc) {
-		rss->hfunc = hfunc;
+	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != rss->hash.hfunc) {
+		rss->hash.hfunc = hfunc;
 		refresh_rqt = true;
 		refresh_tirs = true;
 	}
@@ -1250,9 +1249,8 @@ int mlx5e_set_rxfh(struct net_device *de
 	}
 
 	if (key) {
-		memcpy(rss->toeplitz_hash_key, key,
-		       sizeof(rss->toeplitz_hash_key));
-		refresh_tirs = refresh_tirs || rss->hfunc == ETH_RSS_HASH_TOP;
+		memcpy(rss->hash.toeplitz_hash_key, key, sizeof(rss->hash.toeplitz_hash_key));
+		refresh_tirs = refresh_tirs || rss->hash.hfunc == ETH_RSS_HASH_TOP;
 	}
 
 	if (refresh_rqt && test_bit(MLX5E_STATE_OPENED, &priv->state)) {
@@ -1267,7 +1265,7 @@ int mlx5e_set_rxfh(struct net_device *de
 
 			mlx5e_rqt_redirect_indir(&priv->rx_res->indir_rqt, rqns,
 						 priv->channels.num,
-						 rss->hfunc, &rss->indir);
+						 rss->hash.hfunc, &rss->indir);
 			kvfree(rqns);
 		}
 	}
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -2276,7 +2276,7 @@ static void mlx5e_redirect_rqts_to_chann
 			rqns[ix] = chs->c[ix]->rq.rqn;
 
 		mlx5e_rqt_redirect_indir(&res->indir_rqt, rqns, chs->num,
-					 res->rss_params.hfunc,
+					 res->rss_params.hash.hfunc,
 					 &res->rss_params.indir);
 		kvfree(rqns);
 	}
@@ -2384,15 +2384,15 @@ void mlx5e_build_indir_tir_ctx_hash(stru
 	void *hfso = inner ? MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_inner) :
 			     MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);
 
-	MLX5_SET(tirc, tirc, rx_hash_fn, mlx5e_rx_hash_fn(rss_params->hfunc));
-	if (rss_params->hfunc == ETH_RSS_HASH_TOP) {
+	MLX5_SET(tirc, tirc, rx_hash_fn, mlx5e_rx_hash_fn(rss_params->hash.hfunc));
+	if (rss_params->hash.hfunc == ETH_RSS_HASH_TOP) {
 		void *rss_key = MLX5_ADDR_OF(tirc, tirc,
 					     rx_hash_toeplitz_key);
 		size_t len = MLX5_FLD_SZ_BYTES(tirc,
 					       rx_hash_toeplitz_key);
 
 		MLX5_SET(tirc, tirc, rx_hash_symmetric, 1);
-		memcpy(rss_key, rss_params->toeplitz_hash_key, len);
+		memcpy(rss_key, rss_params->hash.toeplitz_hash_key, len);
 	}
 	MLX5_SET(rx_hash_field_select, hfso, l3_prot_type,
 		 ttconfig->l3_prot_type);
@@ -4595,9 +4595,9 @@ void mlx5e_build_rss_params(struct mlx5e
 {
 	enum mlx5e_traffic_types tt;
 
-	rss_params->hfunc = ETH_RSS_HASH_TOP;
-	netdev_rss_key_fill(rss_params->toeplitz_hash_key,
-			    sizeof(rss_params->toeplitz_hash_key));
+	rss_params->hash.hfunc = ETH_RSS_HASH_TOP;
+	netdev_rss_key_fill(rss_params->hash.toeplitz_hash_key,
+			    sizeof(rss_params->hash.toeplitz_hash_key));
 	mlx5e_build_default_indir_rqt(rss_params->indir.table,
 				      MLX5E_INDIR_RQT_SIZE, num_channels);
 	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++)
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -527,7 +527,7 @@ static int mlx5e_hairpin_create_indirect
 
 	mlx5e_build_default_indir_rqt(indir->table, MLX5E_INDIR_RQT_SIZE, hp->num_channels);
 	err = mlx5e_rqt_init_indir(&hp->indir_rqt, mdev, hp->pair->rqn, hp->num_channels,
-				   priv->rx_res->rss_params.hfunc, indir);
+				    priv->rx_res->rss_params.hash.hfunc, indir);
 
 	kvfree(indir);
 	return err;
