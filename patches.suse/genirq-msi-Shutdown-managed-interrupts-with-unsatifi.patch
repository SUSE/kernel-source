From: Marc Zyngier <maz@kernel.org>
Date: Tue, 5 Apr 2022 19:50:38 +0100
Subject: genirq/msi: Shutdown managed interrupts with unsatifiable affinities
Git-commit: d802057c7c553ad426520a053da9f9fe08e2c35a
Patch-mainline: 5.19-rc1
References: git-fixes

When booting with maxcpus=<small number>, interrupt controllers
such as the GICv3 ITS may not be able to satisfy the affinity of
some managed interrupts, as some of the HW resources are simply
not available.

The same thing happens when loading a driver using managed interrupts
while CPUs are offline.

In order to deal with this, do not try to activate such interrupt
if there is no online CPU capable of handling it. Instead, place
it in shutdown state. Once a capable CPU shows up, it will be
activated.

Reported-by: John Garry <john.garry@huawei.com>
Reported-by: David Decotigny <ddecotig@google.com>
Signed-off-by: Marc Zyngier <maz@kernel.org>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Tested-by: John Garry <john.garry@huawei.com>
Link: https://lore.kernel.org/r/20220405185040.206297-2-maz@kernel.org
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 kernel/irq/msi.c |   14 ++++++++++++++
 1 file changed, 14 insertions(+)

--- a/kernel/irq/msi.c
+++ b/kernel/irq/msi.c
@@ -456,6 +456,20 @@ int __msi_domain_alloc_irqs(struct irq_d
 			irqd_clr_can_reserve(irq_data);
 			if (domain->flags & IRQ_DOMAIN_MSI_NOMASK_QUIRK)
 				irqd_set_msi_nomask_quirk(irq_data);
+
+			/*
+			 * If the interrupt is managed but no CPU is available to
+			 * service it, shut it down until better times. Note that
+			 * we only do this on the !RESERVE path as x86 (the only
+			 * architecture using this flag) deals with this in a
+			 * different way by using a catch-all vector.
+			 */
+			if (irqd_affinity_is_managed(irq_data) &&
+			    !cpumask_intersects(irq_data_get_affinity_mask(irq_data),
+						cpu_online_mask)) {
+				    irqd_set_managed_shutdown(irq_data);
+				    return 0;
+			}
 		}
 		ret = irq_domain_activate_irq(irq_data, can_reserve);
 		if (ret)
