From 86cbcf6c354dbc278efdba569997604c8dc3f7c5 Mon Sep 17 00:00:00 2001
From: Matthew Auld <matthew.auld@intel.com>
Date: Fri, 20 Jan 2023 11:48:53 +0000
Subject: drm/xe/bo: reduce xe_bo_create_pin_map() restrictions
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: f3edf6917ca8e4e11a6af39e926558d4609dd9ea
Patch-mainline: v6.8-rc1
References: jsc#PED-9898 jsc#PED-10191 jsc#PED-10197 jsc#PED-10226 jsc#PED-10237 jsc#PED-10340 jsc#PED-10852 jsc#PED-11022

On DGFX this blows up if can call this with a system memory object:

XE_BUG_ON(!mem_type_is_vram(place->mem_type) && place->mem_type != XE_PL_STOLEN);

If we consider dpt it looks like we can already in theory hit this, if
we run out of vram and stolen vram. It at least seems reasonable to
allow calling this on any object which supports CPU access.

Note this also changes the behaviour with stolen VRAM and suspend, such
that we no longer attempt to migrate stolen objects into system memory.
However nothing in stolen should ever need to be restored (same on
integrated), so should be fine. Also on small-bar systems the stolen
portion is pretty much always non-CPU accessible, and currently pinned
objects use plain memcpy when being moved, which doesn't play nicely.

Signed-off-by: Matthew Auld <matthew.auld@intel.com>
Reviewed-by: Matthew Brost <matthew.brost@intel.com>
Cc: Thomas Hellstr√∂m <thomas.hellstrom@linux.intel.com>
Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/xe/xe_bo.c | 35 ++++++++++++++++++++---------------
 1 file changed, 20 insertions(+), 15 deletions(-)

diff --git a/drivers/gpu/drm/xe/xe_bo.c b/drivers/gpu/drm/xe/xe_bo.c
index 1fcde1e93301..3c9d90dcf125 100644
--- a/drivers/gpu/drm/xe/xe_bo.c
+++ b/drivers/gpu/drm/xe/xe_bo.c
@@ -1290,25 +1290,26 @@ int xe_bo_pin(struct xe_bo *bo)
 		return err;
 
 	/*
-	 * For pinned objects in on DGFX, we expect these objects to be in
-	 * contiguous VRAM memory. Required eviction / restore during suspend /
-	 * resume (force restore to same physical address).
+	 * For pinned objects in on DGFX, which are also in vram, we expect
+	 * these to be in contiguous VRAM memory. Required eviction / restore
+	 * during suspend / resume (force restore to same physical address).
 	 */
 	if (IS_DGFX(xe) && !(IS_ENABLED(CONFIG_DRM_XE_DEBUG) &&
 	    bo->flags & XE_BO_INTERNAL_TEST)) {
 		struct ttm_place *place = &(bo->placements[0]);
 		bool lmem;
 
-		XE_BUG_ON(!(place->flags & TTM_PL_FLAG_CONTIGUOUS));
-		XE_BUG_ON(!mem_type_is_vram(place->mem_type) && place->mem_type != XE_PL_STOLEN);
+		if (mem_type_is_vram(place->mem_type)) {
+			XE_BUG_ON(!(place->flags & TTM_PL_FLAG_CONTIGUOUS));
 
-		place->fpfn = (xe_bo_addr(bo, 0, PAGE_SIZE, &lmem) -
-			       vram_region_io_offset(bo)) >> PAGE_SHIFT;
-		place->lpfn = place->fpfn + (bo->size >> PAGE_SHIFT);
+			place->fpfn = (xe_bo_addr(bo, 0, PAGE_SIZE, &lmem) -
+				       vram_region_io_offset(bo)) >> PAGE_SHIFT;
+			place->lpfn = place->fpfn + (bo->size >> PAGE_SHIFT);
 
-		spin_lock(&xe->pinned.lock);
-		list_add_tail(&bo->pinned_link, &xe->pinned.kernel_bo_present);
-		spin_unlock(&xe->pinned.lock);
+			spin_lock(&xe->pinned.lock);
+			list_add_tail(&bo->pinned_link, &xe->pinned.kernel_bo_present);
+			spin_unlock(&xe->pinned.lock);
+		}
 	}
 
 	ttm_bo_pin(&bo->ttm);
@@ -1364,11 +1365,15 @@ void xe_bo_unpin(struct xe_bo *bo)
 
 	if (IS_DGFX(xe) && !(IS_ENABLED(CONFIG_DRM_XE_DEBUG) &&
 	    bo->flags & XE_BO_INTERNAL_TEST)) {
-		XE_BUG_ON(list_empty(&bo->pinned_link));
+		struct ttm_place *place = &(bo->placements[0]);
 
-		spin_lock(&xe->pinned.lock);
-		list_del_init(&bo->pinned_link);
-		spin_unlock(&xe->pinned.lock);
+		if (mem_type_is_vram(place->mem_type)) {
+			XE_BUG_ON(list_empty(&bo->pinned_link));
+
+			spin_lock(&xe->pinned.lock);
+			list_del_init(&bo->pinned_link);
+			spin_unlock(&xe->pinned.lock);
+		}
 	}
 
 	ttm_bo_unpin(&bo->ttm);
-- 
2.46.1

