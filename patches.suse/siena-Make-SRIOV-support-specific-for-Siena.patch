From: Martin Habets <habetsm.xilinx@gmail.com>
Date: Wed, 11 May 2022 17:19:36 +0100
Subject: siena: Make SRIOV support specific for Siena
Patch-mainline: v5.19-rc1
Git-commit: dfb1cfbd497e758de43ee02fbeb1fe66ed1ed26b
References: jsc#PED-1565

Add a Siena Kconfig option and use it in stead of the sfc one.

Signed-off-by: Martin Habets <habetsm.xilinx@gmail.com>
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/sfc/Kconfig              |    2 +-
 drivers/net/ethernet/sfc/siena/Kconfig        |    8 ++++++++
 drivers/net/ethernet/sfc/siena/Makefile       |    2 +-
 drivers/net/ethernet/sfc/siena/efx.c          |   12 ++++++------
 drivers/net/ethernet/sfc/siena/efx.h          |    2 +-
 drivers/net/ethernet/sfc/siena/efx_channels.c |    4 ++--
 drivers/net/ethernet/sfc/siena/efx_common.c   |    2 +-
 drivers/net/ethernet/sfc/siena/farch.c        |   18 +++++++++---------
 drivers/net/ethernet/sfc/siena/net_driver.h   |    2 +-
 drivers/net/ethernet/sfc/siena/nic.h          |    2 +-
 drivers/net/ethernet/sfc/siena/siena.c        |    4 ++--
 drivers/net/ethernet/sfc/siena/siena_sriov.h  |    6 +++---
 drivers/net/ethernet/sfc/siena/sriov.h        |    4 ++--
 13 files changed, 38 insertions(+), 30 deletions(-)

--- a/drivers/net/ethernet/sfc/Kconfig
+++ b/drivers/net/ethernet/sfc/Kconfig
@@ -47,7 +47,7 @@ config SFC_MCDI_MON
 	  This exposes the on-board firmware-managed sensors as a
 	  hardware monitor device.
 config SFC_SRIOV
-	bool "Solarflare SFC9000/SFC9100-family SR-IOV support"
+	bool "Solarflare SFC9100-family SR-IOV support"
 	depends on SFC && PCI_IOV
 	default y
 	help
--- a/drivers/net/ethernet/sfc/siena/Kconfig
+++ b/drivers/net/ethernet/sfc/siena/Kconfig
@@ -18,3 +18,11 @@ config SFC_SIENA_MTD
 	  This exposes the on-board flash and/or EEPROM as MTD devices
 	  (e.g. /dev/mtd1).  This is required to update the firmware or
 	  the boot configuration under Linux.
+config SFC_SIENA_SRIOV
+	bool "Solarflare SFC9000-family SR-IOV support"
+	depends on SFC_SIENA && PCI_IOV
+	default n
+	help
+	  This enables support for the Single Root I/O Virtualization
+	  features, allowing accelerated network performance in
+	  virtualized environments.
--- a/drivers/net/ethernet/sfc/siena/Makefile
+++ b/drivers/net/ethernet/sfc/siena/Makefile
@@ -6,6 +6,6 @@ sfc-siena-y		+= farch.o siena.o \
 			   mcdi.o mcdi_port.o mcdi_port_common.o \
 			   mcdi_mon.o
 sfc-siena-$(CONFIG_SFC_SIENA_MTD)	+= mtd.o
-sfc-siena-$(CONFIG_SFC_SRIOV)		+= siena_sriov.o
+sfc-siena-$(CONFIG_SFC_SIENA_SRIOV)	+= siena_sriov.o
 
 obj-$(CONFIG_SFC_SIENA)	+= sfc-siena.o
--- a/drivers/net/ethernet/sfc/siena/efx.c
+++ b/drivers/net/ethernet/sfc/siena/efx.c
@@ -359,7 +359,7 @@ static int efx_probe_all(struct efx_nic
 		goto fail3;
 	}
 
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	rc = efx->type->vswitching_probe(efx);
 	if (rc) /* not fatal; the PF will still work fine */
 		netif_warn(efx, probe, efx->net_dev,
@@ -383,7 +383,7 @@ static int efx_probe_all(struct efx_nic
  fail5:
 	efx_siena_remove_filters(efx);
  fail4:
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	efx->type->vswitching_remove(efx);
 #endif
  fail3:
@@ -402,7 +402,7 @@ static void efx_remove_all(struct efx_ni
 
 	efx_siena_remove_channels(efx);
 	efx_siena_remove_filters(efx);
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	efx->type->vswitching_remove(efx);
 #endif
 	efx_remove_port(efx);
@@ -592,7 +592,7 @@ static const struct net_device_ops efx_n
 	.ndo_features_check	= efx_siena_features_check,
 	.ndo_vlan_rx_add_vid	= efx_vlan_rx_add_vid,
 	.ndo_vlan_rx_kill_vid	= efx_vlan_rx_kill_vid,
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	.ndo_set_vf_mac		= efx_sriov_set_vf_mac,
 	.ndo_set_vf_vlan	= efx_sriov_set_vf_vlan,
 	.ndo_set_vf_spoofchk	= efx_sriov_set_vf_spoofchk,
@@ -1108,7 +1108,7 @@ static int efx_pci_probe(struct pci_dev
 /* efx_pci_sriov_configure returns the actual number of Virtual Functions
  * enabled on success
  */
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 static int efx_pci_sriov_configure(struct pci_dev *dev, int num_vfs)
 {
 	int rc;
@@ -1250,7 +1250,7 @@ static struct pci_driver efx_pci_driver
 	.remove		= efx_pci_remove,
 	.driver.pm	= &efx_pm_ops,
 	.err_handler	= &efx_siena_err_handlers,
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	.sriov_configure = efx_pci_sriov_configure,
 #endif
 };
--- a/drivers/net/ethernet/sfc/siena/efx.h
+++ b/drivers/net/ethernet/sfc/siena/efx.h
@@ -177,7 +177,7 @@ static inline void efx_siena_mtd_rename(
 static inline void efx_siena_mtd_remove(struct efx_nic *efx) {}
 #endif
 
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 static inline unsigned int efx_vf_size(struct efx_nic *efx)
 {
 	return 1 << efx->vi_scale;
--- a/drivers/net/ethernet/sfc/siena/efx_channels.c
+++ b/drivers/net/ethernet/sfc/siena/efx_channels.c
@@ -110,7 +110,7 @@ static unsigned int efx_wanted_paralleli
 	/* If RSS is requested for the PF *and* VFs then we can't write RSS
 	 * table entries that are inaccessible to VFs
 	 */
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	if (efx->type->sriov_wanted) {
 		if (efx->type->sriov_wanted(efx) && efx_vf_size(efx) > 1 &&
 		    count > efx_vf_size(efx)) {
@@ -348,7 +348,7 @@ int efx_siena_probe_interrupts(struct ef
 
 	rss_spread = efx->n_rx_channels;
 	/* RSS might be usable on VFs even if it is disabled on the PF */
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	if (efx->type->sriov_wanted) {
 		efx->rss_spread = ((rss_spread > 1 ||
 				    !efx->type->sriov_wanted(efx)) ?
--- a/drivers/net/ethernet/sfc/siena/efx_common.c
+++ b/drivers/net/ethernet/sfc/siena/efx_common.c
@@ -778,7 +778,7 @@ int efx_siena_reset_up(struct efx_nic *e
 	if (rc)
 		goto fail;
 
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	rc = efx->type->vswitching_restore(efx);
 	if (rc) /* not fatal; the PF will still work fine */
 		netif_warn(efx, probe, efx->net_dev,
--- a/drivers/net/ethernet/sfc/siena/farch.c
+++ b/drivers/net/ethernet/sfc/siena/farch.c
@@ -228,7 +228,7 @@ static int efx_alloc_special_buffer(stru
 				    struct efx_special_buffer *buffer,
 				    unsigned int len)
 {
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	struct siena_nic_data *nic_data = efx->nic_data;
 #endif
 	len = ALIGN(len, EFX_BUF_SIZE);
@@ -241,7 +241,7 @@ static int efx_alloc_special_buffer(stru
 	/* Select new buffer ID */
 	buffer->index = efx->next_buffer_table;
 	efx->next_buffer_table += buffer->entries;
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	BUG_ON(efx_siena_sriov_enabled(efx) &&
 	       nic_data->vf_buftbl_base < efx->next_buffer_table);
 #endif
@@ -1187,7 +1187,7 @@ efx_farch_handle_driver_event(struct efx
 		netif_vdbg(efx, hw, efx->net_dev, "channel %d TXQ %d flushed\n",
 			   channel->channel, ev_sub_data);
 		efx_farch_handle_tx_flush_done(efx, event);
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 		efx_siena_sriov_tx_flush_done(efx, event);
 #endif
 		break;
@@ -1195,7 +1195,7 @@ efx_farch_handle_driver_event(struct efx
 		netif_vdbg(efx, hw, efx->net_dev, "channel %d RXQ %d flushed\n",
 			   channel->channel, ev_sub_data);
 		efx_farch_handle_rx_flush_done(efx, event);
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 		efx_siena_sriov_rx_flush_done(efx, event);
 #endif
 		break;
@@ -1233,7 +1233,7 @@ efx_farch_handle_driver_event(struct efx
 				  ev_sub_data);
 			efx_siena_schedule_reset(efx, RESET_TYPE_DMA_ERROR);
 		}
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 		else
 			efx_siena_sriov_desc_fetch_err(efx, ev_sub_data);
 #endif
@@ -1246,7 +1246,7 @@ efx_farch_handle_driver_event(struct efx
 				  ev_sub_data);
 			efx_siena_schedule_reset(efx, RESET_TYPE_DMA_ERROR);
 		}
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 		else
 			efx_siena_sriov_desc_fetch_err(efx, ev_sub_data);
 #endif
@@ -1307,7 +1307,7 @@ int efx_farch_ev_process(struct efx_chan
 		case FSE_AZ_EV_CODE_DRIVER_EV:
 			efx_farch_handle_driver_event(channel, &event);
 			break;
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 		case FSE_CZ_EV_CODE_USER_EV:
 			efx_siena_sriov_event(channel, &event);
 			break;
@@ -1671,7 +1671,7 @@ void efx_farch_rx_pull_indir_table(struc
 void efx_farch_dimension_resources(struct efx_nic *efx, unsigned sram_lim_qw)
 {
 	unsigned vi_count, total_tx_channels;
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	struct siena_nic_data *nic_data;
 	unsigned buftbl_min;
 #endif
@@ -1679,7 +1679,7 @@ void efx_farch_dimension_resources(struc
 	total_tx_channels = efx->n_tx_channels + efx->n_extra_tx_channels;
 	vi_count = max(efx->n_channels, total_tx_channels * EFX_MAX_TXQ_PER_CHANNEL);
 
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	nic_data = efx->nic_data;
 	/* Account for the buffer table entries backing the datapath channels
 	 * and the descriptor caches for those channels.
--- a/drivers/net/ethernet/sfc/siena/net_driver.h
+++ b/drivers/net/ethernet/sfc/siena/net_driver.h
@@ -1096,7 +1096,7 @@ struct efx_nic {
 	atomic_t rxq_flush_outstanding;
 	wait_queue_head_t flush_wq;
 
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	unsigned vf_count;
 	unsigned vf_init_count;
 	unsigned vi_scale;
--- a/drivers/net/ethernet/sfc/siena/nic.h
+++ b/drivers/net/ethernet/sfc/siena/nic.h
@@ -104,7 +104,7 @@ struct siena_nic_data {
 	struct efx_nic *efx;
 	int wol_filter_id;
 	u64 stats[SIENA_STAT_COUNT];
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	struct siena_vf *vf;
 	struct efx_channel *vfdi_channel;
 	unsigned vf_buftbl_base;
--- a/drivers/net/ethernet/sfc/siena/siena.c
+++ b/drivers/net/ethernet/sfc/siena/siena.c
@@ -328,7 +328,7 @@ static int siena_probe_nic(struct efx_ni
 	if (rc)
 		goto fail5;
 
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	efx_siena_sriov_probe(efx);
 #endif
 	efx_siena_ptp_defer_probe_with_channel(efx);
@@ -1068,7 +1068,7 @@ const struct efx_nic_type siena_a0_nic_t
 #endif
 	.ptp_write_host_time = siena_ptp_write_host_time,
 	.ptp_set_ts_config = siena_ptp_set_ts_config,
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 	.sriov_configure = efx_siena_sriov_configure,
 	.sriov_init = efx_siena_sriov_init,
 	.sriov_fini = efx_siena_sriov_fini,
--- a/drivers/net/ethernet/sfc/siena/siena_sriov.h
+++ b/drivers/net/ethernet/sfc/siena/siena_sriov.h
@@ -54,18 +54,18 @@ int efx_siena_sriov_set_vf_spoofchk(stru
 int efx_siena_sriov_get_vf_config(struct efx_nic *efx, int vf,
 				  struct ifla_vf_info *ivf);
 
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 
 static inline bool efx_siena_sriov_enabled(struct efx_nic *efx)
 {
 	return efx->vf_init_count != 0;
 }
-#else /* !CONFIG_SFC_SRIOV */
+#else /* !CONFIG_SFC_SIENA_SRIOV */
 static inline bool efx_siena_sriov_enabled(struct efx_nic *efx)
 {
 	return false;
 }
-#endif /* CONFIG_SFC_SRIOV */
+#endif /* CONFIG_SFC_SIENA_SRIOV */
 
 void efx_siena_sriov_probe(struct efx_nic *efx);
 void efx_siena_sriov_tx_flush_done(struct efx_nic *efx, efx_qword_t *event);
--- a/drivers/net/ethernet/sfc/siena/sriov.h
+++ b/drivers/net/ethernet/sfc/siena/sriov.h
@@ -9,7 +9,7 @@
 
 #include "net_driver.h"
 
-#ifdef CONFIG_SFC_SRIOV
+#ifdef CONFIG_SFC_SIENA_SRIOV
 
 static inline
 int efx_sriov_set_vf_mac(struct net_device *net_dev, int vf_i, u8 *mac)
@@ -78,6 +78,6 @@ int efx_sriov_set_vf_link_state(struct n
 	else
 		return -EOPNOTSUPP;
 }
-#endif /* CONFIG_SFC_SRIOV */
+#endif /* CONFIG_SFC_SIENA_SRIOV */
 
 #endif /* EFX_SRIOV_H */
