From b280edf61427c6b40eaf327a488d715827c83d02 Mon Sep 17 00:00:00 2001
From: Oliver Neukum <oneukum@suse.com>
Date: Mon, 20 Jan 2025 13:37:03 +0100
Subject: [PATCH 1/4] i2c: adding kABI paddings
Patch-mainline: Never , kABI padding
References: bsc#1220369

Facilitating future fixes for i2c

Signed-off-by: oneukum@suse.com
---
 include/linux/i2c-algo-pca.h | 3 +++
 include/linux/i2c-algo-pcf.h | 2 ++
 include/linux/i2c-mux.h      | 3 +++
 include/linux/i2c.h          | 8 ++++++++
 4 files changed, 16 insertions(+)

diff --git a/include/linux/i2c-algo-pca.h b/include/linux/i2c-algo-pca.h
index 7c522fdd9..9c17bf918 100644
--- a/include/linux/i2c-algo-pca.h
+++ b/include/linux/i2c-algo-pca.h
@@ -78,6 +78,9 @@ struct i2c_algo_pca_data {
 	 * For PCA9665, use the frequency you want here. */
 	unsigned int			i2c_clock;
 	unsigned int			chip;
+
+	void *suse_kabi_padding;
+
 	struct pca_i2c_bus_settings		bus_settings;
 };
 
diff --git a/include/linux/i2c-algo-pcf.h b/include/linux/i2c-algo-pcf.h
index 696e7de83..d34b2a8c7 100644
--- a/include/linux/i2c-algo-pcf.h
+++ b/include/linux/i2c-algo-pcf.h
@@ -25,6 +25,8 @@ struct i2c_algo_pcf_data {
 	void (*xfer_begin) (void *data);
 	void (*xfer_end) (void *data);
 
+	void *suse_kabi_padding;
+
 	/* Multi-master lost arbitration back-off delay (msecs)
 	 * This should be set by the bus adapter or knowledgable client
 	 * if bus is multi-mastered, else zero
diff --git a/include/linux/i2c-mux.h b/include/linux/i2c-mux.h
index 1784ac7af..4ab4a9c3a 100644
--- a/include/linux/i2c-mux.h
+++ b/include/linux/i2c-mux.h
@@ -29,6 +29,9 @@ struct i2c_mux_core {
 
 	int num_adapters;
 	int max_adapters;
+
+	void *suse_kabi_padding;
+
 	struct i2c_adapter *adapter[];
 };
 
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index e4fff0889..8135bf9c2 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -311,6 +311,8 @@ struct i2c_driver {
 	const unsigned short *address_list;
 	struct list_head clients;
 
+	void *suse_kabi_padding;
+
 	u32 flags;
 };
 #define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)
@@ -359,6 +361,7 @@ struct i2c_client {
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
 	i2c_slave_cb_t slave_cb;	/* callback for slave mode	*/
 #endif
+	void *suse_kabi_padding;
 	void *devres_group_id;		/* ID of probe devres group	*/
 };
 #define to_i2c_client(d) container_of(d, struct i2c_client, dev)
@@ -575,6 +578,7 @@ struct i2c_algorithm {
 	int (*reg_slave)(struct i2c_client *client);
 	int (*unreg_slave)(struct i2c_client *client);
 #endif
+	void *suse_kabi_padding;
 };
 
 /**
@@ -664,6 +668,8 @@ struct i2c_bus_recovery_info {
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *pins_default;
 	struct pinctrl_state *pins_gpio;
+
+	void *suse_kabi_padding;
 };
 
 int i2c_recover_bus(struct i2c_adapter *adap);
@@ -758,6 +764,8 @@ struct i2c_adapter {
 
 	struct dentry *debugfs;
 
+	void *suse_kabi_padding;
+
 	/* 7bit address space */
 	DECLARE_BITMAP(addrs_in_instantiation, 1 << 7);
 };
-- 
2.47.1

