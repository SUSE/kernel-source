From: Daniel Wagner <dwagner@suse.de>
Date: Fri, 8 Sep 2023 09:59:35 +0200
Subject: nvme-tcp: add recovery_delay to sysfs
Patch-mainline: Not yet, TP is not yet released
References: bsc#1201284

Allow userland to set the recovery delay value.

Signed-off-by: Daniel Wagner <dwagner@suse.de>
---
 drivers/nvme/host/core.c    | 32 ++++++++++++++++++++++++++++++++
 drivers/nvme/host/fabrics.c | 13 +++++++++++++
 drivers/nvme/host/fabrics.h |  3 +++
 drivers/nvme/host/tcp.c     |  6 +++++-
 4 files changed, 53 insertions(+), 1 deletion(-)

diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index 4ad0f1f8d2a0..e57bc2d6ac8b 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -3728,6 +3728,35 @@ static DEVICE_ATTR(dhchap_ctrl_secret, S_IRUGO | S_IWUSR,
 	nvme_ctrl_dhchap_ctrl_secret_show, nvme_ctrl_dhchap_ctrl_secret_store);
 #endif
 
+static ssize_t recovery_delay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct nvme_ctrl *ctrl = dev_get_drvdata(dev);
+	struct nvmf_ctrl_options *opts = ctrl->opts;
+
+	if (opts->recovery_delay == -1)
+		return sysfs_emit(buf, "off\n");
+	return sysfs_emit(buf, "%d\n", opts->recovery_delay);
+}
+
+static ssize_t recovery_delay_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct nvme_ctrl *ctrl = dev_get_drvdata(dev);
+	struct nvmf_ctrl_options *opts = ctrl->opts;
+	unsigned int recovery_delay;
+	int err;
+
+	err = kstrtou32(buf, 10, &recovery_delay);
+	if (err)
+		return err;
+
+	opts->recovery_delay = recovery_delay;
+	return count;
+}
+static DEVICE_ATTR(recovery_delay, S_IRUGO | S_IWUSR,
+	recovery_delay_show, recovery_delay_store);
+
 static struct attribute *nvme_dev_attrs[] = {
 	&dev_attr_reset_controller.attr,
 	&dev_attr_rescan_controller.attr,
@@ -3755,6 +3784,7 @@ static struct attribute *nvme_dev_attrs[] = {
 	&dev_attr_dhchap_secret.attr,
 	&dev_attr_dhchap_ctrl_secret.attr,
 #endif
+	&dev_attr_recovery_delay.attr,
 	NULL
 };
 
@@ -3784,6 +3814,8 @@ static umode_t nvme_dev_attrs_are_visible(struct kobject *kobj,
 	if (a == &dev_attr_dhchap_ctrl_secret.attr && !ctrl->opts)
 		return 0;
 #endif
+	if (a == &dev_attr_recovery_delay.attr && !ctrl->opts)
+		return 0;
 
 	return a->mode;
 }
diff --git a/drivers/nvme/host/fabrics.c b/drivers/nvme/host/fabrics.c
index cedd064b3307..196e7333474b 100644
--- a/drivers/nvme/host/fabrics.c
+++ b/drivers/nvme/host/fabrics.c
@@ -595,6 +595,7 @@ static const match_table_t opt_tokens = {
 	{ NVMF_OPT_DISCOVERY,		"discovery"		},
 	{ NVMF_OPT_DHCHAP_SECRET,	"dhchap_secret=%s"	},
 	{ NVMF_OPT_DHCHAP_CTRL_SECRET,	"dhchap_ctrl_secret=%s"	},
+	{ NVMF_OPT_RECOVERY_DELAY,	"recovery_delay=%d"	},
 	{ NVMF_OPT_ERR,			NULL			}
 };
 
@@ -904,6 +905,18 @@ static int nvmf_parse_options(struct nvmf_ctrl_options *opts,
 			kfree(opts->dhchap_ctrl_secret);
 			opts->dhchap_ctrl_secret = p;
 			break;
+		case NVMF_OPT_RECOVERY_DELAY:
+			if (match_int(args, &token)) {
+				ret = -EINVAL;
+				goto out;
+			}
+			if (token <= 0) {
+				pr_err("Invalid recovery_delay %d\n", token);
+				ret = -EINVAL;
+				goto out;
+			}
+			opts->recovery_delay = token;
+			break;
 		default:
 			pr_warn("unknown parameter or missing value '%s' in ctrl creation request\n",
 				p);
diff --git a/drivers/nvme/host/fabrics.h b/drivers/nvme/host/fabrics.h
index f45b07694ec6..aae3ad053f35 100644
--- a/drivers/nvme/host/fabrics.h
+++ b/drivers/nvme/host/fabrics.h
@@ -70,6 +70,7 @@ enum {
 	NVMF_OPT_DISCOVERY	= 1 << 22,
 	NVMF_OPT_DHCHAP_SECRET	= 1 << 23,
 	NVMF_OPT_DHCHAP_CTRL_SECRET = 1 << 24,
+	NVMF_OPT_RECOVERY_DELAY = 1 << 25,
 };
 
 /**
@@ -93,6 +94,7 @@ enum {
  * @queue_size: Number of IO queue elements.
  * @nr_io_queues: Number of controller IO queues that will be established.
  * @reconnect_delay: Time between two consecutive reconnect attempts.
+ * @recovery_delay: Time before error recovery starts after error detection.
  * @discovery_nqn: indicates if the subsysnqn is the well-known discovery NQN.
  * @kato:	Keep-alive timeout.
  * @host:	Virtual NVMe host, contains the NQN and Host ID.
@@ -121,6 +123,7 @@ struct nvmf_ctrl_options {
 	size_t			queue_size;
 	unsigned int		nr_io_queues;
 	unsigned int		reconnect_delay;
+	unsigned int		recovery_delay;
 	bool			discovery_nqn;
 	bool			duplicate_connect;
 	unsigned int		kato;
diff --git a/drivers/nvme/host/tcp.c b/drivers/nvme/host/tcp.c
index 6995673c16ab..45f96e420179 100644
--- a/drivers/nvme/host/tcp.c
+++ b/drivers/nvme/host/tcp.c
@@ -523,11 +523,15 @@ static void nvme_tcp_init_recv_ctx(struct nvme_tcp_queue *queue)
  */
 static void nvme_tcp_error_recovery(struct nvme_ctrl *ctrl)
 {
-	unsigned long delay = nvme_keep_alive_work_period(ctrl);
+	unsigned long delay;
 
 	if (!nvme_change_ctrl_state(ctrl, NVME_CTRL_RESETTING))
 		return;
 
+	delay = ctrl->opts->recovery_delay * HZ;
+	if (!delay)
+		delay = nvme_keep_alive_work_period(ctrl);
+
 	dev_warn(ctrl->device, "starting error recovery in %lu seconds\n",
 		 delay / HZ);
 	queue_delayed_work(nvme_reset_wq, &to_tcp_ctrl(ctrl)->err_work, delay);
-- 
2.35.3

