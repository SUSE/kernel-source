From ef34add89ee4d1473bd0e78f551efa6fc1feb0cd Mon Sep 17 00:00:00 2001
From: Mika Westerberg <mika.westerberg@linux.intel.com>
Date: Mon, 10 Oct 2022 18:04:16 +0300
Subject: [PATCH] thunderbolt: Check valid TMU configuration in
 tb_switch_tmu_configure()
Git-commit: ef34add89ee4d1473bd0e78f551efa6fc1feb0cd
References: jsc#PED-6061
Patch-mainline: v6.5-rc1

Instead of at enable time we can do this already in
tb_switch_tmu_configure().

Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
Signed-off-by: Oliver Neukum <oneukum@suse.com>
---
 drivers/thunderbolt/tb.c  |  6 ++++--
 drivers/thunderbolt/tb.h  |  5 ++---
 drivers/thunderbolt/tmu.c | 13 ++++++++-----
 3 files changed, 14 insertions(+), 10 deletions(-)

diff --git a/drivers/thunderbolt/tb.c b/drivers/thunderbolt/tb.c
index 41c353f462e7..91459bf2fd0f 100644
--- a/drivers/thunderbolt/tb.c
+++ b/drivers/thunderbolt/tb.c
@@ -282,9 +282,11 @@ static int tb_enable_tmu(struct tb_switch *sw)
 	 * highest accuracy.
 	 */
 	if (tb_switch_is_clx_enabled(sw, TB_CL1))
-		tb_switch_tmu_configure(sw, TB_SWITCH_TMU_RATE_NORMAL, true);
+		ret = tb_switch_tmu_configure(sw, TB_SWITCH_TMU_RATE_NORMAL, true);
 	else
-		tb_switch_tmu_configure(sw, TB_SWITCH_TMU_RATE_HIFI, false);
+		ret = tb_switch_tmu_configure(sw, TB_SWITCH_TMU_RATE_HIFI, false);
+	if (ret)
+		return ret;
 
 	/* If it is already enabled in correct mode, don't touch it */
 	if (tb_switch_tmu_is_enabled(sw))
diff --git a/drivers/thunderbolt/tb.h b/drivers/thunderbolt/tb.h
index 5c4b671092bf..2ecad0a6c6a4 100644
--- a/drivers/thunderbolt/tb.h
+++ b/drivers/thunderbolt/tb.h
@@ -987,9 +987,8 @@ int tb_switch_tmu_init(struct tb_switch *sw);
 int tb_switch_tmu_post_time(struct tb_switch *sw);
 int tb_switch_tmu_disable(struct tb_switch *sw);
 int tb_switch_tmu_enable(struct tb_switch *sw);
-void tb_switch_tmu_configure(struct tb_switch *sw,
-			     enum tb_switch_tmu_rate rate,
-			     bool unidirectional);
+int tb_switch_tmu_configure(struct tb_switch *sw, enum tb_switch_tmu_rate rate,
+			    bool unidirectional);
 /**
  * tb_switch_tmu_is_enabled() - Checks if the specified TMU mode is enabled
  * @sw: Router whose TMU mode to check
diff --git a/drivers/thunderbolt/tmu.c b/drivers/thunderbolt/tmu.c
index 84abb783a6d9..be310d97ea7b 100644
--- a/drivers/thunderbolt/tmu.c
+++ b/drivers/thunderbolt/tmu.c
@@ -648,9 +648,6 @@ int tb_switch_tmu_enable(struct tb_switch *sw)
 	bool unidirectional = sw->tmu.unidirectional_request;
 	int ret;
 
-	if (unidirectional && !sw->tmu.has_ucap)
-		return -EOPNOTSUPP;
-
 	/*
 	 * No need to enable TMU on devices that don't support CLx since on
 	 * these devices e.g. Alpine Ridge and earlier, the TMU mode HiFi
@@ -724,10 +721,16 @@ int tb_switch_tmu_enable(struct tb_switch *sw)
  *
  * Selects the rate of the TMU and directionality (uni-directional or
  * bi-directional). Must be called before tb_switch_tmu_enable().
+ *
+ * Returns %0 in success and negative errno otherwise.
  */
-void tb_switch_tmu_configure(struct tb_switch *sw,
-			     enum tb_switch_tmu_rate rate, bool unidirectional)
+int tb_switch_tmu_configure(struct tb_switch *sw, enum tb_switch_tmu_rate rate,
+			    bool unidirectional)
 {
+	if (unidirectional && !sw->tmu.has_ucap)
+		return -EINVAL;
+
 	sw->tmu.unidirectional_request = unidirectional;
 	sw->tmu.rate_request = rate;
+	return 0;
 }
-- 
2.41.0

