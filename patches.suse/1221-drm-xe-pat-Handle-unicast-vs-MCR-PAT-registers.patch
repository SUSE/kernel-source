From b88945bfb5d465a00881bc08375524769913e826 Mon Sep 17 00:00:00 2001
From: Matt Roper <matthew.d.roper@intel.com>
Date: Fri, 24 Mar 2023 14:04:12 -0700
Subject: drm/xe/pat: Handle unicast vs MCR PAT registers
Git-commit: 152d7f2db978780f6c7e95711c00dc1e0888535b
Patch-mainline: v6.8-rc1
References: drm-backport-placeholder

The PAT_INDEX registers are MCR registers on some platforms and unicast
on others.  On MTL the handling even varies between GTs:  the primary GT
uses MCR registers while the media GT uses unicast registers.  Let's add
proper MCR programming on the relevant platforms/GTs.

Given that we PAT tables to change pretty regularly on future platforms,
we'll make PAT programming an exception to the usual model of assuming
new platforms should inherit the previous platform's behavior.  Instead
we'll raise a warning if the current platform isn't handled in the
if/else ladder.  This should help prevent subtle cache misbehavior if we
forget to add the table for a new platform.

Bspec: 66534, 67609, 67788
Reviewed-by: Nirmoy Das <nirmoy.das@intel.com>
Link: https://lore.kernel.org/r/20230324210415.2434992-4-matthew.d.roper@intel.com
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/xe/xe_pat.c | 37 ++++++++++++++++++++++++++++++-------
 1 file changed, 30 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/xe/xe_pat.c b/drivers/gpu/drm/xe/xe_pat.c
index d1a3e170fb33..6e3a74aa46e7 100644
--- a/drivers/gpu/drm/xe/xe_pat.c
+++ b/drivers/gpu/drm/xe/xe_pat.c
@@ -7,9 +7,10 @@
 
 #include "regs/xe_reg_defs.h"
 #include "xe_gt.h"
+#include "xe_gt_mcr.h"
 #include "xe_mmio.h"
 
-#define GEN12_PAT_INDEX(index)			_MMIO(0x4800 + (index) * 4)
+#define _PAT_INDEX(index)			(0x4800 + (index) * 4)
 
 #define GEN8_PPAT_WB			(3<<0)
 #define GEN8_PPAT_WT			(2<<0)
@@ -58,17 +59,39 @@ const u32 mtl_pat_table[] = {
 
 #define PROGRAM_PAT_UNICAST(gt, table) do { \
 	for (int i = 0; i < ARRAY_SIZE(table); i++) \
-		xe_mmio_write32(gt, GEN12_PAT_INDEX(i).reg, table[i]); \
+		xe_mmio_write32(gt, _PAT_INDEX(i), table[i]); \
+} while (0)
+
+#define PROGRAM_PAT_MCR(gt, table) do { \
+	for (int i = 0; i < ARRAY_SIZE(table); i++) \
+		xe_gt_mcr_multicast_write(gt, MCR_REG(_PAT_INDEX(i)), table[i]); \
 } while (0)
 
 void xe_pat_init(struct xe_gt *gt)
 {
 	struct xe_device *xe = gt_to_xe(gt);
 
-	if (xe->info.platform == XE_METEORLAKE)
-		PROGRAM_PAT_UNICAST(gt, mtl_pat_table);
-	else if (xe->info.platform == XE_PVC)
-		PROGRAM_PAT_UNICAST(gt, pvc_pat_table);
-	else
+	if (xe->info.platform == XE_METEORLAKE) {
+		if (xe_gt_is_media_type(gt))
+			PROGRAM_PAT_UNICAST(gt, mtl_pat_table);
+		else
+			PROGRAM_PAT_MCR(gt, mtl_pat_table);
+	} else if (xe->info.platform == XE_PVC) {
+		PROGRAM_PAT_MCR(gt, pvc_pat_table);
+	} else if (xe->info.platform == XE_DG2) {
+		PROGRAM_PAT_MCR(gt, pvc_pat_table);
+	} else if (GRAPHICS_VERx100(xe) <= 1210) {
 		PROGRAM_PAT_UNICAST(gt, tgl_pat_table);
+	} else {
+		/*
+		 * Going forward we expect to need new PAT settings for most
+		 * new platforms; failure to provide a new table can easily
+		 * lead to subtle, hard-to-debug problems.  If none of the
+		 * conditions above match the platform we're running on we'll
+		 * raise an error rather than trying to silently inherit the
+		 * most recent platform's behavior.
+		 */
+		drm_err(&xe->drm, "Missing PAT table for platform with graphics version %d.%2d!\n",
+			GRAPHICS_VER(xe), GRAPHICS_VERx100(xe) % 100);
+	}
 }
-- 
2.46.1

