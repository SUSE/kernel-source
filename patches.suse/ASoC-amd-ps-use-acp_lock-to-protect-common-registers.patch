From 45aa83cb93885d406c178498623b01cf128ca233 Mon Sep 17 00:00:00 2001
From: Vijendar Mukunda <Vijendar.Mukunda@amd.com>
Date: Wed, 4 Jan 2023 11:24:30 +0530
Subject: [PATCH] ASoC: amd: ps: use acp_lock to protect common registers in pdm driver
Git-commit: 45aa83cb93885d406c178498623b01cf128ca233
Patch-mainline: v6.3-rc1
References: bsc#1219136

Retrieve acp_lock mutex as platform data and use it for protecting
ACP common registers access in acp pdm driver.

Signed-off-by: Vijendar Mukunda <Vijendar.Mukunda@amd.com>
Link: https://lore.kernel.org/r/20230104055435.321327-2-Vijendar.Mukunda@amd.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/amd/ps/acp63.h      |  1 +
 sound/soc/amd/ps/ps-pdm-dma.c | 32 ++++++++++++++++++++------------
 2 files changed, 21 insertions(+), 12 deletions(-)

diff --git a/sound/soc/amd/ps/acp63.h b/sound/soc/amd/ps/acp63.h
index 47854280dd4b..e0160cbf5447 100644
--- a/sound/soc/amd/ps/acp63.h
+++ b/sound/soc/amd/ps/acp63.h
@@ -88,6 +88,7 @@ struct pdm_stream_instance {
 struct pdm_dev_data {
 	u32 pdm_irq;
 	void __iomem *acp63_base;
+	struct mutex *acp_lock;
 	struct snd_pcm_substream *capture_stream;
 };
 
diff --git a/sound/soc/amd/ps/ps-pdm-dma.c b/sound/soc/amd/ps/ps-pdm-dma.c
index eea71a9d2ef1..8957d8f8d3c6 100644
--- a/sound/soc/amd/ps/ps-pdm-dma.c
+++ b/sound/soc/amd/ps/ps-pdm-dma.c
@@ -59,22 +59,26 @@ static void acp63_enable_pdm_clock(void __iomem *acp_base)
 	acp63_writel(pdm_ctrl, acp_base + ACP_WOV_MISC_CTRL);
 }
 
-static void acp63_enable_pdm_interrupts(void __iomem *acp_base)
+static void acp63_enable_pdm_interrupts(struct pdm_dev_data *adata)
 {
 	u32 ext_int_ctrl;
 
-	ext_int_ctrl = acp63_readl(acp_base + ACP_EXTERNAL_INTR_CNTL);
+	mutex_lock(adata->acp_lock);
+	ext_int_ctrl = acp63_readl(adata->acp63_base + ACP_EXTERNAL_INTR_CNTL);
 	ext_int_ctrl |= PDM_DMA_INTR_MASK;
-	acp63_writel(ext_int_ctrl, acp_base + ACP_EXTERNAL_INTR_CNTL);
+	acp63_writel(ext_int_ctrl, adata->acp63_base + ACP_EXTERNAL_INTR_CNTL);
+	mutex_unlock(adata->acp_lock);
 }
 
-static void acp63_disable_pdm_interrupts(void __iomem *acp_base)
+static void acp63_disable_pdm_interrupts(struct pdm_dev_data *adata)
 {
 	u32 ext_int_ctrl;
 
-	ext_int_ctrl = acp63_readl(acp_base + ACP_EXTERNAL_INTR_CNTL);
+	mutex_lock(adata->acp_lock);
+	ext_int_ctrl = acp63_readl(adata->acp63_base + ACP_EXTERNAL_INTR_CNTL);
 	ext_int_ctrl &= ~PDM_DMA_INTR_MASK;
-	acp63_writel(ext_int_ctrl, acp_base + ACP_EXTERNAL_INTR_CNTL);
+	acp63_writel(ext_int_ctrl, adata->acp63_base + ACP_EXTERNAL_INTR_CNTL);
+	mutex_unlock(adata->acp_lock);
 }
 
 static bool acp63_check_pdm_dma_status(void __iomem *acp_base)
@@ -196,7 +200,7 @@ static int acp63_pdm_dma_open(struct snd_soc_component *component,
 		return ret;
 	}
 
-	acp63_enable_pdm_interrupts(adata->acp63_base);
+	acp63_enable_pdm_interrupts(adata);
 
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 		adata->capture_stream = substream;
@@ -272,7 +276,7 @@ static int acp63_pdm_dma_close(struct snd_soc_component *component,
 	struct pdm_dev_data *adata = dev_get_drvdata(component->dev);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	acp63_disable_pdm_interrupts(adata->acp63_base);
+	acp63_disable_pdm_interrupts(adata);
 	adata->capture_stream = NULL;
 	kfree(runtime->private_data);
 	return 0;
@@ -353,6 +357,10 @@ static int acp63_pdm_audio_probe(struct platform_device *pdev)
 	struct pdm_dev_data *adata;
 	int status;
 
+	if (!pdev->dev.platform_data) {
+		dev_err(&pdev->dev, "platform_data not retrieved\n");
+		return -ENODEV;
+	}
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "IORESOURCE_MEM FAILED\n");
@@ -368,7 +376,7 @@ static int acp63_pdm_audio_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	adata->capture_stream = NULL;
-
+	adata->acp_lock = pdev->dev.platform_data;
 	dev_set_drvdata(&pdev->dev, adata);
 	status = devm_snd_soc_register_component(&pdev->dev,
 						 &acp63_pdm_component,
@@ -408,7 +416,7 @@ static int __maybe_unused acp63_pdm_resume(struct device *dev)
 		acp63_init_pdm_ring_buffer(PDM_MEM_WINDOW_START, buffer_len,
 					   period_bytes, adata->acp63_base);
 	}
-	acp63_enable_pdm_interrupts(adata->acp63_base);
+	acp63_enable_pdm_interrupts(adata);
 	return 0;
 }
 
@@ -417,7 +425,7 @@ static int __maybe_unused acp63_pdm_suspend(struct device *dev)
 	struct pdm_dev_data *adata;
 
 	adata = dev_get_drvdata(dev);
-	acp63_disable_pdm_interrupts(adata->acp63_base);
+	acp63_disable_pdm_interrupts(adata);
 	return 0;
 }
 
@@ -426,7 +434,7 @@ static int __maybe_unused acp63_pdm_runtime_resume(struct device *dev)
 	struct pdm_dev_data *adata;
 
 	adata = dev_get_drvdata(dev);
-	acp63_enable_pdm_interrupts(adata->acp63_base);
+	acp63_enable_pdm_interrupts(adata);
 	return 0;
 }
 
-- 
2.35.3

