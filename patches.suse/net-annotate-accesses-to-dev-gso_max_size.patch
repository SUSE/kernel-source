From: Eric Dumazet <edumazet@google.com>
Date: Fri, 19 Nov 2021 07:43:31 -0800
Subject: net: annotate accesses to dev->gso_max_size
Patch-mainline: v5.17-rc1
Git-commit: 4b66d2161b8125b6caa6971815e85631cf3cf36f
References: jsc#PED-1565

dev->gso_max_size is written under RTNL protection, or when the device is
not yet visible, but is read locklessly.

Add the READ_ONCE()/WRITE_ONCE() pairs, and use netif_set_gso_max_size()
where we can to better document what is going on.

Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/netronome/nfp/nfp_net_repr.c |    2 +-
 drivers/net/ethernet/realtek/r8169_main.c         |    4 ++--
 drivers/net/ethernet/sfc/ef100_nic.c              |    2 +-
 drivers/net/ipvlan/ipvlan_main.c                  |    4 ++--
 drivers/net/macvlan.c                             |    4 ++--
 drivers/net/veth.c                                |    2 +-
 drivers/net/vxlan.c                               |    2 +-
 include/linux/netdevice.h                         |    3 ++-
 net/8021q/vlan.c                                  |    2 +-
 net/8021q/vlan_dev.c                              |    2 +-
 net/bridge/br_if.c                                |    2 +-
 net/core/sock.c                                   |    3 ++-
 net/sctp/output.c                                 |    2 +-
 13 files changed, 18 insertions(+), 16 deletions(-)

--- a/drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
@@ -286,7 +286,7 @@ nfp_repr_transfer_features(struct net_de
 	if (repr->dst->u.port_info.lower_dev != lower)
 		return;
 
-	netdev->gso_max_size = lower->gso_max_size;
+	netif_set_gso_max_size(netdev, lower->gso_max_size);
 	netdev->gso_max_segs = lower->gso_max_segs;
 
 	netdev_update_features(netdev);
--- a/drivers/net/ethernet/realtek/r8169_main.c
+++ b/drivers/net/ethernet/realtek/r8169_main.c
@@ -5392,11 +5392,11 @@ static int rtl_init_one(struct pci_dev *
 	 */
 	if (rtl_chip_supports_csum_v2(tp)) {
 		dev->hw_features |= NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6;
-		dev->gso_max_size = RTL_GSO_MAX_SIZE_V2;
+		netif_set_gso_max_size(dev, RTL_GSO_MAX_SIZE_V2);
 		dev->gso_max_segs = RTL_GSO_MAX_SEGS_V2;
 	} else {
 		dev->hw_features |= NETIF_F_SG | NETIF_F_TSO;
-		dev->gso_max_size = RTL_GSO_MAX_SIZE_V1;
+		netif_set_gso_max_size(dev, RTL_GSO_MAX_SIZE_V1);
 		dev->gso_max_segs = RTL_GSO_MAX_SEGS_V1;
 	}
 
--- a/drivers/net/ethernet/sfc/ef100_nic.c
+++ b/drivers/net/ethernet/sfc/ef100_nic.c
@@ -996,7 +996,7 @@ static int ef100_process_design_param(st
 		return 0;
 	case ESE_EF100_DP_GZ_TSO_MAX_PAYLOAD_LEN:
 		nic_data->tso_max_payload_len = min_t(u64, reader->value, GSO_MAX_SIZE);
-		efx->net_dev->gso_max_size = nic_data->tso_max_payload_len;
+		netif_set_gso_max_size(efx->net_dev, nic_data->tso_max_payload_len);
 		return 0;
 	case ESE_EF100_DP_GZ_TSO_MAX_PAYLOAD_NUM_SEGS:
 		nic_data->tso_max_payload_num_segs = min_t(u64, reader->value, 0xffff);
--- a/drivers/net/ipvlan/ipvlan_main.c
+++ b/drivers/net/ipvlan/ipvlan_main.c
@@ -140,7 +140,7 @@ static int ipvlan_init(struct net_device
 	dev->vlan_features = phy_dev->vlan_features & IPVLAN_FEATURES;
 	dev->vlan_features |= IPVLAN_ALWAYS_ON_OFLOADS;
 	dev->hw_enc_features |= dev->features;
-	dev->gso_max_size = phy_dev->gso_max_size;
+	netif_set_gso_max_size(dev, phy_dev->gso_max_size);
 	dev->gso_max_segs = phy_dev->gso_max_segs;
 	dev->hard_header_len = phy_dev->hard_header_len;
 
@@ -762,7 +762,7 @@ static int ipvlan_device_event(struct no
 
 	case NETDEV_FEAT_CHANGE:
 		list_for_each_entry(ipvlan, &port->ipvlans, pnode) {
-			ipvlan->dev->gso_max_size = dev->gso_max_size;
+			netif_set_gso_max_size(ipvlan->dev, dev->gso_max_size);
 			ipvlan->dev->gso_max_segs = dev->gso_max_segs;
 			netdev_update_features(ipvlan->dev);
 		}
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@ -899,7 +899,7 @@ static int macvlan_init(struct net_devic
 	dev->vlan_features	= lowerdev->vlan_features & MACVLAN_FEATURES;
 	dev->vlan_features	|= ALWAYS_ON_OFFLOADS;
 	dev->hw_enc_features    |= dev->features;
-	dev->gso_max_size	= lowerdev->gso_max_size;
+	netif_set_gso_max_size(dev, lowerdev->gso_max_size);
 	dev->gso_max_segs	= lowerdev->gso_max_segs;
 	dev->hard_header_len	= lowerdev->hard_header_len;
 	macvlan_set_lockdep_class(dev);
@@ -1747,7 +1747,7 @@ static int macvlan_device_event(struct n
 		break;
 	case NETDEV_FEAT_CHANGE:
 		list_for_each_entry(vlan, &port->vlans, list) {
-			vlan->dev->gso_max_size = dev->gso_max_size;
+			netif_set_gso_max_size(vlan->dev, dev->gso_max_size);
 			vlan->dev->gso_max_segs = dev->gso_max_segs;
 			netdev_update_features(vlan->dev);
 		}
--- a/drivers/net/veth.c
+++ b/drivers/net/veth.c
@@ -1514,7 +1514,7 @@ static int veth_newlink(struct net *src_
 	if (ifmp && (dev->ifindex != 0))
 		peer->ifindex = ifmp->ifi_index;
 
-	peer->gso_max_size = dev->gso_max_size;
+	netif_set_gso_max_size(peer, dev->gso_max_size);
 	peer->gso_max_segs = dev->gso_max_segs;
 
 	err = register_netdevice(peer);
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -3811,7 +3811,7 @@ static void vxlan_config_apply(struct ne
 	if (lowerdev) {
 		dst->remote_ifindex = conf->remote_ifindex;
 
-		dev->gso_max_size = lowerdev->gso_max_size;
+		netif_set_gso_max_size(dev, lowerdev->gso_max_size);
 		dev->gso_max_segs = lowerdev->gso_max_segs;
 
 		needed_headroom = lowerdev->hard_header_len;
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -4735,7 +4735,8 @@ static inline bool netif_needs_gso(struc
 static inline void netif_set_gso_max_size(struct net_device *dev,
 					  unsigned int size)
 {
-	dev->gso_max_size = size;
+	/* dev->gso_max_size is read locklessly from sk_setup_caps() */
+	WRITE_ONCE(dev->gso_max_size, size);
 }
 
 static inline void skb_gso_error_unwind(struct sk_buff *skb, __be16 protocol,
--- a/net/8021q/vlan.c
+++ b/net/8021q/vlan.c
@@ -322,7 +322,7 @@ static void vlan_transfer_features(struc
 {
 	struct vlan_dev_priv *vlan = vlan_dev_priv(vlandev);
 
-	vlandev->gso_max_size = dev->gso_max_size;
+	netif_set_gso_max_size(vlandev, dev->gso_max_size);
 	vlandev->gso_max_segs = dev->gso_max_segs;
 
 	if (vlan_hw_offload_capable(dev->features, vlan->vlan_proto))
--- a/net/8021q/vlan_dev.c
+++ b/net/8021q/vlan_dev.c
@@ -573,7 +573,7 @@ static int vlan_dev_init(struct net_devi
 			   NETIF_F_ALL_FCOE;
 
 	dev->features |= dev->hw_features | NETIF_F_LLTX;
-	dev->gso_max_size = real_dev->gso_max_size;
+	netif_set_gso_max_size(dev, real_dev->gso_max_size);
 	dev->gso_max_segs = real_dev->gso_max_segs;
 	if (dev->features & NETIF_F_VLAN_FEATURES)
 		netdev_warn(real_dev, "VLAN features are set incorrectly.  Q-in-Q configurations may not work correctly.\n");
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -527,7 +527,7 @@ static void br_set_gso_limits(struct net
 		gso_max_size = min(gso_max_size, p->dev->gso_max_size);
 		gso_max_segs = min(gso_max_segs, p->dev->gso_max_segs);
 	}
-	br->dev->gso_max_size = gso_max_size;
+	netif_set_gso_max_size(br->dev, gso_max_size);
 	br->dev->gso_max_segs = gso_max_segs;
 }
 
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -2159,7 +2159,8 @@ void sk_setup_caps(struct sock *sk, stru
 			sk->sk_route_caps &= ~NETIF_F_GSO_MASK;
 		} else {
 			sk->sk_route_caps |= NETIF_F_SG | NETIF_F_HW_CSUM;
-			sk->sk_gso_max_size = dst->dev->gso_max_size;
+			/* pairs with the WRITE_ONCE() in netif_set_gso_max_size() */
+			sk->sk_gso_max_size = READ_ONCE(dst->dev->gso_max_size);
 			max_segs = max_t(u32, dst->dev->gso_max_segs, 1);
 		}
 	}
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -134,7 +134,7 @@ void sctp_packet_config(struct sctp_pack
 		dst_hold(tp->dst);
 		sk_setup_caps(sk, tp->dst);
 	}
-	packet->max_size = sk_can_gso(sk) ? tp->dst->dev->gso_max_size
+	packet->max_size = sk_can_gso(sk) ? READ_ONCE(tp->dst->dev->gso_max_size)
 					  : asoc->pathmtu;
 	rcu_read_unlock();
 }
