From: Bart Van Assche <bvanassche@acm.org>
Date: Fri, 18 Feb 2022 11:50:37 -0800
Subject: [PATCH] scsi: arm: Rename arm/scsi.h into arm/arm_scsi.h
Git-commit: 8c97e2f390f56ea81e71abf02af3a6cf4de598f0
Patch-mainline: v5.18-rc1
References: jsc#PED-1559

The new name makes the purpose of this header file more clear and also
makes it easier to find this header file with grep.

Link: https://lore.kernel.org/r/20220218195117.25689-10-bvanassche@acm.org
Cc: Russell King <linux@armlinux.org.uk>
Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
Reviewed-by: Hannes Reinecke <hare@suse.de>
Signed-off-by: Bart Van Assche <bvanassche@acm.org>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/arm/acornscsi.c |   2 +-
 drivers/scsi/arm/arm_scsi.h  | 123 ++++++++++++++++++++++++++++++++++
 drivers/scsi/arm/cumana_2.c  |   2 +-
 drivers/scsi/arm/eesox.c     |   2 +-
 drivers/scsi/arm/fas216.c    |   2 +-
 drivers/scsi/arm/powertec.c  |   2 +-
 drivers/scsi/arm/scsi.h      | 125 -----------------------------------
 7 files changed, 128 insertions(+), 130 deletions(-)
 create mode 100644 drivers/scsi/arm/arm_scsi.h
 delete mode 100644 drivers/scsi/arm/scsi.h

diff --git a/drivers/scsi/arm/acornscsi.c b/drivers/scsi/arm/acornscsi.c
index a8a72d822862..38aa9333631b 100644
--- a/drivers/scsi/arm/acornscsi.c
+++ b/drivers/scsi/arm/acornscsi.c
@@ -136,7 +136,7 @@
 #include <scsi/scsi_transport_spi.h>
 #include "acornscsi.h"
 #include "msgqueue.h"
-#include "scsi.h"
+#include "arm_scsi.h"
 
 #include <scsi/scsicam.h>
 
diff --git a/drivers/scsi/arm/arm_scsi.h b/drivers/scsi/arm/arm_scsi.h
new file mode 100644
index 000000000000..3eb5c6aa93c9
--- /dev/null
+++ b/drivers/scsi/arm/arm_scsi.h
@@ -0,0 +1,123 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ *  Copyright (C) 2002 Russell King
+ *
+ *  Commonly used functions by the ARM SCSI-II drivers.
+ */
+
+#include <linux/scatterlist.h>
+
+#define BELT_AND_BRACES
+
+/*
+ * The scatter-gather list handling.  This contains all
+ * the yucky stuff that needs to be fixed properly.
+ */
+
+/*
+ * copy_SCp_to_sg() Assumes contiguous allocation at @sg of at-most @max
+ * entries of uninitialized memory. SCp is from scsi-ml and has a valid
+ * (possibly chained) sg-list
+ */
+static inline int copy_SCp_to_sg(struct scatterlist *sg, struct scsi_pointer *SCp, int max)
+{
+	int bufs = SCp->buffers_residual;
+
+	/* FIXME: It should be easy for drivers to loop on copy_SCp_to_sg().
+	 * and to remove this BUG_ON. Use min() in-its-place
+	 */
+	BUG_ON(bufs + 1 > max);
+
+	sg_set_buf(sg, SCp->ptr, SCp->this_residual);
+
+	if (bufs) {
+		struct scatterlist *src_sg;
+		unsigned i;
+
+		for_each_sg(sg_next(SCp->buffer), src_sg, bufs, i)
+			*(++sg) = *src_sg;
+		sg_mark_end(sg);
+	}
+
+	return bufs + 1;
+}
+
+static inline int next_SCp(struct scsi_pointer *SCp)
+{
+	int ret = SCp->buffers_residual;
+	if (ret) {
+		SCp->buffer = sg_next(SCp->buffer);
+		SCp->buffers_residual--;
+		SCp->ptr = sg_virt(SCp->buffer);
+		SCp->this_residual = SCp->buffer->length;
+	} else {
+		SCp->ptr = NULL;
+		SCp->this_residual = 0;
+	}
+	return ret;
+}
+
+static inline unsigned char get_next_SCp_byte(struct scsi_pointer *SCp)
+{
+	char c = *SCp->ptr;
+
+	SCp->ptr += 1;
+	SCp->this_residual -= 1;
+
+	return c;
+}
+
+static inline void put_next_SCp_byte(struct scsi_pointer *SCp, unsigned char c)
+{
+	*SCp->ptr = c;
+	SCp->ptr += 1;
+	SCp->this_residual -= 1;
+}
+
+static inline void init_SCp(struct scsi_cmnd *SCpnt)
+{
+	memset(&SCpnt->SCp, 0, sizeof(struct scsi_pointer));
+
+	if (scsi_bufflen(SCpnt)) {
+		unsigned long len = 0;
+
+		SCpnt->SCp.buffer = scsi_sglist(SCpnt);
+		SCpnt->SCp.buffers_residual = scsi_sg_count(SCpnt) - 1;
+		SCpnt->SCp.ptr = sg_virt(SCpnt->SCp.buffer);
+		SCpnt->SCp.this_residual = SCpnt->SCp.buffer->length;
+		SCpnt->SCp.phase = scsi_bufflen(SCpnt);
+
+#ifdef BELT_AND_BRACES
+		{	/*
+			 * Calculate correct buffer length.  Some commands
+			 * come in with the wrong scsi_bufflen.
+			 */
+			struct scatterlist *sg;
+			unsigned i, sg_count = scsi_sg_count(SCpnt);
+
+			scsi_for_each_sg(SCpnt, sg, sg_count, i)
+				len += sg->length;
+
+			if (scsi_bufflen(SCpnt) != len) {
+				printk(KERN_WARNING
+				       "scsi%d.%c: bad request buffer "
+				       "length %d, should be %ld\n",
+					SCpnt->device->host->host_no,
+					'0' + SCpnt->device->id,
+					scsi_bufflen(SCpnt), len);
+				/*
+				 * FIXME: Totaly naive fixup. We should abort
+				 * with error
+				 */
+				SCpnt->SCp.phase =
+					min_t(unsigned long, len,
+					      scsi_bufflen(SCpnt));
+			}
+		}
+#endif
+	} else {
+		SCpnt->SCp.ptr = NULL;
+		SCpnt->SCp.this_residual = 0;
+		SCpnt->SCp.phase = 0;
+	}
+}
diff --git a/drivers/scsi/arm/cumana_2.c b/drivers/scsi/arm/cumana_2.c
index 536d6646e40b..d15053f02472 100644
--- a/drivers/scsi/arm/cumana_2.c
+++ b/drivers/scsi/arm/cumana_2.c
@@ -36,7 +36,7 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
 #include "fas216.h"
-#include "scsi.h"
+#include "arm_scsi.h"
 
 #include <scsi/scsicam.h>
 
diff --git a/drivers/scsi/arm/eesox.c b/drivers/scsi/arm/eesox.c
index ab0f6422a6a9..6f374af9f45f 100644
--- a/drivers/scsi/arm/eesox.c
+++ b/drivers/scsi/arm/eesox.c
@@ -42,7 +42,7 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
 #include "fas216.h"
-#include "scsi.h"
+#include "arm_scsi.h"
 
 #include <scsi/scsicam.h>
 
diff --git a/drivers/scsi/arm/fas216.c b/drivers/scsi/arm/fas216.c
index 0d6df5ebf934..a23e34c9f7de 100644
--- a/drivers/scsi/arm/fas216.c
+++ b/drivers/scsi/arm/fas216.c
@@ -55,7 +55,7 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
 #include "fas216.h"
-#include "scsi.h"
+#include "arm_scsi.h"
 
 /* NOTE: SCSI2 Synchronous transfers *require* DMA according to
  *  the data sheet.  This restriction is crazy, especially when
diff --git a/drivers/scsi/arm/powertec.c b/drivers/scsi/arm/powertec.c
index 797568b271e3..7586d2a03812 100644
--- a/drivers/scsi/arm/powertec.c
+++ b/drivers/scsi/arm/powertec.c
@@ -27,7 +27,7 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
 #include "fas216.h"
-#include "scsi.h"
+#include "arm_scsi.h"
 
 #include <scsi/scsicam.h>
 
diff --git a/drivers/scsi/arm/scsi.h b/drivers/scsi/arm/scsi.h
deleted file mode 100644
index 4d5ff7b4e864..000000000000
--- a/drivers/scsi/arm/scsi.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- *  linux/drivers/acorn/scsi/scsi.h
- *
- *  Copyright (C) 2002 Russell King
- *
- *  Commonly used scsi driver functions.
- */
-
-#include <linux/scatterlist.h>
-
-#define BELT_AND_BRACES
-
-/*
- * The scatter-gather list handling.  This contains all
- * the yucky stuff that needs to be fixed properly.
- */
-
-/*
- * copy_SCp_to_sg() Assumes contiguous allocation at @sg of at-most @max
- * entries of uninitialized memory. SCp is from scsi-ml and has a valid
- * (possibly chained) sg-list
- */
-static inline int copy_SCp_to_sg(struct scatterlist *sg, struct scsi_pointer *SCp, int max)
-{
-	int bufs = SCp->buffers_residual;
-
-	/* FIXME: It should be easy for drivers to loop on copy_SCp_to_sg().
-	 * and to remove this BUG_ON. Use min() in-its-place
-	 */
-	BUG_ON(bufs + 1 > max);
-
-	sg_set_buf(sg, SCp->ptr, SCp->this_residual);
-
-	if (bufs) {
-		struct scatterlist *src_sg;
-		unsigned i;
-
-		for_each_sg(sg_next(SCp->buffer), src_sg, bufs, i)
-			*(++sg) = *src_sg;
-		sg_mark_end(sg);
-	}
-
-	return bufs + 1;
-}
-
-static inline int next_SCp(struct scsi_pointer *SCp)
-{
-	int ret = SCp->buffers_residual;
-	if (ret) {
-		SCp->buffer = sg_next(SCp->buffer);
-		SCp->buffers_residual--;
-		SCp->ptr = sg_virt(SCp->buffer);
-		SCp->this_residual = SCp->buffer->length;
-	} else {
-		SCp->ptr = NULL;
-		SCp->this_residual = 0;
-	}
-	return ret;
-}
-
-static inline unsigned char get_next_SCp_byte(struct scsi_pointer *SCp)
-{
-	char c = *SCp->ptr;
-
-	SCp->ptr += 1;
-	SCp->this_residual -= 1;
-
-	return c;
-}
-
-static inline void put_next_SCp_byte(struct scsi_pointer *SCp, unsigned char c)
-{
-	*SCp->ptr = c;
-	SCp->ptr += 1;
-	SCp->this_residual -= 1;
-}
-
-static inline void init_SCp(struct scsi_cmnd *SCpnt)
-{
-	memset(&SCpnt->SCp, 0, sizeof(struct scsi_pointer));
-
-	if (scsi_bufflen(SCpnt)) {
-		unsigned long len = 0;
-
-		SCpnt->SCp.buffer = scsi_sglist(SCpnt);
-		SCpnt->SCp.buffers_residual = scsi_sg_count(SCpnt) - 1;
-		SCpnt->SCp.ptr = sg_virt(SCpnt->SCp.buffer);
-		SCpnt->SCp.this_residual = SCpnt->SCp.buffer->length;
-		SCpnt->SCp.phase = scsi_bufflen(SCpnt);
-
-#ifdef BELT_AND_BRACES
-		{	/*
-			 * Calculate correct buffer length.  Some commands
-			 * come in with the wrong scsi_bufflen.
-			 */
-			struct scatterlist *sg;
-			unsigned i, sg_count = scsi_sg_count(SCpnt);
-
-			scsi_for_each_sg(SCpnt, sg, sg_count, i)
-				len += sg->length;
-
-			if (scsi_bufflen(SCpnt) != len) {
-				printk(KERN_WARNING
-				       "scsi%d.%c: bad request buffer "
-				       "length %d, should be %ld\n",
-					SCpnt->device->host->host_no,
-					'0' + SCpnt->device->id,
-					scsi_bufflen(SCpnt), len);
-				/*
-				 * FIXME: Totaly naive fixup. We should abort
-				 * with error
-				 */
-				SCpnt->SCp.phase =
-					min_t(unsigned long, len,
-					      scsi_bufflen(SCpnt));
-			}
-		}
-#endif
-	} else {
-		SCpnt->SCp.ptr = NULL;
-		SCpnt->SCp.this_residual = 0;
-		SCpnt->SCp.phase = 0;
-	}
-}
-- 
2.35.3

