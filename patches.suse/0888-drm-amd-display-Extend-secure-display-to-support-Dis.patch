From 44cea2bb9c872594e538412eb9c780b391eb112c Mon Sep 17 00:00:00 2001
From: Wayne Lin <Wayne.Lin@amd.com>
Date: Thu, 31 Oct 2024 15:57:40 +0800
Subject: drm/amd/display: Extend secure display to support DisplayCRC mode
Git-commit: 44cea2bb9c872594e538412eb9c780b391eb112c
Patch-mainline: v6.14-rc1
References: jsc#PED-13979 jsc#PED-14039 jsc#PED-14046 jsc#PED-14211 jsc#PED-14333 jsc#PED-14487 jsc#PED-14488 jsc#PED-14497 jsc#PED-14499

[Why]
For the legacy secure display, it involves PSP + DMUB to confgiure and
retrieve the CRC/ROI result. Have requirement to support mode which all
handled by driver only.

[How]
Add another "DisplayCRC" mode, which doesn't involve PSP + DMUB.
All things are handled by the driver only

Reviewed-by: HaoPing Liu <haoping.liu@amd.com>
Signed-off-by: Wayne Lin <Wayne.Lin@amd.com>
Signed-off-by: Tom Chung <chiahsuan.chung@amd.com>
Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>

---
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c | 56 +++++++++++++------
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_crc.h |  9 +++
 2 files changed, 49 insertions(+), 16 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index d3cc41e49b79..033bd817d871 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -317,7 +317,7 @@ static void amdgpu_dm_set_crc_window_default(struct drm_crtc *crtc, struct dc_st
 	spin_unlock_irqrestore(&drm_dev->event_lock, flags);
 
 	/* Disable secure_display if it was enabled */
-	if (was_activated) {
+	if (was_activated && dm->secure_display_ctx.op_mode == LEGACY_MODE) {
 		/* stop ROI update on this crtc */
 		flush_work(&dm->secure_display_ctx.crtc_ctx[crtc->index].notify_ta_work);
 		flush_work(&dm->secure_display_ctx.crtc_ctx[crtc->index].forward_roi_work);
@@ -698,7 +698,8 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 
 #if defined(CONFIG_DRM_AMD_SECURE_DISPLAY)
 	/* Initialize phy id mapping table for secure display*/
-	if (!dm->secure_display_ctx.phy_mapping_updated)
+	if (dm->secure_display_ctx.op_mode == LEGACY_MODE &&
+		!dm->secure_display_ctx.phy_mapping_updated)
 		update_phy_id_mapping(adev);
 #endif
 
@@ -781,6 +782,7 @@ void amdgpu_dm_crtc_handle_crc_window_irq(struct drm_crtc *crtc)
 	bool forward_roi_change = false;
 	bool notify_ta = false;
 	bool all_crc_ready = true;
+	struct dc_stream_state *stream_state;
 	int i;
 
 	if (crtc == NULL)
@@ -789,6 +791,7 @@ void amdgpu_dm_crtc_handle_crc_window_irq(struct drm_crtc *crtc)
 	acrtc = to_amdgpu_crtc(crtc);
 	adev = drm_to_adev(crtc->dev);
 	drm_dev = crtc->dev;
+	stream_state = to_dm_crtc_state(crtc->state)->stream;
 
 	spin_lock_irqsave(&drm_dev->event_lock, flags1);
 	cur_crc_src = acrtc->dm_irq_params.crc_src;
@@ -814,6 +817,17 @@ void amdgpu_dm_crtc_handle_crc_window_irq(struct drm_crtc *crtc)
 	}
 
 	for (i = 0; i < MAX_CRC_WINDOW_NUM; i++) {
+		struct crc_params crc_window = {
+			.windowa_x_start = acrtc->dm_irq_params.window_param[i].x_start,
+			.windowa_y_start = acrtc->dm_irq_params.window_param[i].y_start,
+			.windowa_x_end = acrtc->dm_irq_params.window_param[i].x_end,
+			.windowa_y_end = acrtc->dm_irq_params.window_param[i].y_end,
+			.windowb_x_start = acrtc->dm_irq_params.window_param[i].x_start,
+			.windowb_y_start = acrtc->dm_irq_params.window_param[i].y_start,
+			.windowb_x_end = acrtc->dm_irq_params.window_param[i].x_end,
+			.windowb_y_end = acrtc->dm_irq_params.window_param[i].y_end,
+		};
+
 		crtc_ctx->roi[i].enable = acrtc->dm_irq_params.window_param[i].enable;
 
 		if (!acrtc->dm_irq_params.window_param[i].enable) {
@@ -828,15 +842,20 @@ void amdgpu_dm_crtc_handle_crc_window_irq(struct drm_crtc *crtc)
 		}
 
 		if (acrtc->dm_irq_params.window_param[i].update_win) {
-			/* prepare work for dmub to update ROI */
-			crtc_ctx->roi[i].rect.x = acrtc->dm_irq_params.window_param[i].x_start;
-			crtc_ctx->roi[i].rect.y = acrtc->dm_irq_params.window_param[i].y_start;
-			crtc_ctx->roi[i].rect.width = acrtc->dm_irq_params.window_param[i].x_end -
-						acrtc->dm_irq_params.window_param[i].x_start;
-			crtc_ctx->roi[i].rect.height = acrtc->dm_irq_params.window_param[i].y_end -
-						acrtc->dm_irq_params.window_param[i].y_start;
-
-			forward_roi_change = true;
+			crtc_ctx->roi[i].rect.x = crc_window.windowa_x_start;
+			crtc_ctx->roi[i].rect.y = crc_window.windowa_y_start;
+			crtc_ctx->roi[i].rect.width = crc_window.windowa_x_end -
+						crc_window.windowa_x_start;
+			crtc_ctx->roi[i].rect.height = crc_window.windowa_y_end -
+						crc_window.windowa_y_start;
+
+			if (adev->dm.secure_display_ctx.op_mode == LEGACY_MODE)
+				/* forward task to dmub to update ROI */
+				forward_roi_change = true;
+			else if (adev->dm.secure_display_ctx.op_mode == DISPLAY_CRC_MODE)
+				/* update ROI via dm*/
+				dc_stream_configure_crc(stream_state->ctx->dc, stream_state,
+					&crc_window, true, true, i, false);
 
 			reset_crc_frame_count[i] = true;
 
@@ -850,14 +869,18 @@ void amdgpu_dm_crtc_handle_crc_window_irq(struct drm_crtc *crtc)
 			acrtc->dm_irq_params.window_param[i].skip_frame_cnt = 1;
 			crtc_ctx->crc_info.crc[i].crc_ready = false;
 		} else {
-			struct dc_stream_state *stream_state = to_dm_crtc_state(crtc->state)->stream;
-
 			if (!dc_stream_get_crc(stream_state->ctx->dc, stream_state, i,
 						&crc_r[i], &crc_g[i], &crc_b[i]))
 				DRM_ERROR("Secure Display: fail to get crc from engine %d\n", i);
 
-			/* prepare work for psp to read ROI/CRC and send to I2C */
-			notify_ta = true;
+			if (adev->dm.secure_display_ctx.op_mode == LEGACY_MODE)
+				/* forward task to psp to read ROI/CRC and output via I2C */
+				notify_ta = true;
+			else if (adev->dm.secure_display_ctx.op_mode == DISPLAY_CRC_MODE)
+				/* Avoid ROI window get changed, keep overwriting. */
+				dc_stream_configure_crc(stream_state->ctx->dc, stream_state,
+						&crc_window, true, true, i, false);
+
 			/* crc ready for psp to read out */
 			crtc_ctx->crc_info.crc[i].crc_ready = true;
 		}
@@ -921,6 +944,7 @@ void amdgpu_dm_crtc_secure_display_create_contexts(struct amdgpu_device *adev)
 	}
 
 	adev->dm.secure_display_ctx.crtc_ctx = crtc_ctx;
-	return;
+
+	adev->dm.secure_display_ctx.op_mode = DISPLAY_CRC_MODE;
 }
 #endif
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.h
index 0c96f2db1352..3da056c8d20b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.h
@@ -42,6 +42,14 @@ enum amdgpu_dm_pipe_crc_source {
 #ifdef CONFIG_DRM_AMD_SECURE_DISPLAY
 #define MAX_CRTC 6
 
+enum secure_display_mode {
+	/* via dmub + psp */
+	LEGACY_MODE = 0,
+	/* driver directly */
+	DISPLAY_CRC_MODE,
+	SECURE_DISPLAY_MODE_MAX,
+};
+
 struct phy_id_mapping {
 	bool assigned;
 	bool is_mst;
@@ -98,6 +106,7 @@ struct secure_display_context {
 	struct secure_display_crtc_context *crtc_ctx;
     /* Whether dmub support multiple ROI setting */
 	bool support_mul_roi;
+	enum secure_display_mode op_mode;
 	bool phy_mapping_updated;
 	int phy_id_mapping_cnt;
 	struct phy_id_mapping phy_id_mapping[MAX_CRTC];
-- 
2.52.0

