From: Sabrina Dubroca <sd@queasysnail.net>
Date: Fri, 20 Oct 2023 16:00:55 +0200
Subject: tls: don't reset prot->aad_size and prot->tail_size for TLS_HW
Patch-mainline: v6.7-rc1
Git-commit: b7c4f5730a9fa258c8e79f6387a03f3a95c681a2
References: jsc#PED-6831

Prior to commit 1a074f7618e8 ("tls: also use init_prot_info in
tls_set_device_offload"), setting TLS_HW on TX didn't touch
prot->aad_size and prot->tail_size. They are set to 0 during context
allocation (tls_prot_info is embedded in tls_context, kzalloc'd by
tls_ctx_create).

When the RX key is configured, tls_set_sw_offload is called (for both
TLS_SW and TLS_HW). If the TX key is configured in TLS_HW mode after
the RX key has been installed, init_prot_info will now overwrite the
correct values of aad_size and tail_size, breaking SW decryption and
causing -EBADMSG errors to be returned to userspace.

Since TLS_HW doesn't use aad_size and tail_size at all (for TLS1.2,
tail_size is always 0, and aad_size is equal to TLS_HEADER_SIZE +
rec_seq_size), we can simply drop this hunk.

Fixes: 1a074f7618e8 ("tls: also use init_prot_info in tls_set_device_offload")
Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
Acked-by: Jakub Kicinski <kuba@kernel.org>
Tested-by: Ran Rozenstein <ranro@nvidia.com>
Link: https://lore.kernel.org/r/979d2f89a6a994d5bb49cae49a80be54150d094d.1697653889.git.sd@queasysnail.net
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 net/tls/tls.h        |    3 +--
 net/tls/tls_device.c |    2 +-
 net/tls/tls_sw.c     |   10 ++--------
 3 files changed, 4 insertions(+), 11 deletions(-)

--- a/net/tls/tls.h
+++ b/net/tls/tls.h
@@ -144,8 +144,7 @@ void tls_err_abort(struct sock *sk, int
 
 int init_prot_info(struct tls_prot_info *prot,
 		   const struct tls_crypto_info *crypto_info,
-		   const struct tls_cipher_desc *cipher_desc,
-		   int mode);
+		   const struct tls_cipher_desc *cipher_desc);
 int tls_set_sw_offload(struct sock *sk, int tx);
 void tls_update_rx_zc_capable(struct tls_context *tls_ctx);
 void tls_sw_strparser_arm(struct sock *sk, struct tls_context *ctx);
--- a/net/tls/tls_device.c
+++ b/net/tls/tls_device.c
@@ -1099,7 +1099,7 @@ int tls_set_device_offload(struct sock *
 		goto release_netdev;
 	}
 
-	rc = init_prot_info(prot, crypto_info, cipher_desc, TLS_HW);
+	rc = init_prot_info(prot, crypto_info, cipher_desc);
 	if (rc)
 		goto release_netdev;
 
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@ -2629,8 +2629,7 @@ static struct tls_sw_context_rx *init_ct
 
 int init_prot_info(struct tls_prot_info *prot,
 		   const struct tls_crypto_info *crypto_info,
-		   const struct tls_cipher_desc *cipher_desc,
-		   int mode)
+		   const struct tls_cipher_desc *cipher_desc)
 {
 	u16 nonce_size = cipher_desc->nonce;
 
@@ -2643,11 +2642,6 @@ int init_prot_info(struct tls_prot_info
 		prot->tail_size = 0;
 	}
 
-	if (mode == TLS_HW) {
-		prot->aad_size = 0;
-		prot->tail_size = 0;
-	}
-
 	/* Sanity-check the sizes for stack allocations. */
 	if (nonce_size > TLS_MAX_IV_SIZE || prot->aad_size > TLS_MAX_AAD_SIZE)
 		return -EINVAL;
@@ -2707,7 +2701,7 @@ int tls_set_sw_offload(struct sock *sk,
 		goto free_priv;
 	}
 
-	rc = init_prot_info(prot, crypto_info, cipher_desc, TLS_SW);
+	rc = init_prot_info(prot, crypto_info, cipher_desc);
 	if (rc)
 		goto free_priv;
 
