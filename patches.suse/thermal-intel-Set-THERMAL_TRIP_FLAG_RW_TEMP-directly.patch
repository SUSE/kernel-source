From: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
Date: Thu, 22 Feb 2024 19:06:05 +0100
Subject: thermal: intel: Set THERMAL_TRIP_FLAG_RW_TEMP directly
Patch-mainline: v6.9-rc1
Git-commit: cca52f696952962f020c7e1393740d0ba07c3dc2
References: jsc#PED-11164

Some Intel thermal drivers need/want the temperature of their trip
points to be set by user space via sysfs and so they pass nonzero
writable trip masks during thermal zone registration for this purpose.

It is now possible to achieve the same result by setting the
THERMAL_TRIP_FLAG_RW_TEMP trip flag directly, so modify the drivers
in question to do that instead of using a nonzero writable trips mask.

No intentional functional impact.

Note that this change is requisite for dropping the mask argument from
thermal_zone_device_register_with_trips() going forward.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
Acked-by: Chun-Yi Lee <jlee@suse.com>
---
 drivers/thermal/intel/int340x_thermal/int340x_thermal_zone.c         |    8 -
 drivers/thermal/intel/int340x_thermal/processor_thermal_device_pci.c |    3 
 drivers/thermal/intel/intel_quark_dts_thermal.c                      |   20 +--
 drivers/thermal/intel/intel_soc_dts_iosf.c                           |   57 ++++------
 drivers/thermal/intel/intel_soc_dts_iosf.h                           |    1 
 drivers/thermal/intel/x86_pkg_temp_thermal.c                         |    4 
 6 files changed, 38 insertions(+), 55 deletions(-)

--- a/drivers/thermal/intel/int340x_thermal/int340x_thermal_zone.c
+++ b/drivers/thermal/intel/int340x_thermal/int340x_thermal_zone.c
@@ -129,7 +129,6 @@ struct int34x_thermal_zone *int340x_ther
 	struct thermal_trip *zone_trips;
 	unsigned long long trip_cnt = 0;
 	unsigned long long hyst;
-	int trip_mask = 0;
 	acpi_status status;
 	int i, ret;
 
@@ -140,10 +139,8 @@ struct int34x_thermal_zone *int340x_ther
 	int34x_zone->adev = adev;
 
 	status = acpi_evaluate_integer(adev->handle, "PATC", NULL, &trip_cnt);
-	if (ACPI_SUCCESS(status)) {
+	if (ACPI_SUCCESS(status))
 		int34x_zone->aux_trip_nr = trip_cnt;
-		trip_mask = BIT(trip_cnt) - 1;
-	}
 
 	zone_trips = kzalloc(sizeof(*zone_trips) * (trip_cnt + INT340X_THERMAL_MAX_TRIP_COUNT),
 			     GFP_KERNEL);
@@ -155,6 +152,7 @@ struct int34x_thermal_zone *int340x_ther
 	for (i = 0; i < trip_cnt; i++) {
 		zone_trips[i].type = THERMAL_TRIP_PASSIVE;
 		zone_trips[i].temperature = THERMAL_TEMP_INVALID;
+		zone_trips[i].flags |= THERMAL_TRIP_FLAG_RW_TEMP;
 	}
 
 	trip_cnt = int340x_thermal_read_trips(adev, zone_trips, trip_cnt);
@@ -173,7 +171,7 @@ struct int34x_thermal_zone *int340x_ther
 	int34x_zone->zone = thermal_zone_device_register_with_trips(
 							acpi_device_bid(adev),
 							zone_trips, trip_cnt,
-							trip_mask, int34x_zone,
+							0, int34x_zone,
 							&zone_ops,
 							&int340x_thermal_params,
 							0, 0);
--- a/drivers/thermal/intel/int340x_thermal/processor_thermal_device_pci.c
+++ b/drivers/thermal/intel/int340x_thermal/processor_thermal_device_pci.c
@@ -249,6 +249,7 @@ static int proc_thermal_pci_probe(struct
 	struct proc_thermal_pci *pci_info;
 	struct thermal_trip psv_trip = {
 		.type = THERMAL_TRIP_PASSIVE,
+		.flags = THERMAL_TRIP_FLAG_RW_TEMP,
 	};
 	int irq_flag = 0, irq, ret;
 	bool msi_irq = false;
@@ -289,7 +290,7 @@ static int proc_thermal_pci_probe(struct
 	psv_trip.temperature = get_trip_temp(pci_info);
 
 	pci_info->tzone = thermal_zone_device_register_with_trips("TCPU_PCI", &psv_trip,
-							1, 1, pci_info,
+							1, 0, pci_info,
 							&tzone_ops,
 							&tzone_params, 0, 0);
 	if (IS_ERR(pci_info->tzone)) {
--- a/drivers/thermal/intel/intel_quark_dts_thermal.c
+++ b/drivers/thermal/intel/intel_quark_dts_thermal.c
@@ -93,10 +93,6 @@
 
 /* Quark DTS has 2 trip points: hot & catastrophic */
 #define QRK_MAX_DTS_TRIPS	2
-/* If DTS not locked, all trip points are configurable */
-#define QRK_DTS_WR_MASK_SET	0x3
-/* If DTS locked, all trip points are not configurable */
-#define QRK_DTS_WR_MASK_CLR	0
 
 #define DEFAULT_POLL_DELAY	2000
 
@@ -323,7 +319,6 @@ static struct soc_sensor_entry *alloc_so
 	struct soc_sensor_entry *aux_entry;
 	int err;
 	u32 out;
-	int wr_mask;
 
 	aux_entry = kzalloc(sizeof(*aux_entry), GFP_KERNEL);
 	if (!aux_entry) {
@@ -337,13 +332,7 @@ static struct soc_sensor_entry *alloc_so
 	if (err)
 		goto err_ret;
 
-	if (out & QRK_DTS_LOCK_BIT) {
-		aux_entry->locked = true;
-		wr_mask = QRK_DTS_WR_MASK_CLR;
-	} else {
-		aux_entry->locked = false;
-		wr_mask = QRK_DTS_WR_MASK_SET;
-	}
+	aux_entry->locked = !!(out & QRK_DTS_LOCK_BIT);
 
 	/* Store DTS default state if DTS registers are not locked */
 	if (!aux_entry->locked) {
@@ -360,6 +349,9 @@ static struct soc_sensor_entry *alloc_so
 				    &aux_entry->store_ptps);
 		if (err)
 			goto err_ret;
+
+		trips[QRK_DTS_ID_TP_CRITICAL].flags |= THERMAL_TRIP_FLAG_RW_TEMP;
+		trips[QRK_DTS_ID_TP_HOT].flags |= THERMAL_TRIP_FLAG_RW_TEMP;
 	}
 
 	trips[QRK_DTS_ID_TP_CRITICAL].temperature = get_trip_temp(QRK_DTS_ID_TP_CRITICAL);
@@ -371,8 +363,8 @@ static struct soc_sensor_entry *alloc_so
 	aux_entry->tzone = thermal_zone_device_register_with_trips("quark_dts",
 								   trips,
 								   QRK_MAX_DTS_TRIPS,
-								   wr_mask,
-								   aux_entry, &tzone_ops,
+								   0, aux_entry,
+								   &tzone_ops,
 								   NULL, 0, polling_delay);
 	if (IS_ERR(aux_entry->tzone)) {
 		err = PTR_ERR(aux_entry->tzone);
--- a/drivers/thermal/intel/intel_soc_dts_iosf.c
+++ b/drivers/thermal/intel/intel_soc_dts_iosf.c
@@ -202,16 +202,10 @@ static void remove_dts_thermal_zone(stru
 }
 
 static int add_dts_thermal_zone(int id, struct intel_soc_dts_sensor_entry *dts,
-				struct thermal_trip *trips,
-				bool critical_trip)
+				struct thermal_trip *trips)
 {
-	int writable_trip_cnt = SOC_MAX_DTS_TRIPS;
 	char name[10];
-	unsigned long trip;
-	int trip_mask;
-	unsigned long ptps;
 	u32 store_ptps;
-	unsigned long i;
 	int ret;
 
 	/* Store status to restor on exit */
@@ -222,27 +216,21 @@ static int add_dts_thermal_zone(int id,
 
 	dts->id = id;
 
-	if (critical_trip)
-		writable_trip_cnt--;
-
-	trip_mask = GENMASK(writable_trip_cnt - 1, 0);
-
 	/* Check if the writable trip we provide is not used by BIOS */
 	ret = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,
 			    SOC_DTS_OFFSET_PTPS, &store_ptps);
-	if (ret)
-		trip_mask = 0;
-	else {
-		ptps = store_ptps;
-		for_each_set_clump8(i, trip, &ptps, writable_trip_cnt * 8)
-			trip_mask &= ~BIT(i / 8);
+	if (!ret) {
+		int i;
+
+		for (i = 0; i <= 1; i++) {
+			if (store_ptps & (0xFFU << i * 8))
+				trips[i].flags &= ~THERMAL_TRIP_FLAG_RW_TEMP;
+		}
 	}
-	dts->trip_mask = trip_mask;
 	snprintf(name, sizeof(name), "soc_dts%d", id);
 	dts->tzone = thermal_zone_device_register_with_trips(name, trips,
 							     SOC_MAX_DTS_TRIPS,
-							     trip_mask,
-							     dts, &tzone_ops,
+							     0, dts, &tzone_ops,
 							     NULL, 0, 0);
 	if (IS_ERR(dts->tzone)) {
 		ret = PTR_ERR(dts->tzone);
@@ -304,6 +292,14 @@ static void dts_trips_reset(struct intel
 	update_trip_temp(sensors, 1, 0);
 }
 
+static void set_trip(struct thermal_trip *trip, enum thermal_trip_type type,
+		     u8 flags, int temp)
+{
+	trip->type = type;
+	trip->flags = flags;
+	trip->temperature = temp;
+}
+
 struct intel_soc_dts_sensors *
 intel_soc_dts_iosf_init(enum intel_soc_dts_interrupt_type intr_type,
 			bool critical_trip, int crit_offset)
@@ -331,36 +327,33 @@ intel_soc_dts_iosf_init(enum intel_soc_d
 	sensors->tj_max = tj_max * 1000;
 
 	for (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {
-		enum thermal_trip_type trip_type;
 		int temp;
 
 		sensors->soc_dts[i].sensors = sensors;
 
+		set_trip(&trips[i][0], THERMAL_TRIP_PASSIVE,
+			 THERMAL_TRIP_FLAG_RW_TEMP, 0);
+
 		ret = update_trip_temp(sensors, 0, 0);
 		if (ret)
 			goto err_reset_trips;
 
-		trips[i][0].type = THERMAL_TRIP_PASSIVE;
-		trips[i][0].temperature = 0;
-
 		if (critical_trip) {
-			trip_type = THERMAL_TRIP_CRITICAL;
 			temp = sensors->tj_max - crit_offset;
+			set_trip(&trips[i][1], THERMAL_TRIP_CRITICAL, 0, temp);
 		} else {
-			trip_type = THERMAL_TRIP_PASSIVE;
+			set_trip(&trips[i][1], THERMAL_TRIP_PASSIVE,
+				 THERMAL_TRIP_FLAG_RW_TEMP, 0);
 			temp = 0;
 		}
+
 		ret = update_trip_temp(sensors, 1, temp);
 		if (ret)
 			goto err_reset_trips;
-
-		trips[i][1].type = trip_type;
-		trips[i][1].temperature = temp;
 	}
 
 	for (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {
-		ret = add_dts_thermal_zone(i, &sensors->soc_dts[i], trips[i],
-					   critical_trip);
+		ret = add_dts_thermal_zone(i, &sensors->soc_dts[i], trips[i]);
 		if (ret)
 			goto err_remove_zone;
 	}
--- a/drivers/thermal/intel/intel_soc_dts_iosf.h
+++ b/drivers/thermal/intel/intel_soc_dts_iosf.h
@@ -28,7 +28,6 @@ struct intel_soc_dts_sensors;
 struct intel_soc_dts_sensor_entry {
 	int id;
 	u32 store_status;
-	u32 trip_mask;
 	struct thermal_zone_device *tzone;
 	struct intel_soc_dts_sensors *sensors;
 };
--- a/drivers/thermal/intel/x86_pkg_temp_thermal.c
+++ b/drivers/thermal/intel/x86_pkg_temp_thermal.c
@@ -295,6 +295,7 @@ static int pkg_temp_thermal_trips_init(i
 			tj_max - thres_reg_value * 1000 : THERMAL_TEMP_INVALID;
 
 		trips[i].type = THERMAL_TRIP_PASSIVE;
+		trips[i].flags |= THERMAL_TRIP_FLAG_RW_TEMP;
 
 		pr_debug("%s: cpu=%d, trip=%d, temp=%d\n",
 			 __func__, cpu, i, trips[i].temperature);
@@ -337,8 +338,7 @@ static int pkg_temp_thermal_device_add(u
 	INIT_DELAYED_WORK(&zonedev->work, pkg_temp_thermal_threshold_work_fn);
 	zonedev->cpu = cpu;
 	zonedev->tzone = thermal_zone_device_register_with_trips("x86_pkg_temp",
-			trips, thres_count,
-			(thres_count == MAX_NUMBER_OF_TRIPS) ? 0x03 : 0x01,
+			trips, thres_count, 0,
 			zonedev, &tzone_ops, &pkg_temp_tz_params, 0, 0);
 	if (IS_ERR(zonedev->tzone)) {
 		err = PTR_ERR(zonedev->tzone);
