From: Enzo Matsumiya <ematsumiya@suse.de>
Date: Thu,  4 Apr 2024 07:40:45 -0300
Subject: [PATCH] cifs: fix hang in wait_for_response()
References: bsc#1220812, bsc#1220368
Patch-mainline: Never, SUSE-specific fix (SLE15-SP5 only)

When there's a network interruption while sending NegotiateProtocol message,
cifsd thread might hang forever in wait_for_response() because a) the server is
not responding, and b) there are no other mechanisms to kill it.

This patch fixes this by setting a timeout in wait_for_response().  An arbitrary
value of 10 seconds was chosen as such request shouldn't take longer than that
to get a response anyway.

A side-effect of this bug is that any concurrent commands will reach
smb2_reconnect() and keep waiting for ses->session_mutex to become available,
but from an uninterruptible thread.

This patch also fixes this by bailing out of smb2_reconnect() if the server is
mid-negotiation.

Signed-off-by: Enzo Matsumiya <ematsumiya@suse.de>
---
 fs/smb/client/smb2pdu.c   |    9 +++++++++
 fs/smb/client/transport.c |   23 ++++++++++++++++++++---
 2 files changed, 29 insertions(+), 3 deletions(-)

--- a/fs/smb/client/smb2pdu.c
+++ b/fs/smb/client/smb2pdu.c
@@ -205,6 +205,15 @@ smb2_reconnect(__le16 smb2_command, stru
 			spin_unlock(&server->srv_lock);
 			return -EAGAIN;
 		}
+	} else {
+		/*
+		 * There's a reconnect happening in another thread, return
+		 * immediately to avoid getting stuck uninterruptible.
+		 */
+		if (server->tcpStatus == CifsInNegotiate) {
+			spin_unlock(&server->srv_lock);
+			return -EAGAIN;
+		}
 	}
 	spin_unlock(&server->srv_lock);
 
--- a/fs/smb/client/transport.c
+++ b/fs/smb/client/transport.c
@@ -761,9 +761,26 @@ wait_for_response(struct TCP_Server_Info
 {
 	int error;
 
-	error = wait_event_freezekillable_unsafe(server->response_q,
-						 midQ->mid_state != MID_REQUEST_SUBMITTED &&
-						 midQ->mid_state != MID_RESPONSE_RECEIVED);
+	if (midQ->optype & CIFS_NEG_OP) {
+		/*
+		 * Set a 10 seconds timeout when negotiating because if we get
+		 * disconnected while doing so, we'll be stuck here forever
+		 * since there's no one else to do a reconnect.
+		 */
+		error = wait_event_killable_timeout(server->response_q,
+						    midQ->mid_state != MID_REQUEST_SUBMITTED &&
+						    midQ->mid_state != MID_RESPONSE_RECEIVED,
+						    10 * HZ);
+
+		/* timeout elapsed with no response */
+		if (error == 0)
+			return -EAGAIN;
+	} else {
+		error = wait_event_freezekillable_unsafe(server->response_q,
+							 midQ->mid_state != MID_REQUEST_SUBMITTED &&
+							 midQ->mid_state != MID_RESPONSE_RECEIVED);
+	}
+
 	if (error < 0)
 		return -ERESTARTSYS;
 
