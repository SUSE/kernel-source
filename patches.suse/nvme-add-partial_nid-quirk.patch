From: Hannes Reinecke <hare@kernel.org>
Date: Mon, 14 Apr 2025 11:09:58 +0200
Subject: nvme: Add 'partial_nid' quirk
Patch-mainline: Never, upstream NAKed 
References: bsc#1241148

Add a quirk to handle NVMe devices for which not all NID values are unique,
and return a match from nvme_subsys_check_duplicate_ids() once the first
matching NID value is found.

Signed-off-by: Hannes Reinecke <hare@kernel.org>
Acked-by: Daniel Wagner <dwagner@suse.de>
---
 drivers/nvme/host/core.c | 28 ++++++++++++++++++++++------
 drivers/nvme/host/nvme.h |  5 +++++
 2 files changed, 27 insertions(+), 6 deletions(-)

diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index 02967dbd8069..de25187ea83a 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -3368,18 +3368,30 @@ static int nvme_subsys_check_duplicate_ids(struct nvme_subsystem *subsys,
 	bool has_nguid = memchr_inv(ids->nguid, 0, sizeof(ids->nguid));
 	bool has_eui64 = memchr_inv(ids->eui64, 0, sizeof(ids->eui64));
 	struct nvme_ns_head *h;
+	bool match_nid = false;
 
 	lockdep_assert_held(&subsys->lock);
 
 	list_for_each_entry(h, &subsys->nsheads, entry) {
-		if (has_uuid && uuid_equal(&ids->uuid, &h->ids.uuid))
-			return -EINVAL;
-		if (has_nguid &&
-		    memcmp(&ids->nguid, &h->ids.nguid, sizeof(ids->nguid)) == 0)
-			return -EINVAL;
+		if (has_uuid) {
+			if (uuid_equal(&ids->uuid, &h->ids.uuid))
+				return -EINVAL;
+			match_nid = true;
+		}
+		if (has_nguid) {
+			if (memcmp(&ids->nguid, &h->ids.nguid, sizeof(ids->nguid)) == 0) {
+				if (match_nid)
+					return -ENOTUNIQ;
+				return -EINVAL;
+			}
+			match_nid = true;
+		}
 		if (has_eui64 &&
-		    memcmp(&ids->eui64, &h->ids.eui64, sizeof(ids->eui64)) == 0)
+		    memcmp(&ids->eui64, &h->ids.eui64, sizeof(ids->eui64)) == 0) {
+			if (match_nid)
+				return -ENOTUNIQ;
 			return -EINVAL;
+		}
 	}
 
 	return 0;
@@ -3541,6 +3553,8 @@ static int nvme_init_ns_head(struct nvme_ns *ns, struct nvme_ns_info *info)
 	int ret;
 
 	ret = nvme_global_check_duplicate_ids(ctrl->subsys, &info->ids);
+	if (ret == -ENOTUNIQ && ctrl->quirks & NVME_QUIRK_PARTIAL_NID)
+		ret = 0;
 	if (ret) {
 		/*
 		 * We've found two different namespaces on two different
@@ -3582,6 +3596,8 @@ static int nvme_init_ns_head(struct nvme_ns *ns, struct nvme_ns_info *info)
 	head = nvme_find_ns_head(ctrl, info->nsid);
 	if (!head) {
 		ret = nvme_subsys_check_duplicate_ids(ctrl->subsys, &info->ids);
+		if (ret == -ENOTUNIQ && ctrl->quirks & NVME_QUIRK_PARTIAL_NID)
+			ret = 0;
 		if (ret) {
 			dev_err(ctrl->device,
 				"duplicate IDs in subsystem for nsid %d\n",
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index 8fe30cd747ce..cd3a83cf4978 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -177,6 +177,11 @@ enum nvme_quirks {
 	 * Align dma pool segment size to 512 bytes
 	 */
 	NVME_QUIRK_DMAPOOL_ALIGN_512		= (1 << 22),
+
+	/*
+	 * Not all namespace identifiers are unique
+	 */
+	NVME_QUIRK_PARTIAL_NID			= (1 << 23),
 };
 
 /*
-- 
2.35.3

