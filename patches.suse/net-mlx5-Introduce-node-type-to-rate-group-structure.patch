From: Carolina Jubran <cjubran@nvidia.com>
Date: Wed, 16 Oct 2024 20:36:04 +0300
Subject: net/mlx5: Introduce node type to rate group structure
Patch-mainline: v6.13-rc1
Git-commit: 4235fe2cb8e98dec6f49a86c93704b6a4762c4a2
References: jsc#PED-9900 jsc#PED-11429

Introduce the `sched_node_type` enum to represent both the group and
its members as scheduling nodes in the rate hierarchy.

Add the `type` field to the rate group structure to specify the type of
the node membership in the rate hierarchy.

Generalize comments to reflect this flexibility within the rate group
structure.

Signed-off-by: Carolina Jubran <cjubran@nvidia.com>
Reviewed-by: Cosmin Ratiu <cratiu@nvidia.com>
Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
Reviewed-by: Daniel Machon <daniel.machon@microchip.com>
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c |   28 ++++++++++++++--------
 1 file changed, 18 insertions(+), 10 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c
@@ -61,6 +61,10 @@ static void esw_qos_domain_release(struc
 	esw->qos.domain = NULL;
 }
 
+enum sched_node_type {
+	SCHED_NODE_TYPE_VPORTS_TSAR,
+};
+
 struct mlx5_esw_rate_group {
 	u32 tsar_ix;
 	/* Bandwidth parameters. */
@@ -68,11 +72,13 @@ struct mlx5_esw_rate_group {
 	u32 min_rate;
 	/* A computed value indicating relative min_rate between group members. */
 	u32 bw_share;
-	/* Membership in the qos domain 'groups' list. */
+	/* Membership in the parent list. */
 	struct list_head parent_entry;
+	/* The type of this group node in the rate hierarchy. */
+	enum sched_node_type type;
 	/* The eswitch this group belongs to. */
 	struct mlx5_eswitch *esw;
-	/* Vport members of this group.*/
+	/* Members of this group.*/
 	struct list_head members;
 };
 
@@ -499,7 +505,7 @@ static int esw_qos_vport_update_group(st
 }
 
 static struct mlx5_esw_rate_group *
-__esw_qos_alloc_rate_group(struct mlx5_eswitch *esw, u32 tsar_ix)
+__esw_qos_alloc_rate_group(struct mlx5_eswitch *esw, u32 tsar_ix, enum sched_node_type type)
 {
 	struct mlx5_esw_rate_group *group;
 
@@ -509,6 +515,7 @@ __esw_qos_alloc_rate_group(struct mlx5_e
 
 	group->esw = esw;
 	group->tsar_ix = tsar_ix;
+	group->type = type;
 	INIT_LIST_HEAD(&group->members);
 	list_add_tail(&group->parent_entry, &esw->qos.domain->groups);
 	return group;
@@ -521,7 +528,7 @@ static void __esw_qos_free_rate_group(st
 }
 
 static struct mlx5_esw_rate_group *
-__esw_qos_create_rate_group(struct mlx5_eswitch *esw, struct netlink_ext_ack *extack)
+__esw_qos_create_vports_rate_group(struct mlx5_eswitch *esw, struct netlink_ext_ack *extack)
 {
 	struct mlx5_esw_rate_group *group;
 	u32 tsar_ix;
@@ -533,7 +540,7 @@ __esw_qos_create_rate_group(struct mlx5_
 		return ERR_PTR(err);
 	}
 
-	group = __esw_qos_alloc_rate_group(esw, tsar_ix);
+	group = __esw_qos_alloc_rate_group(esw, tsar_ix, SCHED_NODE_TYPE_VPORTS_TSAR);
 	if (!group) {
 		NL_SET_ERR_MSG_MOD(extack, "E-Switch alloc group failed");
 		err = -ENOMEM;
@@ -563,7 +570,7 @@ static int esw_qos_get(struct mlx5_eswit
 static void esw_qos_put(struct mlx5_eswitch *esw);
 
 static struct mlx5_esw_rate_group *
-esw_qos_create_rate_group(struct mlx5_eswitch *esw, struct netlink_ext_ack *extack)
+esw_qos_create_vports_rate_group(struct mlx5_eswitch *esw, struct netlink_ext_ack *extack)
 {
 	struct mlx5_esw_rate_group *group;
 	int err;
@@ -576,7 +583,7 @@ esw_qos_create_rate_group(struct mlx5_es
 	if (err)
 		return ERR_PTR(err);
 
-	group = __esw_qos_create_rate_group(esw, extack);
+	group = __esw_qos_create_vports_rate_group(esw, extack);
 	if (IS_ERR(group))
 		esw_qos_put(esw);
 
@@ -621,12 +628,13 @@ static int esw_qos_create(struct mlx5_es
 	}
 
 	if (MLX5_CAP_QOS(dev, log_esw_max_sched_depth)) {
-		esw->qos.group0 = __esw_qos_create_rate_group(esw, extack);
+		esw->qos.group0 = __esw_qos_create_vports_rate_group(esw, extack);
 	} else {
 		/* The eswitch doesn't support scheduling groups.
 		 * Create a software-only group0 using the root TSAR to attach vport QoS to.
 		 */
-		if (!__esw_qos_alloc_rate_group(esw, esw->qos.root_tsar_ix))
+		if (!__esw_qos_alloc_rate_group(esw, esw->qos.root_tsar_ix,
+						SCHED_NODE_TYPE_VPORTS_TSAR))
 			esw->qos.group0 = ERR_PTR(-ENOMEM);
 	}
 	if (IS_ERR(esw->qos.group0)) {
@@ -1038,7 +1046,7 @@ int mlx5_esw_devlink_rate_node_new(struc
 		goto unlock;
 	}
 
-	group = esw_qos_create_rate_group(esw, extack);
+	group = esw_qos_create_vports_rate_group(esw, extack);
 	if (IS_ERR(group)) {
 		err = PTR_ERR(group);
 		goto unlock;
