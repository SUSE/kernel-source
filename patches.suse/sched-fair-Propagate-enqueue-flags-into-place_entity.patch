From 99b32e8f6bbd7fcd107d67ec5699cb83a301299c Mon Sep 17 00:00:00 2001
From: Peter Zijlstra <peterz@infradead.org>
Date: Wed, 31 May 2023 13:58:49 +0200
Subject: [PATCH] sched/fair: Propagate enqueue flags into place_entity()

References: bsc#1233998 (Scheduler functional and performance backports)
Patch-mainline: v6.6-rc1
Git-commit: d07f09a1f99cabbc86bc5c97d962eb8a466106b5

This allows place_entity() to consider ENQUEUE_WAKEUP and
ENQUEUE_MIGRATED.

Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20230531124604.274010996@infradead.org
Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 kernel/sched/fair.c  | 17 +++++++++--------
 kernel/sched/sched.h |  1 +
 2 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 1a2560d18ca5..e154e06b03a4 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -4953,9 +4953,10 @@ static inline bool entity_is_long_sleeper(struct sched_entity *se)
 }
 
 static void
-place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)
+place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
 {
 	u64 vruntime = cfs_rq->min_vruntime;
+	int initial = (flags & ENQUEUE_INITIAL);
 
 	/*
 	 * The 'current' period is already promised to the current tasks,
@@ -4963,11 +4964,11 @@ place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)
 	 * little, place the new task so that it fits in the slot that
 	 * stays open at the end.
 	 */
-	if (initial && sched_feat(START_DEBIT))
-		vruntime += sched_vslice(cfs_rq, se);
-
-	/* sleeps up to a single latency don't count. */
-	if (!initial) {
+	if (initial) {
+		if (sched_feat(START_DEBIT))
+			vruntime += sched_vslice(cfs_rq, se);
+	} else {
+		/* sleeps up to a single latency don't count. */
 		unsigned long thresh;
 
 		if (se_is_idle(se))
@@ -5084,7 +5085,7 @@ enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
 	account_entity_enqueue(cfs_rq, se);
 
 	if (flags & ENQUEUE_WAKEUP)
-		place_entity(cfs_rq, se, 0);
+		place_entity(cfs_rq, se, flags);
 	/* Entity has migrated, no longer consider this task hot */
 	if (flags & ENQUEUE_MIGRATED)
 		se->exec_start = 0;
@@ -12680,7 +12681,7 @@ static void task_fork_fair(struct task_struct *p)
 		update_curr(cfs_rq);
 		se->vruntime = curr->vruntime;
 	}
-	place_entity(cfs_rq, se, 1);
+	place_entity(cfs_rq, se, ENQUEUE_INITIAL);
 
 	if (sysctl_sched_child_runs_first && curr && entity_before(curr, se)) {
 		/*
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index e6420f230145..bf91c8fe0f36 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -2205,6 +2205,7 @@ extern const u32		sched_prio_to_wmult[40];
 #else
 #define ENQUEUE_MIGRATED	0x00
 #endif
+#define ENQUEUE_INITIAL		0x80
 
 #define RETRY_TASK		((void *)-1UL)
 
