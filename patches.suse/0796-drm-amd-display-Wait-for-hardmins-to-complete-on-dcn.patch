From b4724ee106a54729ab0feff82287847996a05a8b Mon Sep 17 00:00:00 2001
From: Dillon Varone <dillon.varone@amd.com>
Date: Mon, 13 May 2024 14:24:14 -0400
Subject: drm/amd/display: Wait for hardmins to complete on dcn401
Git-commit: 57c4982169dfca65ed35081228857312dfa04c4c
Patch-mainline: v6.11-rc1
References: jsc#PED-9898 jsc#PED-10191 jsc#PED-10197 jsc#PED-10226 jsc#PED-10237 jsc#PED-10340 jsc#PED-10852 jsc#PED-11022

[WHY&HOW]
When updating clocks via SMU, DAL needs to wait for requests to be fulfilled
before proceeding.

Reviewed-by: Alvin Lee <alvin.lee2@amd.com>
Acked-by: Zaeem Mohamed <zaeem.mohamed@amd.com>
Signed-off-by: Dillon Varone <dillon.varone@amd.com>
Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../amd/display/dc/clk_mgr/dcn401/dalsmc.h    |   3 +-
 .../clk_mgr/dcn401/dcn401_clk_mgr_smu_msg.c   | 113 +++++++++++++++++-
 2 files changed, 112 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dalsmc.h b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dalsmc.h
index 5653c7991c62..dbfdd3487da5 100644
--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dalsmc.h
+++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dalsmc.h
@@ -42,7 +42,8 @@
 #define DALSMC_MSG_IndicateDrrStatus              0x17  // PMFW 15811
 #define DALSMC_MSG_ActiveUclkFclk                 0x18
 #define DALSMC_MSG_IdleUclkFclk                   0x19
-#define DALSMC_Message_Count                      0x1A
+#define DALSMC_MSG_SetUclkPstateAllow             0x1A
+#define DALSMC_Message_Count                      0x1B
 
 typedef enum {
   FCLK_SWITCH_DISALLOW,
diff --git a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr_smu_msg.c b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr_smu_msg.c
index a3d0a48ed7ce..84e9203aba3b 100644
--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr_smu_msg.c
+++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr_smu_msg.c
@@ -69,6 +69,68 @@ static bool dcn401_smu_send_msg_with_param(struct clk_mgr_internal *clk_mgr, uin
 	return false;
 }
 
+/*
+ * Use these functions to return back delay information so we can aggregate the total
+ *  delay when requesting hardmin clk
+ *
+ * dcn401_smu_wait_for_response_delay
+ * dcn401_smu_send_msg_with_param_delay
+ *
+ */
+static uint32_t dcn401_smu_wait_for_response_delay(struct clk_mgr_internal *clk_mgr, unsigned int delay_us, unsigned int max_retries, unsigned int *total_delay_us)
+{
+	uint32_t reg = 0;
+	*total_delay_us = 0;
+
+	do {
+		reg = REG_READ(DAL_RESP_REG);
+		if (reg)
+			break;
+
+		if (delay_us >= 1000)
+			msleep(delay_us/1000);
+		else if (delay_us > 0)
+			udelay(delay_us);
+		*total_delay_us += delay_us;
+	} while (max_retries--);
+
+	TRACE_SMU_DELAY(*total_delay_us, clk_mgr->base.ctx);
+
+	return reg;
+}
+
+static bool dcn401_smu_send_msg_with_param_delay(struct clk_mgr_internal *clk_mgr, uint32_t msg_id, uint32_t param_in, uint32_t *param_out, unsigned int *total_delay_us)
+{
+	unsigned int delay1_us, delay2_us;
+	*total_delay_us = 0;
+
+	/* Wait for response register to be ready */
+	dcn401_smu_wait_for_response_delay(clk_mgr, 10, 200000, &delay1_us);
+
+	/* Clear response register */
+	REG_WRITE(DAL_RESP_REG, 0);
+
+	/* Set the parameter register for the SMU message */
+	REG_WRITE(DAL_ARG_REG, param_in);
+
+	/* Trigger the message transaction by writing the message ID */
+	REG_WRITE(DAL_MSG_REG, msg_id);
+
+	TRACE_SMU_MSG(msg_id, param_in, clk_mgr->base.ctx);
+
+	/* Wait for response */
+	if (dcn401_smu_wait_for_response_delay(clk_mgr, 10, 200000, &delay2_us) == DALSMC_Result_OK) {
+		if (param_out)
+			*param_out = REG_READ(DAL_ARG_REG);
+
+		*total_delay_us = delay1_us + delay2_us;
+		return true;
+	}
+
+	*total_delay_us = delay1_us + 2000000;
+	return false;
+}
+
 void dcn401_smu_send_fclk_pstate_message(struct clk_mgr_internal *clk_mgr, bool enable)
 {
 	smu_print("FCLK P-state support value is : %d\n", enable);
@@ -101,6 +163,51 @@ void dcn401_smu_set_pme_workaround(struct clk_mgr_internal *clk_mgr)
 		DALSMC_MSG_BacoAudioD3PME, 0, NULL);
 }
 
+static unsigned int dcn401_smu_get_hard_min_status(struct clk_mgr_internal *clk_mgr, bool *no_timeout, unsigned int *total_delay_us)
+{
+	uint32_t response = 0;
+
+	/* bits 23:16 for clock type, lower 16 bits for frequency in MHz */
+	uint32_t param = 0;
+
+	*no_timeout = dcn401_smu_send_msg_with_param_delay(clk_mgr,
+			DALSMC_MSG_ReturnHardMinStatus, param, &response, total_delay_us);
+
+	smu_print("SMU Get hard min status: no_timeout %d delay %d us clk bits %x\n",
+		*no_timeout, *total_delay_us, response);
+
+	return response;
+}
+
+static bool dcn401_smu_wait_hard_min_status(struct clk_mgr_internal *clk_mgr, uint32_t ppclk)
+{
+	const unsigned int max_delay_us = 1000000;
+
+	unsigned int hardmin_status_mask = (1 << ppclk);
+	unsigned int total_delay_us = 0;
+	bool hardmin_done = false;
+
+	while (!hardmin_done && total_delay_us < max_delay_us) {
+		unsigned int hardmin_status;
+		unsigned int read_total_delay_us;
+		bool no_timeout;
+
+		if (!hardmin_done && total_delay_us > 0) {
+			/* hardmin not yet fulfilled, wait 500us and retry*/
+			udelay(500);
+			total_delay_us += 500;
+
+			smu_print("SMU Wait hard min status for %d us\n", total_delay_us);
+		}
+
+		hardmin_status = dcn401_smu_get_hard_min_status(clk_mgr, &no_timeout, &read_total_delay_us);
+		total_delay_us += read_total_delay_us;
+		hardmin_done = hardmin_status & hardmin_status_mask;
+	}
+
+	return hardmin_done;
+}
+
 /* Returns the actual frequency that was set in MHz, 0 on failure */
 unsigned int dcn401_smu_set_hard_min_by_freq(struct clk_mgr_internal *clk_mgr, uint32_t clk, uint16_t freq_mhz)
 {
@@ -116,7 +223,7 @@ unsigned int dcn401_smu_set_hard_min_by_freq(struct clk_mgr_internal *clk_mgr, u
 			DALSMC_MSG_SetHardMinByFreq, param, &response);
 
 	/* wait until hardmin acknowledged */
-	//hard_min_done = dcn401_smu_wait_get_hard_min_status(clk_mgr, clk);
+	hard_min_done = dcn401_smu_wait_hard_min_status(clk_mgr, clk);
 	smu_print("SMU Frequency set = %d KHz hard_min_done %d\n", response, hard_min_done);
 
 	return response;
@@ -153,7 +260,7 @@ bool dcn401_smu_set_idle_uclk_fclk_hardmin(struct clk_mgr_internal *clk_mgr,
 			DALSMC_MSG_IdleUclkFclk, param, &response);
 
 	/* wait until hardmin acknowledged */
-	//success &= dcn401_smu_wait_get_hard_min_status(clk_mgr, PPCLK_UCLK);
+	success &= dcn401_smu_wait_hard_min_status(clk_mgr, PPCLK_UCLK);
 	smu_print("SMU hard_min_done %d\n", success);
 
 	return success;
@@ -175,7 +282,7 @@ bool dcn401_smu_set_active_uclk_fclk_hardmin(struct clk_mgr_internal *clk_mgr,
 			DALSMC_MSG_ActiveUclkFclk, param, &response);
 
 	/* wait until hardmin acknowledged */
-	//success &= dcn401_smu_wait_get_hard_min_status(clk_mgr, PPCLK_UCLK);
+	success &= dcn401_smu_wait_hard_min_status(clk_mgr, PPCLK_UCLK);
 	smu_print("SMU hard_min_done %d\n", success);
 
 	return success;
-- 
2.46.1

