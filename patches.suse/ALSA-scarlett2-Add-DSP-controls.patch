From b64678eb4e703aa7631d75d622bd295a717e74a8 Mon Sep 17 00:00:00 2001
From: "Geoffrey D. Bennett" <g@b4.vu>
Date: Wed, 13 Mar 2024 05:07:12 +1030
Subject: [PATCH] ALSA: scarlett2: Add DSP controls
Git-commit: b64678eb4e703aa7631d75d622bd295a717e74a8
Patch-mainline: v6.10-rc1
References: jsc#PED-9993 jsc#PED-10202

Add filter and compressor DSP controls for the Vocaster interfaces.
Mark scarlett2_notify_input_dsp() as __always_unused until it gets
used when the Vocaster callback function array is added.

Signed-off-by: Geoffrey D. Bennett <g@b4.vu>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
Message-id: <a45316f79600b862dae38da24f13def638b06476.1710264833.git.g@b4.vu>

---
 sound/usb/mixer_scarlett2.c | 855 ++++++++++++++++++++++++++++++++++++
 1 file changed, 855 insertions(+)

diff --git a/sound/usb/mixer_scarlett2.c b/sound/usb/mixer_scarlett2.c
index 17fadfddc240..77bfaadb99b8 100644
--- a/sound/usb/mixer_scarlett2.c
+++ b/sound/usb/mixer_scarlett2.c
@@ -87,6 +87,7 @@
  *  - disable/enable standalone mode
  *  - input mute, gain, autogain, safe mode
  *  - direct monitor mixes
+ *  - compressor and EQ
  *
  * <ditaa>
  *    /--------------\    18chn            20chn     /--------------\
@@ -214,6 +215,7 @@ static const u16 scarlett2_mixer_values[SCARLETT2_MIXER_VALUE_COUNT] = {
 #define SCARLETT2_LEVEL_SWITCH_MAX 2
 #define SCARLETT2_PAD_SWITCH_MAX 8
 #define SCARLETT2_AIR_SWITCH_MAX 8
+#define SCARLETT2_DSP_SWITCH_MAX 2
 #define SCARLETT2_INPUT_MUTE_SWITCH_MAX 2
 #define SCARLETT2_PHANTOM_SWITCH_MAX 2
 #define SCARLETT2_INPUT_GAIN_MAX 2
@@ -245,6 +247,59 @@ static const u16 scarlett2_mixer_values[SCARLETT2_MIXER_VALUE_COUNT] = {
 /* Maximum number of meters (sum of output port counts) */
 #define SCARLETT2_MAX_METERS 65
 
+/* Compressor parameter data
+ *
+ * The compressor parameters are 32-bit fixed point values with 24
+ * bits of fraction. Integer values are sufficient for the parameters
+ * except for ratio which we can set in 0.5:1 steps.
+ */
+struct compressor_param {
+	const char          *name;
+	snd_ctl_elem_type_t  type;
+	s32                  min;
+	s32                  max;
+	int                  scale_bits;
+};
+
+/* The available compressor parameters on the Vocaster:
+ * - Enable: Off, On
+ * - Threshold: -40dB to 0dB
+ * - Ratio: 1:1 to 50:1 in 0.5:1 steps
+ * - Knee Width: 0dB to 10dB
+ * - Attack: 30ms to 127ms
+ * - Release: 30ms to 127ms
+ * - Makeup Gain: 0dB to 24dB
+ */
+static const struct compressor_param compressor_params[] = {
+	{ "Enable",      SNDRV_CTL_ELEM_TYPE_BOOLEAN,   0,   1,  0 },
+	{ "Threshold",   SNDRV_CTL_ELEM_TYPE_INTEGER, -40,   0, 24 },
+	{ "Ratio",       SNDRV_CTL_ELEM_TYPE_INTEGER,   2, 100, 23 },
+	{ "Knee Width",  SNDRV_CTL_ELEM_TYPE_INTEGER,   0,  10, 24 },
+	{ "Attack",      SNDRV_CTL_ELEM_TYPE_INTEGER,  30, 127, 24 },
+	{ "Release",     SNDRV_CTL_ELEM_TYPE_INTEGER,  30, 127, 24 },
+	{ "Makeup Gain", SNDRV_CTL_ELEM_TYPE_INTEGER,   0,  24, 24 },
+};
+
+#define SCARLETT2_COMPRESSOR_PARAM_COUNT ARRAY_SIZE(compressor_params)
+#define SCARLETT2_COMPRESSOR_CTLS_MAX \
+	(SCARLETT2_COMPRESSOR_PARAM_COUNT * SCARLETT2_DSP_SWITCH_MAX)
+
+/* Maximum number of filter controls */
+#define SCARLETT2_PRECOMP_FLT_CTLS_MAX (2 * SCARLETT2_DSP_SWITCH_MAX)
+#define SCARLETT2_PEQ_FLT_CTLS_MAX (3 * SCARLETT2_DSP_SWITCH_MAX)
+
+/* Number of biquad filter coefficients */
+#define SCARLETT2_BIQUAD_COEFFS 5
+
+/* Maximum number of filter coefficient values */
+#define SCARLETT2_PRECOMP_FLT_VALUES_MAX \
+	(SCARLETT2_PRECOMP_FLT_CTLS_MAX * SCARLETT2_BIQUAD_COEFFS)
+#define SCARLETT2_PEQ_FLT_VALUES_MAX \
+	(SCARLETT2_PEQ_FLT_CTLS_MAX * SCARLETT2_BIQUAD_COEFFS)
+
+/* Maximum number of PEQ filter slots */
+#define SCARLETT2_PEQ_FLT_SLOTS_MAX 4
+
 /* Hardware port types:
  * - None (no input to mux)
  * - Analogue I/O
@@ -330,6 +385,7 @@ static void scarlett2_notify_volume(struct usb_mixer_interface *mixer);
 static void scarlett2_notify_input_level(struct usb_mixer_interface *mixer);
 static void scarlett2_notify_input_pad(struct usb_mixer_interface *mixer);
 static void scarlett2_notify_input_air(struct usb_mixer_interface *mixer);
+static void scarlett2_notify_input_dsp(struct usb_mixer_interface *mixer);
 static void scarlett2_notify_input_mute(struct usb_mixer_interface *mixer);
 static void scarlett2_notify_input_phantom(struct usb_mixer_interface *mixer);
 static void scarlett2_notify_input_other(struct usb_mixer_interface *mixer);
@@ -417,6 +473,12 @@ enum {
 	SCARLETT2_CONFIG_PAD_SWITCH,
 	SCARLETT2_CONFIG_MSD_SWITCH,
 	SCARLETT2_CONFIG_AIR_SWITCH,
+	SCARLETT2_CONFIG_DSP_SWITCH,
+	SCARLETT2_CONFIG_COMPRESSOR_PARAMS,
+	SCARLETT2_CONFIG_PRECOMP_FLT_SWITCH,
+	SCARLETT2_CONFIG_PRECOMP_FLT_PARAMS,
+	SCARLETT2_CONFIG_PEQ_FLT_SWITCH,
+	SCARLETT2_CONFIG_PEQ_FLT_PARAMS,
 	SCARLETT2_CONFIG_INPUT_MUTE_SWITCH,
 	SCARLETT2_CONFIG_STANDALONE_SWITCH,
 	SCARLETT2_CONFIG_PHANTOM_SWITCH,
@@ -918,6 +980,18 @@ struct scarlett2_device_info {
 	 */
 	u8 air_option;
 
+	/* the number of analogue inputs with DSP control */
+	u8 dsp_input_count;
+
+	/* number of pre-compressor filters */
+	u8 precomp_flt_count;
+
+	/* number of parametric EQ filters */
+	u8 peq_flt_count;
+
+	/* number of PEQ filters plus unused slots */
+	u8 peq_flt_total_count;
+
 	/* the number of analogue inputs with a software switchable
 	 * mute control
 	 */
@@ -1004,6 +1078,7 @@ struct scarlett2_data {
 	u8 input_level_updated;
 	u8 input_pad_updated;
 	u8 input_air_updated;
+	u8 input_dsp_updated;
 	u8 input_mute_updated;
 	u8 input_phantom_updated;
 	u8 input_select_updated;
@@ -1027,6 +1102,12 @@ struct scarlett2_data {
 	u8 pad_switch[SCARLETT2_PAD_SWITCH_MAX];
 	u8 dim_mute[SCARLETT2_DIM_MUTE_COUNT];
 	u8 air_switch[SCARLETT2_AIR_SWITCH_MAX];
+	u8 dsp_switch[SCARLETT2_DSP_SWITCH_MAX];
+	s32 compressor_values[SCARLETT2_COMPRESSOR_CTLS_MAX];
+	s32 precomp_flt_values[SCARLETT2_PRECOMP_FLT_VALUES_MAX];
+	s32 peq_flt_values[SCARLETT2_PEQ_FLT_VALUES_MAX];
+	u8 precomp_flt_switch[SCARLETT2_DSP_SWITCH_MAX];
+	u8 peq_flt_switch[SCARLETT2_DSP_SWITCH_MAX];
 	u8 input_mute_switch[SCARLETT2_INPUT_MUTE_SWITCH_MAX];
 	u8 phantom_switch[SCARLETT2_PHANTOM_SWITCH_MAX];
 	u8 phantom_persistence;
@@ -1055,6 +1136,7 @@ struct scarlett2_data {
 	struct snd_kcontrol *level_ctls[SCARLETT2_LEVEL_SWITCH_MAX];
 	struct snd_kcontrol *pad_ctls[SCARLETT2_PAD_SWITCH_MAX];
 	struct snd_kcontrol *air_ctls[SCARLETT2_AIR_SWITCH_MAX];
+	struct snd_kcontrol *dsp_ctls[SCARLETT2_DSP_SWITCH_MAX];
 	struct snd_kcontrol *input_mute_ctls[SCARLETT2_INPUT_MUTE_SWITCH_MAX];
 	struct snd_kcontrol *phantom_ctls[SCARLETT2_PHANTOM_SWITCH_MAX];
 	struct snd_kcontrol *input_select_ctl;
@@ -1066,6 +1148,11 @@ struct scarlett2_data {
 	struct snd_kcontrol *pcm_input_switch_ctl;
 	struct snd_kcontrol *mux_ctls[SCARLETT2_MUX_MAX];
 	struct snd_kcontrol *mix_ctls[SCARLETT2_MIX_MAX];
+	struct snd_kcontrol *compressor_ctls[SCARLETT2_COMPRESSOR_CTLS_MAX];
+	struct snd_kcontrol *precomp_flt_ctls[SCARLETT2_PRECOMP_FLT_CTLS_MAX];
+	struct snd_kcontrol *peq_flt_ctls[SCARLETT2_PEQ_FLT_CTLS_MAX];
+	struct snd_kcontrol *precomp_flt_switch_ctls[SCARLETT2_DSP_SWITCH_MAX];
+	struct snd_kcontrol *peq_flt_switch_ctls[SCARLETT2_DSP_SWITCH_MAX];
 	struct snd_kcontrol *direct_monitor_ctl;
 	struct snd_kcontrol *speaker_switching_ctl;
 	struct snd_kcontrol *talkback_ctl;
@@ -2174,6 +2261,54 @@ static int scarlett2_usb_set_data(
 			     &req, sizeof(u32) * 2 + size, NULL, 0);
 }
 
+/* Send a SCARLETT2_USB_SET_DATA command with multiple values.
+ * offset: location in the device's data space
+ * size: size in bytes of each value (1, 2, 4)
+ * count: number of values
+ */
+static int scarlett2_usb_set_data_buf(
+	struct usb_mixer_interface *mixer,
+	int offset, int size, int count, void *buf)
+{
+	struct scarlett2_data *private = mixer->private_data;
+	int bytes = size * count;
+	struct {
+		__le32 offset;
+		__le32 size;
+		u8 data[];
+	} __packed *req;
+	int err;
+	int buf_size = struct_size(req, data, bytes);
+
+	req = kmalloc(buf_size, GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	req->offset = cpu_to_le32(offset);
+	req->size = cpu_to_le32(bytes);
+	if (size == 1) {
+		memcpy(req->data, buf, count);
+	} else if (size == 2) {
+		u16 *buf_16 = buf;
+		int i;
+
+		for (i = 0; i < count; i++)
+			((__le16 *)req->data)[i] = cpu_to_le16(buf_16[i]);
+	} else {
+		u32 *buf_32 = buf;
+		int i;
+
+		for (i = 0; i < count; i++)
+			((__le32 *)req->data)[i] = cpu_to_le32(buf_32[i]);
+	}
+
+	err = scarlett2_usb(private->mixer, SCARLETT2_USB_SET_DATA,
+			    req, buf_size, NULL, 0);
+
+	kfree(req);
+	return err;
+}
+
 /* Send a SCARLETT2_USB_DATA_CMD command.
  * Configuration changes require activation with this after they have
  * been uploaded by a previous SCARLETT2_USB_SET_DATA.
@@ -2288,6 +2423,47 @@ static int scarlett2_usb_set_config(
 	return 0;
 }
 
+/* Send USB messages to set a SCARLETT2_CONFIG_* parameter with
+ * multiple values
+ */
+static int scarlett2_usb_set_config_buf(
+	struct usb_mixer_interface *mixer,
+	int config_item_num, int index, int count, void *buf)
+{
+	struct scarlett2_data *private = mixer->private_data;
+	const struct scarlett2_config_set *config_set = private->config_set;
+	const struct scarlett2_config *config_item =
+		&config_set->items[config_item_num];
+	int offset, size;
+	int err;
+
+	/* Check that the configuration item is present in the
+	 * configuration set used by this device
+	 */
+	if (!config_item->offset)
+		return -EFAULT;
+
+	/* Convert config_item->size in bits to size in bytes and
+	 * calculate offset
+	 */
+	if (config_item->size >= 8) {
+		size = config_item->size / 8;
+		offset = config_item->offset + index * size;
+
+	/* Bit updates not supported */
+	} else {
+		return -EFAULT;
+	}
+
+	/* Write the new values */
+	err = scarlett2_usb_set_data_buf(mixer, offset, size, count, buf);
+	if (err < 0)
+		return err;
+
+	/* Activate the change */
+	return scarlett2_usb_activate_config(mixer, config_item->activate);
+}
+
 /* Send SCARLETT2_USB_DATA_CMD SCARLETT2_USB_CONFIG_SAVE */
 static void scarlett2_config_save(struct usb_mixer_interface *mixer)
 {
@@ -2985,6 +3161,8 @@ static void scarlett2_autogain_update_access(struct usb_mixer_interface *mixer)
 		scarlett2_set_ctl_access(private->input_mute_ctls[i], val);
 	for (i = 0; i < info->phantom_count; i++)
 		scarlett2_set_ctl_access(private->phantom_ctls[i], val);
+	for (i = 0; i < info->dsp_input_count; i++)
+		scarlett2_set_ctl_access(private->dsp_ctls[i], val);
 }
 
 /* Notify of access mode change for all controls read-only while
@@ -3018,6 +3196,9 @@ static void scarlett2_autogain_notify_access(struct usb_mixer_interface *mixer)
 	for (i = 0; i < info->air_input_count; i++)
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO,
 			       &private->air_ctls[i]->id);
+	for (i = 0; i < info->dsp_input_count; i++)
+		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO,
+			       &private->dsp_ctls[i]->id);
 	for (i = 0; i < info->mute_input_count; i++)
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO,
 			       &private->input_mute_ctls[i]->id);
@@ -4635,6 +4816,576 @@ static const struct snd_kcontrol_new scarlett2_air_ctl[2] = {
 	}
 };
 
+/*** DSP Switch Control ***/
+
+static int scarlett2_update_input_dsp(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+
+	private->input_dsp_updated = 0;
+
+	if (!info->dsp_input_count)
+		return 0;
+
+	return scarlett2_usb_get_config(
+		mixer, SCARLETT2_CONFIG_DSP_SWITCH,
+		info->dsp_input_count, private->dsp_switch);
+}
+
+static int scarlett2_dsp_ctl_get(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_data *private = mixer->private_data;
+	int err = 0;
+
+	mutex_lock(&private->data_mutex);
+
+	if (private->hwdep_in_use) {
+		err = -EBUSY;
+		goto unlock;
+	}
+
+	if (private->input_dsp_updated) {
+		err = scarlett2_update_input_dsp(mixer);
+		if (err < 0)
+			goto unlock;
+	}
+	ucontrol->value.integer.value[0] = private->dsp_switch[elem->control];
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static int scarlett2_dsp_ctl_put(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_data *private = mixer->private_data;
+
+	int index = elem->control;
+	int oval, val, err;
+
+	mutex_lock(&private->data_mutex);
+
+	if (private->hwdep_in_use) {
+		err = -EBUSY;
+		goto unlock;
+	}
+
+	err = scarlett2_check_put_during_autogain(mixer);
+	if (err < 0)
+		goto unlock;
+
+	oval = private->dsp_switch[index];
+	val = ucontrol->value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private->dsp_switch[index] = val;
+
+	/* Send switch change to the device */
+	err = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_DSP_SWITCH,
+				       index, val);
+	if (err == 0)
+		err = 1;
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_dsp_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "",
+	.info = scarlett2_autogain_disables_ctl_info,
+	.get  = scarlett2_dsp_ctl_get,
+	.put  = scarlett2_dsp_ctl_put,
+};
+
+/*** DSP Compressor Parameter Controls ***/
+
+static int scarlett2_update_compressor_values(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+	int err, i, j;
+
+	if (!info->dsp_input_count)
+		return 0;
+
+	err = scarlett2_usb_get_config(
+		mixer, SCARLETT2_CONFIG_COMPRESSOR_PARAMS,
+		SCARLETT2_COMPRESSOR_PARAM_COUNT * info->dsp_input_count,
+		private->compressor_values);
+
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < SCARLETT2_COMPRESSOR_PARAM_COUNT; i++) {
+		const struct compressor_param *param = &compressor_params[i];
+
+		for (j = 0; j < info->dsp_input_count; j++) {
+			int idx = i + j * SCARLETT2_COMPRESSOR_PARAM_COUNT;
+			int val = private->compressor_values[idx];
+
+			val >>= param->scale_bits;
+			val = clamp(val, param->min, param->max);
+			private->compressor_values[idx] = val;
+		}
+	}
+
+	return 0;
+}
+
+static int scarlett2_compressor_ctl_get(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett2_data *private = elem->head.mixer->private_data;
+
+	ucontrol->value.integer.value[0] =
+		private->compressor_values[elem->control];
+	return 0;
+}
+
+static int scarlett2_compressor_ctl_put(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_data *private = mixer->private_data;
+
+	int index = elem->control;
+	int channel = index / SCARLETT2_COMPRESSOR_PARAM_COUNT;
+	int param_index = index % SCARLETT2_COMPRESSOR_PARAM_COUNT;
+	int oval, val, err;
+	s32 scaled_val;
+
+	mutex_lock(&private->data_mutex);
+
+	if (private->hwdep_in_use) {
+		err = -EBUSY;
+		goto unlock;
+	}
+
+	err = scarlett2_check_put_during_autogain(mixer);
+	if (err < 0)
+		goto unlock;
+
+	oval = private->compressor_values[index];
+	val = ucontrol->value.integer.value[0];
+	if (oval == val)
+		goto unlock;
+
+	private->compressor_values[index] = val;
+
+	const struct compressor_param *param = &compressor_params[param_index];
+
+	scaled_val = val << param->scale_bits;
+
+	/* Send change to the device */
+
+	/* The channel needs to be put in the parameter buffer index
+	 * field (param_buf_addr + 1); the value field isn't used in
+	 * this case.
+	 */
+	err = scarlett2_usb_set_data(
+		mixer, private->config_set->param_buf_addr + 1, 1, channel);
+	if (err < 0)
+		goto unlock;
+
+	err = scarlett2_usb_set_config(
+		mixer, SCARLETT2_CONFIG_COMPRESSOR_PARAMS, index, scaled_val);
+	if (err < 0)
+		goto unlock;
+
+	if (err == 0)
+		err = 1;
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static int scarlett2_compressor_ctl_info(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	int control = elem->control % SCARLETT2_COMPRESSOR_PARAM_COUNT;
+
+	uinfo->type = compressor_params[control].type;
+	uinfo->count = 1;
+	uinfo->value.integer.min = compressor_params[control].min;
+	uinfo->value.integer.max = compressor_params[control].max;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static const struct snd_kcontrol_new scarlett2_compressor_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+	.name = "",
+	.info = scarlett2_compressor_ctl_info,
+	.get  = scarlett2_compressor_ctl_get,
+	.put  = scarlett2_compressor_ctl_put,
+};
+
+/*** DSP Pre-Compressor and PEQ Filter Controls ***/
+
+static int scarlett2_precomp_flt_switch_ctl_get(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett2_data *private = elem->head.mixer->private_data;
+
+	ucontrol->value.integer.value[0] = private->precomp_flt_switch[elem->control];
+
+	return 0;
+}
+
+static int scarlett2_peq_flt_switch_ctl_get(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett2_data *private = elem->head.mixer->private_data;
+
+	ucontrol->value.integer.value[0] =
+		private->peq_flt_switch[elem->control];
+
+	return 0;
+}
+
+static int scarlett2_precomp_flt_switch_ctl_put(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_data *private = mixer->private_data;
+	int oval, val, err = 0;
+
+	mutex_lock(&private->data_mutex);
+
+	if (private->hwdep_in_use) {
+		err = -EBUSY;
+		goto unlock;
+	}
+
+	oval = private->precomp_flt_switch[elem->control];
+	val = ucontrol->value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private->precomp_flt_switch[elem->control] = val;
+
+	/* Send change to the device */
+	err = scarlett2_usb_set_config(
+		mixer, SCARLETT2_CONFIG_PRECOMP_FLT_SWITCH,
+		elem->control, val);
+	if (err == 0)
+		err = 1;
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static int scarlett2_peq_flt_switch_ctl_put(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_data *private = mixer->private_data;
+	int oval, val, err = 0;
+
+	mutex_lock(&private->data_mutex);
+
+	if (private->hwdep_in_use) {
+		err = -EBUSY;
+		goto unlock;
+	}
+
+	oval = private->peq_flt_switch[elem->control];
+	val = ucontrol->value.integer.value[0];
+
+	if (oval == val)
+		goto unlock;
+
+	private->peq_flt_switch[elem->control] = val;
+
+	/* Send change to the device */
+	err = scarlett2_usb_set_config(
+		mixer, SCARLETT2_CONFIG_PEQ_FLT_SWITCH,
+		elem->control, val);
+	if (err == 0)
+		err = 1;
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static const struct snd_kcontrol_new scarlett2_precomp_flt_switch_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+	.name = "",
+	.info = snd_ctl_boolean_mono_info,
+	.get  = scarlett2_precomp_flt_switch_ctl_get,
+	.put  = scarlett2_precomp_flt_switch_ctl_put,
+};
+
+static const struct snd_kcontrol_new scarlett2_peq_flt_switch_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+	.name = "",
+	.info = snd_ctl_boolean_mono_info,
+	.get  = scarlett2_peq_flt_switch_ctl_get,
+	.put  = scarlett2_peq_flt_switch_ctl_put,
+};
+
+static int scarlett2_update_filter_values(struct usb_mixer_interface *mixer)
+{
+	struct scarlett2_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+	int err, i, j, k, src_idx, dst_idx;
+	s32 peq_flt_values[SCARLETT2_DSP_SWITCH_MAX *
+			   SCARLETT2_PEQ_FLT_SLOTS_MAX *
+			   SCARLETT2_BIQUAD_COEFFS];
+
+	if (!info->dsp_input_count)
+		return 0;
+
+	/* Get filter switch values */
+	err = scarlett2_usb_get_config(
+		mixer, SCARLETT2_CONFIG_PRECOMP_FLT_SWITCH,
+		info->dsp_input_count, private->precomp_flt_switch);
+	if (err < 0)
+		return err;
+
+	err = scarlett2_usb_get_config(
+		mixer, SCARLETT2_CONFIG_PEQ_FLT_SWITCH,
+		info->dsp_input_count * info->peq_flt_count,
+		private->peq_flt_switch);
+	if (err < 0)
+		return err;
+
+	/* Get pre-compressor filter values directly */
+	err = scarlett2_usb_get_config(
+		mixer, SCARLETT2_CONFIG_PRECOMP_FLT_PARAMS,
+		info->dsp_input_count *
+			info->precomp_flt_count *
+			SCARLETT2_BIQUAD_COEFFS,
+		private->precomp_flt_values);
+
+	if (err < 0)
+		return err;
+
+	/* PEQ filter values need to be copied via buffer because of
+	 * padding after peq_flt_count up to peq_flt_total_count
+	 */
+	err = scarlett2_usb_get_config(
+		mixer, SCARLETT2_CONFIG_PEQ_FLT_PARAMS,
+		info->dsp_input_count *
+			info->peq_flt_total_count *
+			SCARLETT2_BIQUAD_COEFFS,
+		peq_flt_values);
+
+	for (i = 0, dst_idx = 0; i < info->dsp_input_count; i++) {
+		src_idx = i *
+			  info->peq_flt_total_count *
+			  SCARLETT2_BIQUAD_COEFFS;
+		for (j = 0; j < info->peq_flt_count; j++)
+			for (k = 0;
+			     k < SCARLETT2_BIQUAD_COEFFS;
+			     k++, src_idx++, dst_idx++)
+				private->peq_flt_values[dst_idx] =
+					peq_flt_values[src_idx];
+	}
+
+	return 0;
+}
+
+static int scarlett2_precomp_flt_ctl_get(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett2_data *private = elem->head.mixer->private_data;
+	int i, idx;
+
+	for (i = 0, idx = elem->control * SCARLETT2_BIQUAD_COEFFS;
+	     i < SCARLETT2_BIQUAD_COEFFS;
+	     i++, idx++)
+		ucontrol->value.integer.value[i] =
+			private->precomp_flt_values[idx];
+
+	return 0;
+}
+
+static int scarlett2_peq_flt_ctl_get(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett2_data *private = elem->head.mixer->private_data;
+	int i, idx;
+
+	for (i = 0, idx = elem->control * SCARLETT2_BIQUAD_COEFFS;
+	     i < SCARLETT2_BIQUAD_COEFFS;
+	     i++, idx++)
+		ucontrol->value.integer.value[i] =
+			private->peq_flt_values[idx];
+
+	return 0;
+}
+
+static int scarlett2_precomp_flt_ctl_put(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_data *private = mixer->private_data;
+
+	int index = elem->control * SCARLETT2_BIQUAD_COEFFS;
+	int i, oval, val, err;
+
+	mutex_lock(&private->data_mutex);
+
+	if (private->hwdep_in_use) {
+		err = -EBUSY;
+		goto unlock;
+	}
+
+	err = scarlett2_check_put_during_autogain(mixer);
+	if (err < 0)
+		goto unlock;
+
+	/* Check if any of the values have changed; if not, return */
+	for (i = 0; i < SCARLETT2_BIQUAD_COEFFS; i++) {
+		oval = private->precomp_flt_values[index + i];
+		val = ucontrol->value.integer.value[i];
+		if (oval != val)
+			break;
+	}
+
+	if (i == SCARLETT2_BIQUAD_COEFFS)
+		goto unlock;
+
+	/* Update the values */
+	for (i = 0; i < SCARLETT2_BIQUAD_COEFFS; i++)
+		private->precomp_flt_values[index + i] =
+			ucontrol->value.integer.value[i];
+
+	/* Send change to the device */
+	err = scarlett2_usb_set_data(
+		mixer, private->config_set->param_buf_addr, 1, index);
+	if (err < 0)
+		goto unlock;
+
+	err = scarlett2_usb_set_config_buf(
+		mixer, SCARLETT2_CONFIG_PRECOMP_FLT_PARAMS,
+		index, SCARLETT2_BIQUAD_COEFFS,
+		&private->precomp_flt_values[index]);
+
+	if (err == 0)
+		err = 1;
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static int scarlett2_peq_flt_ctl_put(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct usb_mixer_interface *mixer = elem->head.mixer;
+	struct scarlett2_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+
+	int src_index = elem->control * SCARLETT2_BIQUAD_COEFFS;
+	int dst_index = (
+		elem->control /
+		info->peq_flt_count *
+		info->peq_flt_total_count +
+		elem->control % info->peq_flt_count
+	) * SCARLETT2_BIQUAD_COEFFS;
+	int i, oval, val, err;
+
+	mutex_lock(&private->data_mutex);
+
+	if (private->hwdep_in_use) {
+		err = -EBUSY;
+		goto unlock;
+	}
+
+	err = scarlett2_check_put_during_autogain(mixer);
+	if (err < 0)
+		goto unlock;
+
+	/* Check if any of the values have changed; if not, return */
+	for (i = 0; i < SCARLETT2_BIQUAD_COEFFS; i++) {
+		oval = private->peq_flt_values[src_index + i];
+		val = ucontrol->value.integer.value[i];
+		if (oval != val)
+			break;
+	}
+
+	if (i == SCARLETT2_BIQUAD_COEFFS)
+		goto unlock;
+
+	/* Update the values */
+	for (i = 0; i < SCARLETT2_BIQUAD_COEFFS; i++)
+		private->peq_flt_values[src_index + i] =
+			ucontrol->value.integer.value[i];
+
+	/* Send change to the device */
+	err = scarlett2_usb_set_data(
+		mixer, private->config_set->param_buf_addr, 1, dst_index);
+	if (err < 0)
+		goto unlock;
+
+	err = scarlett2_usb_set_config_buf(
+		mixer, SCARLETT2_CONFIG_PEQ_FLT_PARAMS,
+		dst_index, SCARLETT2_BIQUAD_COEFFS,
+		&private->peq_flt_values[src_index]);
+
+	if (err == 0)
+		err = 1;
+
+unlock:
+	mutex_unlock(&private->data_mutex);
+	return err;
+}
+
+static int scarlett2_flt_ctl_info(
+	struct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = SCARLETT2_BIQUAD_COEFFS;
+	uinfo->value.integer.min = INT_MIN;
+	uinfo->value.integer.max = INT_MAX;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static const struct snd_kcontrol_new scarlett2_precomp_flt_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+	.name = "",
+	.info = scarlett2_flt_ctl_info,
+	.get  = scarlett2_precomp_flt_ctl_get,
+	.put  = scarlett2_precomp_flt_ctl_put,
+};
+
+static const struct snd_kcontrol_new scarlett2_peq_flt_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+	.name = "",
+	.info = scarlett2_flt_ctl_info,
+	.get  = scarlett2_peq_flt_ctl_get,
+	.put  = scarlett2_peq_flt_ctl_put,
+};
+
 /*** Input Mute Switch Controls ***/
 
 static int scarlett2_update_input_mute(struct usb_mixer_interface *mixer)
@@ -5568,6 +6319,69 @@ static int scarlett2_add_line_out_ctls(struct usb_mixer_interface *mixer)
 
 /*** Create the analogue input controls ***/
 
+static int scarlett2_add_dsp_ctls(struct usb_mixer_interface *mixer, int i)
+{
+	struct scarlett2_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+	int j, err;
+	char s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+	const char *compr_fmt = "Line In %d Compressor %s";
+	const char *flt_switch_fmt = "Line In %d %s Filter Enable";
+	const char *flt_fmt = "Line In %d %s Coefficients %d";
+
+	/* Add compressor controls */
+	for (j = 0; j < SCARLETT2_COMPRESSOR_PARAM_COUNT; j++) {
+		const struct compressor_param *param = &compressor_params[j];
+		int idx = i * SCARLETT2_COMPRESSOR_PARAM_COUNT + j;
+
+		scnprintf(s, sizeof(s), compr_fmt, i + 1, param->name);
+		err = scarlett2_add_new_ctl(
+			mixer, &scarlett2_compressor_ctl,
+			i * SCARLETT2_COMPRESSOR_PARAM_COUNT + j,
+			1, s, &private->compressor_ctls[idx]);
+		if (err < 0)
+			return err;
+	}
+
+	/* Add filter enable controls */
+	scnprintf(s, sizeof(s), flt_switch_fmt, i + 1, "Pre-Comp");
+	err = scarlett2_add_new_ctl(
+		mixer, &scarlett2_precomp_flt_switch_ctl,
+		i, 1, s, &private->precomp_flt_switch_ctls[i]);
+	if (err < 0)
+		return err;
+
+	scnprintf(s, sizeof(s), flt_switch_fmt, i + 1, "PEQ");
+	err = scarlett2_add_new_ctl(
+		mixer, &scarlett2_peq_flt_switch_ctl,
+		i, 1, s, &private->peq_flt_switch_ctls[i]);
+	if (err < 0)
+		return err;
+
+	/* Add filter coefficient controls */
+	for (j = 0; j < info->precomp_flt_count; j++) {
+		scnprintf(s, sizeof(s), flt_fmt, i + 1, "Pre-Comp", j + 1);
+		err = scarlett2_add_new_ctl(
+			mixer, &scarlett2_precomp_flt_ctl,
+			i * info->precomp_flt_count + j,
+			1, s, &private->precomp_flt_switch_ctls[j]);
+		if (err < 0)
+			return err;
+	}
+
+	for (j = 0; j < info->peq_flt_count; j++) {
+		scnprintf(s, sizeof(s), flt_fmt, i + 1, "PEQ", j + 1);
+		err = scarlett2_add_new_ctl(
+			mixer, &scarlett2_peq_flt_ctl,
+			i * info->peq_flt_count + j,
+			1, s, &private->peq_flt_switch_ctls[j]);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
 static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 {
 	struct scarlett2_data *private = mixer->private_data;
@@ -5607,6 +6421,19 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 			return err;
 	}
 
+	/* Add input DSP controls */
+	for (i = 0; i < info->dsp_input_count; i++) {
+		scnprintf(s, sizeof(s), fmt, i + 1, "DSP", "Switch");
+		err = scarlett2_add_new_ctl(mixer, &scarlett2_dsp_ctl,
+					    i, 1, s, &private->dsp_ctls[i]);
+		if (err < 0)
+			return err;
+
+		err = scarlett2_add_dsp_ctls(mixer, i);
+		if (err < 0)
+			return err;
+	}
+
 	/* Add input mute controls */
 	for (i = 0; i < info->mute_input_count; i++) {
 		scnprintf(s, sizeof(s), fmt, i + 1, "Mute", "Switch");
@@ -6678,6 +7505,22 @@ static void scarlett2_notify_input_air(struct usb_mixer_interface *mixer)
 			       &private->air_ctls[i]->id);
 }
 
+/* Notify on input DSP switch change */
+static __always_unused void scarlett2_notify_input_dsp(
+	struct usb_mixer_interface *mixer)
+{
+	struct snd_card *card = mixer->chip->card;
+	struct scarlett2_data *private = mixer->private_data;
+	const struct scarlett2_device_info *info = private->info;
+	int i;
+
+	private->input_dsp_updated = 1;
+
+	for (i = 0; i < info->dsp_input_count; i++)
+		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
+			       &private->dsp_ctls[i]->id);
+}
+
 /* Notify on input mute switch change */
 static __always_unused void scarlett2_notify_input_mute(
 	struct usb_mixer_interface *mixer)
@@ -7307,6 +8150,18 @@ static int scarlett2_read_configs(struct usb_mixer_interface *mixer)
 	if (err < 0)
 		return err;
 
+	err = scarlett2_update_input_dsp(mixer);
+	if (err < 0)
+		return err;
+
+	err = scarlett2_update_compressor_values(mixer);
+	if (err < 0)
+		return err;
+
+	err = scarlett2_update_filter_values(mixer);
+	if (err < 0)
+		return err;
+
 	err = scarlett2_update_input_mute(mixer);
 	if (err < 0)
 		return err;
-- 
2.43.0

