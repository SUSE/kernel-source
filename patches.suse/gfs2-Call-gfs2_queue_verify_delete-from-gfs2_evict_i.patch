From 8c21c2c71e668a5eed9fe9981a2306f9178e6c3e Mon Sep 17 00:00:00 2001
From: Andreas Gruenbacher <agruenba@redhat.com>
Date: Thu, 12 Sep 2024 22:32:46 +0200
Subject: [PATCH] gfs2: Call gfs2_queue_verify_delete from
 gfs2_evict_inode
Git-commit: 8c21c2c71e668a5eed9fe9981a2306f9178e6c3e
Patch-mainline: v6.13-rc1
References: bsc#1247220

Move calls to gfs2_queue_verify_delete() into gfs2_evict_inode().

Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
Signed-off-by: Su Yue <glass.su@suse.com>
---
 fs/gfs2/glock.c | 13 ++-----------
 fs/gfs2/super.c |  9 ++++++++-
 2 files changed, 10 insertions(+), 12 deletions(-)

diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index b5618012115c..eb56baeb914c 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -959,10 +959,9 @@ static void gfs2_glock_poke(struct gfs2_glock *gl)
 	gfs2_holder_uninit(&gh);
 }
 
-static bool gfs2_try_evict(struct gfs2_glock *gl)
+static void gfs2_try_evict(struct gfs2_glock *gl)
 {
 	struct gfs2_inode *ip;
-	bool evicted = false;
 
 	/*
 	 * If there is contention on the iopen glock and we have an inode, try
@@ -997,9 +996,7 @@ static bool gfs2_try_evict(struct gfs2_glock *gl)
 			gfs2_glock_poke(ip->i_gl);
 			iput(&ip->i_inode);
 		}
-		evicted = !ip;
 	}
-	return evicted;
 }
 
 bool gfs2_queue_try_to_evict(struct gfs2_glock *gl)
@@ -1048,13 +1045,7 @@ static void delete_work_func(struct work_struct *work)
 		 * care about compatibility with such nodes, we can skip this
 		 * step entirely.
 		 */
-		if (gfs2_try_evict(gl)) {
-			if (!test_bit(SDF_KILL, &sdp->sd_flags)) {
-				gfs2_glock_hold(gl);
-				if (!gfs2_queue_verify_delete(gl, true))
-					gfs2_glock_put(gl);
-			}
-		}
+		gfs2_try_evict(gl);
 	}
 
 	if (verify_delete) {
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index bb98698bc785..1307c7c877ba 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -1499,8 +1499,15 @@ static void gfs2_evict_inode(struct inode *inode)
 
 	gfs2_holder_mark_uninitialized(&gh);
 	behavior = evict_should_delete(inode, &gh);
-	if (behavior == EVICT_SHOULD_DEFER_DELETE)
+	if (behavior == EVICT_SHOULD_DEFER_DELETE &&
+	    !test_bit(SDF_KILL, &sdp->sd_flags)) {
+		struct gfs2_glock *io_gl = ip->i_iopen_gh.gh_gl;
+
+		gfs2_glock_hold(io_gl);
+		if (!gfs2_queue_verify_delete(io_gl, true))
+			gfs2_glock_put(io_gl);
 		goto out;
+	}
 	if (behavior == EVICT_SHOULD_DELETE)
 		ret = evict_unlinked_inode(inode);
 	else
-- 
2.43.0

