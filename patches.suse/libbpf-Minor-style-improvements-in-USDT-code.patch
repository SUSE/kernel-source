From: Ilya Leoshkevich <iii@linux.ibm.com>
Date: Thu, 7 Apr 2022 23:44:09 +0200
Subject: libbpf: Minor style improvements in USDT code
Patch-mainline: v5.19-rc1
Git-commit: e1b6df598aa86e351437135c76ed38c9a5e3d397
References: jsc#PED-1368

Fix several typos and references to non-existing headers.
Also use __BYTE_ORDER__ instead of __BYTE_ORDER for consistency with
the rest of the bpf code - see commit 45f2bebc8079 ("libbpf: Fix
endianness detection in BPF_CORE_READ_BITFIELD_PROBED()") for
rationale).

Signed-off-by: Ilya Leoshkevich <iii@linux.ibm.com>
Signed-off-by: Andrii Nakryiko <andrii@kernel.org>
Link: https://lore.kernel.org/bpf/20220407214411.257260-2-iii@linux.ibm.com
Acked-by: Shung-Hsi Yu <shung-hsi.yu@suse.com>
---
 tools/lib/bpf/usdt.bpf.h |    4 ++--
 tools/lib/bpf/usdt.c     |   12 ++++++------
 2 files changed, 8 insertions(+), 8 deletions(-)

--- a/tools/lib/bpf/usdt.bpf.h
+++ b/tools/lib/bpf/usdt.bpf.h
@@ -166,7 +166,7 @@ int bpf_usdt_arg(struct pt_regs *ctx, __
 	case BPF_USDT_ARG_REG_DEREF:
 		/* Arg is in memory addressed by register, plus some offset
 		 * (e.g., "-4@-1204(%rbp)" in USDT arg spec). Register is
-		 * identified lik with BPF_USDT_ARG_REG case, and the offset
+		 * identified like with BPF_USDT_ARG_REG case, and the offset
 		 * is in arg_spec->val_off. We first fetch register contents
 		 * from pt_regs, then do another user-space probe read to
 		 * fetch argument value itself.
@@ -198,7 +198,7 @@ int bpf_usdt_arg(struct pt_regs *ctx, __
 /* Retrieve user-specified cookie value provided during attach as
  * bpf_usdt_opts.usdt_cookie. This serves the same purpose as BPF cookie
  * returned by bpf_get_attach_cookie(). Libbpf's support for USDT is itself
- * utilizaing BPF cookies internally, so user can't use BPF cookie directly
+ * utilizing BPF cookies internally, so user can't use BPF cookie directly
  * for USDT programs and has to use bpf_usdt_cookie() API instead.
  */
 static inline __noinline
--- a/tools/lib/bpf/usdt.c
+++ b/tools/lib/bpf/usdt.c
@@ -108,7 +108,7 @@
  * code through spec map. This allows BPF applications to quickly fetch the
  * actual value at runtime using a simple BPF-side code.
  *
- * With basics out of the way, let's go over less immeditately obvious aspects
+ * With basics out of the way, let's go over less immediately obvious aspects
  * of supporting USDTs.
  *
  * First, there is no special USDT BPF program type. It is actually just
@@ -189,14 +189,14 @@
 #define USDT_NOTE_TYPE 3
 #define USDT_NOTE_NAME "stapsdt"
 
-/* should match exactly enum __bpf_usdt_arg_type from bpf_usdt.bpf.h */
+/* should match exactly enum __bpf_usdt_arg_type from usdt.bpf.h */
 enum usdt_arg_type {
 	USDT_ARG_CONST,
 	USDT_ARG_REG,
 	USDT_ARG_REG_DEREF,
 };
 
-/* should match exactly struct __bpf_usdt_arg_spec from bpf_usdt.bpf.h */
+/* should match exactly struct __bpf_usdt_arg_spec from usdt.bpf.h */
 struct usdt_arg_spec {
 	__u64 val_off;
 	enum usdt_arg_type arg_type;
@@ -328,9 +328,9 @@ static int sanity_check_usdt_elf(Elf *el
 		return -EBADF;
 	}
 
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
 	endianness = ELFDATA2LSB;
-#elif __BYTE_ORDER == __BIG_ENDIAN
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 	endianness = ELFDATA2MSB;
 #else
 # error "Unrecognized __BYTE_ORDER__"
@@ -843,7 +843,7 @@ static int bpf_link_usdt_detach(struct b
 						   sizeof(*new_free_ids));
 		/* If we couldn't resize free_spec_ids, we'll just leak
 		 * a bunch of free IDs; this is very unlikely to happen and if
-		 * system is so exausted on memory, it's the least of user's
+		 * system is so exhausted on memory, it's the least of user's
 		 * concerns, probably.
 		 * So just do our best here to return those IDs to usdt_manager.
 		 */
