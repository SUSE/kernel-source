From: =?utf-8?b?TWljaGFsIEtvdXRuw70gPG1rb3V0bnlAc3VzZS5jb20+?=
Date: Thu, 31 Jul 2025 17:40:28 +0200
Subject: af_unix: Disable MSG_OOB for unprivileged users
Patch-mainline: Never, upstream has fix via 32ca245464e14
References: CVE-2025-38236 bsc#1246093

MSG_OOB for af_unix is in unfortunate state prior af_unix GC rework and number
of fixups. It'd have been better to disable CONFIG_AF_UNIX_OOB whatsover,
however, we don't want to break possible (no known at the moment) users
scenario. Guard the MSG_OOB entrances with privileges of CAP_SYS_ADMIN (it's
almost root, this is clearer than uid==0) -- and use the implementation of
!CONFIG_AF_UNIX_OOB (i.e. EOPNOTSUP, do not introduce new API with EPERM).

Also, add a boot cmdline option to override this disablement so that workload
relying on MSG_OOB may choose the insecure option. Making this switch a sysctl
is not worth it because more complex implementation (considering existing
sockets).

Acked-by: Michal Koutn√Ω <mkoutny@suse.com>
---
 include/net/af_unix.h |    1 +
 net/unix/af_unix.c    |   50 ++++++++++++++++++++++++++++++++++++++++++--------
 net/unix/garbage.c    |    1 +
 3 files changed, 44 insertions(+), 8 deletions(-)

--- a/include/net/af_unix.h
+++ b/include/net/af_unix.h
@@ -116,3 +116,4 @@ static inline void __init unix_bpf_build
 {}
 #endif
 #endif
+int unix_oob_enabled(void);
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -235,6 +235,29 @@ static inline int unix_recvq_full_lockle
 		READ_ONCE(sk->sk_max_ack_backlog);
 }
 
+static bool oob_unprivileged __ro_after_init;
+static int __init af_unix_oob_unprivileged(char *str)
+{
+	oob_unprivileged = 1;
+	pr_warn("Enabling insecure MSG_OOB on AF_UNIX for unprivileged users\n");
+	return 1;
+}
+__setup("af_unix_oob_unprivileged", af_unix_oob_unprivileged);
+
+int unix_oob_enabled(void)
+{
+#if IS_ENABLED(CONFIG_AF_UNIX_OOB)
+	return capable(CAP_SYS_ADMIN) || oob_unprivileged;
+#endif
+	return 0;
+}
+
+static void unix_oob_message(void)
+{
+	pr_info_once("%s cannot use MSG_OOB due to CVE-2025-38236\n",
+		     current->comm);
+}
+
 struct sock *unix_peer_get(struct sock *s)
 {
 	struct sock *peer;
@@ -617,6 +640,7 @@ static void unix_release_sock(struct soc
 
 #if IS_ENABLED(CONFIG_AF_UNIX_OOB)
 	if (u->oob_skb) {
+		WARN_ON_ONCE(!unix_oob_enabled());
 		kfree_skb(u->oob_skb);
 		u->oob_skb = NULL;
 	}
@@ -2147,11 +2171,13 @@ static int unix_stream_sendmsg(struct so
 	err = -EOPNOTSUPP;
 	if (msg->msg_flags & MSG_OOB) {
 #if IS_ENABLED(CONFIG_AF_UNIX_OOB)
-		if (len)
+		if (unix_oob_enabled() && len)
 			len--;
-		else
+		else {
+			unix_oob_message();
 #endif
 			goto out_err;
+		}
 	}
 
 	if (msg->msg_namelen) {
@@ -2236,7 +2262,7 @@ static int unix_stream_sendmsg(struct so
 	}
 
 #if IS_ENABLED(CONFIG_AF_UNIX_OOB)
-	if (msg->msg_flags & MSG_OOB) {
+	if (unix_oob_enabled() && msg->msg_flags & MSG_OOB) {
 		err = queue_oob(sock, msg, other, &scm, fds_sent);
 		if (err)
 			goto out_err;
@@ -2598,7 +2624,7 @@ static int unix_stream_read_skb(struct s
 		return err;
 
 #if IS_ENABLED(CONFIG_AF_UNIX_OOB)
-	if (unlikely(skb == READ_ONCE(u->oob_skb))) {
+	if (unix_oob_enabled() && unlikely(skb == READ_ONCE(u->oob_skb))) {
 		bool drop = false;
 
 		unix_state_lock(sk);
@@ -2655,7 +2681,10 @@ static int unix_stream_read_generic(stru
 	if (unlikely(flags & MSG_OOB)) {
 		err = -EOPNOTSUPP;
 #if IS_ENABLED(CONFIG_AF_UNIX_OOB)
-		err = unix_stream_recv_urg(state);
+		if (unix_oob_enabled())
+			err = unix_stream_recv_urg(state);
+		else
+			unix_oob_message();
 #endif
 		goto out;
 	}
@@ -2688,7 +2717,7 @@ redo:
 
 again:
 #if IS_ENABLED(CONFIG_AF_UNIX_OOB)
-		if (skb) {
+		if (unix_oob_enabled() && skb) {
 			skb = manage_oob(skb, sk, flags, copied);
 			if (!skb && copied) {
 				unix_state_unlock(sk);
@@ -3056,7 +3085,7 @@ static int unix_ioctl(struct socket *soc
 		break;
 #if IS_ENABLED(CONFIG_AF_UNIX_OOB)
 	case SIOCATMARK:
-		{
+		if (unix_oob_enabled()) {
 			struct sk_buff *skb;
 			int answ = 0;
 
@@ -3064,6 +3093,9 @@ static int unix_ioctl(struct socket *soc
 			if (skb && skb == READ_ONCE(unix_sk(sk)->oob_skb))
 				answ = 1;
 			err = put_user(answ, (int __user *)arg);
+		} else {
+			err = -ENOIOCTLCMD;
+			unix_oob_message();
 		}
 		break;
 #endif
@@ -3105,8 +3137,10 @@ static __poll_t unix_poll(struct file *f
 	if (sk_is_readable(sk))
 		mask |= EPOLLIN | EPOLLRDNORM;
 #if IS_ENABLED(CONFIG_AF_UNIX_OOB)
-	if (READ_ONCE(unix_sk(sk)->oob_skb))
+	if (READ_ONCE(unix_sk(sk)->oob_skb)) {
+		WARN_ON_ONCE(!unix_oob_enabled());
 		mask |= EPOLLPRI;
+	}
 #endif
 
 	/* Connection-based need to check for termination and startup */
--- a/net/unix/garbage.c
+++ b/net/unix/garbage.c
@@ -304,6 +304,7 @@ void unix_gc(void)
 
 #if IS_ENABLED(CONFIG_AF_UNIX_OOB)
 		if (u->oob_skb) {
+			WARN_ON_ONCE(!unix_oob_enabled());
 			kfree_skb(u->oob_skb);
 			u->oob_skb = NULL;
 		}
