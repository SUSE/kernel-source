From 6c6c7f784d9e07f6748c944df556ebebbce86e8a Mon Sep 17 00:00:00 2001
From: Muhammad Ahmed <ahmed.ahmed@amd.com>
Date: Wed, 23 Aug 2023 19:25:25 -0400
Subject: drm/amd/display: Fix MST recognizes connected displays as one
Git-commit: 8ce74b35630d60f4272da26270233768eb0d17d0
Patch-mainline: v6.7-rc1
References: jsc#PED-9898 jsc#PED-10191 jsc#PED-10197 jsc#PED-10226 jsc#PED-10237 jsc#PED-10340 jsc#PED-10852 jsc#PED-11022 jsc#PED-3527 jsc#PED-5475 jsc#PED-6068 jsc#PED-6070 jsc#PED-6116 jsc#PED-6120 jsc#PED-5065 jsc#PED-5477 jsc#PED-5511 jsc#PED-6041 jsc#PED-6069 jsc#PED-6071

MST now recognizes both connected displays

Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
Reviewed-by: Charlene Liu <charlene.liu@amd.com>
Acked-by: Qingqing Zhuo <qingqing.zhuo@amd.com>
Signed-off-by: Muhammad Ahmed <ahmed.ahmed@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c | 95 +++++++++++++++----
 .../drm/amd/display/dc/dcn35/dcn35_resource.c |  4 -
 2 files changed, 74 insertions(+), 25 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c
index 70a66df8315a..22137fde62bd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_dccg.c
@@ -635,8 +635,55 @@ static void dccg35_enable_symclk_se(struct dccg *dccg, uint32_t stream_enc_inst,
 	}
 }
 
+/*get other front end connected to this backend*/
+static uint8_t dccg35_get_other_enabled_symclk_fe(struct dccg *dccg, uint32_t stream_enc_inst, uint32_t link_enc_inst)
+{
+	uint8_t num_enabled_symclk_fe = 0;
+	uint32_t be_clk_en = 0, fe_clk_en[5] = {0}, be_clk_sel[5] = {0};
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	switch (link_enc_inst) {
+	case 0:
+		REG_GET_3(SYMCLKA_CLOCK_ENABLE, SYMCLKA_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKA_FE_EN, &fe_clk_en[0],
+				SYMCLKA_FE_SRC_SEL, &be_clk_sel[0]);
+				break;
+	case 1:
+		REG_GET_3(SYMCLKB_CLOCK_ENABLE, SYMCLKB_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKB_FE_EN, &fe_clk_en[1],
+				SYMCLKB_FE_SRC_SEL, &be_clk_sel[1]);
+				break;
+	case 2:
+			REG_GET_3(SYMCLKC_CLOCK_ENABLE, SYMCLKC_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKC_FE_EN, &fe_clk_en[2],
+				SYMCLKC_FE_SRC_SEL, &be_clk_sel[2]);
+				break;
+	case 3:
+			REG_GET_3(SYMCLKD_CLOCK_ENABLE, SYMCLKD_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKD_FE_EN, &fe_clk_en[3],
+				SYMCLKD_FE_SRC_SEL, &be_clk_sel[3]);
+				break;
+	case 4:
+			REG_GET_3(SYMCLKE_CLOCK_ENABLE, SYMCLKE_CLOCK_ENABLE, &be_clk_en,
+				SYMCLKE_FE_EN, &fe_clk_en[4],
+				SYMCLKE_FE_SRC_SEL, &be_clk_sel[4]);
+				break;
+	}
+	if (be_clk_en) {
+	/* for DPMST, this backend could be used by multiple front end.
+	only disable the backend if this stream_enc_ins is the last active stream enc connected to this back_end*/
+		uint8_t i;
+		for (i = 0; i != link_enc_inst && i < sizeof(fe_clk_en); i++) {
+			if (fe_clk_en[i] && be_clk_sel[i] == link_enc_inst)
+				num_enabled_symclk_fe++;
+		}
+	}
+	return num_enabled_symclk_fe;
+}
+
 static void dccg35_disable_symclk_se(struct dccg *dccg, uint32_t stream_enc_inst, uint32_t link_enc_inst)
 {
+	uint8_t num_enabled_symclk_fe = 0;
 	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
 
 	switch (stream_enc_inst) {
@@ -667,27 +714,33 @@ static void dccg35_disable_symclk_se(struct dccg *dccg, uint32_t stream_enc_inst
 		break;
 	}
 
-	switch (link_enc_inst) {
-	case 0:
-		REG_UPDATE(SYMCLKA_CLOCK_ENABLE,
-				SYMCLKA_CLOCK_ENABLE, 0);
-		break;
-	case 1:
-		REG_UPDATE(SYMCLKB_CLOCK_ENABLE,
-				SYMCLKB_CLOCK_ENABLE, 0);
-		break;
-	case 2:
-		REG_UPDATE(SYMCLKC_CLOCK_ENABLE,
-				SYMCLKC_CLOCK_ENABLE, 0);
-		break;
-	case 3:
-		REG_UPDATE(SYMCLKD_CLOCK_ENABLE,
-				SYMCLKD_CLOCK_ENABLE, 0);
-		break;
-	case 4:
-		REG_UPDATE(SYMCLKE_CLOCK_ENABLE,
-				SYMCLKE_CLOCK_ENABLE, 0);
-		break;
+	/*check other enabled symclk fe */
+	num_enabled_symclk_fe = dccg35_get_other_enabled_symclk_fe(dccg, stream_enc_inst, link_enc_inst);
+	/*only turn off backend clk if other front end attachecd to this backend are all off,
+	 for mst, only turn off the backend if this is the last front end*/
+	if (num_enabled_symclk_fe == 0) {
+		switch (link_enc_inst) {
+		case 0:
+			REG_UPDATE(SYMCLKA_CLOCK_ENABLE,
+					SYMCLKA_CLOCK_ENABLE, 0);
+			break;
+		case 1:
+			REG_UPDATE(SYMCLKB_CLOCK_ENABLE,
+					SYMCLKB_CLOCK_ENABLE, 0);
+			break;
+		case 2:
+			REG_UPDATE(SYMCLKC_CLOCK_ENABLE,
+					SYMCLKC_CLOCK_ENABLE, 0);
+			break;
+		case 3:
+			REG_UPDATE(SYMCLKD_CLOCK_ENABLE,
+					SYMCLKD_CLOCK_ENABLE, 0);
+			break;
+		case 4:
+			REG_UPDATE(SYMCLKE_CLOCK_ENABLE,
+					SYMCLKE_CLOCK_ENABLE, 0);
+			break;
+		}
 	}
 }
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_resource.c b/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_resource.c
index 7fa1172b98d0..4a0bca134581 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn35/dcn35_resource.c
@@ -751,14 +751,10 @@ static const struct dc_debug_options debug_defaults_drv = {
 	.disable_unbounded_requesting = false,
 	.disable_mem_low_power = true,
 	.enable_hpo_pg_support = false,
-
 	//must match enable_single_display_2to1_odm_policy to support dynamic ODM transitions
 	.enable_double_buffered_dsc_pg_support = false,
 	.enable_dp_dig_pixel_rate_div_policy = 1,
-	.disable_stutter = true,
-	.disable_idle_power_optimizations = true,
 	.disable_z10 = false,
-	.disable_mem_low_power = true,
 	.ignore_pg = true,
 	.psp_disabled_wa = true,
 	.disable_ips = true,
-- 
2.46.0

