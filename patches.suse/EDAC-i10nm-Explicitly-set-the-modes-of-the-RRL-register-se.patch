From: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
Date: Thu, 17 Apr 2025 23:07:20 +0800
Subject: EDAC/i10nm: Explicitly set the modes of the RRL register sets
Git-commit: 4878e1e90056230cefd580136d0e6d5689a7b770
Patch-mainline: v6.16-rc1
References: jsc#PED-14206

The i10nm_edac driver uses the default modes (either patrol scrub read
or on-demand read) of the RRL register sets configured by the BIOS.

Explicitly set the modes during the loading of the i10nm_edac driver with
the module parameter retry_rd_err_log=2.

Signed-off-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
Signed-off-by: Tony Luck <tony.luck@intel.com>
Tested-by: Feng Xu <feng.f.xu@intel.com>
Link: https://lore.kernel.org/r/20250417150724.1170168-4-qiuxu.zhuo@intel.com

Acked-by: Nikolay Borisov <nik.borisov@suse.com>
---
 drivers/edac/i10nm_base.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/drivers/edac/i10nm_base.c b/drivers/edac/i10nm_base.c
index 355b527d839e..50a16ce0aa22 100644
--- a/drivers/edac/i10nm_base.c
+++ b/drivers/edac/i10nm_base.c
@@ -73,6 +73,7 @@
 #define I10NM_SAD_NM_CACHEABLE(reg)	GET_BITFIELD(reg, 5, 5)
 
 #define RETRY_RD_ERR_LOG_UC		BIT(1)
+#define RETRY_RD_ERR_LOG_EN_PATSPR	BIT(13)
 #define RETRY_RD_ERR_LOG_NOOVER		BIT(14)
 #define RETRY_RD_ERR_LOG_EN		BIT(15)
 #define RETRY_RD_ERR_LOG_NOOVER_UC	(BIT(14) | BIT(1))
@@ -114,12 +115,15 @@ static void __enable_retry_rd_err_log(struct skx_imc *imc, int chan, bool enable
 			rrl_ctl[2] = d2;
 
 		s &= ~RETRY_RD_ERR_LOG_NOOVER_UC;
+		s |=  RETRY_RD_ERR_LOG_EN_PATSPR;
 		s |=  RETRY_RD_ERR_LOG_EN;
 		d &= ~RETRY_RD_ERR_LOG_NOOVER_UC;
+		d &= ~RETRY_RD_ERR_LOG_EN_PATSPR;
 		d |=  RETRY_RD_ERR_LOG_EN;
 
 		if (offsets_demand2) {
 			d2 &= ~RETRY_RD_ERR_LOG_UC;
+			d2 &= ~RETRY_RD_ERR_LOG_EN_PATSPR;
 			d2 |=  RETRY_RD_ERR_LOG_NOOVER;
 			d2 |=  RETRY_RD_ERR_LOG_EN;
 		}
@@ -129,18 +133,24 @@ static void __enable_retry_rd_err_log(struct skx_imc *imc, int chan, bool enable
 			s |=  RETRY_RD_ERR_LOG_UC;
 		if (rrl_ctl[0] & RETRY_RD_ERR_LOG_NOOVER)
 			s |=  RETRY_RD_ERR_LOG_NOOVER;
+		if (!(rrl_ctl[0] & RETRY_RD_ERR_LOG_EN_PATSPR))
+			s &=  ~RETRY_RD_ERR_LOG_EN_PATSPR;
 		if (!(rrl_ctl[0] & RETRY_RD_ERR_LOG_EN))
 			s &= ~RETRY_RD_ERR_LOG_EN;
 		if (rrl_ctl[1] & RETRY_RD_ERR_LOG_UC)
 			d |=  RETRY_RD_ERR_LOG_UC;
 		if (rrl_ctl[1] & RETRY_RD_ERR_LOG_NOOVER)
 			d |=  RETRY_RD_ERR_LOG_NOOVER;
+		if (rrl_ctl[1] & RETRY_RD_ERR_LOG_EN_PATSPR)
+			d |=  RETRY_RD_ERR_LOG_EN_PATSPR;
 		if (!(rrl_ctl[1] & RETRY_RD_ERR_LOG_EN))
 			d &= ~RETRY_RD_ERR_LOG_EN;
 
 		if (offsets_demand2) {
 			if (rrl_ctl[2] & RETRY_RD_ERR_LOG_UC)
 				d2 |=  RETRY_RD_ERR_LOG_UC;
+			if (rrl_ctl[2] & RETRY_RD_ERR_LOG_EN_PATSPR)
+				d2 |=  RETRY_RD_ERR_LOG_EN_PATSPR;
 			if (!(rrl_ctl[2] & RETRY_RD_ERR_LOG_NOOVER))
 				d2 &=  ~RETRY_RD_ERR_LOG_NOOVER;
 			if (!(rrl_ctl[2] & RETRY_RD_ERR_LOG_EN))

