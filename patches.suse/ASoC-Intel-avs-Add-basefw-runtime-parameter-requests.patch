From 3322e1688953966da15fcd0ae3183a351e241ea3 Mon Sep 17 00:00:00 2001
From: Cezary Rojewski <cezary.rojewski@intel.com>
Date: Fri, 11 Mar 2022 16:35:37 +0100
Subject: [PATCH] ASoC: Intel: avs: Add basefw runtime-parameter requests
Mime-version: 1.0
Content-type: text/plain; charset=UTF-8
Content-transfer-encoding: 8bit
Git-commit: 3322e1688953966da15fcd0ae3183a351e241ea3
Patch-mainline: v5.18-rc1
References: jsc#PED-850

Each module may expose a range of runtime parameters. For basefw,
implement handlers for: FIRMWARE_CONFIG, HARDWARE_CONFIG and
MODULES_INFO. These are used by driver to dynamically allocate resources
in respect to platform details, reducing number of hardcodes and code
duplications that would otherwise be needed to be defined within the
driver code.

Signed-off-by: Amadeusz Sławiński <amadeuszx.slawinski@linux.intel.com>
Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
Link: https://lore.kernel.org/r/20220311153544.136854-11-cezary.rojewski@intel.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/intel/avs/messages.c | 214 +++++++++++++++++++++++++++++++++
 sound/soc/intel/avs/messages.h | 179 +++++++++++++++++++++++++++
 2 files changed, 393 insertions(+)

diff --git a/sound/soc/intel/avs/messages.c b/sound/soc/intel/avs/messages.c
index 0d71ab297e91..d260b5d30c87 100644
--- a/sound/soc/intel/avs/messages.c
+++ b/sound/soc/intel/avs/messages.c
@@ -462,3 +462,217 @@ int avs_ipc_set_d0ix(struct avs_dev *adev, bool enable_pg, bool streaming)
 
 	return ret;
 }
+
+int avs_ipc_get_fw_config(struct avs_dev *adev, struct avs_fw_cfg *cfg)
+{
+	struct avs_tlv *tlv;
+	size_t payload_size;
+	size_t offset = 0;
+	u8 *payload;
+	int ret;
+
+	ret = avs_ipc_get_large_config(adev, AVS_BASEFW_MOD_ID, AVS_BASEFW_INST_ID,
+				       AVS_BASEFW_FIRMWARE_CONFIG, NULL, 0,
+				       &payload, &payload_size);
+	if (ret)
+		return ret;
+
+	while (offset < payload_size) {
+		tlv = (struct avs_tlv *)(payload + offset);
+
+		switch (tlv->type) {
+		case AVS_FW_CFG_FW_VERSION:
+			memcpy(&cfg->fw_version, tlv->value, sizeof(cfg->fw_version));
+			break;
+
+		case AVS_FW_CFG_MEMORY_RECLAIMED:
+			cfg->memory_reclaimed = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_SLOW_CLOCK_FREQ_HZ:
+			cfg->slow_clock_freq_hz = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_FAST_CLOCK_FREQ_HZ:
+			cfg->fast_clock_freq_hz = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_ALH_SUPPORT_LEVEL:
+			cfg->alh_support = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_IPC_DL_MAILBOX_BYTES:
+			cfg->ipc_dl_mailbox_bytes = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_IPC_UL_MAILBOX_BYTES:
+			cfg->ipc_ul_mailbox_bytes = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_TRACE_LOG_BYTES:
+			cfg->trace_log_bytes = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_MAX_PPL_COUNT:
+			cfg->max_ppl_count = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_MAX_ASTATE_COUNT:
+			cfg->max_astate_count = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_MAX_MODULE_PIN_COUNT:
+			cfg->max_module_pin_count = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_MODULES_COUNT:
+			cfg->modules_count = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_MAX_MOD_INST_COUNT:
+			cfg->max_mod_inst_count = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_MAX_LL_TASKS_PER_PRI_COUNT:
+			cfg->max_ll_tasks_per_pri_count = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_LL_PRI_COUNT:
+			cfg->ll_pri_count = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_MAX_DP_TASKS_COUNT:
+			cfg->max_dp_tasks_count = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_MAX_LIBS_COUNT:
+			cfg->max_libs_count = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_XTAL_FREQ_HZ:
+			cfg->xtal_freq_hz = *tlv->value;
+			break;
+
+		case AVS_FW_CFG_POWER_GATING_POLICY:
+			cfg->power_gating_policy = *tlv->value;
+			break;
+
+		/* Known but not useful to us. */
+		case AVS_FW_CFG_DMA_BUFFER_CONFIG:
+		case AVS_FW_CFG_SCHEDULER_CONFIG:
+		case AVS_FW_CFG_CLOCKS_CONFIG:
+			break;
+
+		default:
+			dev_info(adev->dev, "Unrecognized fw param: %d\n", tlv->type);
+			break;
+		}
+
+		offset += sizeof(*tlv) + tlv->length;
+	}
+
+	/* No longer needed, free it as it's owned by the get_large_config() caller. */
+	kfree(payload);
+	return ret;
+}
+
+int avs_ipc_get_hw_config(struct avs_dev *adev, struct avs_hw_cfg *cfg)
+{
+	struct avs_tlv *tlv;
+	size_t payload_size;
+	size_t size, offset = 0;
+	u8 *payload;
+	int ret;
+
+	ret = avs_ipc_get_large_config(adev, AVS_BASEFW_MOD_ID, AVS_BASEFW_INST_ID,
+				       AVS_BASEFW_HARDWARE_CONFIG, NULL, 0,
+				       &payload, &payload_size);
+	if (ret)
+		return ret;
+
+	while (offset < payload_size) {
+		tlv = (struct avs_tlv *)(payload + offset);
+
+		switch (tlv->type) {
+		case AVS_HW_CFG_AVS_VER:
+			cfg->avs_version = *tlv->value;
+			break;
+
+		case AVS_HW_CFG_DSP_CORES:
+			cfg->dsp_cores = *tlv->value;
+			break;
+
+		case AVS_HW_CFG_MEM_PAGE_BYTES:
+			cfg->mem_page_bytes = *tlv->value;
+			break;
+
+		case AVS_HW_CFG_TOTAL_PHYS_MEM_PAGES:
+			cfg->total_phys_mem_pages = *tlv->value;
+			break;
+
+		case AVS_HW_CFG_I2S_CAPS:
+			cfg->i2s_caps.i2s_version = tlv->value[0];
+			size = tlv->value[1];
+			cfg->i2s_caps.ctrl_count = size;
+			if (!size)
+				break;
+
+			/* Multiply to get entire array size. */
+			size *= sizeof(*cfg->i2s_caps.ctrl_base_addr);
+			cfg->i2s_caps.ctrl_base_addr = devm_kmemdup(adev->dev,
+								    &tlv->value[2],
+								    size, GFP_KERNEL);
+			if (!cfg->i2s_caps.ctrl_base_addr) {
+				ret = -ENOMEM;
+				goto exit;
+			}
+			break;
+
+		case AVS_HW_CFG_GATEWAY_COUNT:
+			cfg->gateway_count = *tlv->value;
+			break;
+
+		case AVS_HW_CFG_HP_EBB_COUNT:
+			cfg->hp_ebb_count = *tlv->value;
+			break;
+
+		case AVS_HW_CFG_LP_EBB_COUNT:
+			cfg->lp_ebb_count = *tlv->value;
+			break;
+
+		case AVS_HW_CFG_EBB_SIZE_BYTES:
+			cfg->ebb_size_bytes = *tlv->value;
+			break;
+
+		case AVS_HW_CFG_GPDMA_CAPS:
+			break;
+
+		default:
+			dev_info(adev->dev, "Unrecognized hw config: %d\n", tlv->type);
+			break;
+		}
+
+		offset += sizeof(*tlv) + tlv->length;
+	}
+
+exit:
+	/* No longer needed, free it as it's owned by the get_large_config() caller. */
+	kfree(payload);
+	return ret;
+}
+
+int avs_ipc_get_modules_info(struct avs_dev *adev, struct avs_mods_info **info)
+{
+	size_t payload_size;
+	u8 *payload;
+	int ret;
+
+	ret = avs_ipc_get_large_config(adev, AVS_BASEFW_MOD_ID, AVS_BASEFW_INST_ID,
+				       AVS_BASEFW_MODULES_INFO, NULL, 0,
+				       &payload, &payload_size);
+	if (ret)
+		return ret;
+
+	*info = (struct avs_mods_info *)payload;
+	return 0;
+}
diff --git a/sound/soc/intel/avs/messages.h b/sound/soc/intel/avs/messages.h
index c9de7f5a8f69..2c0614eed128 100644
--- a/sound/soc/intel/avs/messages.h
+++ b/sound/soc/intel/avs/messages.h
@@ -318,4 +318,183 @@ struct avs_dxstate_info {
 int avs_ipc_set_dx(struct avs_dev *adev, u32 core_mask, bool powerup);
 int avs_ipc_set_d0ix(struct avs_dev *adev, bool enable_pg, bool streaming);
 
+/* Base-firmware runtime parameters */
+
+#define AVS_BASEFW_MOD_ID	0
+#define AVS_BASEFW_INST_ID	0
+
+enum avs_basefw_runtime_param {
+	AVS_BASEFW_FIRMWARE_CONFIG = 7,
+	AVS_BASEFW_HARDWARE_CONFIG = 8,
+	AVS_BASEFW_MODULES_INFO = 9,
+	AVS_BASEFW_LIBRARIES_INFO = 16,
+};
+
+struct avs_fw_version {
+	u16 major;
+	u16 minor;
+	u16 hotfix;
+	u16 build;
+};
+
+enum avs_fw_cfg_params {
+	AVS_FW_CFG_FW_VERSION = 0,
+	AVS_FW_CFG_MEMORY_RECLAIMED,
+	AVS_FW_CFG_SLOW_CLOCK_FREQ_HZ,
+	AVS_FW_CFG_FAST_CLOCK_FREQ_HZ,
+	AVS_FW_CFG_DMA_BUFFER_CONFIG,
+	AVS_FW_CFG_ALH_SUPPORT_LEVEL,
+	AVS_FW_CFG_IPC_DL_MAILBOX_BYTES,
+	AVS_FW_CFG_IPC_UL_MAILBOX_BYTES,
+	AVS_FW_CFG_TRACE_LOG_BYTES,
+	AVS_FW_CFG_MAX_PPL_COUNT,
+	AVS_FW_CFG_MAX_ASTATE_COUNT,
+	AVS_FW_CFG_MAX_MODULE_PIN_COUNT,
+	AVS_FW_CFG_MODULES_COUNT,
+	AVS_FW_CFG_MAX_MOD_INST_COUNT,
+	AVS_FW_CFG_MAX_LL_TASKS_PER_PRI_COUNT,
+	AVS_FW_CFG_LL_PRI_COUNT,
+	AVS_FW_CFG_MAX_DP_TASKS_COUNT,
+	AVS_FW_CFG_MAX_LIBS_COUNT,
+	AVS_FW_CFG_SCHEDULER_CONFIG,
+	AVS_FW_CFG_XTAL_FREQ_HZ,
+	AVS_FW_CFG_CLOCKS_CONFIG,
+	AVS_FW_CFG_RESERVED,
+	AVS_FW_CFG_POWER_GATING_POLICY,
+	AVS_FW_CFG_ASSERT_MODE,
+};
+
+struct avs_fw_cfg {
+	struct avs_fw_version fw_version;
+	u32 memory_reclaimed;
+	u32 slow_clock_freq_hz;
+	u32 fast_clock_freq_hz;
+	u32 alh_support;
+	u32 ipc_dl_mailbox_bytes;
+	u32 ipc_ul_mailbox_bytes;
+	u32 trace_log_bytes;
+	u32 max_ppl_count;
+	u32 max_astate_count;
+	u32 max_module_pin_count;
+	u32 modules_count;
+	u32 max_mod_inst_count;
+	u32 max_ll_tasks_per_pri_count;
+	u32 ll_pri_count;
+	u32 max_dp_tasks_count;
+	u32 max_libs_count;
+	u32 xtal_freq_hz;
+	u32 power_gating_policy;
+};
+
+int avs_ipc_get_fw_config(struct avs_dev *adev, struct avs_fw_cfg *cfg);
+
+enum avs_hw_cfg_params {
+	AVS_HW_CFG_AVS_VER,
+	AVS_HW_CFG_DSP_CORES,
+	AVS_HW_CFG_MEM_PAGE_BYTES,
+	AVS_HW_CFG_TOTAL_PHYS_MEM_PAGES,
+	AVS_HW_CFG_I2S_CAPS,
+	AVS_HW_CFG_GPDMA_CAPS,
+	AVS_HW_CFG_GATEWAY_COUNT,
+	AVS_HW_CFG_HP_EBB_COUNT,
+	AVS_HW_CFG_LP_EBB_COUNT,
+	AVS_HW_CFG_EBB_SIZE_BYTES,
+};
+
+enum avs_iface_version {
+	AVS_AVS_VER_1_5 = 0x10005,
+	AVS_AVS_VER_1_8 = 0x10008,
+};
+
+enum avs_i2s_version {
+	AVS_I2S_VER_15_SKYLAKE   = 0x00000,
+	AVS_I2S_VER_15_BROXTON   = 0x10000,
+	AVS_I2S_VER_15_BROXTON_P = 0x20000,
+	AVS_I2S_VER_18_KBL_CNL   = 0x30000,
+};
+
+struct avs_i2s_caps {
+	u32 i2s_version;
+	u32 ctrl_count;
+	u32 *ctrl_base_addr;
+};
+
+struct avs_hw_cfg {
+	u32 avs_version;
+	u32 dsp_cores;
+	u32 mem_page_bytes;
+	u32 total_phys_mem_pages;
+	struct avs_i2s_caps i2s_caps;
+	u32 gateway_count;
+	u32 hp_ebb_count;
+	u32 lp_ebb_count;
+	u32 ebb_size_bytes;
+};
+
+int avs_ipc_get_hw_config(struct avs_dev *adev, struct avs_hw_cfg *cfg);
+
+#define AVS_MODULE_LOAD_TYPE_BUILTIN	0
+#define AVS_MODULE_LOAD_TYPE_LOADABLE	1
+#define AVS_MODULE_STATE_LOADED		BIT(0)
+
+struct avs_module_type {
+	u32 load_type:4;
+	u32 auto_start:1;
+	u32 domain_ll:1;
+	u32 domain_dp:1;
+	u32 lib_code:1;
+	u32 rsvd:24;
+} __packed;
+
+union avs_segment_flags {
+	u32 ul;
+	struct {
+		u32 contents:1;
+		u32 alloc:1;
+		u32 load:1;
+		u32 readonly:1;
+		u32 code:1;
+		u32 data:1;
+		u32 rsvd_1:2;
+		u32 type:4;
+		u32 rsvd_2:4;
+		u32 length:16;
+	};
+} __packed;
+
+struct avs_segment_desc {
+	union avs_segment_flags flags;
+	u32 v_base_addr;
+	u32 file_offset;
+} __packed;
+
+struct avs_module_entry {
+	u16 module_id;
+	u16 state_flags;
+	u8 name[8];
+	guid_t uuid;
+	struct avs_module_type type;
+	u8 hash[32];
+	u32 entry_point;
+	u16 cfg_offset;
+	u16 cfg_count;
+	u32 affinity_mask;
+	u16 instance_max_count;
+	u16 instance_bss_size;
+	struct avs_segment_desc segments[3];
+} __packed;
+
+struct avs_mods_info {
+	u32 count;
+	struct avs_module_entry entries[];
+} __packed;
+
+static inline bool avs_module_entry_is_loaded(struct avs_module_entry *mentry)
+{
+	return mentry->type.load_type == AVS_MODULE_LOAD_TYPE_BUILTIN ||
+	       mentry->state_flags & AVS_MODULE_STATE_LOADED;
+}
+
+int avs_ipc_get_modules_info(struct avs_dev *adev, struct avs_mods_info **info);
+
 #endif /* __SOUND_SOC_INTEL_AVS_MSGS_H */
-- 
2.35.3

