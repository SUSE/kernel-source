From b1c684e4bab9fa0bdc779e55b6f8e4e8cbef169d Mon Sep 17 00:00:00 2001
Message-Id: <b1c684e4bab9fa0bdc779e55b6f8e4e8cbef169d.1571938257.git.msuchanek@suse.de>
From: Michal Suchanek <msuchanek@suse.de>
Date: Thu, 2 Nov 2017 20:34:04 +0100
Subject: [PATCH v3 3/7] cdrom: wait for the tray to close

References: bsc#1048585
Patch-mainline: submitted https://lore.kernel.org/lkml/cover.1571834862.git.msuchanek@suse.de/

The scsi command to close the tray only starts the motor and does not
wait for the tray to close. Wait until the state chages from TRAY_OPEN
so users do not race with the tray closing.

This looks like inifinte wait but unless the drive is broken it either
closes the tray shortly or reports an error when it detects the tray is
blocked. At worst the wait can be interrupted by the user.

Also wait for the drive to become ready once the tray closes.

Signed-off-by: Michal Suchanek <msuchanek@suse.de>
---
v2:
 - check drive_status exists before using it
 - rename tray_close -> cdrom_tray_close
 - also wait for drive to become ready after tray closes
 - do not wait in cdrom_ioctl_closetray
---
 drivers/cdrom/cdrom.c | 27 ++++++++++++++++++++++++---
 1 file changed, 24 insertions(+), 3 deletions(-)

diff --git a/drivers/cdrom/cdrom.c b/drivers/cdrom/cdrom.c
index cc6936e20982..b9b8cebfc9eb 100644
--- a/drivers/cdrom/cdrom.c
+++ b/drivers/cdrom/cdrom.c
@@ -1045,6 +1045,18 @@ static void cdrom_count_tracks(struct cdrom_device_info *cdi, tracktype *tracks)
 	       tracks->cdi, tracks->xa);
 }
 
+static int cdrom_tray_close(struct cdrom_device_info *cdi)
+{
+	int ret;
+
+	ret = cdi->ops->tray_move(cdi, 0);
+	if (ret || !cdi->ops->drive_status)
+		return ret;
+
+	return poll_event_interruptible(CDS_TRAY_OPEN !=
+			cdi->ops->drive_status(cdi, CDSL_CURRENT), 500);
+}
+
 static int open_for_common(struct cdrom_device_info *cdi, tracktype *tracks)
 {
 	int ret;
@@ -1062,14 +1074,14 @@ static int open_for_common(struct cdrom_device_info *cdi, tracktype *tracks)
 				if (!(cdi->options & CDO_AUTO_CLOSE))
 					return -ENOMEDIUM;
 				cd_dbg(CD_OPEN, "trying to close the tray\n");
-				ret=cdo->tray_move(cdi,0);
+				ret = cdrom_tray_close(cdi);
+				if (ret == -ERESTARTSYS)
+					return ret;
 				if (ret) {
 					cd_dbg(CD_OPEN, "bummer. tried to close the tray but failed.\n");
 					return -ENOMEDIUM;
 				}
 				ret = cdo->drive_status(cdi, CDSL_CURRENT);
-				if (ret == CDS_TRAY_OPEN)
-					cd_dbg(CD_OPEN, "bummer. the tray is still not closed.\n");
 				if (ret == CDS_NO_DISC)
 					cd_dbg(CD_OPEN, "tray might not contain a medium\n");
 			} else {
@@ -1077,6 +1089,15 @@ static int open_for_common(struct cdrom_device_info *cdi, tracktype *tracks)
 				return -ENOMEDIUM;
 			}
 		}
+		if (ret == CDS_DRIVE_NOT_READY) {
+			int poll_res;
+
+			cd_dbg(CD_OPEN, "waiting for drive to become ready...\n");
+			poll_res = poll_event_interruptible(CDS_DRIVE_NOT_READY !=
+					(ret = cdo->drive_status(cdi, CDSL_CURRENT)), 50);
+			if (poll_res == -ERESTARTSYS)
+				return poll_res;
+		}
 		if (ret != CDS_DISC_OK)
 			return -ENOMEDIUM;
 	}
-- 
2.23.0

