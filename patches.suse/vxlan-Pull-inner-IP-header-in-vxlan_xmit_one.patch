From: Guillaume Nault <gnault@redhat.com>
Date: Wed, 19 Jun 2024 15:34:57 +0200
Subject: vxlan: Pull inner IP header in vxlan_xmit_one().
Git-commit: 31392048f55f98cb01ca709d32d06d926ab9760a
Patch-mainline: v6.10-rc6
References: bsc#1257942 bsc#1257246 CVE-2026-23003

Ensure the inner IP header is part of the skb's linear data before
setting old_iph. Otherwise, on a non-linear skb, old_iph could point
outside of the packet data.

Unlike classical VXLAN, which always encapsulates Ethernet packets,
VXLAN-GPE can transport IP packets directly. In that case, we need to
look at skb->protocol to figure out if an Ethernet header is present.

Fixes: d342894c5d2f ("vxlan: virtual extensible lan")
Signed-off-by: Guillaume Nault <gnault@redhat.com>
Link: https://patch.msgid.link/2aa75f6fa62ac9dbe4f16ad5ba75dd04a51d4b99.1718804000.git.gnault@redhat.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Acked-by: Ricardo B. Marli√®re <rbm@suse.com>
---
 drivers/net/vxlan/vxlan_core.c |    9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

--- a/drivers/net/vxlan/vxlan_core.c
+++ b/drivers/net/vxlan/vxlan_core.c
@@ -2427,7 +2427,7 @@ void vxlan_xmit_one(struct sk_buff *skb,
 	struct dst_cache *dst_cache;
 	struct ip_tunnel_info *info;
 	struct vxlan_dev *vxlan = netdev_priv(dev);
-	const struct iphdr *old_iph = ip_hdr(skb);
+	const struct iphdr *old_iph;
 	union vxlan_addr *dst;
 	union vxlan_addr remote_ip, local_ip;
 	struct vxlan_metadata _md;
@@ -2441,11 +2441,18 @@ void vxlan_xmit_one(struct sk_buff *skb,
 	u32 flags = vxlan->cfg.flags;
 	bool udp_sum = false;
 	bool xnet = !net_eq(vxlan->net, dev_net(vxlan->dev));
+	bool no_eth_encap;
 	__be32 vni = 0;
 #if IS_ENABLED(CONFIG_IPV6)
 	__be32 label;
 #endif
 
+	no_eth_encap = flags & VXLAN_F_GPE && skb->protocol != htons(ETH_P_TEB);
+	if (!skb_vlan_inet_prepare(skb, no_eth_encap))
+		goto drop;
+
+	old_iph = ip_hdr(skb);
+
 	info = skb_tunnel_info(skb);
 
 	if (rdst) {
