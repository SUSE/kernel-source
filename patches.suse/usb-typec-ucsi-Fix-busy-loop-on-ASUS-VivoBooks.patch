From 7fa6b25dfb43dafc0e16510e2fcfd63634fc95c2 Mon Sep 17 00:00:00 2001
From: "Christian A. Ehrhardt" <lk@c--e.de>
Date: Thu, 12 Sep 2024 09:41:32 +0200
Subject: [PATCH] usb: typec: ucsi: Fix busy loop on ASUS VivoBooks
Git-commit: 7fa6b25dfb43dafc0e16510e2fcfd63634fc95c2
References: git-fixes
Patch-mainline: v6.12-rc1

If the busy indicator is set, all other fields in CCI should be
clear according to the spec. However, some UCSI implementations do
not follow this rule and report bogus data in CCI along with the
busy indicator. Ignore the contents of CCI if the busy indicator is
set.

If a command timeout is hit it is possible that the EVENT_PENDING
bit is cleared while connector work is still scheduled which can
cause the EVENT_PENDING bit to go out of sync with scheduled connector
work. Check and set the EVENT_PENDING bit on entry to
ucsi_handle_connector_change() to fix this.

Finally, check UCSI_CCI_BUSY before the return code of ->sync_control.
This ensures that the command is cancelled even if ->sync_control
returns an error (most likely -ETIMEDOUT).

Reported-by: Anurag Bijea <icaliberdev@gmail.com>
Closes: https://bugzilla.kernel.org/show_bug.cgi?id=219108
Bisected-by: Christian Heusel <christian@heusel.eu>
Tested-by: Anurag Bijea <icaliberdev@gmail.com>
Fixes: de52aca4d9d5 ("usb: typec: ucsi: Never send a lone connector change ack")
Cc: stable@vger.kernel.org
Signed-off-by: Christian A. Ehrhardt <lk@c--e.de>
Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Link: https://lore.kernel.org/r/20240912074132.722855-1-lk@c--e.de
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Oliver Neukum <oneukum@suse.com>

---
 drivers/usb/typec/ucsi/ucsi.c         |   13 +++++++++----
 drivers/usb/typec/ucsi/ucsi_acpi.c    |    3 +++
 drivers/usb/typec/ucsi/ucsi_ccg.c     |    3 +++
 drivers/usb/typec/ucsi/ucsi_glink.c   |    3 +++
 drivers/usb/typec/ucsi/ucsi_stm32g0.c |    3 +++
 5 files changed, 21 insertions(+), 4 deletions(-)

--- a/drivers/usb/typec/ucsi/ucsi.c
+++ b/drivers/usb/typec/ucsi/ucsi.c
@@ -124,15 +124,13 @@ static int ucsi_read_error(struct ucsi *
 static int ucsi_exec_command(struct ucsi *ucsi, u64 cmd)
 {
 	u32 cci;
-	int ret;
+	int ret, ret2;
 
 	ret = ucsi->ops->sync_write(ucsi, UCSI_CONTROL, &cmd, sizeof(cmd));
 	if (ret)
 		return ret;
 
-	ret = ucsi->ops->read(ucsi, UCSI_CCI, &cci, sizeof(cci));
-	if (ret)
-		return ret;
+	ret2 = ucsi->ops->read(ucsi, UCSI_CCI, &cci, sizeof(cci));
 
 	if (cmd != UCSI_CANCEL && cci & UCSI_CCI_BUSY)
 		return ucsi_exec_command(ucsi, UCSI_CANCEL);
@@ -164,6 +162,9 @@ static int ucsi_exec_command(struct ucsi
 		return ret ? ret : -EBUSY;
 	}
 
+	if (ret2)
+		return ret2;
+
 	return UCSI_CCI_LENGTH(cci);
 }
 
@@ -929,6 +930,10 @@ static void ucsi_handle_connector_change
 
 	mutex_lock(&con->lock);
 
+	if (!test_and_set_bit(EVENT_PENDING, &ucsi->flags))
+		dev_err_once(ucsi->dev, "%s entered without EVENT_PENDING\n",
+			     __func__);
+
 	command = UCSI_GET_CONNECTOR_STATUS | UCSI_CONNECTOR_NUMBER(con->num);
 
 	ret = ucsi_send_command_common(ucsi, command, &con->status,
--- a/drivers/usb/typec/ucsi/ucsi_acpi.c
+++ b/drivers/usb/typec/ucsi/ucsi_acpi.c
@@ -260,6 +260,9 @@ static void ucsi_acpi_notify(acpi_handle
 	if (ret)
 		return;
 
+	if (cci & UCSI_CCI_BUSY)
+		return;
+
 	if (UCSI_CCI_CONNECTOR(cci) &&
 	    !test_bit(UCSI_ACPI_SUPPRESS_EVENT, &ua->flags))
 		ucsi_connector_change(ua->ucsi, UCSI_CCI_CONNECTOR(cci));
--- a/drivers/usb/typec/ucsi/ucsi_ccg.c
+++ b/drivers/usb/typec/ucsi/ucsi_ccg.c
@@ -694,6 +694,9 @@ static irqreturn_t ccg_irq_handler(int i
 	if (ret)
 		goto err_clear_irq;
 
+	if (cci & UCSI_CCI_BUSY)
+		return IRQ_HANDLED;
+
 	if (UCSI_CCI_CONNECTOR(cci))
 		ucsi_connector_change(uc->ucsi, UCSI_CCI_CONNECTOR(cci));
 
--- a/drivers/usb/typec/ucsi/ucsi_glink.c
+++ b/drivers/usb/typec/ucsi/ucsi_glink.c
@@ -249,6 +249,9 @@ static void pmic_glink_ucsi_notify(struc
 		return;
 	}
 
+	if (cci & UCSI_CCI_BUSY)
+		return;
+
 	con_num = UCSI_CCI_CONNECTOR(cci);
 	if (con_num)
 		ucsi_connector_change(ucsi->ucsi, con_num);
--- a/drivers/usb/typec/ucsi/ucsi_stm32g0.c
+++ b/drivers/usb/typec/ucsi/ucsi_stm32g0.c
@@ -434,6 +434,9 @@ static irqreturn_t ucsi_stm32g0_irq_hand
 	if (ret)
 		return IRQ_NONE;
 
+	if (cci & UCSI_CCI_BUSY)
+		return IRQ_HANDLED;
+
 	if (UCSI_CCI_CONNECTOR(cci))
 		ucsi_connector_change(g0->ucsi, UCSI_CCI_CONNECTOR(cci));
 
