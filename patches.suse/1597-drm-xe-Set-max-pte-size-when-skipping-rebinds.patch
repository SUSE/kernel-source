From ad4f2b98a60f499254686b6ad76241e49ee7aa68 Mon Sep 17 00:00:00 2001
From: Matthew Brost <matthew.brost@intel.com>
Date: Wed, 2 Aug 2023 20:15:38 -0700
Subject: drm/xe: Set max pte size when skipping rebinds
Git-commit: c47794bdd63d8304fa5d410039e81c6387388340
Patch-mainline: v6.8-rc1
References: jsc#PED-9898 jsc#PED-10191 jsc#PED-10197 jsc#PED-10226 jsc#PED-10237 jsc#PED-10340 jsc#PED-10852 jsc#PED-11022

When a rebind is skipped, we must set the max pte size of the newly
created vma to value of the old vma as we do not pte walk for the new
vma. Without this future rebinds may be incorrectly skipped due to the
wrong max pte size. Null binds are more likely to expose this bug as
larger ptes are more frequently used compared to normal bindings.

Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Signed-off-by: Matthew Brost <matthew.brost@intel.com>
Testcase: dEQP-VK.sparse_resources.buffer.ssbo.sparse_residency.buffer_size_2_24
Reported-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
Fixes: 8f33b4f054fc ("drm/xe: Avoid doing rebinds")
Reference: https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/23045
Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/xe/xe_vm.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/xe/xe_vm.c b/drivers/gpu/drm/xe/xe_vm.c
index 374f111eea9c..ff7fafe1315b 100644
--- a/drivers/gpu/drm/xe/xe_vm.c
+++ b/drivers/gpu/drm/xe/xe_vm.c
@@ -2410,6 +2410,20 @@ static u64 xe_vma_max_pte_size(struct xe_vma *vma)
 	return SZ_4K;
 }
 
+static u64 xe_vma_set_pte_size(struct xe_vma *vma, u64 size)
+{
+	switch (size) {
+	case SZ_1G:
+		vma->gpuva.flags |= XE_VMA_PTE_1G;
+		break;
+	case SZ_2M:
+		vma->gpuva.flags |= XE_VMA_PTE_2M;
+		break;
+	}
+
+	return SZ_4K;
+}
+
 /*
  * Parse operations list and create any resources needed for the operations
  * prior to fully committing to the operations. This setup can fail.
@@ -2520,6 +2534,7 @@ static int vm_bind_ioctl_ops_parse(struct xe_vm *vm, struct xe_exec_queue *q,
 						IS_ALIGNED(xe_vma_end(vma),
 							   xe_vma_max_pte_size(old));
 					if (op->remap.skip_prev) {
+						xe_vma_set_pte_size(vma, xe_vma_max_pte_size(old));
 						op->remap.range -=
 							xe_vma_end(vma) -
 							xe_vma_start(old);
@@ -2554,10 +2569,12 @@ static int vm_bind_ioctl_ops_parse(struct xe_vm *vm, struct xe_exec_queue *q,
 					op->remap.skip_next = !xe_vma_is_userptr(old) &&
 						IS_ALIGNED(xe_vma_start(vma),
 							   xe_vma_max_pte_size(old));
-					if (op->remap.skip_next)
+					if (op->remap.skip_next) {
+						xe_vma_set_pte_size(vma, xe_vma_max_pte_size(old));
 						op->remap.range -=
 							xe_vma_end(old) -
 							xe_vma_start(vma);
+					}
 				}
 				break;
 			}
-- 
2.46.1

