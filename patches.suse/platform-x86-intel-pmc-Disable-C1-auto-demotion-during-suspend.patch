From: David E. Box <david.e.box@linux.intel.com>
Subject: platform/x86/intel/pmc: Disable C1 auto-demotion during suspend
References: jsc#PED-12855
Patch-Mainline: v6.13-rc1
Git-commit: 7a797cc9f80915cc5f1a5aee46d14880eb444644


On some platforms, aggressive C1 auto-demotion may lead to failure to enter
the deepest C-state during suspend-to-idle, causing high power consumption.
To prevent this, disable C1 auto-demotion during suspend and re-enable on
resume.

Signed-off-by: David E. Box <david.e.box@linux.intel.com>
Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Link: https://lore.kernel.org/r/20241017210439.3449324-2-david.e.box@linux.intel.com
Reviewed-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>


Signed-off-by:  <trenn@suse.de>
---
 drivers/platform/x86/intel/pmc/cnp.c |   53 +++++++++++++++++++++++++++++++++++
 1 file changed, 53 insertions(+)

--- a/drivers/platform/x86/intel/pmc/cnp.c
+++ b/drivers/platform/x86/intel/pmc/cnp.c
@@ -8,6 +8,8 @@
  *
  */
 
+#include <linux/smp.h>
+#include <linux/suspend.h>
 #include "core.h"
 
 /* Cannon Lake: PGD PFET Enable Ack Status Register(s) bitmap */
@@ -204,8 +206,57 @@
 	.etr3_offset = ETR3_OFFSET,
 };
 
+
+/*
+ * Disable C1 auto-demotion
+ *
+ * Aggressive C1 auto-demotion may lead to failure to enter the deepest C-state
+ * during suspend-to-idle, causing high power consumption. To prevent this, we
+ * disable C1 auto-demotion during suspend and re-enable on resume.
+ *
+ * Note that, although MSR_PKG_CST_CONFIG_CONTROL has 'package' in its name, it
+ * is actually a per-core MSR on client platforms, affecting only a single CPU.
+ * Therefore, it must be configured on all online CPUs. The online cpu mask is
+ * unchanged during the phase of suspend/resume as user space is frozen.
+ */
+
+static DEFINE_PER_CPU(u64, pkg_cst_config);
+
+static void disable_c1_auto_demote(void *unused)
+{
+	int cpunum = smp_processor_id();
+	u64 val;
+
+	rdmsrl(MSR_PKG_CST_CONFIG_CONTROL, val);
+	per_cpu(pkg_cst_config, cpunum) = val;
+	val &= ~NHM_C1_AUTO_DEMOTE;
+	wrmsrl(MSR_PKG_CST_CONFIG_CONTROL, val);
+
+	pr_debug("%s: cpu:%d cst %llx\n", __func__, cpunum, val);
+}
+
+static void restore_c1_auto_demote(void *unused)
+{
+	int cpunum = smp_processor_id();
+
+	wrmsrl(MSR_PKG_CST_CONFIG_CONTROL, per_cpu(pkg_cst_config, cpunum));
+
+	pr_debug("%s: cpu:%d cst %llx\n", __func__, cpunum,
+		 per_cpu(pkg_cst_config, cpunum));
+}
+
+static void s2idle_cpu_quirk(smp_call_func_t func)
+{
+	if (pm_suspend_via_firmware())
+		return;
+
+	on_each_cpu(func, NULL, true);
+}
+
 void cnl_suspend(struct pmc_dev *pmcdev)
 {
+	s2idle_cpu_quirk(disable_c1_auto_demote);
+
 	/*
 	 * Due to a hardware limitation, the GBE LTR blocks PC10
 	 * when a cable is attached. To unblock PC10 during suspend,
@@ -216,6 +267,8 @@
 
 int cnl_resume(struct pmc_dev *pmcdev)
 {
+	s2idle_cpu_quirk(restore_c1_auto_demote);
+
 	pmc_core_send_ltr_ignore(pmcdev, 3, 0);
 
 	return pmc_core_resume_common(pmcdev);
