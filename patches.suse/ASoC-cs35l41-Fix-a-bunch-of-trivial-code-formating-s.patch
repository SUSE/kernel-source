From 4295c8cc17481e0d7d4c3a404eaf87dc8dfc26be Mon Sep 17 00:00:00 2001
From: Charles Keepax <ckeepax@opensource.cirrus.com>
Date: Tue, 14 Sep 2021 15:13:49 +0100
Subject: [PATCH] ASoC: cs35l41: Fix a bunch of trivial code formating/style issues
Git-commit: 4295c8cc17481e0d7d4c3a404eaf87dc8dfc26be
Patch-mainline: v5.16-rc1
References: bsc#1203699

Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20210914141349.30218-6-ckeepax@opensource.cirrus.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/codecs/cs35l41-i2c.c    |   5 +-
 sound/soc/codecs/cs35l41-spi.c    |  13 +-
 sound/soc/codecs/cs35l41-tables.c | 477 +++++++++++++++---------------
 sound/soc/codecs/cs35l41.c        | 387 ++++++++++++------------
 sound/soc/codecs/cs35l41.h        |  81 +++--
 5 files changed, 467 insertions(+), 496 deletions(-)

diff --git a/sound/soc/codecs/cs35l41-i2c.c b/sound/soc/codecs/cs35l41-i2c.c
index dc9da78df412..2f3d1bd8e046 100644
--- a/sound/soc/codecs/cs35l41-i2c.c
+++ b/sound/soc/codecs/cs35l41-i2c.c
@@ -44,7 +44,7 @@ static const struct i2c_device_id cs35l41_id_i2c[] = {
 MODULE_DEVICE_TABLE(i2c, cs35l41_id_i2c);
 
 static int cs35l41_i2c_probe(struct i2c_client *client,
-				const struct i2c_device_id *id)
+			     const struct i2c_device_id *id)
 {
 	struct cs35l41_private *cs35l41;
 	struct device *dev = &client->dev;
@@ -64,8 +64,7 @@ static int cs35l41_i2c_probe(struct i2c_client *client,
 	cs35l41->regmap = devm_regmap_init_i2c(client, regmap_config);
 	if (IS_ERR(cs35l41->regmap)) {
 		ret = PTR_ERR(cs35l41->regmap);
-		dev_err(cs35l41->dev, "Failed to allocate register map: %d\n",
-			ret);
+		dev_err(cs35l41->dev, "Failed to allocate register map: %d\n", ret);
 		return ret;
 	}
 
diff --git a/sound/soc/codecs/cs35l41-spi.c b/sound/soc/codecs/cs35l41-spi.c
index e253c6d82ce8..eac64779eea8 100644
--- a/sound/soc/codecs/cs35l41-spi.c
+++ b/sound/soc/codecs/cs35l41-spi.c
@@ -43,7 +43,7 @@ static const struct spi_device_id cs35l41_id_spi[] = {
 MODULE_DEVICE_TABLE(spi, cs35l41_id_spi);
 
 static void cs35l41_spi_otp_setup(struct cs35l41_private *cs35l41,
-					bool is_pre_setup, unsigned int *freq)
+				  bool is_pre_setup, unsigned int *freq)
 {
 	struct spi_device *spi;
 	u32 orig_spi_freq;
@@ -73,24 +73,19 @@ static void cs35l41_spi_otp_setup(struct cs35l41_private *cs35l41,
 static int cs35l41_spi_probe(struct spi_device *spi)
 {
 	const struct regmap_config *regmap_config = &cs35l41_regmap_spi;
-	struct cs35l41_platform_data *pdata =
-					dev_get_platdata(&spi->dev);
+	struct cs35l41_platform_data *pdata = dev_get_platdata(&spi->dev);
 	struct cs35l41_private *cs35l41;
 	int ret;
 
-	cs35l41 = devm_kzalloc(&spi->dev,
-			       sizeof(struct cs35l41_private),
-			       GFP_KERNEL);
+	cs35l41 = devm_kzalloc(&spi->dev, sizeof(struct cs35l41_private), GFP_KERNEL);
 	if (!cs35l41)
 		return -ENOMEM;
 
-
 	spi_set_drvdata(spi, cs35l41);
 	cs35l41->regmap = devm_regmap_init_spi(spi, regmap_config);
 	if (IS_ERR(cs35l41->regmap)) {
 		ret = PTR_ERR(cs35l41->regmap);
-		dev_err(&spi->dev, "Failed to allocate register map: %d\n",
-			ret);
+		dev_err(&spi->dev, "Failed to allocate register map: %d\n", ret);
 		return ret;
 	}
 
diff --git a/sound/soc/codecs/cs35l41-tables.c b/sound/soc/codecs/cs35l41-tables.c
index 155db0e6e3d8..964e530afa27 100644
--- a/sound/soc/codecs/cs35l41-tables.c
+++ b/sound/soc/codecs/cs35l41-tables.c
@@ -9,42 +9,42 @@
 #include "cs35l41.h"
 
 const struct reg_default cs35l41_reg[CS35L41_MAX_CACHE_REG] = {
-	{CS35L41_PWR_CTRL1,			0x00000000},
-	{CS35L41_PWR_CTRL3,			0x01000010},
-	{CS35L41_GPIO_PAD_CONTROL,		0x00000000},
-	{CS35L41_SP_ENABLES,			0x00000000},
-	{CS35L41_SP_RATE_CTRL,			0x00000028},
-	{CS35L41_SP_FORMAT,			0x18180200},
-	{CS35L41_SP_HIZ_CTRL,			0x00000002},
-	{CS35L41_SP_FRAME_TX_SLOT,		0x03020100},
-	{CS35L41_SP_FRAME_RX_SLOT,		0x00000100},
-	{CS35L41_SP_TX_WL,			0x00000018},
-	{CS35L41_SP_RX_WL,			0x00000018},
-	{CS35L41_DAC_PCM1_SRC,			0x00000008},
-	{CS35L41_ASP_TX1_SRC,			0x00000018},
-	{CS35L41_ASP_TX2_SRC,			0x00000019},
-	{CS35L41_ASP_TX3_SRC,			0x00000020},
-	{CS35L41_ASP_TX4_SRC,			0x00000021},
-	{CS35L41_DSP1_RX1_SRC,			0x00000008},
-	{CS35L41_DSP1_RX2_SRC,			0x00000009},
-	{CS35L41_DSP1_RX3_SRC,			0x00000018},
-	{CS35L41_DSP1_RX4_SRC,			0x00000019},
-	{CS35L41_DSP1_RX5_SRC,			0x00000020},
-	{CS35L41_DSP1_RX6_SRC,			0x00000021},
-	{CS35L41_DSP1_RX7_SRC,			0x0000003A},
-	{CS35L41_DSP1_RX8_SRC,			0x00000001},
-	{CS35L41_NGATE1_SRC,			0x00000008},
-	{CS35L41_NGATE2_SRC,			0x00000009},
-	{CS35L41_AMP_DIG_VOL_CTRL,		0x00008000},
-	{CS35L41_CLASSH_CFG,			0x000B0405},
-	{CS35L41_WKFET_CFG,			0x00000111},
-	{CS35L41_NG_CFG,			0x00000033},
-	{CS35L41_AMP_GAIN_CTRL,			0x00000273},
-	{CS35L41_GPIO1_CTRL1,			0xE1000001},
-	{CS35L41_GPIO2_CTRL1,			0xE1000001},
-	{CS35L41_MIXER_NGATE_CFG,		0x00000000},
-	{CS35L41_MIXER_NGATE_CH1_CFG,		0x00000303},
-	{CS35L41_MIXER_NGATE_CH2_CFG,		0x00000303},
+	{ CS35L41_PWR_CTRL1,			0x00000000 },
+	{ CS35L41_PWR_CTRL3,			0x01000010 },
+	{ CS35L41_GPIO_PAD_CONTROL,		0x00000000 },
+	{ CS35L41_SP_ENABLES,			0x00000000 },
+	{ CS35L41_SP_RATE_CTRL,			0x00000028 },
+	{ CS35L41_SP_FORMAT,			0x18180200 },
+	{ CS35L41_SP_HIZ_CTRL,			0x00000002 },
+	{ CS35L41_SP_FRAME_TX_SLOT,		0x03020100 },
+	{ CS35L41_SP_FRAME_RX_SLOT,		0x00000100 },
+	{ CS35L41_SP_TX_WL,			0x00000018 },
+	{ CS35L41_SP_RX_WL,			0x00000018 },
+	{ CS35L41_DAC_PCM1_SRC,			0x00000008 },
+	{ CS35L41_ASP_TX1_SRC,			0x00000018 },
+	{ CS35L41_ASP_TX2_SRC,			0x00000019 },
+	{ CS35L41_ASP_TX3_SRC,			0x00000020 },
+	{ CS35L41_ASP_TX4_SRC,			0x00000021 },
+	{ CS35L41_DSP1_RX1_SRC,			0x00000008 },
+	{ CS35L41_DSP1_RX2_SRC,			0x00000009 },
+	{ CS35L41_DSP1_RX3_SRC,			0x00000018 },
+	{ CS35L41_DSP1_RX4_SRC,			0x00000019 },
+	{ CS35L41_DSP1_RX5_SRC,			0x00000020 },
+	{ CS35L41_DSP1_RX6_SRC,			0x00000021 },
+	{ CS35L41_DSP1_RX7_SRC,			0x0000003A },
+	{ CS35L41_DSP1_RX8_SRC,			0x00000001 },
+	{ CS35L41_NGATE1_SRC,			0x00000008 },
+	{ CS35L41_NGATE2_SRC,			0x00000009 },
+	{ CS35L41_AMP_DIG_VOL_CTRL,		0x00008000 },
+	{ CS35L41_CLASSH_CFG,			0x000B0405 },
+	{ CS35L41_WKFET_CFG,			0x00000111 },
+	{ CS35L41_NG_CFG,			0x00000033 },
+	{ CS35L41_AMP_GAIN_CTRL,		0x00000273 },
+	{ CS35L41_GPIO1_CTRL1,			0xE1000001 },
+	{ CS35L41_GPIO2_CTRL1,			0xE1000001 },
+	{ CS35L41_MIXER_NGATE_CFG,		0x00000000 },
+	{ CS35L41_MIXER_NGATE_CH1_CFG,		0x00000303 },
+	{ CS35L41_MIXER_NGATE_CH2_CFG,		0x00000303 },
 };
 
 bool cs35l41_readable_reg(struct device *dev, unsigned int reg)
@@ -349,216 +349,213 @@ bool cs35l41_volatile_reg(struct device *dev, unsigned int reg)
 	}
 }
 
-static const struct cs35l41_otp_packed_element_t
-					otp_map_1[CS35L41_NUM_OTP_ELEM] = {
+static const struct cs35l41_otp_packed_element_t otp_map_1[CS35L41_NUM_OTP_ELEM] = {
 	/* addr         shift   size */
-	{0x00002030,	0,	4}, /*TRIM_OSC_FREQ_TRIM*/
-	{0x00002030,	7,	1}, /*TRIM_OSC_TRIM_DONE*/
-	{0x0000208c,	24,	6}, /*TST_DIGREG_VREF_TRIM*/
-	{0x00002090,	14,	4}, /*TST_REF_TRIM*/
-	{0x00002090,	10,	4}, /*TST_REF_TEMPCO_TRIM*/
-	{0x0000300C,	11,	4}, /*PLL_LDOA_TST_VREF_TRIM*/
-	{0x0000394C,	23,	2}, /*BST_ATEST_CM_VOFF*/
-	{0x00003950,	0,	7}, /*BST_ATRIM_IADC_OFFSET*/
-	{0x00003950,	8,	7}, /*BST_ATRIM_IADC_GAIN1*/
-	{0x00003950,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET1*/
-	{0x00003950,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN1*/
-	{0x00003954,	0,	7}, /*BST_ATRIM_IADC_OFFSET2*/
-	{0x00003954,	8,	7}, /*BST_ATRIM_IADC_GAIN2*/
-	{0x00003954,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET2*/
-	{0x00003954,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN2*/
-	{0x00003958,	0,	7}, /*BST_ATRIM_IADC_OFFSET3*/
-	{0x00003958,	8,	7}, /*BST_ATRIM_IADC_GAIN3*/
-	{0x00003958,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET3*/
-	{0x00003958,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN3*/
-	{0x0000395C,	0,	7}, /*BST_ATRIM_IADC_OFFSET4*/
-	{0x0000395C,	8,	7}, /*BST_ATRIM_IADC_GAIN4*/
-	{0x0000395C,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET4*/
-	{0x0000395C,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN4*/
-	{0x0000416C,	0,	8}, /*VMON_GAIN_OTP_VAL*/
-	{0x00004160,	0,	7}, /*VMON_OFFSET_OTP_VAL*/
-	{0x0000416C,	8,	8}, /*IMON_GAIN_OTP_VAL*/
-	{0x00004160,	16,	10}, /*IMON_OFFSET_OTP_VAL*/
-	{0x0000416C,	16,	12}, /*VMON_CM_GAIN_OTP_VAL*/
-	{0x0000416C,	28,	1}, /*VMON_CM_GAIN_SIGN_OTP_VAL*/
-	{0x00004170,	0,	6}, /*IMON_CAL_TEMPCO_OTP_VAL*/
-	{0x00004170,	6,	1}, /*IMON_CAL_TEMPCO_SIGN_OTP*/
-	{0x00004170,	8,	6}, /*IMON_CAL_TEMPCO2_OTP_VAL*/
-	{0x00004170,	14,	1}, /*IMON_CAL_TEMPCO2_DN_UPB_OTP_VAL*/
-	{0x00004170,	16,	9}, /*IMON_CAL_TEMPCO_TBASE_OTP_VAL*/
-	{0x00004360,	0,	5}, /*TEMP_GAIN_OTP_VAL*/
-	{0x00004360,	6,	9}, /*TEMP_OFFSET_OTP_VAL*/
-	{0x00004448,	0,	8}, /*VP_SARADC_OFFSET*/
-	{0x00004448,	8,	8}, /*VP_GAIN_INDEX*/
-	{0x00004448,	16,	8}, /*VBST_SARADC_OFFSET*/
-	{0x00004448,	24,	8}, /*VBST_GAIN_INDEX*/
-	{0x0000444C,	0,	3}, /*ANA_SELINVREF*/
-	{0x00006E30,	0,	5}, /*GAIN_ERR_COEFF_0*/
-	{0x00006E30,	8,	5}, /*GAIN_ERR_COEFF_1*/
-	{0x00006E30,	16,	5}, /*GAIN_ERR_COEFF_2*/
-	{0x00006E30,	24,	5}, /*GAIN_ERR_COEFF_3*/
-	{0x00006E34,	0,	5}, /*GAIN_ERR_COEFF_4*/
-	{0x00006E34,	8,	5}, /*GAIN_ERR_COEFF_5*/
-	{0x00006E34,	16,	5}, /*GAIN_ERR_COEFF_6*/
-	{0x00006E34,	24,	5}, /*GAIN_ERR_COEFF_7*/
-	{0x00006E38,	0,	5}, /*GAIN_ERR_COEFF_8*/
-	{0x00006E38,	8,	5}, /*GAIN_ERR_COEFF_9*/
-	{0x00006E38,	16,	5}, /*GAIN_ERR_COEFF_10*/
-	{0x00006E38,	24,	5}, /*GAIN_ERR_COEFF_11*/
-	{0x00006E3C,	0,	5}, /*GAIN_ERR_COEFF_12*/
-	{0x00006E3C,	8,	5}, /*GAIN_ERR_COEFF_13*/
-	{0x00006E3C,	16,	5}, /*GAIN_ERR_COEFF_14*/
-	{0x00006E3C,	24,	5}, /*GAIN_ERR_COEFF_15*/
-	{0x00006E40,	0,	5}, /*GAIN_ERR_COEFF_16*/
-	{0x00006E40,	8,	5}, /*GAIN_ERR_COEFF_17*/
-	{0x00006E40,	16,	5}, /*GAIN_ERR_COEFF_18*/
-	{0x00006E40,	24,	5}, /*GAIN_ERR_COEFF_19*/
-	{0x00006E44,	0,	5}, /*GAIN_ERR_COEFF_20*/
-	{0x00006E48,	0,	10}, /*VOFF_GAIN_0*/
-	{0x00006E48,	10,	10}, /*VOFF_GAIN_1*/
-	{0x00006E48,	20,	10}, /*VOFF_GAIN_2*/
-	{0x00006E4C,	0,	10}, /*VOFF_GAIN_3*/
-	{0x00006E4C,	10,	10}, /*VOFF_GAIN_4*/
-	{0x00006E4C,	20,	10}, /*VOFF_GAIN_5*/
-	{0x00006E50,	0,	10}, /*VOFF_GAIN_6*/
-	{0x00006E50,	10,	10}, /*VOFF_GAIN_7*/
-	{0x00006E50,	20,	10}, /*VOFF_GAIN_8*/
-	{0x00006E54,	0,	10}, /*VOFF_GAIN_9*/
-	{0x00006E54,	10,	10}, /*VOFF_GAIN_10*/
-	{0x00006E54,	20,	10}, /*VOFF_GAIN_11*/
-	{0x00006E58,	0,	10}, /*VOFF_GAIN_12*/
-	{0x00006E58,	10,	10}, /*VOFF_GAIN_13*/
-	{0x00006E58,	20,	10}, /*VOFF_GAIN_14*/
-	{0x00006E5C,	0,	10}, /*VOFF_GAIN_15*/
-	{0x00006E5C,	10,	10}, /*VOFF_GAIN_16*/
-	{0x00006E5C,	20,	10}, /*VOFF_GAIN_17*/
-	{0x00006E60,	0,	10}, /*VOFF_GAIN_18*/
-	{0x00006E60,	10,	10}, /*VOFF_GAIN_19*/
-	{0x00006E60,	20,	10}, /*VOFF_GAIN_20*/
-	{0x00006E64,	0,	10}, /*VOFF_INT1*/
-	{0x00007418,	7,	5}, /*DS_SPK_INT1_CAP_TRIM*/
-	{0x0000741C,	0,	5}, /*DS_SPK_INT2_CAP_TRIM*/
-	{0x0000741C,	11,	4}, /*DS_SPK_LPF_CAP_TRIM*/
-	{0x0000741C,	19,	4}, /*DS_SPK_QUAN_CAP_TRIM*/
-	{0x00007434,	17,	1}, /*FORCE_CAL*/
-	{0x00007434,	18,	7}, /*CAL_OVERRIDE*/
-	{0x00007068,	0,	9}, /*MODIX*/
-	{0x0000410C,	7,	1}, /*VIMON_DLY_NOT_COMB*/
-	{0x0000400C,	0,	7}, /*VIMON_DLY*/
-	{0x00000000,	0,	1}, /*extra bit*/
-	{0x00017040,	0,	8}, /*X_COORDINATE*/
-	{0x00017040,	8,	8}, /*Y_COORDINATE*/
-	{0x00017040,	16,	8}, /*WAFER_ID*/
-	{0x00017040,	24,	8}, /*DVS*/
-	{0x00017044,	0,	24}, /*LOT_NUMBER*/
+	{ 0x00002030,	0,	4 }, /*TRIM_OSC_FREQ_TRIM*/
+	{ 0x00002030,	7,	1 }, /*TRIM_OSC_TRIM_DONE*/
+	{ 0x0000208c,	24,	6 }, /*TST_DIGREG_VREF_TRIM*/
+	{ 0x00002090,	14,	4 }, /*TST_REF_TRIM*/
+	{ 0x00002090,	10,	4 }, /*TST_REF_TEMPCO_TRIM*/
+	{ 0x0000300C,	11,	4 }, /*PLL_LDOA_TST_VREF_TRIM*/
+	{ 0x0000394C,	23,	2 }, /*BST_ATEST_CM_VOFF*/
+	{ 0x00003950,	0,	7 }, /*BST_ATRIM_IADC_OFFSET*/
+	{ 0x00003950,	8,	7 }, /*BST_ATRIM_IADC_GAIN1*/
+	{ 0x00003950,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET1*/
+	{ 0x00003950,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN1*/
+	{ 0x00003954,	0,	7 }, /*BST_ATRIM_IADC_OFFSET2*/
+	{ 0x00003954,	8,	7 }, /*BST_ATRIM_IADC_GAIN2*/
+	{ 0x00003954,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET2*/
+	{ 0x00003954,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN2*/
+	{ 0x00003958,	0,	7 }, /*BST_ATRIM_IADC_OFFSET3*/
+	{ 0x00003958,	8,	7 }, /*BST_ATRIM_IADC_GAIN3*/
+	{ 0x00003958,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET3*/
+	{ 0x00003958,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN3*/
+	{ 0x0000395C,	0,	7 }, /*BST_ATRIM_IADC_OFFSET4*/
+	{ 0x0000395C,	8,	7 }, /*BST_ATRIM_IADC_GAIN4*/
+	{ 0x0000395C,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET4*/
+	{ 0x0000395C,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN4*/
+	{ 0x0000416C,	0,	8 }, /*VMON_GAIN_OTP_VAL*/
+	{ 0x00004160,	0,	7 }, /*VMON_OFFSET_OTP_VAL*/
+	{ 0x0000416C,	8,	8 }, /*IMON_GAIN_OTP_VAL*/
+	{ 0x00004160,	16,	10 }, /*IMON_OFFSET_OTP_VAL*/
+	{ 0x0000416C,	16,	12 }, /*VMON_CM_GAIN_OTP_VAL*/
+	{ 0x0000416C,	28,	1 }, /*VMON_CM_GAIN_SIGN_OTP_VAL*/
+	{ 0x00004170,	0,	6 }, /*IMON_CAL_TEMPCO_OTP_VAL*/
+	{ 0x00004170,	6,	1 }, /*IMON_CAL_TEMPCO_SIGN_OTP*/
+	{ 0x00004170,	8,	6 }, /*IMON_CAL_TEMPCO2_OTP_VAL*/
+	{ 0x00004170,	14,	1 }, /*IMON_CAL_TEMPCO2_DN_UPB_OTP_VAL*/
+	{ 0x00004170,	16,	9 }, /*IMON_CAL_TEMPCO_TBASE_OTP_VAL*/
+	{ 0x00004360,	0,	5 }, /*TEMP_GAIN_OTP_VAL*/
+	{ 0x00004360,	6,	9 }, /*TEMP_OFFSET_OTP_VAL*/
+	{ 0x00004448,	0,	8 }, /*VP_SARADC_OFFSET*/
+	{ 0x00004448,	8,	8 }, /*VP_GAIN_INDEX*/
+	{ 0x00004448,	16,	8 }, /*VBST_SARADC_OFFSET*/
+	{ 0x00004448,	24,	8 }, /*VBST_GAIN_INDEX*/
+	{ 0x0000444C,	0,	3 }, /*ANA_SELINVREF*/
+	{ 0x00006E30,	0,	5 }, /*GAIN_ERR_COEFF_0*/
+	{ 0x00006E30,	8,	5 }, /*GAIN_ERR_COEFF_1*/
+	{ 0x00006E30,	16,	5 }, /*GAIN_ERR_COEFF_2*/
+	{ 0x00006E30,	24,	5 }, /*GAIN_ERR_COEFF_3*/
+	{ 0x00006E34,	0,	5 }, /*GAIN_ERR_COEFF_4*/
+	{ 0x00006E34,	8,	5 }, /*GAIN_ERR_COEFF_5*/
+	{ 0x00006E34,	16,	5 }, /*GAIN_ERR_COEFF_6*/
+	{ 0x00006E34,	24,	5 }, /*GAIN_ERR_COEFF_7*/
+	{ 0x00006E38,	0,	5 }, /*GAIN_ERR_COEFF_8*/
+	{ 0x00006E38,	8,	5 }, /*GAIN_ERR_COEFF_9*/
+	{ 0x00006E38,	16,	5 }, /*GAIN_ERR_COEFF_10*/
+	{ 0x00006E38,	24,	5 }, /*GAIN_ERR_COEFF_11*/
+	{ 0x00006E3C,	0,	5 }, /*GAIN_ERR_COEFF_12*/
+	{ 0x00006E3C,	8,	5 }, /*GAIN_ERR_COEFF_13*/
+	{ 0x00006E3C,	16,	5 }, /*GAIN_ERR_COEFF_14*/
+	{ 0x00006E3C,	24,	5 }, /*GAIN_ERR_COEFF_15*/
+	{ 0x00006E40,	0,	5 }, /*GAIN_ERR_COEFF_16*/
+	{ 0x00006E40,	8,	5 }, /*GAIN_ERR_COEFF_17*/
+	{ 0x00006E40,	16,	5 }, /*GAIN_ERR_COEFF_18*/
+	{ 0x00006E40,	24,	5 }, /*GAIN_ERR_COEFF_19*/
+	{ 0x00006E44,	0,	5 }, /*GAIN_ERR_COEFF_20*/
+	{ 0x00006E48,	0,	10 }, /*VOFF_GAIN_0*/
+	{ 0x00006E48,	10,	10 }, /*VOFF_GAIN_1*/
+	{ 0x00006E48,	20,	10 }, /*VOFF_GAIN_2*/
+	{ 0x00006E4C,	0,	10 }, /*VOFF_GAIN_3*/
+	{ 0x00006E4C,	10,	10 }, /*VOFF_GAIN_4*/
+	{ 0x00006E4C,	20,	10 }, /*VOFF_GAIN_5*/
+	{ 0x00006E50,	0,	10 }, /*VOFF_GAIN_6*/
+	{ 0x00006E50,	10,	10 }, /*VOFF_GAIN_7*/
+	{ 0x00006E50,	20,	10 }, /*VOFF_GAIN_8*/
+	{ 0x00006E54,	0,	10 }, /*VOFF_GAIN_9*/
+	{ 0x00006E54,	10,	10 }, /*VOFF_GAIN_10*/
+	{ 0x00006E54,	20,	10 }, /*VOFF_GAIN_11*/
+	{ 0x00006E58,	0,	10 }, /*VOFF_GAIN_12*/
+	{ 0x00006E58,	10,	10 }, /*VOFF_GAIN_13*/
+	{ 0x00006E58,	20,	10 }, /*VOFF_GAIN_14*/
+	{ 0x00006E5C,	0,	10 }, /*VOFF_GAIN_15*/
+	{ 0x00006E5C,	10,	10 }, /*VOFF_GAIN_16*/
+	{ 0x00006E5C,	20,	10 }, /*VOFF_GAIN_17*/
+	{ 0x00006E60,	0,	10 }, /*VOFF_GAIN_18*/
+	{ 0x00006E60,	10,	10 }, /*VOFF_GAIN_19*/
+	{ 0x00006E60,	20,	10 }, /*VOFF_GAIN_20*/
+	{ 0x00006E64,	0,	10 }, /*VOFF_INT1*/
+	{ 0x00007418,	7,	5 }, /*DS_SPK_INT1_CAP_TRIM*/
+	{ 0x0000741C,	0,	5 }, /*DS_SPK_INT2_CAP_TRIM*/
+	{ 0x0000741C,	11,	4 }, /*DS_SPK_LPF_CAP_TRIM*/
+	{ 0x0000741C,	19,	4 }, /*DS_SPK_QUAN_CAP_TRIM*/
+	{ 0x00007434,	17,	1 }, /*FORCE_CAL*/
+	{ 0x00007434,	18,	7 }, /*CAL_OVERRIDE*/
+	{ 0x00007068,	0,	9 }, /*MODIX*/
+	{ 0x0000410C,	7,	1 }, /*VIMON_DLY_NOT_COMB*/
+	{ 0x0000400C,	0,	7 }, /*VIMON_DLY*/
+	{ 0x00000000,	0,	1 }, /*extra bit*/
+	{ 0x00017040,	0,	8 }, /*X_COORDINATE*/
+	{ 0x00017040,	8,	8 }, /*Y_COORDINATE*/
+	{ 0x00017040,	16,	8 }, /*WAFER_ID*/
+	{ 0x00017040,	24,	8 }, /*DVS*/
+	{ 0x00017044,	0,	24 }, /*LOT_NUMBER*/
 };
 
-static const struct cs35l41_otp_packed_element_t
-					otp_map_2[CS35L41_NUM_OTP_ELEM] = {
+static const struct cs35l41_otp_packed_element_t otp_map_2[CS35L41_NUM_OTP_ELEM] = {
 	/* addr         shift   size */
-	{0x00002030,	0,	4}, /*TRIM_OSC_FREQ_TRIM*/
-	{0x00002030,	7,	1}, /*TRIM_OSC_TRIM_DONE*/
-	{0x0000208c,	24,	6}, /*TST_DIGREG_VREF_TRIM*/
-	{0x00002090,	14,	4}, /*TST_REF_TRIM*/
-	{0x00002090,	10,	4}, /*TST_REF_TEMPCO_TRIM*/
-	{0x0000300C,	11,	4}, /*PLL_LDOA_TST_VREF_TRIM*/
-	{0x0000394C,	23,	2}, /*BST_ATEST_CM_VOFF*/
-	{0x00003950,	0,	7}, /*BST_ATRIM_IADC_OFFSET*/
-	{0x00003950,	8,	7}, /*BST_ATRIM_IADC_GAIN1*/
-	{0x00003950,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET1*/
-	{0x00003950,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN1*/
-	{0x00003954,	0,	7}, /*BST_ATRIM_IADC_OFFSET2*/
-	{0x00003954,	8,	7}, /*BST_ATRIM_IADC_GAIN2*/
-	{0x00003954,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET2*/
-	{0x00003954,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN2*/
-	{0x00003958,	0,	7}, /*BST_ATRIM_IADC_OFFSET3*/
-	{0x00003958,	8,	7}, /*BST_ATRIM_IADC_GAIN3*/
-	{0x00003958,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET3*/
-	{0x00003958,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN3*/
-	{0x0000395C,	0,	7}, /*BST_ATRIM_IADC_OFFSET4*/
-	{0x0000395C,	8,	7}, /*BST_ATRIM_IADC_GAIN4*/
-	{0x0000395C,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET4*/
-	{0x0000395C,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN4*/
-	{0x0000416C,	0,	8}, /*VMON_GAIN_OTP_VAL*/
-	{0x00004160,	0,	7}, /*VMON_OFFSET_OTP_VAL*/
-	{0x0000416C,	8,	8}, /*IMON_GAIN_OTP_VAL*/
-	{0x00004160,	16,	10}, /*IMON_OFFSET_OTP_VAL*/
-	{0x0000416C,	16,	12}, /*VMON_CM_GAIN_OTP_VAL*/
-	{0x0000416C,	28,	1}, /*VMON_CM_GAIN_SIGN_OTP_VAL*/
-	{0x00004170,	0,	6}, /*IMON_CAL_TEMPCO_OTP_VAL*/
-	{0x00004170,	6,	1}, /*IMON_CAL_TEMPCO_SIGN_OTP*/
-	{0x00004170,	8,	6}, /*IMON_CAL_TEMPCO2_OTP_VAL*/
-	{0x00004170,	14,	1}, /*IMON_CAL_TEMPCO2_DN_UPB_OTP_VAL*/
-	{0x00004170,	16,	9}, /*IMON_CAL_TEMPCO_TBASE_OTP_VAL*/
-	{0x00004360,	0,	5}, /*TEMP_GAIN_OTP_VAL*/
-	{0x00004360,	6,	9}, /*TEMP_OFFSET_OTP_VAL*/
-	{0x00004448,	0,	8}, /*VP_SARADC_OFFSET*/
-	{0x00004448,	8,	8}, /*VP_GAIN_INDEX*/
-	{0x00004448,	16,	8}, /*VBST_SARADC_OFFSET*/
-	{0x00004448,	24,	8}, /*VBST_GAIN_INDEX*/
-	{0x0000444C,	0,	3}, /*ANA_SELINVREF*/
-	{0x00006E30,	0,	5}, /*GAIN_ERR_COEFF_0*/
-	{0x00006E30,	8,	5}, /*GAIN_ERR_COEFF_1*/
-	{0x00006E30,	16,	5}, /*GAIN_ERR_COEFF_2*/
-	{0x00006E30,	24,	5}, /*GAIN_ERR_COEFF_3*/
-	{0x00006E34,	0,	5}, /*GAIN_ERR_COEFF_4*/
-	{0x00006E34,	8,	5}, /*GAIN_ERR_COEFF_5*/
-	{0x00006E34,	16,	5}, /*GAIN_ERR_COEFF_6*/
-	{0x00006E34,	24,	5}, /*GAIN_ERR_COEFF_7*/
-	{0x00006E38,	0,	5}, /*GAIN_ERR_COEFF_8*/
-	{0x00006E38,	8,	5}, /*GAIN_ERR_COEFF_9*/
-	{0x00006E38,	16,	5}, /*GAIN_ERR_COEFF_10*/
-	{0x00006E38,	24,	5}, /*GAIN_ERR_COEFF_11*/
-	{0x00006E3C,	0,	5}, /*GAIN_ERR_COEFF_12*/
-	{0x00006E3C,	8,	5}, /*GAIN_ERR_COEFF_13*/
-	{0x00006E3C,	16,	5}, /*GAIN_ERR_COEFF_14*/
-	{0x00006E3C,	24,	5}, /*GAIN_ERR_COEFF_15*/
-	{0x00006E40,	0,	5}, /*GAIN_ERR_COEFF_16*/
-	{0x00006E40,	8,	5}, /*GAIN_ERR_COEFF_17*/
-	{0x00006E40,	16,	5}, /*GAIN_ERR_COEFF_18*/
-	{0x00006E40,	24,	5}, /*GAIN_ERR_COEFF_19*/
-	{0x00006E44,	0,	5}, /*GAIN_ERR_COEFF_20*/
-	{0x00006E48,	0,	10}, /*VOFF_GAIN_0*/
-	{0x00006E48,	10,	10}, /*VOFF_GAIN_1*/
-	{0x00006E48,	20,	10}, /*VOFF_GAIN_2*/
-	{0x00006E4C,	0,	10}, /*VOFF_GAIN_3*/
-	{0x00006E4C,	10,	10}, /*VOFF_GAIN_4*/
-	{0x00006E4C,	20,	10}, /*VOFF_GAIN_5*/
-	{0x00006E50,	0,	10}, /*VOFF_GAIN_6*/
-	{0x00006E50,	10,	10}, /*VOFF_GAIN_7*/
-	{0x00006E50,	20,	10}, /*VOFF_GAIN_8*/
-	{0x00006E54,	0,	10}, /*VOFF_GAIN_9*/
-	{0x00006E54,	10,	10}, /*VOFF_GAIN_10*/
-	{0x00006E54,	20,	10}, /*VOFF_GAIN_11*/
-	{0x00006E58,	0,	10}, /*VOFF_GAIN_12*/
-	{0x00006E58,	10,	10}, /*VOFF_GAIN_13*/
-	{0x00006E58,	20,	10}, /*VOFF_GAIN_14*/
-	{0x00006E5C,	0,	10}, /*VOFF_GAIN_15*/
-	{0x00006E5C,	10,	10}, /*VOFF_GAIN_16*/
-	{0x00006E5C,	20,	10}, /*VOFF_GAIN_17*/
-	{0x00006E60,	0,	10}, /*VOFF_GAIN_18*/
-	{0x00006E60,	10,	10}, /*VOFF_GAIN_19*/
-	{0x00006E60,	20,	10}, /*VOFF_GAIN_20*/
-	{0x00006E64,	0,	10}, /*VOFF_INT1*/
-	{0x00007418,	7,	5}, /*DS_SPK_INT1_CAP_TRIM*/
-	{0x0000741C,	0,	5}, /*DS_SPK_INT2_CAP_TRIM*/
-	{0x0000741C,	11,	4}, /*DS_SPK_LPF_CAP_TRIM*/
-	{0x0000741C,	19,	4}, /*DS_SPK_QUAN_CAP_TRIM*/
-	{0x00007434,	17,	1}, /*FORCE_CAL*/
-	{0x00007434,	18,	7}, /*CAL_OVERRIDE*/
-	{0x00007068,	0,	9}, /*MODIX*/
-	{0x0000410C,	7,	1}, /*VIMON_DLY_NOT_COMB*/
-	{0x0000400C,	0,	7}, /*VIMON_DLY*/
-	{0x00004000,	11,	1}, /*VMON_POL*/
-	{0x00017040,	0,	8}, /*X_COORDINATE*/
-	{0x00017040,	8,	8}, /*Y_COORDINATE*/
-	{0x00017040,	16,	8}, /*WAFER_ID*/
-	{0x00017040,	24,	8}, /*DVS*/
-	{0x00017044,	0,	24}, /*LOT_NUMBER*/
+	{ 0x00002030,	0,	4 }, /*TRIM_OSC_FREQ_TRIM*/
+	{ 0x00002030,	7,	1 }, /*TRIM_OSC_TRIM_DONE*/
+	{ 0x0000208c,	24,	6 }, /*TST_DIGREG_VREF_TRIM*/
+	{ 0x00002090,	14,	4 }, /*TST_REF_TRIM*/
+	{ 0x00002090,	10,	4 }, /*TST_REF_TEMPCO_TRIM*/
+	{ 0x0000300C,	11,	4 }, /*PLL_LDOA_TST_VREF_TRIM*/
+	{ 0x0000394C,	23,	2 }, /*BST_ATEST_CM_VOFF*/
+	{ 0x00003950,	0,	7 }, /*BST_ATRIM_IADC_OFFSET*/
+	{ 0x00003950,	8,	7 }, /*BST_ATRIM_IADC_GAIN1*/
+	{ 0x00003950,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET1*/
+	{ 0x00003950,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN1*/
+	{ 0x00003954,	0,	7 }, /*BST_ATRIM_IADC_OFFSET2*/
+	{ 0x00003954,	8,	7 }, /*BST_ATRIM_IADC_GAIN2*/
+	{ 0x00003954,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET2*/
+	{ 0x00003954,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN2*/
+	{ 0x00003958,	0,	7 }, /*BST_ATRIM_IADC_OFFSET3*/
+	{ 0x00003958,	8,	7 }, /*BST_ATRIM_IADC_GAIN3*/
+	{ 0x00003958,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET3*/
+	{ 0x00003958,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN3*/
+	{ 0x0000395C,	0,	7 }, /*BST_ATRIM_IADC_OFFSET4*/
+	{ 0x0000395C,	8,	7 }, /*BST_ATRIM_IADC_GAIN4*/
+	{ 0x0000395C,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET4*/
+	{ 0x0000395C,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN4*/
+	{ 0x0000416C,	0,	8 }, /*VMON_GAIN_OTP_VAL*/
+	{ 0x00004160,	0,	7 }, /*VMON_OFFSET_OTP_VAL*/
+	{ 0x0000416C,	8,	8 }, /*IMON_GAIN_OTP_VAL*/
+	{ 0x00004160,	16,	10 }, /*IMON_OFFSET_OTP_VAL*/
+	{ 0x0000416C,	16,	12 }, /*VMON_CM_GAIN_OTP_VAL*/
+	{ 0x0000416C,	28,	1 }, /*VMON_CM_GAIN_SIGN_OTP_VAL*/
+	{ 0x00004170,	0,	6 }, /*IMON_CAL_TEMPCO_OTP_VAL*/
+	{ 0x00004170,	6,	1 }, /*IMON_CAL_TEMPCO_SIGN_OTP*/
+	{ 0x00004170,	8,	6 }, /*IMON_CAL_TEMPCO2_OTP_VAL*/
+	{ 0x00004170,	14,	1 }, /*IMON_CAL_TEMPCO2_DN_UPB_OTP_VAL*/
+	{ 0x00004170,	16,	9 }, /*IMON_CAL_TEMPCO_TBASE_OTP_VAL*/
+	{ 0x00004360,	0,	5 }, /*TEMP_GAIN_OTP_VAL*/
+	{ 0x00004360,	6,	9 }, /*TEMP_OFFSET_OTP_VAL*/
+	{ 0x00004448,	0,	8 }, /*VP_SARADC_OFFSET*/
+	{ 0x00004448,	8,	8 }, /*VP_GAIN_INDEX*/
+	{ 0x00004448,	16,	8 }, /*VBST_SARADC_OFFSET*/
+	{ 0x00004448,	24,	8 }, /*VBST_GAIN_INDEX*/
+	{ 0x0000444C,	0,	3 }, /*ANA_SELINVREF*/
+	{ 0x00006E30,	0,	5 }, /*GAIN_ERR_COEFF_0*/
+	{ 0x00006E30,	8,	5 }, /*GAIN_ERR_COEFF_1*/
+	{ 0x00006E30,	16,	5 }, /*GAIN_ERR_COEFF_2*/
+	{ 0x00006E30,	24,	5 }, /*GAIN_ERR_COEFF_3*/
+	{ 0x00006E34,	0,	5 }, /*GAIN_ERR_COEFF_4*/
+	{ 0x00006E34,	8,	5 }, /*GAIN_ERR_COEFF_5*/
+	{ 0x00006E34,	16,	5 }, /*GAIN_ERR_COEFF_6*/
+	{ 0x00006E34,	24,	5 }, /*GAIN_ERR_COEFF_7*/
+	{ 0x00006E38,	0,	5 }, /*GAIN_ERR_COEFF_8*/
+	{ 0x00006E38,	8,	5 }, /*GAIN_ERR_COEFF_9*/
+	{ 0x00006E38,	16,	5 }, /*GAIN_ERR_COEFF_10*/
+	{ 0x00006E38,	24,	5 }, /*GAIN_ERR_COEFF_11*/
+	{ 0x00006E3C,	0,	5 }, /*GAIN_ERR_COEFF_12*/
+	{ 0x00006E3C,	8,	5 }, /*GAIN_ERR_COEFF_13*/
+	{ 0x00006E3C,	16,	5 }, /*GAIN_ERR_COEFF_14*/
+	{ 0x00006E3C,	24,	5 }, /*GAIN_ERR_COEFF_15*/
+	{ 0x00006E40,	0,	5 }, /*GAIN_ERR_COEFF_16*/
+	{ 0x00006E40,	8,	5 }, /*GAIN_ERR_COEFF_17*/
+	{ 0x00006E40,	16,	5 }, /*GAIN_ERR_COEFF_18*/
+	{ 0x00006E40,	24,	5 }, /*GAIN_ERR_COEFF_19*/
+	{ 0x00006E44,	0,	5 }, /*GAIN_ERR_COEFF_20*/
+	{ 0x00006E48,	0,	10 }, /*VOFF_GAIN_0*/
+	{ 0x00006E48,	10,	10 }, /*VOFF_GAIN_1*/
+	{ 0x00006E48,	20,	10 }, /*VOFF_GAIN_2*/
+	{ 0x00006E4C,	0,	10 }, /*VOFF_GAIN_3*/
+	{ 0x00006E4C,	10,	10 }, /*VOFF_GAIN_4*/
+	{ 0x00006E4C,	20,	10 }, /*VOFF_GAIN_5*/
+	{ 0x00006E50,	0,	10 }, /*VOFF_GAIN_6*/
+	{ 0x00006E50,	10,	10 }, /*VOFF_GAIN_7*/
+	{ 0x00006E50,	20,	10 }, /*VOFF_GAIN_8*/
+	{ 0x00006E54,	0,	10 }, /*VOFF_GAIN_9*/
+	{ 0x00006E54,	10,	10 }, /*VOFF_GAIN_10*/
+	{ 0x00006E54,	20,	10 }, /*VOFF_GAIN_11*/
+	{ 0x00006E58,	0,	10 }, /*VOFF_GAIN_12*/
+	{ 0x00006E58,	10,	10 }, /*VOFF_GAIN_13*/
+	{ 0x00006E58,	20,	10 }, /*VOFF_GAIN_14*/
+	{ 0x00006E5C,	0,	10 }, /*VOFF_GAIN_15*/
+	{ 0x00006E5C,	10,	10 }, /*VOFF_GAIN_16*/
+	{ 0x00006E5C,	20,	10 }, /*VOFF_GAIN_17*/
+	{ 0x00006E60,	0,	10 }, /*VOFF_GAIN_18*/
+	{ 0x00006E60,	10,	10 }, /*VOFF_GAIN_19*/
+	{ 0x00006E60,	20,	10 }, /*VOFF_GAIN_20*/
+	{ 0x00006E64,	0,	10 }, /*VOFF_INT1*/
+	{ 0x00007418,	7,	5 }, /*DS_SPK_INT1_CAP_TRIM*/
+	{ 0x0000741C,	0,	5 }, /*DS_SPK_INT2_CAP_TRIM*/
+	{ 0x0000741C,	11,	4 }, /*DS_SPK_LPF_CAP_TRIM*/
+	{ 0x0000741C,	19,	4 }, /*DS_SPK_QUAN_CAP_TRIM*/
+	{ 0x00007434,	17,	1 }, /*FORCE_CAL*/
+	{ 0x00007434,	18,	7 }, /*CAL_OVERRIDE*/
+	{ 0x00007068,	0,	9 }, /*MODIX*/
+	{ 0x0000410C,	7,	1 }, /*VIMON_DLY_NOT_COMB*/
+	{ 0x0000400C,	0,	7 }, /*VIMON_DLY*/
+	{ 0x00004000,	11,	1 }, /*VMON_POL*/
+	{ 0x00017040,	0,	8 }, /*X_COORDINATE*/
+	{ 0x00017040,	8,	8 }, /*Y_COORDINATE*/
+	{ 0x00017040,	16,	8 }, /*WAFER_ID*/
+	{ 0x00017040,	24,	8 }, /*DVS*/
+	{ 0x00017044,	0,	24 }, /*LOT_NUMBER*/
 };
 
-const struct cs35l41_otp_map_element_t
-				cs35l41_otp_map_map[CS35L41_NUM_OTP_MAPS] = {
+const struct cs35l41_otp_map_element_t cs35l41_otp_map_map[CS35L41_NUM_OTP_MAPS] = {
 	{
 		.id = 0x01,
 		.map = otp_map_1,
diff --git a/sound/soc/codecs/cs35l41.c b/sound/soc/codecs/cs35l41.c
index cc158fe4b7fe..ad86c030d9cb 100644
--- a/sound/soc/codecs/cs35l41.c
+++ b/sound/soc/codecs/cs35l41.c
@@ -166,7 +166,8 @@ static const unsigned char cs35l41_bst_k2_table[4][5] = {
 };
 
 static const unsigned char cs35l41_bst_slope_table[4] = {
-					0x75, 0x6B, 0x3B, 0x28};
+	0x75, 0x6B, 0x3B, 0x28
+};
 
 static int cs35l41_get_fs_mon_config_index(int freq)
 {
@@ -189,7 +190,8 @@ static const struct snd_kcontrol_new dre_ctrl =
 	SOC_DAPM_SINGLE("Switch", CS35L41_PWR_CTRL3, 20, 1, 0);
 
 static const char * const cs35l41_pcm_sftramp_text[] =  {
-	"Off", ".5ms", "1ms", "2ms", "4ms", "8ms", "15ms", "30ms"};
+	"Off", ".5ms", "1ms", "2ms", "4ms", "8ms", "15ms", "30ms"
+};
 
 static SOC_ENUM_SINGLE_DECL(pcm_sft_ramp,
 			    CS35L41_AMP_DIG_VOL_CTRL, 0,
@@ -198,92 +200,88 @@ static SOC_ENUM_SINGLE_DECL(pcm_sft_ramp,
 static const char * const cs35l41_pcm_source_texts[] = {"ASP", "DSP"};
 static const unsigned int cs35l41_pcm_source_values[] = {0x08, 0x32};
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_pcm_source_enum,
-				CS35L41_DAC_PCM1_SRC,
-				0, CS35L41_ASP_SOURCE_MASK,
-				cs35l41_pcm_source_texts,
-				cs35l41_pcm_source_values);
+				  CS35L41_DAC_PCM1_SRC,
+				  0, CS35L41_ASP_SOURCE_MASK,
+				  cs35l41_pcm_source_texts,
+				  cs35l41_pcm_source_values);
 
 static const struct snd_kcontrol_new pcm_source_mux =
 	SOC_DAPM_ENUM("PCM Source", cs35l41_pcm_source_enum);
 
-static const char * const cs35l41_tx_input_texts[] = {"Zero", "ASPRX1",
-							"ASPRX2", "VMON",
-							"IMON", "VPMON",
-							"VBSTMON",
-							"DSPTX1", "DSPTX2"};
-static const unsigned int cs35l41_tx_input_values[] = {0x00,
-						CS35L41_INPUT_SRC_ASPRX1,
-						CS35L41_INPUT_SRC_ASPRX2,
-						CS35L41_INPUT_SRC_VMON,
-						CS35L41_INPUT_SRC_IMON,
-						CS35L41_INPUT_SRC_VPMON,
-						CS35L41_INPUT_SRC_VBSTMON,
-						CS35L41_INPUT_DSP_TX1,
-						CS35L41_INPUT_DSP_TX2};
+static const char * const cs35l41_tx_input_texts[] = {
+	"Zero", "ASPRX1", "ASPRX2", "VMON", "IMON",
+	"VPMON", "VBSTMON", "DSPTX1", "DSPTX2"
+};
+
+static const unsigned int cs35l41_tx_input_values[] = {
+	0x00, CS35L41_INPUT_SRC_ASPRX1, CS35L41_INPUT_SRC_ASPRX2,
+	CS35L41_INPUT_SRC_VMON, CS35L41_INPUT_SRC_IMON, CS35L41_INPUT_SRC_VPMON,
+	CS35L41_INPUT_SRC_VBSTMON, CS35L41_INPUT_DSP_TX1, CS35L41_INPUT_DSP_TX2
+};
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx1_enum,
-				CS35L41_ASP_TX1_SRC,
-				0, CS35L41_ASP_SOURCE_MASK,
-				cs35l41_tx_input_texts,
-				cs35l41_tx_input_values);
+				  CS35L41_ASP_TX1_SRC,
+				  0, CS35L41_ASP_SOURCE_MASK,
+				  cs35l41_tx_input_texts,
+				  cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new asp_tx1_mux =
 	SOC_DAPM_ENUM("ASPTX1 SRC", cs35l41_asptx1_enum);
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx2_enum,
-				CS35L41_ASP_TX2_SRC,
-				0, CS35L41_ASP_SOURCE_MASK,
-				cs35l41_tx_input_texts,
-				cs35l41_tx_input_values);
+				  CS35L41_ASP_TX2_SRC,
+				  0, CS35L41_ASP_SOURCE_MASK,
+				  cs35l41_tx_input_texts,
+				  cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new asp_tx2_mux =
 	SOC_DAPM_ENUM("ASPTX2 SRC", cs35l41_asptx2_enum);
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx3_enum,
-				CS35L41_ASP_TX3_SRC,
-				0, CS35L41_ASP_SOURCE_MASK,
-				cs35l41_tx_input_texts,
-				cs35l41_tx_input_values);
+				  CS35L41_ASP_TX3_SRC,
+				  0, CS35L41_ASP_SOURCE_MASK,
+				  cs35l41_tx_input_texts,
+				  cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new asp_tx3_mux =
 	SOC_DAPM_ENUM("ASPTX3 SRC", cs35l41_asptx3_enum);
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx4_enum,
-				CS35L41_ASP_TX4_SRC,
-				0, CS35L41_ASP_SOURCE_MASK,
-				cs35l41_tx_input_texts,
-				cs35l41_tx_input_values);
+				  CS35L41_ASP_TX4_SRC,
+				  0, CS35L41_ASP_SOURCE_MASK,
+				  cs35l41_tx_input_texts,
+				  cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new asp_tx4_mux =
 	SOC_DAPM_ENUM("ASPTX4 SRC", cs35l41_asptx4_enum);
 
 static const struct snd_kcontrol_new cs35l41_aud_controls[] = {
 	SOC_SINGLE_SX_TLV("Digital PCM Volume", CS35L41_AMP_DIG_VOL_CTRL,
-		      3, 0x4CF, 0x391, dig_vol_tlv),
+			  3, 0x4CF, 0x391, dig_vol_tlv),
 	SOC_SINGLE_TLV("Analog PCM Volume", CS35L41_AMP_GAIN_CTRL, 5, 0x14, 0,
-			amp_gain_tlv),
+		       amp_gain_tlv),
 	SOC_ENUM("PCM Soft Ramp", pcm_sft_ramp),
 	SOC_SINGLE("HW Noise Gate Enable", CS35L41_NG_CFG, 8, 63, 0),
 	SOC_SINGLE("HW Noise Gate Delay", CS35L41_NG_CFG, 4, 7, 0),
 	SOC_SINGLE("HW Noise Gate Threshold", CS35L41_NG_CFG, 0, 7, 0),
 	SOC_SINGLE("Aux Noise Gate CH1 Enable",
-				CS35L41_MIXER_NGATE_CH1_CFG, 16, 1, 0),
+		   CS35L41_MIXER_NGATE_CH1_CFG, 16, 1, 0),
 	SOC_SINGLE("Aux Noise Gate CH1 Entry Delay",
-				CS35L41_MIXER_NGATE_CH1_CFG, 8, 15, 0),
+		   CS35L41_MIXER_NGATE_CH1_CFG, 8, 15, 0),
 	SOC_SINGLE("Aux Noise Gate CH1 Threshold",
-				CS35L41_MIXER_NGATE_CH1_CFG, 0, 7, 0),
+		   CS35L41_MIXER_NGATE_CH1_CFG, 0, 7, 0),
 	SOC_SINGLE("Aux Noise Gate CH2 Entry Delay",
-				CS35L41_MIXER_NGATE_CH2_CFG, 8, 15, 0),
+		   CS35L41_MIXER_NGATE_CH2_CFG, 8, 15, 0),
 	SOC_SINGLE("Aux Noise Gate CH2 Enable",
-				CS35L41_MIXER_NGATE_CH2_CFG, 16, 1, 0),
+		   CS35L41_MIXER_NGATE_CH2_CFG, 16, 1, 0),
 	SOC_SINGLE("Aux Noise Gate CH2 Threshold",
-				CS35L41_MIXER_NGATE_CH2_CFG, 0, 7, 0),
+		   CS35L41_MIXER_NGATE_CH2_CFG, 0, 7, 0),
 	SOC_SINGLE("SCLK Force", CS35L41_SP_FORMAT, CS35L41_SCLK_FRC_SHIFT, 1, 0),
 	SOC_SINGLE("LRCLK Force", CS35L41_SP_FORMAT, CS35L41_LRCLK_FRC_SHIFT, 1, 0),
 	SOC_SINGLE("Invert Class D", CS35L41_AMP_DIG_VOL_CTRL,
-				CS35L41_AMP_INV_PCM_SHIFT, 1, 0),
+		   CS35L41_AMP_INV_PCM_SHIFT, 1, 0),
 	SOC_SINGLE("Amp Gain ZC", CS35L41_AMP_GAIN_CTRL,
-				CS35L41_AMP_GAIN_ZC_SHIFT, 1, 0),
+		   CS35L41_AMP_GAIN_ZC_SHIFT, 1, 0),
 };
 
 static const struct cs35l41_otp_map_element_t *cs35l41_find_otp_map(u32 otp_id)
@@ -309,8 +307,7 @@ static int cs35l41_otp_unpack(void *data)
 	u32 otp_val, otp_id_reg;
 	u32 *otp_mem;
 
-	otp_mem = kmalloc_array(CS35L41_OTP_SIZE_WORDS, sizeof(*otp_mem),
-							GFP_KERNEL);
+	otp_mem = kmalloc_array(CS35L41_OTP_SIZE_WORDS, sizeof(*otp_mem), GFP_KERNEL);
 	if (!otp_mem)
 		return -ENOMEM;
 
@@ -324,7 +321,7 @@ static int cs35l41_otp_unpack(void *data)
 
 	if (!otp_map_match) {
 		dev_err(cs35l41->dev, "OTP Map matching ID %d not found\n",
-				otp_id_reg);
+			otp_id_reg);
 		ret = -EINVAL;
 		goto err_otp_unpack;
 	}
@@ -333,7 +330,7 @@ static int cs35l41_otp_unpack(void *data)
 		cs35l41->otp_setup(cs35l41, true, &orig_spi_freq);
 
 	ret = regmap_bulk_read(cs35l41->regmap, CS35L41_OTP_MEM0, otp_mem,
-						CS35L41_OTP_SIZE_WORDS);
+			       CS35L41_OTP_SIZE_WORDS);
 	if (ret < 0) {
 		dev_err(cs35l41->dev, "Read OTP Mem failed: %d\n", ret);
 		goto err_otp_unpack;
@@ -360,8 +357,8 @@ static int cs35l41_otp_unpack(void *data)
 
 	for (i = 0; i < otp_map_match->num_elements; i++) {
 		dev_dbg(cs35l41->dev,
-			   "bitoffset= %d, word_offset=%d, bit_sum mod 32=%d\n",
-					 bit_offset, word_offset, bit_sum % 32);
+			"bitoffset= %d, word_offset=%d, bit_sum mod 32=%d\n",
+			bit_offset, word_offset, bit_sum % 32);
 		if (bit_offset + otp_map[i].size - 1 >= 32) {
 			otp_val = (otp_mem[word_offset] &
 					GENMASK(31, bit_offset)) >>
@@ -372,7 +369,6 @@ static int cs35l41_otp_unpack(void *data)
 					(32 - bit_offset);
 			bit_offset += otp_map[i].size - 32;
 		} else {
-
 			otp_val = (otp_mem[word_offset] &
 				GENMASK(bit_offset + otp_map[i].size - 1,
 					bit_offset)) >>	bit_offset;
@@ -387,13 +383,14 @@ static int cs35l41_otp_unpack(void *data)
 
 		if (otp_map[i].reg != 0) {
 			ret = regmap_update_bits(cs35l41->regmap,
-						otp_map[i].reg,
-						GENMASK(otp_map[i].shift +
-							otp_map[i].size - 1,
-						otp_map[i].shift),
-						otp_val << otp_map[i].shift);
+						 otp_map[i].reg,
+						 GENMASK(otp_map[i].shift +
+							 otp_map[i].size - 1,
+						 otp_map[i].shift),
+						 otp_val << otp_map[i].shift);
 			if (ret < 0) {
-				dev_err(cs35l41->dev, "Write OTP val failed: %d\n", ret);
+				dev_err(cs35l41->dev, "Write OTP val failed: %d\n",
+					ret);
 				goto err_otp_unpack;
 			}
 		}
@@ -435,12 +432,12 @@ static irqreturn_t cs35l41_irq(int irq, void *data)
 
 	/* Check to see if unmasked bits are active */
 	if (!(status[0] & ~masks[0]) && !(status[1] & ~masks[1]) &&
-		!(status[2] & ~masks[2]) && !(status[3] & ~masks[3]))
+	    !(status[2] & ~masks[2]) && !(status[3] & ~masks[3]))
 		return IRQ_NONE;
 
 	if (status[3] & CS35L41_OTP_BOOT_DONE) {
 		regmap_update_bits(cs35l41->regmap, CS35L41_IRQ1_MASK4,
-				CS35L41_OTP_BOOT_DONE, CS35L41_OTP_BOOT_DONE);
+				   CS35L41_OTP_BOOT_DONE, CS35L41_OTP_BOOT_DONE);
 	}
 
 	/*
@@ -451,96 +448,93 @@ static irqreturn_t cs35l41_irq(int irq, void *data)
 	if (status[0] & CS35L41_AMP_SHORT_ERR) {
 		dev_crit_ratelimited(cs35l41->dev, "Amp short error\n");
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-					CS35L41_AMP_SHORT_ERR);
+			     CS35L41_AMP_SHORT_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_AMP_SHORT_ERR_RLS,
-					CS35L41_AMP_SHORT_ERR_RLS);
+				   CS35L41_AMP_SHORT_ERR_RLS,
+				   CS35L41_AMP_SHORT_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_AMP_SHORT_ERR_RLS, 0);
+				   CS35L41_AMP_SHORT_ERR_RLS, 0);
 		ret = IRQ_HANDLED;
 	}
 
 	if (status[0] & CS35L41_TEMP_WARN) {
 		dev_crit_ratelimited(cs35l41->dev, "Over temperature warning\n");
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-					CS35L41_TEMP_WARN);
+			     CS35L41_TEMP_WARN);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_TEMP_WARN_ERR_RLS,
-					CS35L41_TEMP_WARN_ERR_RLS);
+				   CS35L41_TEMP_WARN_ERR_RLS,
+				   CS35L41_TEMP_WARN_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_TEMP_WARN_ERR_RLS, 0);
+				   CS35L41_TEMP_WARN_ERR_RLS, 0);
 		ret = IRQ_HANDLED;
 	}
 
 	if (status[0] & CS35L41_TEMP_ERR) {
 		dev_crit_ratelimited(cs35l41->dev, "Over temperature error\n");
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-					CS35L41_TEMP_ERR);
+			     CS35L41_TEMP_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_TEMP_ERR_RLS,
-					CS35L41_TEMP_ERR_RLS);
+				   CS35L41_TEMP_ERR_RLS,
+				   CS35L41_TEMP_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_TEMP_ERR_RLS, 0);
+				   CS35L41_TEMP_ERR_RLS, 0);
 		ret = IRQ_HANDLED;
 	}
 
 	if (status[0] & CS35L41_BST_OVP_ERR) {
 		dev_crit_ratelimited(cs35l41->dev, "VBST Over Voltage error\n");
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-					CS35L41_BST_EN_MASK, 0);
+				   CS35L41_BST_EN_MASK, 0);
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-					CS35L41_BST_OVP_ERR);
+			     CS35L41_BST_OVP_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_BST_OVP_ERR_RLS,
-					CS35L41_BST_OVP_ERR_RLS);
+				   CS35L41_BST_OVP_ERR_RLS,
+				   CS35L41_BST_OVP_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_BST_OVP_ERR_RLS, 0);
+				   CS35L41_BST_OVP_ERR_RLS, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-					CS35L41_BST_EN_MASK,
-					CS35L41_BST_EN_DEFAULT <<
-					CS35L41_BST_EN_SHIFT);
+				   CS35L41_BST_EN_MASK,
+				   CS35L41_BST_EN_DEFAULT << CS35L41_BST_EN_SHIFT);
 		ret = IRQ_HANDLED;
 	}
 
 	if (status[0] & CS35L41_BST_DCM_UVP_ERR) {
 		dev_crit_ratelimited(cs35l41->dev, "DCM VBST Under Voltage Error\n");
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-					CS35L41_BST_EN_MASK, 0);
+				   CS35L41_BST_EN_MASK, 0);
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-					CS35L41_BST_DCM_UVP_ERR);
+			     CS35L41_BST_DCM_UVP_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_BST_UVP_ERR_RLS,
-					CS35L41_BST_UVP_ERR_RLS);
+				   CS35L41_BST_UVP_ERR_RLS,
+				   CS35L41_BST_UVP_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_BST_UVP_ERR_RLS, 0);
+				   CS35L41_BST_UVP_ERR_RLS, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-					CS35L41_BST_EN_MASK,
-					CS35L41_BST_EN_DEFAULT <<
-					CS35L41_BST_EN_SHIFT);
+				   CS35L41_BST_EN_MASK,
+				   CS35L41_BST_EN_DEFAULT << CS35L41_BST_EN_SHIFT);
 		ret = IRQ_HANDLED;
 	}
 
 	if (status[0] & CS35L41_BST_SHORT_ERR) {
 		dev_crit_ratelimited(cs35l41->dev, "LBST error: powering off!\n");
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-					CS35L41_BST_EN_MASK, 0);
+				   CS35L41_BST_EN_MASK, 0);
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-					CS35L41_BST_SHORT_ERR);
+			     CS35L41_BST_SHORT_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_BST_SHORT_ERR_RLS,
-					CS35L41_BST_SHORT_ERR_RLS);
+				   CS35L41_BST_SHORT_ERR_RLS,
+				   CS35L41_BST_SHORT_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-					CS35L41_BST_SHORT_ERR_RLS, 0);
+				   CS35L41_BST_SHORT_ERR_RLS, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-					CS35L41_BST_EN_MASK,
-					CS35L41_BST_EN_DEFAULT <<
-					CS35L41_BST_EN_SHIFT);
+				   CS35L41_BST_EN_MASK,
+				   CS35L41_BST_EN_DEFAULT << CS35L41_BST_EN_SHIFT);
 		ret = IRQ_HANDLED;
 	}
 
@@ -564,12 +558,10 @@ static const struct reg_sequence cs35l41_pdn_patch[] = {
 };
 
 static int cs35l41_main_amp_event(struct snd_soc_dapm_widget *w,
-		struct snd_kcontrol *kcontrol, int event)
+				  struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_component *component =
-		snd_soc_dapm_to_component(w->dapm);
-	struct cs35l41_private *cs35l41 =
-		snd_soc_component_get_drvdata(component);
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
 	unsigned int val;
 	int ret = 0;
 	bool pdn;
@@ -577,18 +569,18 @@ static int cs35l41_main_amp_event(struct snd_soc_dapm_widget *w,
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
 		regmap_multi_reg_write_bypassed(cs35l41->regmap,
-					cs35l41_pup_patch,
-					ARRAY_SIZE(cs35l41_pup_patch));
+						cs35l41_pup_patch,
+						ARRAY_SIZE(cs35l41_pup_patch));
 
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL1,
-				CS35L41_GLOBAL_EN_MASK,
-				1 << CS35L41_GLOBAL_EN_SHIFT);
+				   CS35L41_GLOBAL_EN_MASK,
+				   1 << CS35L41_GLOBAL_EN_SHIFT);
 
 		usleep_range(1000, 1100);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL1,
-				CS35L41_GLOBAL_EN_MASK, 0);
+				   CS35L41_GLOBAL_EN_MASK, 0);
 
 		pdn = false;
 		ret = regmap_read_poll_timeout(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
@@ -598,16 +590,17 @@ static int cs35l41_main_amp_event(struct snd_soc_dapm_widget *w,
 			dev_warn(cs35l41->dev, "PDN failed: %d\n", ret);
 
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-				CS35L41_PDN_DONE_MASK);
+			     CS35L41_PDN_DONE_MASK);
 
 		regmap_multi_reg_write_bypassed(cs35l41->regmap,
-					cs35l41_pdn_patch,
-					ARRAY_SIZE(cs35l41_pdn_patch));
+						cs35l41_pdn_patch,
+						ARRAY_SIZE(cs35l41_pdn_patch));
 		break;
 	default:
 		dev_err(cs35l41->dev, "Invalid event = 0x%x\n", event);
 		ret = -EINVAL;
 	}
+
 	return ret;
 }
 
@@ -629,8 +622,8 @@ static const struct snd_soc_dapm_widget cs35l41_dapm_widgets[] = {
 	SND_SOC_DAPM_ADC("CLASS H", NULL, CS35L41_PWR_CTRL3, 4, 0),
 
 	SND_SOC_DAPM_OUT_DRV_E("Main AMP", CS35L41_PWR_CTRL2, 0, 0, NULL, 0,
-				cs35l41_main_amp_event,
-				SND_SOC_DAPM_POST_PMD |	SND_SOC_DAPM_POST_PMU),
+			       cs35l41_main_amp_event,
+			       SND_SOC_DAPM_POST_PMD |	SND_SOC_DAPM_POST_PMU),
 
 	SND_SOC_DAPM_INPUT("VP"),
 	SND_SOC_DAPM_INPUT("VBST"),
@@ -647,7 +640,6 @@ static const struct snd_soc_dapm_widget cs35l41_dapm_widgets[] = {
 };
 
 static const struct snd_soc_dapm_route cs35l41_audio_map[] = {
-
 	{"ASP TX1 Source", "VMON", "VMON ADC"},
 	{"ASP TX1 Source", "IMON", "IMON ADC"},
 	{"ASP TX1 Source", "VPMON", "VPMON ADC"},
@@ -696,15 +688,13 @@ static const struct snd_soc_dapm_route cs35l41_audio_map[] = {
 
 	{"PCM Source", "ASP", "ASPRX1"},
 	{"CLASS H", NULL, "PCM Source"},
-
 };
 
 static int cs35l41_set_channel_map(struct snd_soc_dai *dai, unsigned int tx_num,
-				unsigned int *tx_slot, unsigned int rx_num,
-				unsigned int *rx_slot)
+				   unsigned int *tx_slot, unsigned int rx_num,
+				   unsigned int *rx_slot)
 {
-	struct cs35l41_private *cs35l41 =
-			snd_soc_component_get_drvdata(dai->component);
+	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);
 	unsigned int val, mask;
 	int i;
 
@@ -732,10 +722,9 @@ static int cs35l41_set_channel_map(struct snd_soc_dai *dai, unsigned int tx_num,
 	return 0;
 }
 
-static int cs35l41_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+static int cs35l41_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	struct cs35l41_private *cs35l41 =
-			snd_soc_component_get_drvdata(codec_dai->component);
+	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);
 	unsigned int daifmt = 0;
 
 	switch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {
@@ -808,8 +797,7 @@ static int cs35l41_pcm_hw_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
 				 struct snd_soc_dai *dai)
 {
-	struct cs35l41_private *cs35l41 =
-			snd_soc_component_get_drvdata(dai->component);
+	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);
 	unsigned int rate = params_rate(params);
 	u8 asp_wl;
 	int i;
@@ -828,23 +816,23 @@ static int cs35l41_pcm_hw_params(struct snd_pcm_substream *substream,
 
 	if (i < ARRAY_SIZE(cs35l41_fs_rates))
 		regmap_update_bits(cs35l41->regmap, CS35L41_GLOBAL_CLK_CTRL,
-			CS35L41_GLOBAL_FS_MASK,
-			cs35l41_fs_rates[i].fs_cfg << CS35L41_GLOBAL_FS_SHIFT);
+				   CS35L41_GLOBAL_FS_MASK,
+				   cs35l41_fs_rates[i].fs_cfg << CS35L41_GLOBAL_FS_SHIFT);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
-				CS35L41_ASP_WIDTH_RX_MASK,
-				asp_wl << CS35L41_ASP_WIDTH_RX_SHIFT);
+				   CS35L41_ASP_WIDTH_RX_MASK,
+				   asp_wl << CS35L41_ASP_WIDTH_RX_SHIFT);
 		regmap_update_bits(cs35l41->regmap, CS35L41_SP_RX_WL,
-				CS35L41_ASP_RX_WL_MASK,
-				asp_wl << CS35L41_ASP_RX_WL_SHIFT);
+				   CS35L41_ASP_RX_WL_MASK,
+				   asp_wl << CS35L41_ASP_RX_WL_SHIFT);
 	} else {
 		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
-				CS35L41_ASP_WIDTH_TX_MASK,
-				asp_wl << CS35L41_ASP_WIDTH_TX_SHIFT);
+				   CS35L41_ASP_WIDTH_TX_MASK,
+				   asp_wl << CS35L41_ASP_WIDTH_TX_SHIFT);
 		regmap_update_bits(cs35l41->regmap, CS35L41_SP_TX_WL,
-				CS35L41_ASP_TX_WL_MASK,
-				asp_wl << CS35L41_ASP_TX_WL_SHIFT);
+				   CS35L41_ASP_TX_WL_MASK,
+				   asp_wl << CS35L41_ASP_TX_WL_SHIFT);
 	}
 
 	return 0;
@@ -877,16 +865,16 @@ static int cs35l41_pcm_startup(struct snd_pcm_substream *substream,
 {
 	if (substream->runtime)
 		return snd_pcm_hw_constraint_list(substream->runtime, 0,
-				SNDRV_PCM_HW_PARAM_RATE, &cs35l41_constraints);
+						  SNDRV_PCM_HW_PARAM_RATE,
+						  &cs35l41_constraints);
 	return 0;
 }
 
 static int cs35l41_component_set_sysclk(struct snd_soc_component *component,
-				int clk_id, int source, unsigned int freq,
-				int dir)
+					int clk_id, int source,
+					unsigned int freq, int dir)
 {
-	struct cs35l41_private *cs35l41 =
-				       snd_soc_component_get_drvdata(component);
+	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
 	int extclk_cfg, clksrc;
 
 	switch (clk_id) {
@@ -913,47 +901,47 @@ static int cs35l41_component_set_sysclk(struct snd_soc_component *component,
 	}
 
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			CS35L41_PLL_OPENLOOP_MASK,
-			1 << CS35L41_PLL_OPENLOOP_SHIFT);
+			   CS35L41_PLL_OPENLOOP_MASK,
+			   1 << CS35L41_PLL_OPENLOOP_SHIFT);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			CS35L41_REFCLK_FREQ_MASK,
-			extclk_cfg << CS35L41_REFCLK_FREQ_SHIFT);
+			   CS35L41_REFCLK_FREQ_MASK,
+			   extclk_cfg << CS35L41_REFCLK_FREQ_SHIFT);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			CS35L41_PLL_CLK_EN_MASK,
-			0 << CS35L41_PLL_CLK_EN_SHIFT);
+			   CS35L41_PLL_CLK_EN_MASK,
+			   0 << CS35L41_PLL_CLK_EN_SHIFT);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			CS35L41_PLL_CLK_SEL_MASK, clksrc);
+			   CS35L41_PLL_CLK_SEL_MASK, clksrc);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			CS35L41_PLL_OPENLOOP_MASK,
-			0 << CS35L41_PLL_OPENLOOP_SHIFT);
+			   CS35L41_PLL_OPENLOOP_MASK,
+			   0 << CS35L41_PLL_OPENLOOP_SHIFT);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			CS35L41_PLL_CLK_EN_MASK,
-			1 << CS35L41_PLL_CLK_EN_SHIFT);
+			   CS35L41_PLL_CLK_EN_MASK,
+			   1 << CS35L41_PLL_CLK_EN_SHIFT);
 
 	return 0;
 }
 
 static int cs35l41_dai_set_sysclk(struct snd_soc_dai *dai,
-					int clk_id, unsigned int freq, int dir)
+				  int clk_id, unsigned int freq, int dir)
 {
-	struct cs35l41_private *cs35l41 =
-				  snd_soc_component_get_drvdata(dai->component);
+	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);
 	unsigned int fs1_val;
 	unsigned int fs2_val;
 	unsigned int val;
-	int fsIndex;
+	int fsindex;
 
-	fsIndex = cs35l41_get_fs_mon_config_index(freq);
-	if (fsIndex < 0) {
+	fsindex = cs35l41_get_fs_mon_config_index(freq);
+	if (fsindex < 0) {
 		dev_err(cs35l41->dev, "Invalid CLK Config freq: %u\n", freq);
 		return -EINVAL;
 	}
 
 	dev_dbg(cs35l41->dev, "Set DAI sysclk %d\n", freq);
+
 	if (freq <= 6144000) {
 		/* Use the lookup table */
-		fs1_val = cs35l41_fs_mon[fsIndex].fs1;
-		fs2_val = cs35l41_fs_mon[fsIndex].fs2;
+		fs1_val = cs35l41_fs_mon[fsindex].fs1;
+		fs2_val = cs35l41_fs_mon[fsindex].fs2;
 	} else {
 		/* Use hard-coded values */
 		fs1_val = 0x10;
@@ -968,7 +956,7 @@ static int cs35l41_dai_set_sysclk(struct snd_soc_dai *dai,
 }
 
 static int cs35l41_boost_config(struct cs35l41_private *cs35l41,
-		int boost_ind, int boost_cap, int boost_ipk)
+				int boost_ind, int boost_cap, int boost_ipk)
 {
 	unsigned char bst_lbst_val, bst_cbst_range, bst_ipk_scaled;
 	struct regmap *regmap = cs35l41->regmap;
@@ -989,8 +977,7 @@ static int cs35l41_boost_config(struct cs35l41_private *cs35l41,
 		bst_lbst_val = 3;
 		break;
 	default:
-		dev_err(dev, "Invalid boost inductor value: %d nH\n",
-				boost_ind);
+		dev_err(dev, "Invalid boost inductor value: %d nH\n", boost_ind);
 		return -EINVAL;
 	}
 
@@ -1032,16 +1019,16 @@ static int cs35l41_boost_config(struct cs35l41_private *cs35l41,
 		return ret;
 	}
 
-	if ((boost_ipk < 1600) || (boost_ipk > 4500)) {
+	if (boost_ipk < 1600 || boost_ipk > 4500) {
 		dev_err(dev, "Invalid boost inductor peak current: %d mA\n",
-				boost_ipk);
+			boost_ipk);
 		return -EINVAL;
 	}
 	bst_ipk_scaled = ((boost_ipk - 1600) / 50) + 0x10;
 
 	ret = regmap_update_bits(regmap, CS35L41_BSTCVRT_PEAK_CUR,
-			CS35L41_BST_IPK_MASK,
-			bst_ipk_scaled << CS35L41_BST_IPK_SHIFT);
+				 CS35L41_BST_IPK_MASK,
+				 bst_ipk_scaled << CS35L41_BST_IPK_SHIFT);
 	if (ret) {
 		dev_err(dev, "Failed to write boost inductor peak current: %d\n", ret);
 		return ret;
@@ -1059,8 +1046,8 @@ static int cs35l41_set_pdata(struct cs35l41_private *cs35l41)
 	if (cs35l41->pdata.bst_ipk &&
 	    cs35l41->pdata.bst_ind && cs35l41->pdata.bst_cap) {
 		ret = cs35l41_boost_config(cs35l41, cs35l41->pdata.bst_ind,
-					cs35l41->pdata.bst_cap,
-					cs35l41->pdata.bst_ipk);
+					   cs35l41->pdata.bst_cap,
+					   cs35l41->pdata.bst_ipk);
 		if (ret) {
 			dev_err(cs35l41->dev, "Error in Boost DT config: %d\n", ret);
 			return ret;
@@ -1074,8 +1061,8 @@ static int cs35l41_set_pdata(struct cs35l41_private *cs35l41)
 	if (cs35l41->pdata.dout_hiz <= CS35L41_ASP_DOUT_HIZ_MASK &&
 	    cs35l41->pdata.dout_hiz >= 0)
 		regmap_update_bits(cs35l41->regmap, CS35L41_SP_HIZ_CTRL,
-				CS35L41_ASP_DOUT_HIZ_MASK,
-				cs35l41->pdata.dout_hiz);
+				   CS35L41_ASP_DOUT_HIZ_MASK,
+				   cs35l41->pdata.dout_hiz);
 
 	return 0;
 }
@@ -1158,8 +1145,8 @@ static const struct snd_soc_component_driver soc_component_dev_cs35l41 = {
 };
 
 static int cs35l41_handle_pdata(struct device *dev,
-				  struct cs35l41_platform_data *pdata,
-				  struct cs35l41_private *cs35l41)
+				struct cs35l41_platform_data *pdata,
+				struct cs35l41_private *cs35l41)
 {
 	struct cs35l41_irq_cfg *irq_gpio1_config = &pdata->irq_config1;
 	struct cs35l41_irq_cfg *irq_gpio2_config = &pdata->irq_config2;
@@ -1190,11 +1177,9 @@ static int cs35l41_handle_pdata(struct device *dev,
 	irq_gpio1_config->irq_out_en = device_property_read_bool(dev,
 					"cirrus,gpio1-output-enable");
 	ret = device_property_read_u32(dev, "cirrus,gpio1-src-select",
-				&val);
-	if (ret >= 0) {
-		val |= CS35L41_VALID_PDATA;
-		irq_gpio1_config->irq_src_sel = val;
-	}
+				       &val);
+	if (ret >= 0)
+		irq_gpio1_config->irq_src_sel = val | CS35L41_VALID_PDATA;
 
 	/* GPIO2 Pin Config */
 	irq_gpio2_config->irq_pol_inv = device_property_read_bool(dev,
@@ -1202,11 +1187,9 @@ static int cs35l41_handle_pdata(struct device *dev,
 	irq_gpio2_config->irq_out_en = device_property_read_bool(dev,
 					"cirrus,gpio2-output-enable");
 	ret = device_property_read_u32(dev, "cirrus,gpio2-src-select",
-				&val);
-	if (ret >= 0) {
-		val |= CS35L41_VALID_PDATA;
-		irq_gpio2_config->irq_src_sel = val;
-	}
+				       &val);
+	if (ret >= 0)
+		irq_gpio2_config->irq_src_sel = val | CS35L41_VALID_PDATA;
 
 	return 0;
 }
@@ -1257,7 +1240,7 @@ static const struct reg_sequence cs35l41_revb2_errata_patch[] = {
 };
 
 int cs35l41_probe(struct cs35l41_private *cs35l41,
-				struct cs35l41_platform_data *pdata)
+		  struct cs35l41_platform_data *pdata)
 {
 	u32 regid, reg_revid, i, mtl_revid, int_status, chipid_match;
 	int irq_pol = 0;
@@ -1266,8 +1249,7 @@ int cs35l41_probe(struct cs35l41_private *cs35l41,
 	if (pdata) {
 		cs35l41->pdata = *pdata;
 	} else {
-		ret = cs35l41_handle_pdata(cs35l41->dev, &cs35l41->pdata,
-					     cs35l41);
+		ret = cs35l41_handle_pdata(cs35l41->dev, &cs35l41->pdata, cs35l41);
 		if (ret != 0)
 			return ret;
 	}
@@ -1276,24 +1258,21 @@ int cs35l41_probe(struct cs35l41_private *cs35l41,
 		cs35l41->supplies[i].supply = cs35l41_supplies[i];
 
 	ret = devm_regulator_bulk_get(cs35l41->dev, CS35L41_NUM_SUPPLIES,
-					cs35l41->supplies);
+				      cs35l41->supplies);
 	if (ret != 0) {
-		dev_err(cs35l41->dev,
-			"Failed to request core supplies: %d\n",
-			ret);
+		dev_err(cs35l41->dev, "Failed to request core supplies: %d\n", ret);
 		return ret;
 	}
 
 	ret = regulator_bulk_enable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);
 	if (ret != 0) {
-		dev_err(cs35l41->dev,
-			"Failed to enable core supplies: %d\n", ret);
+		dev_err(cs35l41->dev, "Failed to enable core supplies: %d\n", ret);
 		return ret;
 	}
 
 	/* returning NULL can be an option if in stereo mode */
 	cs35l41->reset_gpio = devm_gpiod_get_optional(cs35l41->dev, "reset",
-							GPIOD_OUT_LOW);
+						      GPIOD_OUT_LOW);
 	if (IS_ERR(cs35l41->reset_gpio)) {
 		ret = PTR_ERR(cs35l41->reset_gpio);
 		cs35l41->reset_gpio = NULL;
@@ -1358,8 +1337,8 @@ int cs35l41_probe(struct cs35l41_private *cs35l41,
 	switch (reg_revid) {
 	case CS35L41_REVID_A0:
 		ret = regmap_register_patch(cs35l41->regmap,
-				cs35l41_reva0_errata_patch,
-				ARRAY_SIZE(cs35l41_reva0_errata_patch));
+					    cs35l41_reva0_errata_patch,
+					    ARRAY_SIZE(cs35l41_reva0_errata_patch));
 		if (ret < 0) {
 			dev_err(cs35l41->dev,
 				"Failed to apply A0 errata patch: %d\n", ret);
@@ -1368,8 +1347,8 @@ int cs35l41_probe(struct cs35l41_private *cs35l41,
 		break;
 	case CS35L41_REVID_B0:
 		ret = regmap_register_patch(cs35l41->regmap,
-				cs35l41_revb0_errata_patch,
-				ARRAY_SIZE(cs35l41_revb0_errata_patch));
+					    cs35l41_revb0_errata_patch,
+					    ARRAY_SIZE(cs35l41_revb0_errata_patch));
 		if (ret < 0) {
 			dev_err(cs35l41->dev,
 				"Failed to apply B0 errata patch: %d\n", ret);
@@ -1378,8 +1357,8 @@ int cs35l41_probe(struct cs35l41_private *cs35l41,
 		break;
 	case CS35L41_REVID_B2:
 		ret = regmap_register_patch(cs35l41->regmap,
-				cs35l41_revb2_errata_patch,
-				ARRAY_SIZE(cs35l41_revb2_errata_patch));
+					    cs35l41_revb2_errata_patch,
+					    ARRAY_SIZE(cs35l41_revb2_errata_patch));
 		if (ret < 0) {
 			dev_err(cs35l41->dev,
 				"Failed to apply B2 errata patch: %d\n", ret);
@@ -1392,11 +1371,11 @@ int cs35l41_probe(struct cs35l41_private *cs35l41,
 
 	/* Set interrupt masks for critical errors */
 	regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1,
-			CS35L41_INT1_MASK_DEFAULT);
+		     CS35L41_INT1_MASK_DEFAULT);
 
-	ret = devm_request_threaded_irq(cs35l41->dev, cs35l41->irq, NULL,
-			cs35l41_irq, IRQF_ONESHOT | IRQF_SHARED | irq_pol,
-			"cs35l41", cs35l41);
+	ret = devm_request_threaded_irq(cs35l41->dev, cs35l41->irq, NULL, cs35l41_irq,
+					IRQF_ONESHOT | IRQF_SHARED | irq_pol,
+					"cs35l41", cs35l41);
 
 	/* CS35L41 needs INT for PDN_DONE */
 	if (ret != 0) {
@@ -1437,21 +1416,22 @@ int cs35l41_probe(struct cs35l41_private *cs35l41,
 	}
 
 	ret = devm_snd_soc_register_component(cs35l41->dev,
-					&soc_component_dev_cs35l41,
-					cs35l41_dai, ARRAY_SIZE(cs35l41_dai));
+					      &soc_component_dev_cs35l41,
+					      cs35l41_dai, ARRAY_SIZE(cs35l41_dai));
 	if (ret < 0) {
 		dev_err(cs35l41->dev, "Register codec failed: %d\n", ret);
 		goto err;
 	}
 
 	dev_info(cs35l41->dev, "Cirrus Logic CS35L41 (%x), Revision: %02X\n",
-			regid, reg_revid);
+		 regid, reg_revid);
 
 	return 0;
 
 err:
 	regulator_bulk_disable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);
 	gpiod_set_value_cansleep(cs35l41->reset_gpio, 0);
+
 	return ret;
 }
 
@@ -1460,6 +1440,7 @@ int cs35l41_remove(struct cs35l41_private *cs35l41)
 	regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1, 0xFFFFFFFF);
 	regulator_bulk_disable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);
 	gpiod_set_value_cansleep(cs35l41->reset_gpio, 0);
+
 	return 0;
 }
 
diff --git a/sound/soc/codecs/cs35l41.h b/sound/soc/codecs/cs35l41.h
index ec1b00b47d5d..0e2639d6ef19 100644
--- a/sound/soc/codecs/cs35l41.h
+++ b/sound/soc/codecs/cs35l41.h
@@ -498,42 +498,42 @@
 #define CS35L41_DIGPWM_IOCTRL		0x0000706C
 
 /*registers populated by OTP*/
-#define CS35L41_OTP_TRIM_1	0x0000208c
-#define CS35L41_OTP_TRIM_2	0x00002090
-#define CS35L41_OTP_TRIM_3	0x00003010
-#define CS35L41_OTP_TRIM_4	0x0000300C
-#define CS35L41_OTP_TRIM_5	0x0000394C
-#define CS35L41_OTP_TRIM_6	0x00003950
-#define CS35L41_OTP_TRIM_7	0x00003954
-#define CS35L41_OTP_TRIM_8	0x00003958
-#define CS35L41_OTP_TRIM_9	0x0000395C
-#define CS35L41_OTP_TRIM_10	0x0000416C
-#define CS35L41_OTP_TRIM_11	0x00004160
-#define CS35L41_OTP_TRIM_12	0x00004170
-#define CS35L41_OTP_TRIM_13	0x00004360
-#define CS35L41_OTP_TRIM_14	0x00004448
-#define CS35L41_OTP_TRIM_15	0x0000444C
-#define CS35L41_OTP_TRIM_16	0x00006E30
-#define CS35L41_OTP_TRIM_17	0x00006E34
-#define CS35L41_OTP_TRIM_18	0x00006E38
-#define CS35L41_OTP_TRIM_19	0x00006E3C
-#define CS35L41_OTP_TRIM_20	0x00006E40
-#define CS35L41_OTP_TRIM_21	0x00006E44
-#define CS35L41_OTP_TRIM_22	0x00006E48
-#define CS35L41_OTP_TRIM_23	0x00006E4C
-#define CS35L41_OTP_TRIM_24	0x00006E50
-#define CS35L41_OTP_TRIM_25	0x00006E54
-#define CS35L41_OTP_TRIM_26	0x00006E58
-#define CS35L41_OTP_TRIM_27	0x00006E5C
-#define CS35L41_OTP_TRIM_28	0x00006E60
-#define CS35L41_OTP_TRIM_29	0x00006E64
-#define CS35L41_OTP_TRIM_30	0x00007418
-#define CS35L41_OTP_TRIM_31	0x0000741C
-#define CS35L41_OTP_TRIM_32	0x00007434
-#define CS35L41_OTP_TRIM_33	0x00007068
-#define CS35L41_OTP_TRIM_34	0x0000410C
-#define CS35L41_OTP_TRIM_35	0x0000400C
-#define CS35L41_OTP_TRIM_36	0x00002030
+#define CS35L41_OTP_TRIM_1		0x0000208c
+#define CS35L41_OTP_TRIM_2		0x00002090
+#define CS35L41_OTP_TRIM_3		0x00003010
+#define CS35L41_OTP_TRIM_4		0x0000300C
+#define CS35L41_OTP_TRIM_5		0x0000394C
+#define CS35L41_OTP_TRIM_6		0x00003950
+#define CS35L41_OTP_TRIM_7		0x00003954
+#define CS35L41_OTP_TRIM_8		0x00003958
+#define CS35L41_OTP_TRIM_9		0x0000395C
+#define CS35L41_OTP_TRIM_10		0x0000416C
+#define CS35L41_OTP_TRIM_11		0x00004160
+#define CS35L41_OTP_TRIM_12		0x00004170
+#define CS35L41_OTP_TRIM_13		0x00004360
+#define CS35L41_OTP_TRIM_14		0x00004448
+#define CS35L41_OTP_TRIM_15		0x0000444C
+#define CS35L41_OTP_TRIM_16		0x00006E30
+#define CS35L41_OTP_TRIM_17		0x00006E34
+#define CS35L41_OTP_TRIM_18		0x00006E38
+#define CS35L41_OTP_TRIM_19		0x00006E3C
+#define CS35L41_OTP_TRIM_20		0x00006E40
+#define CS35L41_OTP_TRIM_21		0x00006E44
+#define CS35L41_OTP_TRIM_22		0x00006E48
+#define CS35L41_OTP_TRIM_23		0x00006E4C
+#define CS35L41_OTP_TRIM_24		0x00006E50
+#define CS35L41_OTP_TRIM_25		0x00006E54
+#define CS35L41_OTP_TRIM_26		0x00006E58
+#define CS35L41_OTP_TRIM_27		0x00006E5C
+#define CS35L41_OTP_TRIM_28		0x00006E60
+#define CS35L41_OTP_TRIM_29		0x00006E64
+#define CS35L41_OTP_TRIM_30		0x00007418
+#define CS35L41_OTP_TRIM_31		0x0000741C
+#define CS35L41_OTP_TRIM_32		0x00007434
+#define CS35L41_OTP_TRIM_33		0x00007068
+#define CS35L41_OTP_TRIM_34		0x0000410C
+#define CS35L41_OTP_TRIM_35		0x0000400C
+#define CS35L41_OTP_TRIM_36		0x00002030
 
 #define CS35L41_MAX_CACHE_REG		36
 #define CS35L41_OTP_SIZE_WORDS		32
@@ -691,7 +691,6 @@
 #define CS35L41_TEMP_WARN_ERR_RLS	0x20
 #define CS35L41_TEMP_ERR_RLS		0x40
 
-
 #define CS35L41_INT1_MASK_DEFAULT	0x7FFCFE3F
 #define CS35L41_INT1_UNMASK_PUP		0xFEFFFFFF
 #define CS35L41_INT1_UNMASK_PDN		0xFF7FFFFF
@@ -709,7 +708,7 @@
 #define CS35L41_GPIO_POL_SHIFT		12
 
 #define CS35L41_AMP_INV_PCM_SHIFT	14
-#define CS35L41_AMP_INV_PCM_MASK	(1 << CS35L41_AMP_INV_PCM_SHIFT)
+#define CS35L41_AMP_INV_PCM_MASK	BIT(CS35L41_AMP_INV_PCM_SHIFT)
 #define CS35L41_AMP_PCM_VOL_SHIFT	3
 #define CS35L41_AMP_PCM_VOL_MASK	(0x7FF << 3)
 #define CS35L41_AMP_PCM_VOL_MUTE	0x4CF
@@ -754,7 +753,7 @@ extern const struct reg_default cs35l41_reg[CS35L41_MAX_CACHE_REG];
 extern const struct cs35l41_otp_map_element_t
 				cs35l41_otp_map_map[CS35L41_NUM_OTP_MAPS];
 
-#define CS35L41_REGSTRIDE			4
+#define CS35L41_REGSTRIDE		4
 
 struct cs35l41_private {
 	struct snd_soc_codec *codec;
@@ -766,11 +765,11 @@ struct cs35l41_private {
 	/* GPIO for /RST */
 	struct gpio_desc *reset_gpio;
 	void (*otp_setup)(struct cs35l41_private *cs35l41, bool is_pre_setup,
-				unsigned int *freq);
+			  unsigned int *freq);
 };
 
 int cs35l41_probe(struct cs35l41_private *cs35l41,
-						struct cs35l41_platform_data *pdata);
+		  struct cs35l41_platform_data *pdata);
 int cs35l41_remove(struct cs35l41_private *cs35l41);
 
 #endif /*__CS35L41_H__*/
-- 
2.35.3

