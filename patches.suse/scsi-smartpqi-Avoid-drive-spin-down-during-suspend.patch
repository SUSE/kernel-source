From: Sagar Biradar <sagar.biradar@microchip.com>
Date: Tue, 1 Feb 2022 15:48:33 -0600
Subject: scsi: smartpqi: Avoid drive spin-down during suspend
Patch-mainline: v5.18-rc1
Git-commit: b73357a1fd39cec82b654421110e35e8167930d5
References: jsc#PED-1557

On certain systems (based on PCI IDs), when the OS transitions the system
into the suspend (S3) state, the BMIC flush cache command will indicate a
system RESTART instead of SUSPEND.

This avoids drive spin-down.

Link: https://lore.kernel.org/r/164375211330.440833.7203813692110347698.stgit@brunhilda.pdev.net
Reviewed-by: Kevin Barnett <kevin.barnett@microchip.com>
Reviewed-by: Scott Benesh <scott.benesh@microchip.com>
Reviewed-by: Scott Teel <scott.teel@microchip.com>
Signed-off-by: Sagar Biradar <sagar.biradar@microchip.com>
Signed-off-by: Don Brace <don.brace@microchip.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Acked-by: Martin Wilck <mwilck@suse.com>
---
 drivers/scsi/smartpqi/smartpqi_init.c |   11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@ -8976,10 +8976,19 @@ static void pqi_process_module_params(vo
 	pqi_process_lockup_action_param();
 }
 
+static inline enum bmic_flush_cache_shutdown_event pqi_get_flush_cache_shutdown_event(struct pci_dev *pci_dev)
+{
+	if (pci_dev->subsystem_vendor == PCI_VENDOR_ID_ADAPTEC2 && pci_dev->subsystem_device == 0x1304)
+		return RESTART;
+	return SUSPEND;
+}
+
 static __maybe_unused int pqi_suspend(struct pci_dev *pci_dev, pm_message_t state)
 {
 	struct pqi_ctrl_info *ctrl_info;
+	enum bmic_flush_cache_shutdown_event shutdown_event;
 
+	shutdown_event = pqi_get_flush_cache_shutdown_event(pci_dev);
 	ctrl_info = pci_get_drvdata(pci_dev);
 
 	pqi_wait_until_ofa_finished(ctrl_info);
@@ -8989,7 +8998,7 @@ static __maybe_unused int pqi_suspend(st
 	pqi_ctrl_block_device_reset(ctrl_info);
 	pqi_ctrl_block_requests(ctrl_info);
 	pqi_ctrl_wait_until_quiesced(ctrl_info);
-	pqi_flush_cache(ctrl_info, SUSPEND);
+	pqi_flush_cache(ctrl_info, shutdown_event);
 	pqi_stop_heartbeat_timer(ctrl_info);
 
 	pqi_crash_if_pending_command(ctrl_info);
