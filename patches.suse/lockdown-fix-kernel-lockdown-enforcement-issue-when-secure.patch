From 6b5ef62853a660182662d87230e9fcba9d7c36ce Mon Sep 17 00:00:00 2001
From: Srish Srinivasan <ssrish@linux.ibm.com>
Date: Thu, 13 Mar 2025 10:40:43 +0100
Subject: [PATCH] lockdown: fix kernel lockdown enforcement issue when secure 
 boot is enabled
Patch-mainline: Never, SUSE specific
References: bsc#1237521

On secure boot enabled systems, the kernel is expected to be locked down early
in setup_arch. The registration of the lockdown LSM's hook list is carried
out as a part of early_security_init. But early_security_init is no longer
happening before setup_arch after the inclusion of the patch series (Reduce
overhead of LSMs with static calls).
Link: https://lore.kernel.org/all/20240816154307.3031838-1-kpsingh@kernel.org/

Access the lockdown LSM's hook list directly from security_lock_kernel_down and
security_locked_down. Define a macro to invoke a hook function upon getting
the hook list and the hook name. This enforces lockdown when secure boot is enabled.

These changes are based on the SLES-16 Linux Kernel source code, src rpm
version is 6.12.0-slfo.1.2.2.

Fixes: 77b644c39d6a ("init/main.c: Initialize early LSMs after arch code, static keys and calls.")
Signed-off-by: Srish Srinivasan <ssrish@linux.ibm.com>
Reviewed-by: Nayna Jain <nayna@linux.ibm.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 include/linux/lsm_hooks.h    |  5 +++++
 security/lockdown/lockdown.c |  2 ++
 security/security.c          | 14 ++++++++++++--
 3 files changed, 19 insertions(+), 2 deletions(-)

diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
index 090d1d3e1..62db97f81 100644
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@ -173,6 +173,11 @@ extern struct lsm_static_calls_table static_calls_table __ro_after_init;
 extern struct lsm_info __start_lsm_info[], __end_lsm_info[];
 extern struct lsm_info __start_early_lsm_info[], __end_early_lsm_info[];
 
+extern struct security_hook_list* lockdown_hooks_secure_boot;
+
+#define INDEX_LOCKED_DOWN 0
+#define INDEX_LOCK_KERNEL_DOWN 1
+
 /**
  * lsm_get_xattr_slot - Return the next available slot and increment the index
  * @xattrs: array storing LSM-provided xattrs
diff --git a/security/lockdown/lockdown.c b/security/lockdown/lockdown.c
index ddf496f7f..5542fcf9a 100644
--- a/security/lockdown/lockdown.c
+++ b/security/lockdown/lockdown.c
@@ -77,6 +77,8 @@ static struct security_hook_list lockdown_hooks[] __ro_after_init = {
 	LSM_HOOK_INIT(lock_kernel_down, lock_kernel_down),
 };
 
+struct security_hook_list *lockdown_hooks_secure_boot = lockdown_hooks;
+
 static const struct lsm_id lockdown_lsmid = {
 	.name = "lockdown",
 	.id = LSM_ID_LOCKDOWN,
diff --git a/security/security.c b/security/security.c
index 32952b2bc..36e52e2cd 100644
--- a/security/security.c
+++ b/security/security.c
@@ -983,6 +983,16 @@ OUT:									\
 	     scall - static_calls_table.NAME < MAX_LSM_COUNT; scall++)  \
 		if (static_key_enabled(&scall->active->key))
 
+#define call_int_hook_direct(HOOK_DESC, INDEX, HOOK, ...)		\
+({									\
+	int RC = LSM_RET_DEFAULT(HOOK);					\
+	do {								\
+		struct security_hook_list *P = &HOOK_DESC[INDEX];	\
+		RC = P->hook.HOOK(__VA_ARGS__);				\
+	} while (0);							\
+	RC;								\
+})
+
 /* Security operations */
 
 /**
@@ -5765,7 +5775,7 @@ void security_bpf_token_free(struct bpf_token *token)
  */
 int security_locked_down(enum lockdown_reason what)
 {
-	return call_int_hook(locked_down, what);
+	return call_int_hook_direct(lockdown_hooks_secure_boot, INDEX_LOCKED_DOWN, locked_down, what);
 }
 EXPORT_SYMBOL(security_locked_down);
 
@@ -5779,7 +5789,7 @@ EXPORT_SYMBOL(security_locked_down);
  */
 int security_lock_kernel_down(const char *where, enum lockdown_reason level)
 {
-	return call_int_hook(lock_kernel_down, where, level);
+	return call_int_hook_direct(lockdown_hooks_secure_boot, INDEX_LOCK_KERNEL_DOWN, lock_kernel_down, where, level);
 }
 EXPORT_SYMBOL(security_lock_kernel_down);
 
-- 
2.46.1
