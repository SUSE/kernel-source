From: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
Date: Tue, 23 Nov 2021 19:43:05 +0100
Subject: ACPI: EC: Avoid queuing unnecessary work in acpi_ec_submit_event()
Patch-mainline: v5.17-rc1
Git-commit: c793570d8725e44b64dbe466eb8ecda34c5eb8ac
References: jsc#PED-1408

Notice that it is not necessary to queue up the event work again
if the while () loop in acpi_ec_event_handler() is still running
which is the case if nr_pending_queries is greater than 0 at the
beginning of acpi_ec_submit_event() and modify the code to avoid
doing that.

While at it, rename nr_pending_queries in struct acpi_ec to
events_to_process which actually matches the role of that field
and change its data type to unsigned int which is sufficient.

No expected functional impact.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/acpi/ec.c       |   17 +++++++++++++----
 drivers/acpi/internal.h |    2 +-
 2 files changed, 14 insertions(+), 5 deletions(-)

--- a/drivers/acpi/ec.c
+++ b/drivers/acpi/ec.c
@@ -453,7 +453,16 @@ static bool acpi_ec_submit_event(struct
 	if (!test_and_set_bit(EC_FLAGS_QUERY_PENDING, &ec->flags)) {
 		ec_dbg_evt("Command(%s) submitted/blocked",
 			   acpi_ec_cmd_string(ACPI_EC_COMMAND_QUERY));
-		ec->nr_pending_queries++;
+		/*
+		 * If events_to_process is greqter than 0 at this point, the
+		 * while () loop in acpi_ec_event_handler() is still running
+		 * and incrementing events_to_process will cause it to invoke
+		 * acpi_ec_submit_query() once more, so it is not necessary to
+		 * queue up the event work to start the same loop again.
+		 */
+		if (ec->events_to_process++ > 0)
+			return true;
+
 		ec->events_in_progress++;
 		return queue_work(ec_wq, &ec->work);
 	}
@@ -665,7 +674,7 @@ static bool advance_transaction(struct a
 	 */
 	if (!t || !(t->flags & ACPI_EC_COMMAND_POLL)) {
 		if (ec_event_clearing == ACPI_EC_EVT_TIMING_EVENT &&
-		    (!ec->nr_pending_queries ||
+		    (!ec->events_to_process ||
 		     test_bit(EC_FLAGS_QUERY_GUARDING, &ec->flags))) {
 			clear_bit(EC_FLAGS_QUERY_GUARDING, &ec->flags);
 			acpi_ec_close_event(ec);
@@ -1223,13 +1232,13 @@ static void acpi_ec_event_handler(struct
 
 	spin_lock_irq(&ec->lock);
 
-	while (ec->nr_pending_queries) {
+	while (ec->events_to_process) {
 		spin_unlock_irq(&ec->lock);
 
 		acpi_ec_submit_query(ec);
 
 		spin_lock_irq(&ec->lock);
-		ec->nr_pending_queries--;
+		ec->events_to_process--;
 	}
 
 	/*
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -182,7 +182,7 @@ struct acpi_ec {
 	spinlock_t lock;
 	struct work_struct work;
 	unsigned long timestamp;
-	unsigned long nr_pending_queries;
+	unsigned int events_to_process;
 	unsigned int events_in_progress;
 	unsigned int queries_in_progress;
 	bool busy_polling;
