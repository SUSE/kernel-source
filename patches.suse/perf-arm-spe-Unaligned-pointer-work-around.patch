From: Ian Rogers <irogers@google.com>
Date: Mon, 13 May 2024 22:24:02 -0700
Subject: perf arm-spe: Unaligned pointer work around
Git-commit: cbd446b4db7efce27311f3186f81c2a2d906dd60
Patch-mainline: v6.11-rc1
References: perf-sp7-v6.11-userspace-update

Use get_unaligned_leXX instead of leXX_to_cpu to handle unaligned
pointers. Such pointers occur with libFuzzer testing.

A similar change for intel-pt was done in:
https://lore.kernel.org/r/20231005190451.175568-6-adrian.hunter@intel.com

Signed-off-by: Ian Rogers <irogers@google.com>
Reviewed-by: James Clark <james.clark@arm.com>
Signed-off-by: Namhyung Kim <namhyung@kernel.org>
Link: https://lore.kernel.org/r/20240514052402.3031871-1-irogers@google.com

Signed-off-by: Tony Jones <tonyj@suse.de>
---
 .../util/arm-spe-decoder/arm-spe-pkt-decoder.c     | 23 +++++-----------------
 1 file changed, 5 insertions(+), 18 deletions(-)

diff --git a/tools/perf/util/arm-spe-decoder/arm-spe-pkt-decoder.c b/tools/perf/util/arm-spe-decoder/arm-spe-pkt-decoder.c
index a454c6737563..7bf607d0f6d8 100644
--- a/tools/perf/util/arm-spe-decoder/arm-spe-pkt-decoder.c
+++ b/tools/perf/util/arm-spe-decoder/arm-spe-pkt-decoder.c
@@ -10,24 +10,11 @@
 #include <byteswap.h>
 #include <linux/bitops.h>
 #include <stdarg.h>
+#include <linux/kernel.h>
+#include <asm-generic/unaligned.h>
 
 #include "arm-spe-pkt-decoder.h"
 
-#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
-#define le16_to_cpu bswap_16
-#define le32_to_cpu bswap_32
-#define le64_to_cpu bswap_64
-#define memcpy_le64(d, s, n) do { \
-	memcpy((d), (s), (n));    \
-	*(d) = le64_to_cpu(*(d)); \
-} while (0)
-#else
-#define le16_to_cpu
-#define le32_to_cpu
-#define le64_to_cpu
-#define memcpy_le64 memcpy
-#endif
-
 static const char * const arm_spe_packet_name[] = {
 	[ARM_SPE_PAD]		= "PAD",
 	[ARM_SPE_END]		= "END",
@@ -70,9 +57,9 @@ static int arm_spe_get_payload(const unsigned char *buf, size_t len,
 
 	switch (payload_len) {
 	case 1: packet->payload = *(uint8_t *)buf; break;
-	case 2: packet->payload = le16_to_cpu(*(uint16_t *)buf); break;
-	case 4: packet->payload = le32_to_cpu(*(uint32_t *)buf); break;
-	case 8: packet->payload = le64_to_cpu(*(uint64_t *)buf); break;
+	case 2: packet->payload = get_unaligned_le16(buf); break;
+	case 4: packet->payload = get_unaligned_le32(buf); break;
+	case 8: packet->payload = get_unaligned_le64(buf); break;
 	default: return ARM_SPE_BAD_PACKET;
 	}
 

