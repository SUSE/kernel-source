From 2fddc930d9b11fc29c665b85cee3e81fc0de8f95 Mon Sep 17 00:00:00 2001
From: Francois Dugast <francois.dugast@intel.com>
Date: Wed, 19 Jul 2023 13:51:08 +0000
Subject: drm/xe: Cleanup style warnings and errors
Git-commit: 72e8d73b712d2232019b33d2331099d3071ea94a
Patch-mainline: v6.8-rc1
References: drm-backport-placeholder

Fix 6 errors and 20 warnings reported by checkpatch.pl.

Signed-off-by: Francois Dugast <francois.dugast@intel.com>
Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/xe/xe_bo.c              |  2 +-
 drivers/gpu/drm/xe/xe_gt_mcr.c          |  2 +-
 drivers/gpu/drm/xe/xe_gt_sysfs.c        |  4 +---
 drivers/gpu/drm/xe/xe_guc.c             | 14 ++++++--------
 drivers/gpu/drm/xe/xe_hw_engine_types.h |  2 +-
 drivers/gpu/drm/xe/xe_map.h             |  2 +-
 drivers/gpu/drm/xe/xe_migrate.c         |  2 +-
 drivers/gpu/drm/xe/xe_reg_whitelist.c   | 24 ++++++++++++++++++------
 drivers/gpu/drm/xe/xe_res_cursor.h      | 11 +++++------
 drivers/gpu/drm/xe/xe_wopcm.c           | 10 ++++------
 10 files changed, 39 insertions(+), 34 deletions(-)

diff --git a/drivers/gpu/drm/xe/xe_bo.c b/drivers/gpu/drm/xe/xe_bo.c
index a3bb14aa2234..49c80e95222b 100644
--- a/drivers/gpu/drm/xe/xe_bo.c
+++ b/drivers/gpu/drm/xe/xe_bo.c
@@ -1831,7 +1831,7 @@ int xe_bo_lock(struct xe_bo *bo, struct ww_acquire_ctx *ww,
 	XE_BUG_ON(!ww);
 
 	tv_bo.num_shared = num_resv;
-	tv_bo.bo = &bo->ttm;;
+	tv_bo.bo = &bo->ttm;
 	list_add_tail(&tv_bo.head, &objs);
 
 	return ttm_eu_reserve_buffers(ww, &objs, intr, &dups);
diff --git a/drivers/gpu/drm/xe/xe_gt_mcr.c b/drivers/gpu/drm/xe/xe_gt_mcr.c
index ff4075387564..c56815af0686 100644
--- a/drivers/gpu/drm/xe/xe_gt_mcr.c
+++ b/drivers/gpu/drm/xe/xe_gt_mcr.c
@@ -273,7 +273,7 @@ static void init_steering_inst0(struct xe_gt *gt)
 
 static const struct {
 	const char *name;
-	void (*init)(struct xe_gt *);
+	void (*init)(struct xe_gt *gt);
 } xe_steering_types[] = {
 	[L3BANK] =	{ "L3BANK",	init_steering_l3bank },
 	[MSLICE] =	{ "MSLICE",	init_steering_mslice },
diff --git a/drivers/gpu/drm/xe/xe_gt_sysfs.c b/drivers/gpu/drm/xe/xe_gt_sysfs.c
index b955940e8dc6..c69d2e8a0fe1 100644
--- a/drivers/gpu/drm/xe/xe_gt_sysfs.c
+++ b/drivers/gpu/drm/xe/xe_gt_sysfs.c
@@ -37,10 +37,8 @@ void xe_gt_sysfs_init(struct xe_gt *gt)
 	int err;
 
 	kg = kzalloc(sizeof(*kg), GFP_KERNEL);
-	if (!kg) {
-		drm_warn(&xe->drm, "Allocating kobject failed.\n");
+	if (!kg)
 		return;
-	}
 
 	kobject_init(&kg->base, &xe_gt_sysfs_kobj_type);
 	kg->gt = gt;
diff --git a/drivers/gpu/drm/xe/xe_guc.c b/drivers/gpu/drm/xe/xe_guc.c
index ed90d738d673..8ae026838702 100644
--- a/drivers/gpu/drm/xe/xe_guc.c
+++ b/drivers/gpu/drm/xe/xe_guc.c
@@ -396,14 +396,12 @@ static int guc_wait_ucode(struct xe_guc *guc)
 		struct drm_printer p = drm_info_printer(drm->dev);
 
 		drm_info(drm, "GuC load failed: status = 0x%08X\n", status);
-		drm_info(drm, "GuC load failed: status: Reset = %d, "
-			"BootROM = 0x%02X, UKernel = 0x%02X, "
-			"MIA = 0x%02X, Auth = 0x%02X\n",
-			REG_FIELD_GET(GS_MIA_IN_RESET, status),
-			REG_FIELD_GET(GS_BOOTROM_MASK, status),
-			REG_FIELD_GET(GS_UKERNEL_MASK, status),
-			REG_FIELD_GET(GS_MIA_MASK, status),
-			REG_FIELD_GET(GS_AUTH_STATUS_MASK, status));
+		drm_info(drm, "GuC load failed: status: Reset = %d, BootROM = 0x%02X, UKernel = 0x%02X, MIA = 0x%02X, Auth = 0x%02X\n",
+			 REG_FIELD_GET(GS_MIA_IN_RESET, status),
+			 REG_FIELD_GET(GS_BOOTROM_MASK, status),
+			 REG_FIELD_GET(GS_UKERNEL_MASK, status),
+			 REG_FIELD_GET(GS_MIA_MASK, status),
+			 REG_FIELD_GET(GS_AUTH_STATUS_MASK, status));
 
 		if ((status & GS_BOOTROM_MASK) == GS_BOOTROM_RSA_FAILED) {
 			drm_info(drm, "GuC firmware signature verification failed\n");
diff --git a/drivers/gpu/drm/xe/xe_hw_engine_types.h b/drivers/gpu/drm/xe/xe_hw_engine_types.h
index d788e67312b9..803d557cf5aa 100644
--- a/drivers/gpu/drm/xe/xe_hw_engine_types.h
+++ b/drivers/gpu/drm/xe/xe_hw_engine_types.h
@@ -104,7 +104,7 @@ struct xe_hw_engine {
 	/** @fence_irq: fence IRQ to run when a hw engine IRQ is received */
 	struct xe_hw_fence_irq *fence_irq;
 	/** @irq_handler: IRQ handler to run when hw engine IRQ is received */
-	void (*irq_handler)(struct xe_hw_engine *, u16);
+	void (*irq_handler)(struct xe_hw_engine *hwe, u16 intr_vec);
 	/** @engine_id: id  for this hw engine */
 	enum xe_hw_engine_id engine_id;
 };
diff --git a/drivers/gpu/drm/xe/xe_map.h b/drivers/gpu/drm/xe/xe_map.h
index 032c2e8b5438..f62e0c8b67ab 100644
--- a/drivers/gpu/drm/xe/xe_map.h
+++ b/drivers/gpu/drm/xe/xe_map.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: MIT
+/* SPDX-License-Identifier: MIT */
 /*
  * Copyright Â© 2022 Intel Corporation
  */
diff --git a/drivers/gpu/drm/xe/xe_migrate.c b/drivers/gpu/drm/xe/xe_migrate.c
index 0515fbef8eec..827938b666c5 100644
--- a/drivers/gpu/drm/xe/xe_migrate.c
+++ b/drivers/gpu/drm/xe/xe_migrate.c
@@ -475,7 +475,7 @@ static void emit_pte(struct xe_migrate *m,
 			bb->cs[bb->len++] = lower_32_bits(addr);
 			bb->cs[bb->len++] = upper_32_bits(addr);
 
-			xe_res_next(cur, min(size, (u32)PAGE_SIZE));
+			xe_res_next(cur, min_t(u32, size, PAGE_SIZE));
 			cur_ofs += 8;
 		}
 	}
diff --git a/drivers/gpu/drm/xe/xe_reg_whitelist.c b/drivers/gpu/drm/xe/xe_reg_whitelist.c
index ea6dd7d71b59..e83781f9a516 100644
--- a/drivers/gpu/drm/xe/xe_reg_whitelist.c
+++ b/drivers/gpu/drm/xe/xe_reg_whitelist.c
@@ -89,18 +89,30 @@ void xe_reg_whitelist_print_entry(struct drm_printer *p, unsigned int indent,
 	deny = val & RING_FORCE_TO_NONPRIV_DENY;
 
 	switch (val & RING_FORCE_TO_NONPRIV_RANGE_MASK) {
-	case RING_FORCE_TO_NONPRIV_RANGE_4: range_bit = 4; break;
-	case RING_FORCE_TO_NONPRIV_RANGE_16: range_bit = 6; break;
-	case RING_FORCE_TO_NONPRIV_RANGE_64: range_bit = 8; break;
+	case RING_FORCE_TO_NONPRIV_RANGE_4:
+		range_bit = 4;
+		break;
+	case RING_FORCE_TO_NONPRIV_RANGE_16:
+		range_bit = 6;
+		break;
+	case RING_FORCE_TO_NONPRIV_RANGE_64:
+		range_bit = 8;
+		break;
 	}
 
 	range_start = reg & REG_GENMASK(25, range_bit);
 	range_end = range_start | REG_GENMASK(range_bit, 0);
 
 	switch (val & RING_FORCE_TO_NONPRIV_ACCESS_MASK) {
-	case RING_FORCE_TO_NONPRIV_ACCESS_RW: access_str = "rw"; break;
-	case RING_FORCE_TO_NONPRIV_ACCESS_RD: access_str = "read"; break;
-	case RING_FORCE_TO_NONPRIV_ACCESS_WR: access_str = "write"; break;
+	case RING_FORCE_TO_NONPRIV_ACCESS_RW:
+		access_str = "rw";
+		break;
+	case RING_FORCE_TO_NONPRIV_ACCESS_RD:
+		access_str = "read";
+		break;
+	case RING_FORCE_TO_NONPRIV_ACCESS_WR:
+		access_str = "write";
+		break;
 	}
 
 	drm_printf_indent(p, indent, "REG[0x%x-0x%x]: %s %s access\n",
diff --git a/drivers/gpu/drm/xe/xe_res_cursor.h b/drivers/gpu/drm/xe/xe_res_cursor.h
index 2a6fdd284395..dda963fe3300 100644
--- a/drivers/gpu/drm/xe/xe_res_cursor.h
+++ b/drivers/gpu/drm/xe/xe_res_cursor.h
@@ -51,15 +51,14 @@ struct xe_res_cursor {
 static struct drm_buddy *xe_res_get_buddy(struct ttm_resource *res)
 {
 	struct xe_device *xe = ttm_to_xe_device(res->bo->bdev);
+	struct ttm_resource_manager *mgr;
 
-	if (res->mem_type != XE_PL_STOLEN) {
+	if (res->mem_type != XE_PL_STOLEN)
 		return &xe->tiles[res->mem_type - XE_PL_VRAM0].mem.vram_mgr->mm;
-	} else {
-		struct ttm_resource_manager *mgr =
-			ttm_manager_type(&xe->ttm, XE_PL_STOLEN);
 
-		return &to_xe_ttm_vram_mgr(mgr)->mm;
-	}
+	mgr = ttm_manager_type(&xe->ttm, XE_PL_STOLEN);
+
+	return &to_xe_ttm_vram_mgr(mgr)->mm;
 }
 
 /**
diff --git a/drivers/gpu/drm/xe/xe_wopcm.c b/drivers/gpu/drm/xe/xe_wopcm.c
index 35fde8965bca..d9acf8783b83 100644
--- a/drivers/gpu/drm/xe/xe_wopcm.c
+++ b/drivers/gpu/drm/xe/xe_wopcm.c
@@ -47,12 +47,10 @@
  */
 
 /* Default WOPCM size is 2MB from Gen11, 1MB on previous platforms */
-#define DGFX_WOPCM_SIZE			SZ_4M	/* FIXME: Larger size require
-						   for 2 tile PVC, do a proper
-						   probe sooner or later */
-#define MTL_WOPCM_SIZE			SZ_4M	/* FIXME: Larger size require
-						   for MTL, do a proper probe
-						   sooner or later */
+/* FIXME: Larger size require for 2 tile PVC, do a proper probe sooner or later */
+#define DGFX_WOPCM_SIZE			SZ_4M
+/* FIXME: Larger size require for MTL, do a proper probe sooner or later */
+#define MTL_WOPCM_SIZE			SZ_4M
 #define GEN11_WOPCM_SIZE		SZ_2M
 
 #define GEN12_MAX_WOPCM_SIZE            SZ_8M
-- 
2.46.1

