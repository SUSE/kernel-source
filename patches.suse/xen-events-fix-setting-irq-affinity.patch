From: Juergen Gross <jgross@suse.com>
Date: Mon, 12 Apr 2021 07:50:03 +0200
Subject: [PATCH] xen/events: fix setting irq affinity
Patch-mainline: Never, only applies to backports to 5.10 and older
References: bsc#1184583 XSA-332 CVE-2020-27673

The backport of upstream patch 25da4618af240fbec61 ("xen/events: don't
unmask an event channel when an eoi is pending") introduced a
regression for stable kernels 5.10 and older: setting IRQ affinity for
IRQs related to interdomain events would no longer work, as moving the
IRQ to its new cpu was not included in the irq_ack callback for those
events.

Fix that by adding the needed call.

Note that kernels 5.11 and later don't need the explicit moving of the
IRQ to the target cpu in the irq_ack callback, due to a rework of the
affinity setting in kernel 5.11.

Signed-off-by: Juergen Gross <jgross@suse.com>
---
 drivers/xen/events/events_base.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c
index 7bd03f6e0422..ee5269331406 100644
--- a/drivers/xen/events/events_base.c
+++ b/drivers/xen/events/events_base.c
@@ -1792,7 +1792,14 @@ static void lateeoi_ack_dynirq(struct irq_data *data)
 		 * Need to keep is_active non-zero in order to ignore re-raised
 		 * events after cpu affinity changes while a lateeoi is pending.
 		 */
-		clear_evtchn(evtchn);
+		if (unlikely(irqd_is_setaffinity_pending(data)) &&
+		    likely(!irqd_irq_disabled(data))) {
+			do_mask(info, EVT_MASK_REASON_TEMPORARY);
+			clear_evtchn(evtchn);
+			irq_move_masked_irq(data);
+			do_unmask(info, EVT_MASK_REASON_TEMPORARY);
+		} else
+			clear_evtchn(evtchn);
 	}
 }
 
@@ -1803,7 +1810,7 @@ static void lateeoi_mask_ack_dynirq(struct irq_data *data)
 
 	if (VALID_EVTCHN(evtchn)) {
 		do_mask(info, EVT_MASK_REASON_EXPLICIT);
-		event_handler_exit(info);
+		ack_dynirq(data);
 	}
 }
 
-- 
2.26.2

