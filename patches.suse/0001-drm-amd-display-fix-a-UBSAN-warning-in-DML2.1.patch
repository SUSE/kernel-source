From f9cbadc081799e0d65324919959b29f1cf875c65 Mon Sep 17 00:00:00 2001
From: Aurabindo Pillai <aurabindo.pillai@amd.com>
Date: Fri, 19 Jul 2024 14:10:58 -0400
Subject: drm/amd/display: fix a UBSAN warning in DML2.1
Git-commit: eaf3adb8faab611ba57594fa915893fc93a7788c
Patch-mainline: v6.12-rc1
References: bsc#1233115 CVE-2024-50177

When programming phantom pipe, since cursor_width is explicity set to 0,
this causes calculation logic to trigger overflow for an unsigned int
triggering the kernel's UBSAN check as below:

[   40.962845] UBSAN: shift-out-of-bounds in /tmp/amd.EfpumTkO/amd/amdgpu/../display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4_calcs.c:3312:34
[   40.962849] shift exponent 4294967170 is too large for 32-bit type 'unsigned int'
[   40.962852] CPU: 1 PID: 1670 Comm: gnome-shell Tainted: G        W  OE      6.5.0-41-generic #41~22.04.2-Ubuntu
[   40.962854] Hardware name: Gigabyte Technology Co., Ltd. X670E AORUS PRO X/X670E AORUS PRO X, BIOS F21 01/10/2024
[   40.962856] Call Trace:
[   40.962857]  <TASK>
[   40.962860]  dump_stack_lvl+0x48/0x70
[   40.962870]  dump_stack+0x10/0x20
[   40.962872]  __ubsan_handle_shift_out_of_bounds+0x1ac/0x360
[   40.962878]  calculate_cursor_req_attributes.cold+0x1b/0x28 [amdgpu]
[   40.963099]  dml_core_mode_support+0x6b91/0x16bc0 [amdgpu]
[   40.963327]  ? srso_alias_return_thunk+0x5/0x7f
[   40.963331]  ? CalculateWatermarksMALLUseAndDRAMSpeedChangeSupport+0x18b8/0x2790 [amdgpu]
[   40.963534]  ? srso_alias_return_thunk+0x5/0x7f
[   40.963536]  ? dml_core_mode_support+0xb3db/0x16bc0 [amdgpu]
[   40.963730]  dml2_core_calcs_mode_support_ex+0x2c/0x90 [amdgpu]
[   40.963906]  ? srso_alias_return_thunk+0x5/0x7f
[   40.963909]  ? dml2_core_calcs_mode_support_ex+0x2c/0x90 [amdgpu]
[   40.964078]  core_dcn4_mode_support+0x72/0xbf0 [amdgpu]
[   40.964247]  dml2_top_optimization_perform_optimization_phase+0x1d3/0x2a0 [amdgpu]
[   40.964420]  dml2_build_mode_programming+0x23d/0x750 [amdgpu]
[   40.964587]  dml21_validate+0x274/0x770 [amdgpu]
[   40.964761]  ? srso_alias_return_thunk+0x5/0x7f
[   40.964763]  ? resource_append_dpp_pipes_for_plane_composition+0x27c/0x3b0 [amdgpu]
[   40.964942]  dml2_validate+0x504/0x750 [amdgpu]
[   40.965117]  ? dml21_copy+0x95/0xb0 [amdgpu]
[   40.965291]  ? srso_alias_return_thunk+0x5/0x7f
[   40.965295]  dcn401_validate_bandwidth+0x4e/0x70 [amdgpu]
[   40.965491]  update_planes_and_stream_state+0x38d/0x5c0 [amdgpu]
[   40.965672]  update_planes_and_stream_v3+0x52/0x1e0 [amdgpu]
[   40.965845]  ? srso_alias_return_thunk+0x5/0x7f
[   40.965849]  dc_update_planes_and_stream+0x71/0xb0 [amdgpu]

Fix this by adding a guard for checking cursor width before triggering
the size calculation.

Reviewed-by: Rodrigo Siqueira <rodrigo.siqueira@amd.com>
Signed-off-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
Signed-off-by: Wayne Lin <wayne.lin@amd.com>
Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Thomas Zimmermann <tzimmermann@suse.com>
---
 .../amd/display/dc/dml2/display_mode_core.c   | 59 ++++++++++---------
 1 file changed, 31 insertions(+), 28 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/dml2/display_mode_core.c b/drivers/gpu/drm/amd/display/dc/dml2/display_mode_core.c
index 85ffad564ed06..9659e7ce8e23d 100644
--- a/drivers/gpu/drm/amd/display/dc/dml2/display_mode_core.c
+++ b/drivers/gpu/drm/amd/display/dc/dml2/display_mode_core.c
@@ -6411,6 +6411,7 @@ static void dml_prefetch_check(struct display_mode_lib_st *mode_lib)
 			}
 
 			for (k = 0; k <= mode_lib->ms.num_active_planes - 1; k++) {
+				if (mode_lib->ms.cache_display_cfg.plane.NumberOfCursors[k] > 0) {
 					CalculateUrgentBurstFactor(
 							mode_lib->ms.cache_display_cfg.plane.UseMALLForPStateChange[k],
 							mode_lib->ms.swath_width_luma_ub_this_state[k],
@@ -6433,6 +6434,7 @@ static void dml_prefetch_check(struct display_mode_lib_st *mode_lib)
 							&mode_lib->ms.UrgentBurstFactorLumaPre[k],
 							&mode_lib->ms.UrgentBurstFactorChroma[k],
 							&mode_lib->ms.NotUrgentLatencyHidingPre[k]);
+				}
 
 					mode_lib->ms.cursor_bw_pre[k] = mode_lib->ms.cache_display_cfg.plane.NumberOfCursors[k] * mode_lib->ms.cache_display_cfg.plane.CursorWidth[k] *
 													mode_lib->ms.cache_display_cfg.plane.CursorBPP[k] / 8.0 / (mode_lib->ms.cache_display_cfg.timing.HTotal[k] /
@@ -8049,10 +8051,9 @@ dml_bool_t dml_core_mode_support(struct display_mode_lib_st *mode_lib)
 	/*Cursor Support Check*/
 	mode_lib->ms.support.CursorSupport = true;
 	for (k = 0; k <= mode_lib->ms.num_active_planes - 1; k++) {
-		if (mode_lib->ms.cache_display_cfg.plane.CursorWidth[k] > 0.0) {
-			if (mode_lib->ms.cache_display_cfg.plane.CursorBPP[k] == 64 && mode_lib->ms.ip.cursor_64bpp_support == false) {
+		if (mode_lib->ms.cache_display_cfg.plane.NumberOfCursors[k] > 0) {
+			if (mode_lib->ms.cache_display_cfg.plane.CursorBPP[k] == 64 && mode_lib->ms.ip.cursor_64bpp_support == false)
 				mode_lib->ms.support.CursorSupport = false;
-			}
 		}
 	}
 
@@ -8861,7 +8862,8 @@ void dml_core_mode_programming(struct display_mode_lib_st *mode_lib, const struc
 												mode_lib->ms.FabricClock);
 
 	for (k = 0; k < mode_lib->ms.num_active_planes; ++k) {
-		CalculateUrgentBurstFactor(mode_lib->ms.cache_display_cfg.plane.UseMALLForPStateChange[k],
+		if (mode_lib->ms.cache_display_cfg.plane.NumberOfCursors[k] > 0) {
+			CalculateUrgentBurstFactor(mode_lib->ms.cache_display_cfg.plane.UseMALLForPStateChange[k],
 									locals->swath_width_luma_ub[k],
 									locals->swath_width_chroma_ub[k],
 									locals->SwathHeightY[k],
@@ -8883,7 +8885,7 @@ void dml_core_mode_programming(struct display_mode_lib_st *mode_lib, const struc
 									&locals->UrgBurstFactorLuma[k],
 									&locals->UrgBurstFactorChroma[k],
 									&locals->NoUrgentLatencyHiding[k]);
-
+		}
 		locals->cursor_bw[k] = mode_lib->ms.cache_display_cfg.plane.NumberOfCursors[k] * mode_lib->ms.cache_display_cfg.plane.CursorWidth[k] * mode_lib->ms.cache_display_cfg.plane.CursorBPP[k] / 8.0 /
 								((dml_float_t) mode_lib->ms.cache_display_cfg.timing.HTotal[k] / mode_lib->ms.cache_display_cfg.timing.PixelClock[k]) * mode_lib->ms.cache_display_cfg.plane.VRatio[k];
 	}
@@ -9048,29 +9050,30 @@ void dml_core_mode_programming(struct display_mode_lib_st *mode_lib, const struc
 		}
 
 		for (k = 0; k < mode_lib->ms.num_active_planes; ++k) {
-			CalculateUrgentBurstFactor(
-				mode_lib->ms.cache_display_cfg.plane.UseMALLForPStateChange[k],
-				locals->swath_width_luma_ub[k],
-				locals->swath_width_chroma_ub[k],
-				locals->SwathHeightY[k],
-				locals->SwathHeightC[k],
-				mode_lib->ms.cache_display_cfg.timing.HTotal[k] / mode_lib->ms.cache_display_cfg.timing.PixelClock[k],
-				locals->UrgentLatency,
-				mode_lib->ms.ip.cursor_buffer_size,
-				mode_lib->ms.cache_display_cfg.plane.CursorWidth[k],
-				mode_lib->ms.cache_display_cfg.plane.CursorBPP[k],
-				locals->VRatioPrefetchY[k],
-				locals->VRatioPrefetchC[k],
-				locals->BytePerPixelDETY[k],
-				locals->BytePerPixelDETC[k],
-				locals->DETBufferSizeY[k],
-				locals->DETBufferSizeC[k],
-				/* Output */
-				&locals->UrgBurstFactorCursorPre[k],
-				&locals->UrgBurstFactorLumaPre[k],
-				&locals->UrgBurstFactorChromaPre[k],
-				&locals->NoUrgentLatencyHidingPre[k]);
-
+			if (mode_lib->ms.cache_display_cfg.plane.NumberOfCursors[k] > 0) {
+				CalculateUrgentBurstFactor(
+					mode_lib->ms.cache_display_cfg.plane.UseMALLForPStateChange[k],
+					locals->swath_width_luma_ub[k],
+					locals->swath_width_chroma_ub[k],
+					locals->SwathHeightY[k],
+					locals->SwathHeightC[k],
+					mode_lib->ms.cache_display_cfg.timing.HTotal[k] / mode_lib->ms.cache_display_cfg.timing.PixelClock[k],
+					locals->UrgentLatency,
+					mode_lib->ms.ip.cursor_buffer_size,
+					mode_lib->ms.cache_display_cfg.plane.CursorWidth[k],
+					mode_lib->ms.cache_display_cfg.plane.CursorBPP[k],
+					locals->VRatioPrefetchY[k],
+					locals->VRatioPrefetchC[k],
+					locals->BytePerPixelDETY[k],
+					locals->BytePerPixelDETC[k],
+					locals->DETBufferSizeY[k],
+					locals->DETBufferSizeC[k],
+					/* Output */
+					&locals->UrgBurstFactorCursorPre[k],
+					&locals->UrgBurstFactorLumaPre[k],
+					&locals->UrgBurstFactorChromaPre[k],
+					&locals->NoUrgentLatencyHidingPre[k]);
+			}
 			locals->cursor_bw_pre[k] = mode_lib->ms.cache_display_cfg.plane.NumberOfCursors[k] * mode_lib->ms.cache_display_cfg.plane.CursorWidth[k] * mode_lib->ms.cache_display_cfg.plane.CursorBPP[k] / 8.0 / (mode_lib->ms.cache_display_cfg.timing.HTotal[k] / mode_lib->ms.cache_display_cfg.timing.PixelClock[k]) * locals->VRatioPrefetchY[k];
 
 #ifdef __DML_VBA_DEBUG__
-- 
2.47.0

