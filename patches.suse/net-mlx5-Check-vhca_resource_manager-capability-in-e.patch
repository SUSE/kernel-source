From: Jiri Pirko <jiri@nvidia.com>
Date: Thu, 1 Jun 2023 14:13:31 +0200
Subject: net/mlx5: Check vhca_resource_manager capability in each op and add
 extack msg
Patch-mainline: v6.6-rc1
Git-commit: eb555e34f0841c880f709559d58866ff9d9321a1
References: jsc#PED-3311

Since the follow-up patch is going to remove
mlx5_devlink_port_fn_get_vport() entirely, move the vhca_resource_manager
capability checking to individual ops. Add proper extack message
on the way.

Signed-off-by: Jiri Pirko <jiri@nvidia.com>
Reviewed-by: Shay Drory <shayd@nvidia.com>
Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c |   23 +++++++++++--
 1 file changed, 20 insertions(+), 3 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -4258,9 +4258,6 @@ mlx5_devlink_port_fn_get_vport(struct de
 {
 	u16 vport_num;
 
-	if (!MLX5_CAP_GEN(esw->dev, vhca_resource_manager))
-		return ERR_PTR(-EOPNOTSUPP);
-
 	vport_num = mlx5_esw_devlink_port_index_to_vport_num(port->index);
 	return mlx5_eswitch_get_vport(esw, vport_num);
 }
@@ -4276,6 +4273,11 @@ int mlx5_devlink_port_fn_migratable_get(
 		return -EOPNOTSUPP;
 	}
 
+	if (!MLX5_CAP_GEN(esw->dev, vhca_resource_manager)) {
+		NL_SET_ERR_MSG_MOD(extack, "Device doesn't support VHCA management");
+		return -EOPNOTSUPP;
+	}
+
 	vport = mlx5_devlink_port_fn_get_vport(port, esw);
 	if (IS_ERR(vport)) {
 		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
@@ -4303,6 +4305,11 @@ int mlx5_devlink_port_fn_migratable_set(
 		return -EOPNOTSUPP;
 	}
 
+	if (!MLX5_CAP_GEN(esw->dev, vhca_resource_manager)) {
+		NL_SET_ERR_MSG_MOD(extack, "Device doesn't support VHCA management");
+		return -EOPNOTSUPP;
+	}
+
 	vport = mlx5_devlink_port_fn_get_vport(port, esw);
 	if (IS_ERR(vport)) {
 		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
@@ -4354,6 +4361,11 @@ int mlx5_devlink_port_fn_roce_get(struct
 	struct mlx5_eswitch *esw = mlx5_devlink_eswitch_nocheck_get(port->devlink);
 	struct mlx5_vport *vport;
 
+	if (!MLX5_CAP_GEN(esw->dev, vhca_resource_manager)) {
+		NL_SET_ERR_MSG_MOD(extack, "Device doesn't support VHCA management");
+		return -EOPNOTSUPP;
+	}
+
 	vport = mlx5_devlink_port_fn_get_vport(port, esw);
 	if (IS_ERR(vport)) {
 		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
@@ -4377,6 +4389,11 @@ int mlx5_devlink_port_fn_roce_set(struct
 	u16 vport_num;
 	int err;
 
+	if (!MLX5_CAP_GEN(esw->dev, vhca_resource_manager)) {
+		NL_SET_ERR_MSG_MOD(extack, "Device doesn't support VHCA management");
+		return -EOPNOTSUPP;
+	}
+
 	vport = mlx5_devlink_port_fn_get_vport(port, esw);
 	if (IS_ERR(vport)) {
 		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
