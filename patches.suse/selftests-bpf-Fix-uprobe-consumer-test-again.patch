From: Jiri Olsa <jolsa@kernel.org>
Date: Thu, 7 Nov 2024 10:43:37 +0100
Subject: selftests/bpf: Fix uprobe consumer test (again)
Patch-mainline: v6.13-rc1
Git-commit: dcf04676f347133a0c5944152e8d5110aa28d2dd
References: jsc#PED-14653

The new uprobe changes bring some new behaviour that we need to reflect
in the consumer test. Now pending uprobe instance in the kernel can
survive longer and thus might call uretprobe consumer callbacks in
some situations in which, previously, such callback would be omitted.
We now need to take that into account in uprobe-multi consumer tests.

The idea being that uretprobe under test either stayed from before to
after (uret_stays + test_bit) or uretprobe instance survived and we
have uretprobe active in after (uret_survives + test_bit).

uret_survives just states that uretprobe survives if there are *any*
uretprobes both before and after (overlapping or not, doesn't matter)
and uprobe was attached before.

Suggested-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Jiri Olsa <jolsa@kernel.org>
Signed-off-by: Andrii Nakryiko <andrii@kernel.org>
Link: https://lore.kernel.org/bpf/20241107094337.3848210-1-jolsa@kernel.org
Acked-by: Hoyeon Lee <hoyeon.lee@suse.com>
---
 tools/testing/selftests/bpf/prog_tests/uprobe_multi_test.c |   14 +++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

--- a/tools/testing/selftests/bpf/prog_tests/uprobe_multi_test.c
+++ b/tools/testing/selftests/bpf/prog_tests/uprobe_multi_test.c
@@ -869,15 +869,17 @@ static int consumer_test(struct uprobe_m
 			fmt = "prog 0/1: uprobe";
 		} else {
 			/*
-			 * to trigger uretprobe consumer, the uretprobe needs to be installed,
-			 * which means one of the 'return' uprobes was alive when probe was hit:
-			 *
-			 *   idxs: 2/3 uprobe return in 'installed' mask
+			 * To trigger uretprobe consumer, the uretprobe under test either stayed from
+			 * before to after (uret_stays + test_bit) or uretprobe instance survived and
+			 * we have uretprobe active in after (uret_survives + test_bit)
 			 */
-			unsigned long had_uretprobes  = before & 0b1100; /* is uretprobe installed */
 
-			if (had_uretprobes && test_bit(idx, after))
+			bool uret_stays = before & after & 0b1100;
+			bool uret_survives = (before & 0b1100) && (after & 0b1100) && (before & 0b0011);
+
+			if ((uret_stays || uret_survives) && test_bit(idx, after))
 				val++;
+
 			fmt = "idx 2/3: uretprobe";
 		}
 
