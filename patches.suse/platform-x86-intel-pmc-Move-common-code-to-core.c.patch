From d79c3c82ee82cc99ffde4c4f5fe69db35bcfb733 Mon Sep 17 00:00:00 2001
From: Rajvi Jingar <rajvi.jingar@linux.intel.com>
Date: Mon, 18 Dec 2023 20:22:13 -0800
Subject: [PATCH] platform/x86/intel/pmc: Move common code to core.c
Git-commit: d79c3c82ee82cc99ffde4c4f5fe69db35bcfb733
Patch-mainline: v6.8-rc1
References: jsc#PED-10411

Functions like mtl_set_device_d3() and mtl_punit_pmt_init() were added for
Meteor Lake. To be able to use them in Arrow Lake and future platforms,
move them to core.c.

Also, to support different guids, add guid argument in
pmc_core_punit_pmt_init() and to support different PCI function numbers,
add func arg in pmc_core_ssram_init().

Signed-off-by: Rajvi Jingar <rajvi.jingar@linux.intel.com>
Link: https://lore.kernel.org/r/20231219042216.2592029-5-rajvi.jingar@linux.intel.com
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Signed-off-by: Hans de Goede <hdegoede@redhat.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/platform/x86/intel/pmc/core.c       |   45 +++++++++++++++++++++
 drivers/platform/x86/intel/pmc/core.h       |    8 +++
 drivers/platform/x86/intel/pmc/core_ssram.c |    4 -
 drivers/platform/x86/intel/pmc/mtl.c        |   60 ++--------------------------
 4 files changed, 60 insertions(+), 57 deletions(-)

--- a/drivers/platform/x86/intel/pmc/core.c
+++ b/drivers/platform/x86/intel/pmc/core.c
@@ -1109,6 +1109,51 @@ int get_primary_reg_base(struct pmc *pmc
 	return 0;
 }
 
+void pmc_core_punit_pmt_init(struct pmc_dev *pmcdev, u32 guid)
+{
+	struct telem_endpoint *ep;
+	struct pci_dev *pcidev;
+
+	pcidev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(10, 0));
+	if (!pcidev) {
+		dev_err(&pmcdev->pdev->dev, "PUNIT PMT device not found.");
+		return;
+	}
+
+	ep = pmt_telem_find_and_register_endpoint(pcidev, guid, 0);
+	pci_dev_put(pcidev);
+	if (IS_ERR(ep)) {
+		dev_err(&pmcdev->pdev->dev,
+			"pmc_core: couldn't get DMU telem endpoint %ld",
+			PTR_ERR(ep));
+		return;
+	}
+
+	pmcdev->punit_ep = ep;
+
+	pmcdev->has_die_c6 = true;
+	pmcdev->die_c6_offset = MTL_PMT_DMU_DIE_C6_OFFSET;
+}
+
+void pmc_core_set_device_d3(unsigned int device)
+{
+	struct pci_dev *pcidev;
+
+	pcidev = pci_get_device(PCI_VENDOR_ID_INTEL, device, NULL);
+	if (pcidev) {
+		if (!device_trylock(&pcidev->dev)) {
+			pci_dev_put(pcidev);
+			return;
+		}
+		if (!pcidev->dev.driver) {
+			dev_info(&pcidev->dev, "Setting to D3hot\n");
+			pci_set_power_state(pcidev, PCI_D3hot);
+		}
+		device_unlock(&pcidev->dev);
+		pci_dev_put(pcidev);
+	}
+}
+
 static bool pmc_core_is_pson_residency_enabled(struct pmc_dev *pmcdev)
 {
 	struct platform_device *pdev = pmcdev->pdev;
--- a/drivers/platform/x86/intel/pmc/core.h
+++ b/drivers/platform/x86/intel/pmc/core.h
@@ -268,6 +268,10 @@ enum ppfear_regs {
 #define MTL_SOCM_PPFEAR_NUM_ENTRIES		8
 #define MTL_IOE_PPFEAR_NUM_ENTRIES		10
 
+/* Die C6 from PUNIT telemetry */
+#define MTL_PMT_DMU_DIE_C6_OFFSET		15
+#define MTL_PMT_DMU_GUID			0x1A067102
+
 extern const char *pmc_lpm_modes[];
 
 struct pmc_bit_map {
@@ -506,8 +510,10 @@ int pmc_core_send_ltr_ignore(struct pmc_
 int pmc_core_resume_common(struct pmc_dev *pmcdev);
 int get_primary_reg_base(struct pmc *pmc);
 extern void pmc_core_get_low_power_modes(struct pmc_dev *pmcdev);
+extern void pmc_core_punit_pmt_init(struct pmc_dev *pmcdev, u32 guid);
+extern void pmc_core_set_device_d3(unsigned int device);
 
-extern int pmc_core_ssram_init(struct pmc_dev *pmcdev);
+extern int pmc_core_ssram_init(struct pmc_dev *pmcdev, int func);
 
 int spt_core_init(struct pmc_dev *pmcdev);
 int cnp_core_init(struct pmc_dev *pmcdev);
--- a/drivers/platform/x86/intel/pmc/core_ssram.c
+++ b/drivers/platform/x86/intel/pmc/core_ssram.c
@@ -290,12 +290,12 @@ pmc_core_ssram_get_pmc(struct pmc_dev *p
 	return pmc_core_pmc_add(pmcdev, pwrm_base, map, pmc_idx);
 }
 
-int pmc_core_ssram_init(struct pmc_dev *pmcdev)
+int pmc_core_ssram_init(struct pmc_dev *pmcdev, int func)
 {
 	struct pci_dev *pcidev;
 	int ret;
 
-	pcidev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(20, 2));
+	pcidev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(20, func));
 	if (!pcidev)
 		return -ENODEV;
 
--- a/drivers/platform/x86/intel/pmc/mtl.c
+++ b/drivers/platform/x86/intel/pmc/mtl.c
@@ -17,10 +17,6 @@
 #define IOEM_LPM_REQ_GUID	0x4357464
 #define IOEP_LPM_REQ_GUID	0x5077612
 
-/* Die C6 from PUNIT telemetry */
-#define MTL_PMT_DMU_DIE_C6_OFFSET	15
-#define MTL_PMT_DMU_GUID		0x1A067102
-
 static const u8 MTL_LPM_REG_INDEX[] = {0, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20};
 
 /*
@@ -973,63 +969,18 @@ static struct pmc_info mtl_pmc_info_list
 	{}
 };
 
-static void mtl_punit_pmt_init(struct pmc_dev *pmcdev)
-{
-	struct telem_endpoint *ep;
-	struct pci_dev *pcidev;
-
-	pcidev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(10, 0));
-	if (!pcidev) {
-		dev_err(&pmcdev->pdev->dev, "PUNIT PMT device not found.\n");
-		return;
-	}
-
-	ep = pmt_telem_find_and_register_endpoint(pcidev, MTL_PMT_DMU_GUID, 0);
-	pci_dev_put(pcidev);
-	if (IS_ERR(ep)) {
-		dev_err(&pmcdev->pdev->dev,
-			"pmc_core: couldn't get DMU telem endpoint, %ld\n",
-			PTR_ERR(ep));
-		return;
-	}
-
-	pmcdev->punit_ep = ep;
-
-	pmcdev->has_die_c6 = true;
-	pmcdev->die_c6_offset = MTL_PMT_DMU_DIE_C6_OFFSET;
-}
-
 #define MTL_GNA_PCI_DEV	0x7e4c
 #define MTL_IPU_PCI_DEV	0x7d19
 #define MTL_VPU_PCI_DEV	0x7d1d
-static void mtl_set_device_d3(unsigned int device)
-{
-	struct pci_dev *pcidev;
-
-	pcidev = pci_get_device(PCI_VENDOR_ID_INTEL, device, NULL);
-	if (pcidev) {
-		if (!device_trylock(&pcidev->dev)) {
-			pci_dev_put(pcidev);
-			return;
-		}
-		if (!pcidev->dev.driver) {
-			dev_info(&pcidev->dev, "Setting to D3hot\n");
-			pci_set_power_state(pcidev, PCI_D3hot);
-		}
-		device_unlock(&pcidev->dev);
-		pci_dev_put(pcidev);
-	}
-}
-
 /*
  * Set power state of select devices that do not have drivers to D3
  * so that they do not block Package C entry.
  */
 static void mtl_d3_fixup(void)
 {
-	mtl_set_device_d3(MTL_GNA_PCI_DEV);
-	mtl_set_device_d3(MTL_IPU_PCI_DEV);
-	mtl_set_device_d3(MTL_VPU_PCI_DEV);
+	pmc_core_set_device_d3(MTL_GNA_PCI_DEV);
+	pmc_core_set_device_d3(MTL_IPU_PCI_DEV);
+	pmc_core_set_device_d3(MTL_VPU_PCI_DEV);
 }
 
 static int mtl_resume(struct pmc_dev *pmcdev)
@@ -1044,6 +995,7 @@ int mtl_core_init(struct pmc_dev *pmcdev
 {
 	struct pmc *pmc = pmcdev->pmcs[PMC_IDX_SOC];
 	int ret;
+	int func = 2;
 
 	mtl_d3_fixup();
 
@@ -1055,7 +1007,7 @@ int mtl_core_init(struct pmc_dev *pmcdev
 	 * If ssram init fails use legacy method to at least get the
 	 * primary PMC
 	 */
-	ret = pmc_core_ssram_init(pmcdev);
+	ret = pmc_core_ssram_init(pmcdev, func);
 	if (ret) {
 		dev_warn(&pmcdev->pdev->dev,
 			 "ssram init failed, %d, using legacy init\n", ret);
@@ -1066,7 +1018,7 @@ int mtl_core_init(struct pmc_dev *pmcdev
 	}
 
 	pmc_core_get_low_power_modes(pmcdev);
-	mtl_punit_pmt_init(pmcdev);
+	pmc_core_punit_pmt_init(pmcdev, MTL_PMT_DMU_GUID);
 
 	return pmc_core_ssram_get_lpm_reqs(pmcdev);
 }
