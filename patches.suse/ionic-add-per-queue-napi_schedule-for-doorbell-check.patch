From: Shannon Nelson <shannon.nelson@amd.com>
Date: Tue, 18 Jun 2024 17:32:54 -0700
Subject: ionic: add per-queue napi_schedule for doorbell check
Patch-mainline: v6.11-rc1
Git-commit: d7f9bc68591803a9bca34847b76b2fc8f12e5dfd
References: jsc#PED-11379

Add a work item for each queue that will be run on the queue's
preferred cpu and will schedule another napi.  This napi is
run in case the device missed a doorbell and didn't process
a packet.  This is a problem for the Elba asic that happens
very rarely.

Signed-off-by: Shannon Nelson <shannon.nelson@amd.com>
Link: https://lore.kernel.org/r/20240619003257.6138-6-shannon.nelson@amd.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/pensando/ionic/ionic_dev.c |   23 +++++++++++++++++++++--
 drivers/net/ethernet/pensando/ionic/ionic_dev.h |    1 +
 drivers/net/ethernet/pensando/ionic/ionic_lif.c |    2 ++
 drivers/net/ethernet/pensando/ionic/ionic_lif.h |    1 +
 4 files changed, 25 insertions(+), 2 deletions(-)

--- a/drivers/net/ethernet/pensando/ionic/ionic_dev.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_dev.c
@@ -54,6 +54,13 @@ static void ionic_napi_schedule_do_softi
 	local_bh_enable();
 }
 
+void ionic_doorbell_napi_work(struct work_struct *work)
+{
+	struct ionic_qcq *qcq = container_of(work, struct ionic_qcq,
+					     doorbell_napi_work);
+	ionic_napi_schedule_do_softirq(&qcq->napi);
+}
+
 static int ionic_get_preferred_cpu(struct ionic *ionic,
 				   struct ionic_intr_info *intr)
 {
@@ -66,6 +73,18 @@ static int ionic_get_preferred_cpu(struc
 	return cpu;
 }
 
+static void ionic_queue_dbell_napi_work(struct ionic *ionic,
+					struct ionic_qcq *qcq)
+{
+	int cpu;
+
+	if (!(qcq->flags & IONIC_QCQ_F_INTR))
+		return;
+
+	cpu = ionic_get_preferred_cpu(ionic, &qcq->intr);
+	queue_work_on(cpu, ionic->wq, &qcq->doorbell_napi_work);
+}
+
 static void ionic_doorbell_check_dwork(struct work_struct *work)
 {
 	struct ionic *ionic = container_of(work, struct ionic,
@@ -86,8 +105,8 @@ static void ionic_doorbell_check_dwork(s
 		int i;
 
 		for (i = 0; i < lif->nxqs; i++) {
-			ionic_napi_schedule_do_softirq(&lif->txqcqs[i]->napi);
-			ionic_napi_schedule_do_softirq(&lif->rxqcqs[i]->napi);
+			ionic_queue_dbell_napi_work(ionic, lif->txqcqs[i]);
+			ionic_queue_dbell_napi_work(ionic, lif->rxqcqs[i]);
 		}
 
 		if (lif->hwstamp_txq &&
--- a/drivers/net/ethernet/pensando/ionic/ionic_dev.h
+++ b/drivers/net/ethernet/pensando/ionic/ionic_dev.h
@@ -388,6 +388,7 @@ bool ionic_q_is_posted(struct ionic_queu
 
 int ionic_heartbeat_check(struct ionic *ionic);
 bool ionic_is_fw_running(struct ionic_dev *idev);
+void ionic_doorbell_napi_work(struct work_struct *work);
 void ionic_queue_doorbell_check(struct ionic *ionic, int delay);
 
 bool ionic_adminq_poke_doorbell(struct ionic_queue *q);
--- a/drivers/net/ethernet/pensando/ionic/ionic_lif.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_lif.c
@@ -344,6 +344,7 @@ static int ionic_qcq_disable(struct ioni
 	if (qcq->flags & IONIC_QCQ_F_INTR) {
 		struct ionic_dev *idev = &lif->ionic->idev;
 
+		cancel_work_sync(&qcq->doorbell_napi_work);
 		cancel_work_sync(&qcq->dim.work);
 		ionic_intr_mask(idev->intr_ctrl, qcq->intr.index,
 				IONIC_INTR_MASK_SET);
@@ -690,6 +691,7 @@ static int ionic_qcq_alloc(struct ionic_
 
 	INIT_WORK(&new->dim.work, ionic_dim_work);
 	new->dim.mode = DIM_CQ_PERIOD_MODE_START_FROM_CQE;
+	INIT_WORK(&new->doorbell_napi_work, ionic_doorbell_napi_work);
 
 	*qcq = new;
 
--- a/drivers/net/ethernet/pensando/ionic/ionic_lif.h
+++ b/drivers/net/ethernet/pensando/ionic/ionic_lif.h
@@ -88,6 +88,7 @@ struct ionic_qcq {
 	struct ionic_cq cq;
 	struct napi_struct napi;
 	struct ionic_intr_info intr;
+	struct work_struct doorbell_napi_work;
 	struct dentry *dentry;
 };
 
