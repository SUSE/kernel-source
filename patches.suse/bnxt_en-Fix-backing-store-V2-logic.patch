From: Michael Chan <michael.chan@broadcom.com>
Date: Fri, 1 Dec 2023 14:39:10 -0800
Subject: bnxt_en: Fix backing store V2 logic
Patch-mainline: v6.8-rc1
Git-commit: 08b386b132c61e06e573d6523a8c0c17b90fb8da
References: jsc#PED-7574

The current code determines the last backing store valid type during
bnxt_hwrm_func_backing_store_qcaps_v2().  In effect, the last type
is determined based on what firmware advertises.  The more correct
way is to determine it based on what the driver is configuring.  The
driver may not configure all the backing store types advertised by
firmware.

Move the logic to determine the last type to bnxt_backing_store_cfg_v2().
We need to pass the legacy enable flags to the function in case only
the legacy types are being configured.

Fixes: 236e237f8ffe ("bnxt_en: Add support for HWRM_FUNC_BACKING_STORE_CFG_V2 firmware calls")
Signed-off-by: Michael Chan <michael.chan@broadcom.com>
Link: https://lore.kernel.org/r/20231201223924.26955-2-michael.chan@broadcom.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/broadcom/bnxt/bnxt.c |   17 +++++++++++------
 drivers/net/ethernet/broadcom/bnxt/bnxt.h |    1 +
 2 files changed, 12 insertions(+), 6 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -7264,7 +7264,6 @@ static int bnxt_hwrm_func_backing_store_
 {
 	struct hwrm_func_backing_store_qcaps_v2_output *resp;
 	struct hwrm_func_backing_store_qcaps_v2_input *req;
-	u16 last_valid_type = BNXT_CTX_INV;
 	struct bnxt_ctx_mem_info *ctx;
 	u16 type;
 	int rc;
@@ -7296,7 +7295,6 @@ static int bnxt_hwrm_func_backing_store_
 			continue;
 
 		ctxm->type = le16_to_cpu(resp->type);
-		last_valid_type = ctxm->type;
 		ctxm->entry_size = le16_to_cpu(resp->entry_size);
 		ctxm->flags = flags;
 		ctxm->instance_bmap = le32_to_cpu(resp->instance_bit_map);
@@ -7313,8 +7311,6 @@ static int bnxt_hwrm_func_backing_store_
 		     i++, p++)
 			ctxm->split[i] = le32_to_cpu(*p);
 	}
-	if (last_valid_type < BNXT_CTX_V2_MAX)
-		ctx->ctx_arr[last_valid_type].last = true;
 	rc = bnxt_alloc_all_ctx_pg_info(bp, BNXT_CTX_V2_MAX);
 
 ctx_done:
@@ -7766,13 +7762,22 @@ static int bnxt_hwrm_func_backing_store_
 	return rc;
 }
 
-static int bnxt_backing_store_cfg_v2(struct bnxt *bp)
+static int bnxt_backing_store_cfg_v2(struct bnxt *bp, u32 ena)
 {
 	struct bnxt_ctx_mem_info *ctx = bp->ctx;
 	struct bnxt_ctx_mem_type *ctxm;
+	u16 last_type;
 	int rc = 0;
 	u16 type;
 
+	if (!ena)
+		return 0;
+	else if (ena & FUNC_BACKING_STORE_CFG_REQ_ENABLES_TIM)
+		last_type = BNXT_CTX_MAX - 1;
+	else
+		last_type = BNXT_CTX_L2_MAX - 1;
+	ctx->ctx_arr[last_type].last = 1;
+
 	for (type = 0 ; type < BNXT_CTX_V2_MAX; type++) {
 		ctxm = &ctx->ctx_arr[type];
 
@@ -7919,7 +7924,7 @@ skip_rdma:
 	ena |= FUNC_BACKING_STORE_CFG_REQ_DFLT_ENABLES;
 
 	if (bp->fw_cap & BNXT_FW_CAP_BACKING_STORE_V2)
-		rc = bnxt_backing_store_cfg_v2(bp);
+		rc = bnxt_backing_store_cfg_v2(bp, ena);
 	else
 		rc = bnxt_hwrm_func_backing_store_cfg(bp, ena);
 	if (rc) {
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -1617,6 +1617,7 @@ struct bnxt_ctx_mem_type {
 #define BNXT_CTX_XPAR	FUNC_BACKING_STORE_QCAPS_V2_REQ_TYPE_XID_PARTITION
 
 #define BNXT_CTX_MAX	(BNXT_CTX_TIM + 1)
+#define BNXT_CTX_L2_MAX	(BNXT_CTX_FTQM + 1)
 #define BNXT_CTX_V2_MAX	(BNXT_CTX_XPAR + 1)
 #define BNXT_CTX_INV	((u16)-1)
 
