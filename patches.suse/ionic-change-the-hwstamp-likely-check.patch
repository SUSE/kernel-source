From: Brett Creeley <brett.creeley@amd.com>
Date: Thu, 29 Feb 2024 11:39:32 -0800
Subject: ionic: change the hwstamp likely check
Patch-mainline: v6.9-rc1
Git-commit: b889bfe5bd0c278730f92e87a8996aa6ec6d9f09
References: jsc#PED-11379

An earlier change moved the hwstamp queue check into a helper
function with an unlikely(). However, it makes more sense for
the caller to decide if it's likely() or unlikely(), so make
the change to support that.

Signed-off-by: Brett Creeley <brett.creeley@amd.com>
Signed-off-by: Shannon Nelson <shannon.nelson@amd.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/pensando/ionic/ionic_lif.h  |    2 +-
 drivers/net/ethernet/pensando/ionic/ionic_txrx.c |   10 +++++-----
 2 files changed, 6 insertions(+), 6 deletions(-)

--- a/drivers/net/ethernet/pensando/ionic/ionic_lif.h
+++ b/drivers/net/ethernet/pensando/ionic/ionic_lif.h
@@ -327,7 +327,7 @@ static inline u32 ionic_coal_usec_to_hw(
 
 static inline bool ionic_txq_hwstamp_enabled(struct ionic_queue *q)
 {
-	return unlikely(q->features & IONIC_TXQ_F_HWSTAMP);
+	return q->features & IONIC_TXQ_F_HWSTAMP;
 }
 
 void ionic_link_status_check_request(struct ionic_lif *lif, bool can_sleep);
--- a/drivers/net/ethernet/pensando/ionic/ionic_txrx.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_txrx.c
@@ -1201,7 +1201,7 @@ static void ionic_tx_clean(struct ionic_
 	if (!skb)
 		return;
 
-	if (ionic_txq_hwstamp_enabled(q)) {
+	if (unlikely(ionic_txq_hwstamp_enabled(q))) {
 		if (cq_info) {
 			struct skb_shared_hwtstamps hwts = {};
 			__le64 *cq_desc_hwstamp;
@@ -1296,7 +1296,7 @@ unsigned int ionic_tx_cq_service(struct
 	if (work_done) {
 		struct ionic_queue *q = cq->bound_q;
 
-		if (!ionic_txq_hwstamp_enabled(q))
+		if (likely(!ionic_txq_hwstamp_enabled(q)))
 			netif_txq_completed_wake(q_to_ndq(q->lif->netdev, q),
 						 pkts, bytes,
 						 ionic_q_space_avail(q),
@@ -1337,7 +1337,7 @@ void ionic_tx_empty(struct ionic_queue *
 		desc_info->cb_arg = NULL;
 	}
 
-	if (!ionic_txq_hwstamp_enabled(q)) {
+	if (likely(!ionic_txq_hwstamp_enabled(q))) {
 		struct netdev_queue *ndq = q_to_ndq(q->lif->netdev, q);
 
 		netdev_tx_completed_queue(ndq, pkts, bytes);
@@ -1419,7 +1419,7 @@ static void ionic_tx_tso_post(struct net
 
 	if (start) {
 		skb_tx_timestamp(skb);
-		if (!ionic_txq_hwstamp_enabled(q))
+		if (likely(!ionic_txq_hwstamp_enabled(q)))
 			netdev_tx_sent_queue(q_to_ndq(netdev, q), skb->len);
 		ionic_txq_post(q, false, ionic_tx_clean, skb);
 	} else {
@@ -1669,7 +1669,7 @@ static int ionic_tx(struct net_device *n
 	stats->pkts++;
 	stats->bytes += skb->len;
 
-	if (!ionic_txq_hwstamp_enabled(q)) {
+	if (likely(!ionic_txq_hwstamp_enabled(q))) {
 		struct netdev_queue *ndq = q_to_ndq(netdev, q);
 
 		if (unlikely(!ionic_q_has_space(q, MAX_SKB_FRAGS + 1)))
