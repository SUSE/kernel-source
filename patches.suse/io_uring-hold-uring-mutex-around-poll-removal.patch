From 0e388fce7aec40992eadee654193cad345d62663 Mon Sep 17 00:00:00 2001
From: Jens Axboe <axboe@kernel.dk>
Date: Fri, 16 Jun 2023 21:12:06 -0600
Subject: [PATCH] io_uring: hold uring mutex around poll removal
Patch-mainline: Never, 5.15.y stable-tree patch
References: bsc#1212838 CVE-2023-3389

Snipped from commit 9ca9fb24d5febccea354089c41f96a8ad0d853f8 upstream.

While reworking the poll hashing in the v6.0 kernel, we ended up
grabbing the ctx->uring_lock in poll update/removal. This also fixed
a bug with linked timeouts racing with timeout expiry and poll
removal.

Bring back just the locking fix for that.

Reported-and-tested-by: Querijn Voet <querijnqyn@gmail.com>
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Gabriel Krisman Bertazi <krisman@suse.de>
---
 fs/io_uring.c |    4 ++++
 1 file changed, 4 insertions(+)

--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -5510,6 +5510,8 @@ static int io_poll_update(struct io_kioc
 	bool completing;
 	int ret;
 
+	io_ring_submit_lock(ctx, !(issue_flags & IO_URING_F_NONBLOCK));
+
 	spin_lock(&ctx->completion_lock);
 	preq = io_poll_find(ctx, req->poll_update.old_user_data, true);
 	if (!preq) {
@@ -5540,6 +5542,7 @@ err:
 		spin_unlock(&ctx->completion_lock);
 		req_set_fail(req);
 		io_req_complete(req, ret);
+		io_ring_submit_unlock(ctx, !(issue_flags & IO_URING_F_NONBLOCK));
 		return 0;
 	}
 	/* only mask one event flags, keep behavior flags */
@@ -5562,6 +5565,7 @@ err:
 			io_req_complete(preq, ret);
 		}
 	}
+	io_ring_submit_unlock(ctx, !(issue_flags & IO_URING_F_NONBLOCK));
 	return 0;
 }
 
