From 4ade82b8d7b2b267915ca12132b8dc1aa0dfd01f Mon Sep 17 00:00:00 2001
From: Philippe Lecluse <philippe.lecluse@intel.com>
Date: Thu, 12 Jan 2023 17:25:38 -0500
Subject: drm/xe: enforce GSMBASE for DG1 instead of BAR2
Git-commit: 2c33b49a6e6f8e176735eaca9ec6170478e0a426
Patch-mainline: v6.8-rc1
References: drm-backport-placeholder

On DG1, BAR2 is not reliable for reporting Vram size, need to use GSMBASE.
Simplify xe_mmio_total_vram_size to report vram size and usable size.

Signed-off-by: Philippe Lecluse <philippe.lecluse@intel.com>
Reviewed-by: Matthew Auld <matthew.auld@intel.com>
Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/xe/xe_mmio.c | 28 ++++++++++++++--------------
 1 file changed, 14 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/xe/xe_mmio.c b/drivers/gpu/drm/xe/xe_mmio.c
index 54c9362a3050..88d475dca6db 100644
--- a/drivers/gpu/drm/xe/xe_mmio.c
+++ b/drivers/gpu/drm/xe/xe_mmio.c
@@ -150,7 +150,7 @@ static bool xe_pci_resource_valid(struct pci_dev *pdev, int bar)
 	return true;
 }
 
-int xe_mmio_total_vram_size(struct xe_device *xe, u64 *vram_size, u64 *flat_ccs_base)
+int xe_mmio_total_vram_size(struct xe_device *xe, u64 *vram_size, u64 *usable_size)
 {
 	struct xe_gt *gt = xe_device_get_gt(xe, 0);
 	struct pci_dev *pdev = to_pci_dev(xe->drm.dev);
@@ -159,8 +159,12 @@ int xe_mmio_total_vram_size(struct xe_device *xe, u64 *vram_size, u64 *flat_ccs_
 
 	if (!xe->info.has_flat_ccs)  {
 		*vram_size = pci_resource_len(pdev, GEN12_LMEM_BAR);
-		if (flat_ccs_base)
-			*flat_ccs_base = *vram_size;
+		if (usable_size) {
+			if (xe->info.platform == XE_DG1)
+				*usable_size = xe_mmio_read64(gt, GEN12_GSMBASE.reg);
+			else
+				*usable_size = *vram_size;
+		}
 		return 0;
 	}
 
@@ -170,15 +174,13 @@ int xe_mmio_total_vram_size(struct xe_device *xe, u64 *vram_size, u64 *flat_ccs_
 
 	reg = xe_gt_mcr_unicast_read_any(gt, XEHP_TILE0_ADDR_RANGE);
 	*vram_size = (u64)REG_FIELD_GET(GENMASK(14, 8), reg) * SZ_1G;
-	if (flat_ccs_base) {
+	if (usable_size) {
 		reg = xe_gt_mcr_unicast_read_any(gt, XEHP_FLAT_CCS_BASE_ADDR);
-		*flat_ccs_base = (u64)REG_FIELD_GET(GENMASK(31, 8), reg) * SZ_64K;
+		*usable_size = (u64)REG_FIELD_GET(GENMASK(31, 8), reg) * SZ_64K;
+		drm_info(&xe->drm, "lmem_size: 0x%llx usable_size: 0x%llx\n",
+			 *vram_size, *usable_size);
 	}
 
-	if (flat_ccs_base)
-		drm_info(&xe->drm, "lmem_size: 0x%llx flat_ccs_base: 0x%llx\n",
-			 *vram_size, *flat_ccs_base);
-
 	return xe_force_wake_put(gt_to_fw(gt), XE_FW_GT);
 }
 
@@ -190,7 +192,7 @@ int xe_mmio_probe_vram(struct xe_device *xe)
 	u64 lmem_size;
 	u64 original_size;
 	u64 current_size;
-	u64 flat_ccs_base;
+	u64 usable_size;
 	int resize_result, err;
 
 	if (!IS_DGFX(xe)) {
@@ -212,11 +214,9 @@ int xe_mmio_probe_vram(struct xe_device *xe)
 	}
 
 	gt = xe_device_get_gt(xe, 0);
-	lmem_size = xe_mmio_read64(gt, GEN12_GSMBASE.reg);
-
 	original_size = pci_resource_len(pdev, GEN12_LMEM_BAR);
 
-	err = xe_mmio_total_vram_size(xe, &lmem_size, &flat_ccs_base);
+	err = xe_mmio_total_vram_size(xe, &lmem_size, &usable_size);
 	if (err)
 		return err;
 
@@ -244,7 +244,7 @@ int xe_mmio_probe_vram(struct xe_device *xe)
 	xe->mem.vram.mapping = ioremap_wc(xe->mem.vram.io_start, xe->mem.vram.size);
 #endif
 
-	xe->mem.vram.size = min_t(u64, xe->mem.vram.size, flat_ccs_base);
+	xe->mem.vram.size = min_t(u64, xe->mem.vram.size, usable_size);
 
 	drm_info(&xe->drm, "TOTAL VRAM: %pa, %pa\n", &xe->mem.vram.io_start, &xe->mem.vram.size);
 
-- 
2.46.1

