From: Rick Edgecombe <rick.p.edgecombe@intel.com>
Date: Wed, 21 Feb 2024 16:17:21 -0800
Subject: dma-direct: Leak pages on dma_set_decrypted() failure
Git-commit: b9fa16949d18e06bdf728a560f5c8af56d2bdcaf
Patch-mainline: v6.9-rc1
References: bsc#1224535 CVE-2024-35939

On TDX it is possible for the untrusted host to cause
set_memory_encrypted() or set_memory_decrypted() to fail such that an
error is returned and the resulting memory is shared. Callers need to
take care to handle these errors to avoid returning decrypted (shared)
memory to the page allocator, which could lead to functional or security
issues.

DMA could free decrypted/shared pages if dma_set_decrypted() fails. This
should be a rare case. Just leak the pages in this case instead of
freeing them.

Signed-off-by: Rick Edgecombe <rick.p.edgecombe@intel.com>
Signed-off-by: Christoph Hellwig <hch@lst.de>
Acked-by: Nikolay Borisov <nik.borisov@suse.com>
---
 kernel/dma/direct.c |    7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@ -214,7 +214,7 @@ void *dma_direct_alloc(struct device *de
 			err = set_memory_decrypted((unsigned long)ret,
 						   1 << get_order(size));
 			if (err)
-				goto out_free_pages;
+				goto out_leak_pages;
 		}
 		memset(ret, 0, size);
 		goto done;
@@ -263,6 +263,8 @@ out_encrypt_pages:
 out_free_pages:
 	__dma_direct_free_pages(dev, page, size);
 	return NULL;
+out_leak_pages:
+	return NULL;
 }
 
 void dma_direct_free(struct device *dev, size_t size,
@@ -329,13 +331,14 @@ struct page *dma_direct_alloc_pages(stru
 	if (force_dma_unencrypted(dev)) {
 		if (set_memory_decrypted((unsigned long)ret,
 				1 << get_order(size)))
-			goto out_free_pages;
+			goto out_leak_pages;
 	}
 	memset(ret, 0, size);
 	*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));
 	return page;
 out_free_pages:
 	__dma_direct_free_pages(dev, page, size);
+out_leak_pages:
 	return NULL;
 }
 
