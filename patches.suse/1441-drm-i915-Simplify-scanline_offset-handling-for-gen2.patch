From 6e35f39d8a9dab913ad415f0f51a9c6a13b50827 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Tue, 28 May 2024 21:56:44 +0300
Subject: drm/i915: Simplify scanline_offset handling for gen2
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 5316dd0d617bb98956f75cb33982efe1b26d8f19
Patch-mainline: v6.11-rc1
References: jsc#PED-9898 jsc#PED-10191 jsc#PED-10197 jsc#PED-10226 jsc#PED-10237 jsc#PED-10340 jsc#PED-10852 jsc#PED-11022

Currently intel_crtc_scanline_offset() is careful to always
return a positive offset. That is not actually necessary
as long as we take care of negative values when applying the
offset in __intel_get_crtc_scanline().

This simplifies intel_crtc_scanline_offset(), and makes
the scanline_offfset arithmetic more symmetric between
the forward (__intel_get_crtc_scanline()) and reverse
(intel_crtc_scanline_to_hw()) directions.

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20240528185647.7765-5-ville.syrjala@linux.intel.com
Reviewed-by: Jani Nikula <jani.nikula@intel.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/i915/display/intel_vblank.c | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_vblank.c b/drivers/gpu/drm/i915/display/intel_vblank.c
index 31fa5867e1a7..b0e95a4c680d 100644
--- a/drivers/gpu/drm/i915/display/intel_vblank.c
+++ b/drivers/gpu/drm/i915/display/intel_vblank.c
@@ -240,7 +240,7 @@ static int __intel_get_crtc_scanline(struct intel_crtc *crtc)
 	 * See update_scanline_offset() for the details on the
 	 * scanline_offset adjustment.
 	 */
-	return (position + crtc->scanline_offset) % vtotal;
+	return (position + vtotal + crtc->scanline_offset) % vtotal;
 }
 
 int intel_crtc_scanline_to_hw(struct intel_crtc *crtc, int scanline)
@@ -470,7 +470,6 @@ void intel_wait_for_pipe_scanline_moving(struct intel_crtc *crtc)
 static int intel_crtc_scanline_offset(const struct intel_crtc_state *crtc_state)
 {
 	struct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);
-	const struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;
 
 	/*
 	 * The scanline counter increments at the leading edge of hsync.
@@ -482,8 +481,7 @@ static int intel_crtc_scanline_offset(const struct intel_crtc_state *crtc_state)
 	 * last active line), the scanline counter will read vblank_start-1.
 	 *
 	 * On gen2 the scanline counter starts counting from 1 instead
-	 * of vtotal-1, so we have to subtract one (or rather add vtotal-1
-	 * to keep the value positive), instead of adding one.
+	 * of vtotal-1, so we have to subtract one.
 	 *
 	 * On HSW+ the behaviour of the scanline counter depends on the output
 	 * type. For DP ports it behaves like most other platforms, but on HDMI
@@ -500,7 +498,7 @@ static int intel_crtc_scanline_offset(const struct intel_crtc_state *crtc_state)
 	 * answer that's slightly in the future.
 	 */
 	if (DISPLAY_VER(i915) == 2)
-		return intel_mode_vtotal(adjusted_mode) - 1;
+		return -1;
 	else if (HAS_DDI(i915) && intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
 		return 2;
 	else
-- 
2.46.1

