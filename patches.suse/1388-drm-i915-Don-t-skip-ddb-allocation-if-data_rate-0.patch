From 503817afff05e49bed51750b2d908f15645a036b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Mon, 14 Feb 2022 12:55:29 +0200
Subject: drm/i915: Don't skip ddb allocation if data_rate==0
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Alt-commit: 6475e106821babc0dc478a9cb3fc3973739c43fb
Git-commit: 117f5bb31c8cdb1e8f0b443f2a0ac761bf54694c
Patch-mainline: v5.18-rc1
References: jsc#PED-1166 jsc#PED-1168 jsc#PED-1170 jsc#PED-1218 jsc#PED-1220 jsc#PED-1222 jsc#PED-1223 jsc#PED-1225

data_rate==0 no longer means a plane is disabled, it could
also mean we want to use the minimum ddb allocation for it.
Hence we can't bail out early during ddb allocation or
else we'll simply forget to allocate any ddb for such planes.

Cc: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Fixes: 6a4d8cc6bbbf ("drm/i915: Don't allocate extra ddb during async flip for DG2")
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20220214105532.13049-2-ville.syrjala@linux.intel.com
Reviewed-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
(cherry picked from commit 6475e106821babc0dc478a9cb3fc3973739c43fb)
Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/i915/intel_pm.c | 30 ++++++++++++------------------
 1 file changed, 12 insertions(+), 18 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c
index 5af16ca4dabd..71f7fba2c9e2 100644
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@ -5145,12 +5145,15 @@ skl_allocate_plane_ddb(struct skl_plane_ddb_iter *iter,
 		       const struct skl_wm_level *wm,
 		       u64 data_rate)
 {
-	u16 extra;
+	u16 extra = 0;
 
-	extra = min_t(u16, iter->size,
-		      DIV64_U64_ROUND_UP(iter->size * data_rate, iter->data_rate));
-	iter->size -= extra;
-	iter->data_rate -= data_rate;
+	if (data_rate) {
+		extra = min_t(u16, iter->size,
+			      DIV64_U64_ROUND_UP(iter->size * data_rate,
+						 iter->data_rate));
+		iter->size -= extra;
+		iter->data_rate -= data_rate;
+	}
 
 	return wm->min_ddb_alloc + extra;
 }
@@ -5193,9 +5196,6 @@ skl_crtc_allocate_plane_ddb(struct intel_atomic_state *state,
 	skl_ddb_entry_init(&crtc_state->wm.skl.plane_ddb_y[PLANE_CURSOR],
 			   alloc->end - iter.total[PLANE_CURSOR], alloc->end);
 
-	if (iter.data_rate == 0)
-		return 0;
-
 	/*
 	 * Find the highest watermark level for which we can satisfy the block
 	 * requirement of active planes.
@@ -5234,6 +5234,10 @@ skl_crtc_allocate_plane_ddb(struct intel_atomic_state *state,
 		return -EINVAL;
 	}
 
+	/* avoid the WARN later when we don't allocate any extra DDB */
+	if (iter.data_rate == 0)
+		iter.size = 0;
+
 	/*
 	 * Grant each plane the blocks it requires at the highest achievable
 	 * watermark level, plus an extra share of the leftover blocks
@@ -5246,20 +5250,10 @@ skl_crtc_allocate_plane_ddb(struct intel_atomic_state *state,
 		if (plane_id == PLANE_CURSOR)
 			continue;
 
-		/*
-		 * We've accounted for all active planes; remaining planes are
-		 * all disabled.
-		 */
-		if (iter.data_rate == 0)
-			break;
-
 		iter.total[plane_id] =
 			skl_allocate_plane_ddb(&iter, &wm->wm[level],
 					       crtc_state->plane_data_rate[plane_id]);
 
-		if (iter.data_rate == 0)
-			break;
-
 		iter.uv_total[plane_id] =
 			skl_allocate_plane_ddb(&iter, &wm->uv_wm[level],
 					       crtc_state->uv_plane_data_rate[plane_id]);
-- 
2.38.1

