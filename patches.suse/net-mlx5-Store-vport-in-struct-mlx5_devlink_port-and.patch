From: Jiri Pirko <jiri@nvidia.com>
Date: Wed, 31 May 2023 13:36:43 +0200
Subject: net/mlx5: Store vport in struct mlx5_devlink_port and use it in port
 ops
Patch-mainline: v6.6-rc1
Git-commit: 7d8335200c94f6f76fbc3a1682993888bc4eb665
References: jsc#PED-3311

Instead of using internal devlink_port->index to perform vport lookup in
every devlink port op, store the vport pointer to the container struct
mlx5_devlink_port and use it directly in port ops.

Signed-off-by: Jiri Pirko <jiri@nvidia.com>
Reviewed-by: Shay Drory <shayd@nvidia.com>
Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/esw/devlink_port.c |    2 
 drivers/net/ethernet/mellanox/mlx5/core/eswitch.h          |   19 ++++
 drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c |   61 +------------
 3 files changed, 29 insertions(+), 53 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/devlink_port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/devlink_port.c
@@ -71,6 +71,7 @@ int mlx5_esw_offloads_pf_vf_devlink_port
 						       &dl_port->dl_port);
 
 	vport->dl_port = dl_port;
+	mlx5_devlink_port_init(dl_port, vport);
 	return 0;
 }
 
@@ -115,6 +116,7 @@ int mlx5_esw_offloads_sf_devlink_port_in
 	mlx5_esw_offloads_sf_devlink_port_attrs_set(esw, &dl_port->dl_port, controller, sfnum);
 
 	vport->dl_port = dl_port;
+	mlx5_devlink_port_init(dl_port, vport);
 	return 0;
 }
 
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -172,10 +172,29 @@ enum mlx5_eswitch_vport_event {
 	MLX5_VPORT_PROMISC_CHANGE = BIT(3),
 };
 
+struct mlx5_vport;
+
 struct mlx5_devlink_port {
 	struct devlink_port dl_port;
+	struct mlx5_vport *vport;
 };
 
+static inline void mlx5_devlink_port_init(struct mlx5_devlink_port *dl_port,
+					  struct mlx5_vport *vport)
+{
+	dl_port->vport = vport;
+}
+
+static inline struct mlx5_devlink_port *mlx5_devlink_port_get(struct devlink_port *dl_port)
+{
+	return container_of(dl_port, struct mlx5_devlink_port, dl_port);
+}
+
+static inline struct mlx5_vport *mlx5_devlink_port_vport_get(struct devlink_port *dl_port)
+{
+	return mlx5_devlink_port_get(dl_port)->vport;
+}
+
 struct mlx5_vport {
 	struct mlx5_core_dev    *dev;
 	struct hlist_head       uc_list[MLX5_L2_ADDR_HASH_SIZE];
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -4223,17 +4223,7 @@ int mlx5_devlink_port_fn_hw_addr_get(str
 				     struct netlink_ext_ack *extack)
 {
 	struct mlx5_eswitch *esw = mlx5_devlink_eswitch_nocheck_get(port->devlink);
-	struct mlx5_vport *vport;
-	u16 vport_num;
-
-
-	vport_num = mlx5_esw_devlink_port_index_to_vport_num(port->index);
-
-	vport = mlx5_eswitch_get_vport(esw, vport_num);
-	if (IS_ERR(vport)) {
-		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
-		return PTR_ERR(vport);
-	}
+	struct mlx5_vport *vport = mlx5_devlink_port_vport_get(port);
 
 	mutex_lock(&esw->state_lock);
 	ether_addr_copy(hw_addr, vport->info.mac);
@@ -4247,26 +4237,16 @@ int mlx5_devlink_port_fn_hw_addr_set(str
 				     struct netlink_ext_ack *extack)
 {
 	struct mlx5_eswitch *esw = mlx5_devlink_eswitch_nocheck_get(port->devlink);
-	u16 vport_num;
-
-	vport_num = mlx5_esw_devlink_port_index_to_vport_num(port->index);
-	return mlx5_eswitch_set_vport_mac(esw, vport_num, hw_addr);
-}
-
-static struct mlx5_vport *
-mlx5_devlink_port_fn_get_vport(struct devlink_port *port, struct mlx5_eswitch *esw)
-{
-	u16 vport_num;
+	struct mlx5_vport *vport = mlx5_devlink_port_vport_get(port);
 
-	vport_num = mlx5_esw_devlink_port_index_to_vport_num(port->index);
-	return mlx5_eswitch_get_vport(esw, vport_num);
+	return mlx5_eswitch_set_vport_mac(esw, vport->vport, hw_addr);
 }
 
 int mlx5_devlink_port_fn_migratable_get(struct devlink_port *port, bool *is_enabled,
 					struct netlink_ext_ack *extack)
 {
 	struct mlx5_eswitch *esw = mlx5_devlink_eswitch_nocheck_get(port->devlink);
-	struct mlx5_vport *vport;
+	struct mlx5_vport *vport = mlx5_devlink_port_vport_get(port);
 
 	if (!MLX5_CAP_GEN(esw->dev, migration)) {
 		NL_SET_ERR_MSG_MOD(extack, "Device doesn't support migration");
@@ -4278,12 +4258,6 @@ int mlx5_devlink_port_fn_migratable_get(
 		return -EOPNOTSUPP;
 	}
 
-	vport = mlx5_devlink_port_fn_get_vport(port, esw);
-	if (IS_ERR(vport)) {
-		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
-		return PTR_ERR(vport);
-	}
-
 	mutex_lock(&esw->state_lock);
 	*is_enabled = vport->info.mig_enabled;
 	mutex_unlock(&esw->state_lock);
@@ -4294,8 +4268,8 @@ int mlx5_devlink_port_fn_migratable_set(
 					struct netlink_ext_ack *extack)
 {
 	struct mlx5_eswitch *esw = mlx5_devlink_eswitch_nocheck_get(port->devlink);
+	struct mlx5_vport *vport = mlx5_devlink_port_vport_get(port);
 	int query_out_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);
-	struct mlx5_vport *vport;
 	void *query_ctx;
 	void *hca_caps;
 	int err;
@@ -4310,12 +4284,6 @@ int mlx5_devlink_port_fn_migratable_set(
 		return -EOPNOTSUPP;
 	}
 
-	vport = mlx5_devlink_port_fn_get_vport(port, esw);
-	if (IS_ERR(vport)) {
-		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
-		return PTR_ERR(vport);
-	}
-
 	mutex_lock(&esw->state_lock);
 
 	if (vport->info.mig_enabled == enable) {
@@ -4359,19 +4327,13 @@ int mlx5_devlink_port_fn_roce_get(struct
 				  struct netlink_ext_ack *extack)
 {
 	struct mlx5_eswitch *esw = mlx5_devlink_eswitch_nocheck_get(port->devlink);
-	struct mlx5_vport *vport;
+	struct mlx5_vport *vport = mlx5_devlink_port_vport_get(port);
 
 	if (!MLX5_CAP_GEN(esw->dev, vhca_resource_manager)) {
 		NL_SET_ERR_MSG_MOD(extack, "Device doesn't support VHCA management");
 		return -EOPNOTSUPP;
 	}
 
-	vport = mlx5_devlink_port_fn_get_vport(port, esw);
-	if (IS_ERR(vport)) {
-		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
-		return PTR_ERR(vport);
-	}
-
 	mutex_lock(&esw->state_lock);
 	*is_enabled = vport->info.roce_enabled;
 	mutex_unlock(&esw->state_lock);
@@ -4382,11 +4344,11 @@ int mlx5_devlink_port_fn_roce_set(struct
 				  struct netlink_ext_ack *extack)
 {
 	struct mlx5_eswitch *esw = mlx5_devlink_eswitch_nocheck_get(port->devlink);
+	struct mlx5_vport *vport = mlx5_devlink_port_vport_get(port);
 	int query_out_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);
-	struct mlx5_vport *vport;
+	u16 vport_num = vport->vport;
 	void *query_ctx;
 	void *hca_caps;
-	u16 vport_num;
 	int err;
 
 	if (!MLX5_CAP_GEN(esw->dev, vhca_resource_manager)) {
@@ -4394,13 +4356,6 @@ int mlx5_devlink_port_fn_roce_set(struct
 		return -EOPNOTSUPP;
 	}
 
-	vport = mlx5_devlink_port_fn_get_vport(port, esw);
-	if (IS_ERR(vport)) {
-		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
-		return PTR_ERR(vport);
-	}
-	vport_num = vport->vport;
-
 	mutex_lock(&esw->state_lock);
 
 	if (vport->info.roce_enabled == enable) {
