From: NeilBrown <neilb@suse.de>
Subject: NFS: never reuse a NFSv4.0 lock-owner
Patch-mainline: Never, a more intrusive version has been submitted
References: bsc#1227726 bsc#1230733

There appears to be a bug in the NFS server such that lock owners are
sometimes not discarded when the client expect them to be.

The client create a new lock owner re-using the id from a previous lock
owner, and the server thinks it is the same as the old one, so they
disagree on the corrcet seqid and locking doesn't work.

This patch avoids the problem by including a creation timestamp in the
lock owner id.  This ensures that the client never reuses a lock owner,
so the disagreement cannot happen.

Acked-by: NeilBrown <neilb@suse.com>
Signed-off-by: Neil Brown <neilb@suse.com>

---
 fs/nfs/callback_xdr.c   |    6 ++++--
 fs/nfs/nfs4proc.c       |    7 ++++++-
 fs/nfs/nfs4xdr.c        |    7 ++++---
 include/linux/nfs_xdr.h |    1 +
 4 files changed, 15 insertions(+), 6 deletions(-)

--- a/fs/nfs/callback_xdr.c
+++ b/fs/nfs/callback_xdr.c
@@ -496,14 +496,16 @@ static __be32 decode_lockowner(struct xd
 		return htonl(NFS4ERR_BADXDR);
 
 	/* Only try to decode if the length is right */
-	if (len == 20) {
+	if (len == 28) {
 		p += 2;	/* skip "lock id:" */
 		args->cbnl_owner.s_dev = be32_to_cpu(*p++);
-		xdr_decode_hyper(p, &args->cbnl_owner.id);
+		p = xdr_decode_hyper(p, &args->cbnl_owner.id);
+		xdr_decode_hyper(p, &args->cbnl_owner.create_time);
 		args->cbnl_valid = true;
 	} else {
 		args->cbnl_owner.s_dev = 0;
 		args->cbnl_owner.id = 0;
+		args->cbnl_owner.create_time = 0;
 		args->cbnl_valid = false;
 	}
 	return 0;
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -6760,6 +6760,7 @@ static int _nfs4_proc_getlk(struct nfs4_
 		goto out;
 	lsp = request->fl_u.nfs4_fl.owner;
 	arg.lock_owner.id = lsp->ls_seqid.owner_id;
+	arg.lock_owner.create_time = ktime_to_ns(lsp->ls_seqid.create_time);
 	arg.lock_owner.s_dev = server->s_dev;
 	status = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);
 	switch (status) {
@@ -7085,6 +7086,7 @@ static struct nfs4_lockdata *nfs4_alloc_
 		goto out_free_seqid;
 	p->arg.lock_owner.clientid = server->nfs_client->cl_clientid;
 	p->arg.lock_owner.id = lsp->ls_seqid.owner_id;
+	p->arg.lock_owner.create_time = ktime_to_ns(lsp->ls_seqid.create_time);
 	p->arg.lock_owner.s_dev = server->s_dev;
 	p->res.lock_seqid = p->arg.lock_seqid;
 	p->lsp = lsp;
@@ -7478,7 +7480,9 @@ nfs4_retry_setlk(struct nfs4_state *stat
 		.inode = state->inode,
 		.owner = { .clientid = clp->cl_clientid,
 			   .id = lsp->ls_seqid.owner_id,
-			   .s_dev = server->s_dev },
+			  .s_dev = server->s_dev,
+			  .create_time = ktime_to_ns(lsp->ls_seqid.create_time),
+		},
 	};
 	int status;
 
@@ -7694,6 +7698,7 @@ nfs4_release_lockowner(struct nfs_server
 	data->server = server;
 	data->args.lock_owner.clientid = server->nfs_client->cl_clientid;
 	data->args.lock_owner.id = lsp->ls_seqid.owner_id;
+	data->args.lock_owner.create_time = ktime_to_ns(lsp->ls_seqid.create_time);
 	data->args.lock_owner.s_dev = server->s_dev;
 
 	msg.rpc_argp = &data->args;
--- a/fs/nfs/nfs4xdr.c
+++ b/fs/nfs/nfs4xdr.c
@@ -1321,12 +1321,13 @@ static void encode_lockowner(struct xdr_
 {
 	__be32 *p;
 
-	p = reserve_space(xdr, 32);
+	p = reserve_space(xdr, 32+8);
 	p = xdr_encode_hyper(p, lowner->clientid);
-	*p++ = cpu_to_be32(20);
+	*p++ = cpu_to_be32(20+8);
 	p = xdr_encode_opaque_fixed(p, "lock id:", 8);
 	*p++ = cpu_to_be32(lowner->s_dev);
-	xdr_encode_hyper(p, lowner->id);
+	p = xdr_encode_hyper(p, lowner->id);
+	xdr_encode_hyper(p, lowner->create_time);
 }
 
 /*
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -551,6 +551,7 @@ struct nfs_lowner {
 	__u64			clientid;
 	__u64			id;
 	dev_t			s_dev;
+	__u64			create_time;
 };
 
 struct nfs_lock_args {
