From: Fangzhi Zuo <Jerry.Zuo@amd.com>
Date: Tue, 23 Jul 2024 17:14:13 -0400
Subject: drm/amd/display: Take Synaptics Cascaded Topology into Account
Patch-mainline: submitted https://gitlab.freedesktop.org/drm/amd/-/issues/3495#note_2501831
References: bsc#1228093 #3495

Synaptics Cascaded MST hub has chained MST branch device which
requires additional bw overhead.

Signed-off-by: Fangzhi Zuo <Jerry.Zuo@amd.com>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>

---
[v2] call is_synaptics_cascaded_panamera() unconditionally

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h           |    1 
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c |   25 +++++++-----
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.h |    3 +
 3 files changed, 19 insertions(+), 10 deletions(-)

--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
@@ -662,6 +662,7 @@ struct amdgpu_dm_connector {
 	struct amdgpu_dm_connector *mst_root;
 	struct drm_dp_aux *dsc_aux;
 	struct mutex handle_mst_msg_ready;
+	bool is_synaptics_cascaded;
 
 	/* TODO see if we can merge with ddc_bus or make a dm_connector */
 	struct amdgpu_i2c_adapter *i2c;
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -248,8 +248,9 @@ static bool validate_dsc_caps_on_connect
 	    needs_dsc_aux_workaround(aconnector->dc_link))
 		aconnector->dsc_aux = &aconnector->mst_root->dm_dp_aux.aux;
 
+	aconnector->is_synaptics_cascaded = is_synaptics_cascaded_panamera(aconnector->dc_link, port);
 	/* synaptics cascaded MST hub case */
-	if (!aconnector->dsc_aux && is_synaptics_cascaded_panamera(aconnector->dc_link, port))
+	if (!aconnector->dsc_aux && aconnector->is_synaptics_cascaded)
 		aconnector->dsc_aux = port->mgr->aux;
 
 	if (!aconnector->dsc_aux)
@@ -794,12 +795,17 @@ struct dsc_mst_fairness_params {
 	struct amdgpu_dm_connector *aconnector;
 };
 
-static int kbps_to_peak_pbn(int kbps)
+static int kbps_to_peak_pbn(int kbps, struct amdgpu_dm_connector *aconnector)
 {
 	u64 peak_kbps = kbps;
 
 	peak_kbps *= 1006;
 	peak_kbps = div_u64(peak_kbps, 1000);
+	if (aconnector->is_synaptics_cascaded) {
+		printk("Synaptics Cascaded Overhead Adjustment.\n");
+		peak_kbps *= PBN_FEC_OVERHEAD_MULTIPLIER_8B_10B;
+		peak_kbps = div_u64(peak_kbps, 1000);
+	}
 	return (int) DIV64_U64_ROUND_UP(peak_kbps * 64, (54 * 8 * 1000));
 }
 
@@ -904,7 +910,7 @@ static int increase_dsc_bpp(struct drm_a
 	for (i = 0; i < count; i++) {
 		if (vars[i + k].dsc_enabled) {
 			initial_slack[i] =
-			kbps_to_peak_pbn(params[i].bw_range.max_kbps) - vars[i + k].pbn;
+			kbps_to_peak_pbn(params[i].bw_range.max_kbps, params[i].aconnector) - vars[i + k].pbn;
 			bpp_increased[i] = false;
 			remaining_to_increase += 1;
 		} else {
@@ -1029,7 +1035,7 @@ static int try_disable_dsc(struct drm_at
 		if (next_index == -1)
 			break;
 
-		vars[next_index].pbn = kbps_to_peak_pbn(params[next_index].bw_range.stream_kbps);
+		vars[next_index].pbn = kbps_to_peak_pbn(params[next_index].bw_range.stream_kbps, params[i].aconnector);
 		ret = drm_dp_atomic_find_time_slots(state,
 						    params[next_index].port->mgr,
 						    params[next_index].port,
@@ -1043,7 +1049,7 @@ static int try_disable_dsc(struct drm_at
 			vars[next_index].bpp_x16 = 0;
 		} else {
 			vars[next_index].pbn = kbps_to_peak_pbn(
-				params[next_index].bw_range.max_kbps);
+				params[next_index].bw_range.max_kbps, params[i].aconnector);
 			ret = drm_dp_atomic_find_time_slots(state,
 							    params[next_index].port->mgr,
 							    params[next_index].port,
@@ -1135,8 +1141,7 @@ static int compute_mst_dsc_configs_for_l
 
 	/* Try no compression */
 	for (i = 0; i < count; i++) {
-		vars[i + k].aconnector = params[i].aconnector;
-		vars[i + k].pbn = kbps_to_peak_pbn(params[i].bw_range.stream_kbps);
+		vars[i + k].pbn = kbps_to_peak_pbn(params[i].bw_range.stream_kbps, params[i].aconnector);
 		vars[i + k].dsc_enabled = false;
 		vars[i + k].bpp_x16 = 0;
 		ret = drm_dp_atomic_find_time_slots(state, params[i].port->mgr, params[i].port,
@@ -1155,7 +1160,7 @@ static int compute_mst_dsc_configs_for_l
 	/* Try max compression */
 	for (i = 0; i < count; i++) {
 		if (params[i].compression_possible && params[i].clock_force_enable != DSC_CLK_FORCE_DISABLE) {
-			vars[i + k].pbn = kbps_to_peak_pbn(params[i].bw_range.min_kbps);
+			vars[i + k].pbn = kbps_to_peak_pbn(params[i].bw_range.min_kbps, params[i].aconnector);
 			vars[i + k].dsc_enabled = true;
 			vars[i + k].bpp_x16 = params[i].bw_range.min_target_bpp_x16;
 			ret = drm_dp_atomic_find_time_slots(state, params[i].port->mgr,
@@ -1163,7 +1168,7 @@ static int compute_mst_dsc_configs_for_l
 			if (ret < 0)
 				return ret;
 		} else {
-			vars[i + k].pbn = kbps_to_peak_pbn(params[i].bw_range.stream_kbps);
+			vars[i + k].pbn = kbps_to_peak_pbn(params[i].bw_range.stream_kbps, params[i].aconnector);
 			vars[i + k].dsc_enabled = false;
 			vars[i + k].bpp_x16 = 0;
 			ret = drm_dp_atomic_find_time_slots(state, params[i].port->mgr,
@@ -1658,7 +1663,7 @@ enum dc_status dm_dp_mst_is_port_support
 			dc_bandwidth_in_kbps_from_timing(&stream->timing,
 				dc_link_get_highest_encoding_format(stream->link));
 
-		pbn = kbps_to_peak_pbn(stream_kbps);
+		pbn = kbps_to_peak_pbn(stream_kbps, aconnector);
 		pbn_div = dm_mst_get_pbn_divider(stream->link);
 		slot_num = DIV_ROUND_UP(pbn, pbn_div);
 
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.h
@@ -46,6 +46,9 @@
 #define SYNAPTICS_CASCADED_HUB_ID  0x5A
 #define IS_SYNAPTICS_CASCADED_PANAMERA(devName, data) ((IS_SYNAPTICS_PANAMERA(devName) && ((int)data[2] == SYNAPTICS_CASCADED_HUB_ID)) ? 1 : 0)
 
+#define PBN_FEC_OVERHEAD_MULTIPLIER_8B_10B	1031
+#define PBN_FEC_OVERHEAD_MULTIPLIER_128B_132B	1000
+
 enum mst_msg_ready_type {
 	NONE_MSG_RDY_EVENT = 0,
 	DOWN_REP_MSG_RDY_EVENT = 1,
