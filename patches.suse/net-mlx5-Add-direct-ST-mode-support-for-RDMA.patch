From: Yishai Hadas <yishaih@nvidia.com>
Date: Mon, 27 Oct 2025 11:34:02 +0200
Subject: net/mlx5: Add direct ST mode support for RDMA
Patch-mainline: v6.19-rc1
Git-commit: 2d838c11e10e9169cae4f7778345c11b5447ef05
References: jsc#PED-14197 jsc#PED-14199 jsc#PED-15315

Add support for direct ST mode where ST Table Location equals
PCI_TPH_LOC_NONE.

In that case, no steering table exists, the steering tag itself will be
used directly by the SW, FW, HW from the mkey.

This enables RDMA users to use the current exposed APIs to work in
direct mode.

Signed-off-by: Yishai Hadas <yishaih@nvidia.com>
Signed-off-by: Edward Srouji <edwards@nvidia.com>
Link: https://patch.msgid.link/20251027-st-direct-mode-v1-2-e0ad953866b6@nvidia.com
Signed-off-by: Leon Romanovsky <leon@kernel.org>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/lib/st.c |   29 +++++++++++++++++++----
 1 file changed, 25 insertions(+), 4 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/lib/st.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lib/st.c
@@ -19,13 +19,16 @@ struct mlx5_st {
 	struct mutex lock;
 	struct xa_limit index_limit;
 	struct xarray idx_xa; /* key == index, value == struct mlx5_st_idx_data */
+	u8 direct_mode : 1;
 };
 
 struct mlx5_st *mlx5_st_create(struct mlx5_core_dev *dev)
 {
 	struct pci_dev *pdev = dev->pdev;
 	struct mlx5_st *st;
+	u8 direct_mode = 0;
 	u16 num_entries;
+	u32 tbl_loc;
 	int ret;
 
 	if (!MLX5_CAP_GEN(dev, mkey_pcie_tph))
@@ -40,10 +43,16 @@ struct mlx5_st *mlx5_st_create(struct ml
 	if (!pdev->tph_cap)
 		return NULL;
 
-	num_entries = pcie_tph_get_st_table_size(pdev);
-	/* We need a reserved entry for non TPH cases */
-	if (num_entries < 2)
-		return NULL;
+	tbl_loc = pcie_tph_get_st_table_loc(pdev);
+	if (tbl_loc == PCI_TPH_LOC_NONE)
+		direct_mode = 1;
+
+	if (!direct_mode) {
+		num_entries = pcie_tph_get_st_table_size(pdev);
+		/* We need a reserved entry for non TPH cases */
+		if (num_entries < 2)
+			return NULL;
+	}
 
 	/* The OS doesn't support ST */
 	ret = pcie_enable_tph(pdev, PCI_TPH_ST_DS_MODE);
@@ -56,6 +65,10 @@ struct mlx5_st *mlx5_st_create(struct ml
 
 	mutex_init(&st->lock);
 	xa_init_flags(&st->idx_xa, XA_FLAGS_ALLOC);
+	st->direct_mode = direct_mode;
+	if (st->direct_mode)
+		return st;
+
 	/* entry 0 is reserved for non TPH cases */
 	st->index_limit.min = MLX5_MKC_PCIE_TPH_NO_STEERING_TAG_INDEX + 1;
 	st->index_limit.max = num_entries - 1;
@@ -96,6 +109,11 @@ int mlx5_st_alloc_index(struct mlx5_core
 	if (ret)
 		return ret;
 
+	if (st->direct_mode) {
+		*st_index = tag;
+		return 0;
+	}
+
 	mutex_lock(&st->lock);
 
 	xa_for_each(&st->idx_xa, index, idx_data) {
@@ -145,6 +163,9 @@ int mlx5_st_dealloc_index(struct mlx5_co
 	if (!st)
 		return -EOPNOTSUPP;
 
+	if (st->direct_mode)
+		return 0;
+
 	mutex_lock(&st->lock);
 	idx_data = xa_load(&st->idx_xa, st_index);
 	if (WARN_ON_ONCE(!idx_data)) {
