From: David Howells <dhowells@redhat.com>
Date: Tue, 8 Jul 2025 22:15:04 +0100
Subject: [PATCH] rxrpc: Fix oops due to non-existence of prealloc backlog
 struct
Git-commit: 880a88f318cf1d2a0f4c0a7ff7b07e2062b434a4
Patch-mainline: v6.16-rc6
References: CVE-2025-38514 bsc#1248202

If an AF_RXRPC service socket is opened and bound, but calls are
preallocated, then rxrpc_alloc_incoming_call() will oops because the
rxrpc_backlog struct doesn't get allocated until the first preallocation is
made.

Fix this by returning NULL from rxrpc_alloc_incoming_call() if there is no
backlog struct.  This will cause the incoming call to be aborted.

Reported-by: Junvyyang, Tencent Zhuque Lab <zhuque@tencent.com>
Suggested-by: Junvyyang, Tencent Zhuque Lab <zhuque@tencent.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Cc: LePremierHomme <kwqcheii@proton.me>
Cc: Marc Dionne <marc.dionne@auristor.com>
Cc: Willy Tarreau <w@1wt.eu>
Cc: Simon Horman <horms@kernel.org>
Cc: linux-afs@lists.infradead.org
Link: https://patch.msgid.link/20250708211506.2699012-3-dhowells@redhat.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: David Sterba <dsterba@suse.com>
---
 net/rxrpc/call_accept.c |    3 +++
 1 file changed, 3 insertions(+)

--- a/net/rxrpc/call_accept.c
+++ b/net/rxrpc/call_accept.c
@@ -253,6 +253,9 @@ static struct rxrpc_call *rxrpc_alloc_in
 	unsigned short call_tail, conn_tail, peer_tail;
 	unsigned short call_count, conn_count;
 
+	if (!b)
+		return NULL;
+
 	/* #calls >= #conns >= #peers must hold true. */
 	call_head = smp_load_acquire(&b->call_backlog_head);
 	call_tail = b->call_backlog_tail;
