From 8cd5ad18ddc3caab734c376eda5214f01eeb932c Mon Sep 17 00:00:00 2001
From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date: Mon, 9 Oct 2023 12:05:36 -0700
Subject: [PATCH] thermal: int340x: processor_thermal: Handle power floor interrupts
Git-commit: 8cd5ad18ddc3caab734c376eda5214f01eeb932c
Patch-mainline: v6.7-rc1
References: jsc#PED-10050

On thermal device interrupt, if the interrupt is generated for passing
power floor status, call the callback to pass notification to the user
space.

First call proc_thermal_check_power_floor_intr() to check interrupt, if
this callback returns true, wake the IRQ thread to call
proc_thermal_power_floor_intr_callback() to notify user space.

Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 .../intel/int340x_thermal/processor_thermal_device_pci.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/drivers/thermal/intel/int340x_thermal/processor_thermal_device_pci.c b/drivers/thermal/intel/int340x_thermal/processor_thermal_device_pci.c
index ae70fabffb2d..4c2194f19ed2 100644
--- a/drivers/thermal/intel/int340x_thermal/processor_thermal_device_pci.c
+++ b/drivers/thermal/intel/int340x_thermal/processor_thermal_device_pci.c
@@ -126,7 +126,8 @@ static void proc_thermal_clear_soc_int_status(struct proc_thermal_device *proc_p
 {
 	u64 status;
 
-	if (!(proc_priv->mmio_feature_mask & PROC_THERMAL_FEATURE_WT_HINT))
+	if (!(proc_priv->mmio_feature_mask &
+	    (PROC_THERMAL_FEATURE_WT_HINT | PROC_THERMAL_FEATURE_POWER_FLOOR)))
 		return;
 
 	status = readq(proc_priv->mmio_base + SOC_WT_RES_INT_STATUS_OFFSET);
@@ -139,6 +140,7 @@ static irqreturn_t proc_thermal_irq_thread_handler(int irq, void *devid)
 	struct proc_thermal_pci *pci_info = devid;
 
 	proc_thermal_wt_intr_callback(pci_info->pdev, pci_info->proc_priv);
+	proc_thermal_power_floor_intr_callback(pci_info->pdev, pci_info->proc_priv);
 	proc_thermal_clear_soc_int_status(pci_info->proc_priv);
 
 	return IRQ_HANDLED;
@@ -158,6 +160,11 @@ static irqreturn_t proc_thermal_irq_handler(int irq, void *devid)
 			ret = IRQ_WAKE_THREAD;
 	}
 
+	if (proc_priv->mmio_feature_mask & PROC_THERMAL_FEATURE_POWER_FLOOR) {
+		if (proc_thermal_check_power_floor_intr(pci_info->proc_priv))
+			ret = IRQ_WAKE_THREAD;
+	}
+
 	/*
 	 * Since now there are two sources of interrupts: one from thermal threshold
 	 * and another from workload hint, add a check if there was really a threshold
-- 
2.43.0

