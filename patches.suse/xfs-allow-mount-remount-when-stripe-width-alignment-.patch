From 78eebd309af1c495b2c907556baff4a8277f4248 Mon Sep 17 00:00:00 2001
From: Anthony Iliopoulos <ailiop@suse.com>
Date: Thu, 30 Sep 2021 15:49:02 +0200
Subject: [PATCH] xfs: allow mount/remount when stripe width alignment is zero
Patch-mainline: Never, SLE-specific
References: bsc#1188651

Relax the mount-time unit/width alignment checks, so that filesystems
that have been formatted on older kernels and may have bogus alignment
values will still mount on SLE15-SP2 and later releases.

In particular, older SLE releases with an xfsprogs that lacked upstream
commit 14c57d50de91 ("mkfs.xfs: if either sunit or swidth is nonzero,
the other must be as well"), would allow filesystems to be formatted
with only sunit specified but with a zero swidth.

The alignment values are usually autodetected via libblkid, but some
storage systems provide bogus values. This generally does not affect the
filesystem operation, but v4.18-rc1 introduced more stringent mount-time
checks to weed out such issues via kernel upstream commit fa4ca9c55746
("xfs: catch bad stripe alignment configurations").

This breaks customer systems by making such filesystems unmountable when
upgrading to SLE15-SP2, and requires manual intervention to solve this
(editing the fs superblock via xfs_db), which is highly undesirable due
to the related downtime.

Fix this by skipping the particular alignment check when swidth is zero
and thus allow mount to complete.

Also, do not fail remount when swidth is zero, as long as the superblock
specifies a sunit value. This is required for automatic remounts, e.g.
remounting read-only before reboot, which would otherwise fail.

Acked-by: Anthony Iliopoulos <ailiop@suse.com>

---
 fs/xfs/libxfs/xfs_sb.c |    2 +-
 fs/xfs/xfs_super.c     |   11 +++++++----
 2 files changed, 8 insertions(+), 5 deletions(-)

--- a/fs/xfs/libxfs/xfs_sb.c
+++ b/fs/xfs/libxfs/xfs_sb.c
@@ -1369,7 +1369,7 @@ xfs_validate_stripe_geometry(
 		goto check_override;
 	}
 
-	if (sunit > swidth) {
+	if (swidth && sunit > swidth) {
 		if (!silent)
 			xfs_notice(mp,
 "stripe unit (%lld) is larger than the stripe width (%lld)", sunit, swidth);
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@ -1406,7 +1406,8 @@ xfs_fs_parse_param(
 
 static int
 xfs_fs_validate_params(
-	struct xfs_mount	*mp)
+	struct xfs_mount	*mp,
+	struct xfs_sb		*sb)
 {
 	/* No recovery flag requires a read-only mount */
 	if (xfs_has_norecovery(mp) && !xfs_is_readonly(mp)) {
@@ -1438,7 +1439,8 @@ xfs_fs_validate_params(
 	if ((mp->m_dalign && !mp->m_swidth) ||
 	    (!mp->m_dalign && mp->m_swidth)) {
 		xfs_warn(mp, "sunit and swidth must be specified together");
-		return -EINVAL;
+		if (!sb->sb_unit)
+			return -EINVAL;
 	}
 
 	if (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {
@@ -1517,7 +1519,7 @@ xfs_fs_fill_super(
 	if (fc->sb_flags & SB_SYNCHRONOUS)
 		mp->m_features |= XFS_FEAT_WSYNC;
 
-	error = xfs_fs_validate_params(mp);
+	error = xfs_fs_validate_params(mp, &mp->m_sb);
 	if (error)
 		return error;
 
@@ -1950,7 +1952,8 @@ xfs_fs_reconfigure(
 	if (xfs_has_crc(mp))
 		fc->sb_flags |= SB_I_VERSION;
 
-	error = xfs_fs_validate_params(new_mp);
+	error = xfs_fs_validate_params(new_mp, &mp->m_sb);
+
 	if (error)
 		return error;
 
