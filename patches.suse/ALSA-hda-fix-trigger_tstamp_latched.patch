From df5215618fbe425875336d3a2d31bd599ae8c401 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 2 Oct 2024 10:13:06 +0200
Subject: [PATCH] ALSA: hda: fix trigger_tstamp_latched
Git-commit: df5215618fbe425875336d3a2d31bd599ae8c401
Patch-mainline: v6.12-rc2
References: stable-fixes

[ backport note: additional fixup for the code in
  sound/soc/intel/skylake/skl-pcm.c (which has been already dropped in
  the upstream) -- tiwai ]

When the trigger_tstamp_latched flag is set, the PCM core code assumes that
the low-level driver handles the trigger timestamping itself. Ensure that
runtime->trigger_tstamp is always updated.

Buglink: https://github.com/alsa-project/alsa-lib/issues/387
Reported-by: Zeno Endemann <zeno.endemann@mailbox.org>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
Link: https://patch.msgid.link/20241002081306.1788405-1-perex@perex.cz
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 include/sound/hdaudio.h           |    2 +-
 sound/hda/hdac_stream.c           |    6 +++++-
 sound/pci/hda/hda_controller.c    |    3 +--
 sound/soc/intel/skylake/skl-pcm.c |   10 ++++------
 4 files changed, 11 insertions(+), 10 deletions(-)

--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -590,7 +590,7 @@ void snd_hdac_stream_sync_trigger(struct
 void snd_hdac_stream_sync(struct hdac_stream *azx_dev, bool start,
 			  unsigned int streams);
 void snd_hdac_stream_timecounter_init(struct hdac_stream *azx_dev,
-				      unsigned int streams);
+				      unsigned int streams, bool start);
 int snd_hdac_get_stream_stripe_ctl(struct hdac_bus *bus,
 				struct snd_pcm_substream *substream);
 
--- a/sound/hda/hdac_stream.c
+++ b/sound/hda/hdac_stream.c
@@ -664,7 +664,7 @@ static void azx_timecounter_init(struct
  * updated accordingly, too.
  */
 void snd_hdac_stream_timecounter_init(struct hdac_stream *azx_dev,
-				      unsigned int streams)
+				      unsigned int streams, bool start)
 {
 	struct hdac_bus *bus = azx_dev->bus;
 	struct snd_pcm_runtime *runtime = azx_dev->substream->runtime;
@@ -672,6 +672,9 @@ void snd_hdac_stream_timecounter_init(st
 	bool inited = false;
 	u64 cycle_last = 0;
 
+	if (!start)
+		goto skip;
+
 	list_for_each_entry(s, &bus->stream_list, list) {
 		if ((streams & (1 << s->index))) {
 			azx_timecounter_init(s, inited, cycle_last);
@@ -682,6 +685,7 @@ void snd_hdac_stream_timecounter_init(st
 		}
 	}
 
+skip:
 	snd_pcm_gettime(runtime, &runtime->trigger_tstamp);
 	runtime->trigger_tstamp_latched = true;
 }
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@ -275,8 +275,7 @@ static int azx_pcm_trigger(struct snd_pc
 	spin_lock(&bus->reg_lock);
 	/* reset SYNC bits */
 	snd_hdac_stream_sync_trigger(hstr, false, sbits, sync_reg);
-	if (start)
-		snd_hdac_stream_timecounter_init(hstr, sbits);
+	snd_hdac_stream_timecounter_init(hstr, sbits, start);
 	spin_unlock(&bus->reg_lock);
 	return 0;
 }
--- a/sound/soc/intel/skylake/skl-pcm.c
+++ b/sound/soc/intel/skylake/skl-pcm.c
@@ -444,12 +444,11 @@ static int skl_decoupled_trigger(struct
 
 	spin_lock_irqsave(&bus->reg_lock, cookie);
 
-	if (start) {
+	snd_hdac_stream_timecounter_init(hstr, 0, start);
+	if (start)
 		snd_hdac_stream_start(hdac_stream(stream));
-		snd_hdac_stream_timecounter_init(hstr, 0);
-	} else {
+	else
 		snd_hdac_stream_stop(hdac_stream(stream));
-	}
 
 	spin_unlock_irqrestore(&bus->reg_lock, cookie);
 
@@ -1145,8 +1144,7 @@ static int skl_coupled_trigger(struct sn
 
 	/* reset SYNC bits */
 	snd_hdac_stream_sync_trigger(hstr, false, sbits, AZX_REG_SSYNC);
-	if (start)
-		snd_hdac_stream_timecounter_init(hstr, sbits);
+	snd_hdac_stream_timecounter_init(hstr, sbits, start);
 	spin_unlock_irqrestore(&bus->reg_lock, cookie);
 
 	return 0;
