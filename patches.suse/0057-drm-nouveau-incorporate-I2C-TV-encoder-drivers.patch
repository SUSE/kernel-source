From 9a0dfe9bacef9c3bf6aaa92b5913945364ef805f Mon Sep 17 00:00:00 2001
From: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
Date: Mon, 6 Jan 2025 01:00:13 +0200
Subject: drm/nouveau: incorporate I2C TV encoder drivers
Git-commit: 9a0dfe9bacef9c3bf6aaa92b5913945364ef805f
Patch-mainline: v6.15-rc1
References: jsc#PED-13979 jsc#PED-14039 jsc#PED-14046 jsc#PED-14211 jsc#PED-14333 jsc#PED-14487 jsc#PED-14488 jsc#PED-14497 jsc#PED-14499

Chrontel CH7006 and Silicon Image sil164 drivers use drm_encoder_slave
interface which is being used only by the nouveau driver. It doesn't
make sense to keep this interface inside the DRM subsystem. In
preparation to moving this set of helpers to the nouveau driver, move
the only two I2C driver that use that interface to the nouveau driver
too.

Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
Signed-off-by: Danilo Krummrich <dakr@kernel.org>
Link: https://patchwork.freedesktop.org/patch/msgid/20250106-nouveau-encoder-slave-v3-1-1d37d2f2c67f@linaro.org
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>

---
 arch/arm/configs/multi_v7_defconfig           |   4 +-
 arch/parisc/configs/generic-32bit_defconfig   |   4 +-
 arch/parisc/configs/generic-64bit_defconfig   |   4 +-
 drivers/gpu/drm/i2c/Kconfig                   |  18 -
 drivers/gpu/drm/i2c/Makefile                  |   6 -
 drivers/gpu/drm/i2c/ch7006_drv.c              | 549 ------------------
 drivers/gpu/drm/i2c/ch7006_mode.c             | 470 ---------------
 drivers/gpu/drm/i2c/ch7006_priv.h             | 344 -----------
 drivers/gpu/drm/i2c/sil164_drv.c              | 451 --------------
 drivers/gpu/drm/nouveau/Kconfig               |  18 +
 drivers/gpu/drm/nouveau/dispnv04/Kbuild       |   2 +
 drivers/gpu/drm/nouveau/dispnv04/dfp.c        |   2 +-
 drivers/gpu/drm/nouveau/dispnv04/i2c/Kbuild   |   5 +
 .../gpu/drm/nouveau/dispnv04/i2c/ch7006_drv.c | 549 ++++++++++++++++++
 .../drm/nouveau/dispnv04/i2c/ch7006_mode.c    | 470 +++++++++++++++
 .../drm/nouveau/dispnv04/i2c/ch7006_priv.h    | 345 +++++++++++
 .../gpu/drm/nouveau/dispnv04/i2c/sil164_drv.c | 452 ++++++++++++++
 drivers/gpu/drm/nouveau/dispnv04/tvnv04.c     |   2 +-
 .../drm/nouveau/include/dispnv04/i2c/ch7006.h |  87 +++
 .../drm/nouveau/include/dispnv04/i2c/sil164.h |  64 ++
 include/drm/i2c/ch7006.h                      |  87 ---
 include/drm/i2c/sil164.h                      |  64 --
 22 files changed, 2000 insertions(+), 1997 deletions(-)
 delete mode 100644 drivers/gpu/drm/i2c/ch7006_drv.c
 delete mode 100644 drivers/gpu/drm/i2c/ch7006_mode.c
 delete mode 100644 drivers/gpu/drm/i2c/ch7006_priv.h
 delete mode 100644 drivers/gpu/drm/i2c/sil164_drv.c
 create mode 100644 drivers/gpu/drm/nouveau/dispnv04/i2c/Kbuild
 create mode 100644 drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_drv.c
 create mode 100644 drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_mode.c
 create mode 100644 drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_priv.h
 create mode 100644 drivers/gpu/drm/nouveau/dispnv04/i2c/sil164_drv.c
 create mode 100644 drivers/gpu/drm/nouveau/include/dispnv04/i2c/ch7006.h
 create mode 100644 drivers/gpu/drm/nouveau/include/dispnv04/i2c/sil164.h
 delete mode 100644 include/drm/i2c/ch7006.h
 delete mode 100644 include/drm/i2c/sil164.h

diff --git a/arch/arm/configs/multi_v7_defconfig b/arch/arm/configs/multi_v7_defconfig
index 9a5f5c439b87..8a900dada4bc 100644
--- a/arch/arm/configs/multi_v7_defconfig
+++ b/arch/arm/configs/multi_v7_defconfig
@@ -713,10 +713,10 @@ CONFIG_VIDEO_ADV7604_CEC=y
 CONFIG_VIDEO_ML86V7667=m
 CONFIG_IMX_IPUV3_CORE=m
 CONFIG_DRM=y
-# CONFIG_DRM_I2C_CH7006 is not set
-# CONFIG_DRM_I2C_SIL164 is not set
 CONFIG_DRM_I2C_NXP_TDA998X=m
 CONFIG_DRM_NOUVEAU=m
+# CONFIG_DRM_NOUVEAU_CH7006 is not set
+# CONFIG_DRM_NOUVEAU_SIL164 is not set
 CONFIG_DRM_EXYNOS=m
 CONFIG_DRM_EXYNOS_FIMD=y
 CONFIG_DRM_EXYNOS_MIXER=y
diff --git a/arch/parisc/configs/generic-32bit_defconfig b/arch/parisc/configs/generic-32bit_defconfig
index 5ce258f3fffa..f5fffc24c3bc 100644
--- a/arch/parisc/configs/generic-32bit_defconfig
+++ b/arch/parisc/configs/generic-32bit_defconfig
@@ -132,11 +132,11 @@ CONFIG_I2C=y
 CONFIG_HWMON=m
 CONFIG_DRM=m
 CONFIG_DRM_DISPLAY_DP_AUX_CEC=y
-# CONFIG_DRM_I2C_CH7006 is not set
-# CONFIG_DRM_I2C_SIL164 is not set
 CONFIG_DRM_RADEON=m
 CONFIG_DRM_NOUVEAU=m
 # CONFIG_DRM_NOUVEAU_BACKLIGHT is not set
+# CONFIG_DRM_NOUVEAU_CH7006 is not set
+# CONFIG_DRM_NOUVEAU_SIL164 is not set
 CONFIG_DRM_VGEM=m
 CONFIG_DRM_UDL=m
 CONFIG_DRM_MGAG200=m
diff --git a/arch/parisc/configs/generic-64bit_defconfig b/arch/parisc/configs/generic-64bit_defconfig
index 19a804860ed5..704f68fbf960 100644
--- a/arch/parisc/configs/generic-64bit_defconfig
+++ b/arch/parisc/configs/generic-64bit_defconfig
@@ -193,11 +193,11 @@ CONFIG_MEDIA_SUPPORT=m
 CONFIG_AGP=y
 CONFIG_AGP_PARISC=y
 CONFIG_DRM=y
-# CONFIG_DRM_I2C_CH7006 is not set
-# CONFIG_DRM_I2C_SIL164 is not set
 CONFIG_DRM_RADEON=y
 CONFIG_DRM_NOUVEAU=m
 # CONFIG_DRM_NOUVEAU_BACKLIGHT is not set
+# CONFIG_DRM_NOUVEAU_CH7006 is not set
+# CONFIG_DRM_NOUVEAU_SIL164 is not set
 CONFIG_DRM_MGAG200=m
 CONFIG_FB=y
 CONFIG_FB_PM2=m
diff --git a/drivers/gpu/drm/i2c/Kconfig b/drivers/gpu/drm/i2c/Kconfig
index 6f19e1c35e30..d5200f67958e 100644
--- a/drivers/gpu/drm/i2c/Kconfig
+++ b/drivers/gpu/drm/i2c/Kconfig
@@ -2,24 +2,6 @@
 menu "I2C encoder or helper chips"
      depends on DRM && DRM_KMS_HELPER && I2C
 
-config DRM_I2C_CH7006
-	tristate "Chrontel ch7006 TV encoder"
-	default m if DRM_NOUVEAU
-	help
-	  Support for Chrontel ch7006 and similar TV encoders, found
-	  on some nVidia video cards.
-
-	  This driver is currently only useful if you're also using
-	  the nouveau driver.
-
-config DRM_I2C_SIL164
-	tristate "Silicon Image sil164 TMDS transmitter"
-	default m if DRM_NOUVEAU
-	help
-	  Support for sil164 and similar single-link (or dual-link
-	  when used in pairs) TMDS transmitters, used in some nVidia
-	  video cards.
-
 config DRM_I2C_NXP_TDA998X
 	tristate "NXP Semiconductors TDA998X HDMI encoder"
 	default m if DRM_TILCDC
diff --git a/drivers/gpu/drm/i2c/Makefile b/drivers/gpu/drm/i2c/Makefile
index a962f6f08568..31fd35527d99 100644
--- a/drivers/gpu/drm/i2c/Makefile
+++ b/drivers/gpu/drm/i2c/Makefile
@@ -1,10 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0
-ch7006-y := ch7006_drv.o ch7006_mode.o
-obj-$(CONFIG_DRM_I2C_CH7006) += ch7006.o
-
-sil164-y := sil164_drv.o
-obj-$(CONFIG_DRM_I2C_SIL164) += sil164.o
-
 tda998x-y := tda998x_drv.o
 obj-$(CONFIG_DRM_I2C_NXP_TDA998X) += tda998x.o
 obj-$(CONFIG_DRM_I2C_NXP_TDA9950) += tda9950.o
diff --git a/drivers/gpu/drm/i2c/ch7006_drv.c b/drivers/gpu/drm/i2c/ch7006_drv.c
deleted file mode 100644
index db4f95020fae..000000000000
--- a/drivers/gpu/drm/i2c/ch7006_drv.c
+++ /dev/null
@@ -1,549 +0,0 @@
-/*
- * Copyright (C) 2009 Francisco Jerez.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <linux/module.h>
-
-#include <drm/drm_crtc_helper.h>
-
-#include "ch7006_priv.h"
-
-/* DRM encoder functions */
-
-static void ch7006_encoder_set_config(struct drm_encoder *encoder,
-				      void *params)
-{
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-
-	priv->params = *(struct ch7006_encoder_params *)params;
-}
-
-static void ch7006_encoder_destroy(struct drm_encoder *encoder)
-{
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-
-	drm_property_destroy(encoder->dev, priv->scale_property);
-
-	kfree(priv);
-	to_encoder_slave(encoder)->slave_priv = NULL;
-
-	drm_i2c_encoder_destroy(encoder);
-}
-
-static void  ch7006_encoder_dpms(struct drm_encoder *encoder, int mode)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	struct ch7006_state *state = &priv->state;
-
-	ch7006_dbg(client, "\n");
-
-	if (mode == priv->last_dpms)
-		return;
-	priv->last_dpms = mode;
-
-	ch7006_setup_power_state(encoder);
-
-	ch7006_load_reg(client, state, CH7006_POWER);
-}
-
-static void ch7006_encoder_save(struct drm_encoder *encoder)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-
-	ch7006_dbg(client, "\n");
-
-	ch7006_state_save(client, &priv->saved_state);
-}
-
-static void ch7006_encoder_restore(struct drm_encoder *encoder)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-
-	ch7006_dbg(client, "\n");
-
-	ch7006_state_load(client, &priv->saved_state);
-}
-
-static bool ch7006_encoder_mode_fixup(struct drm_encoder *encoder,
-				      const struct drm_display_mode *mode,
-				      struct drm_display_mode *adjusted_mode)
-{
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-
-	/* The ch7006 is painfully picky with the input timings so no
-	 * custom modes for now... */
-
-	priv->mode = ch7006_lookup_mode(encoder, mode);
-
-	return !!priv->mode;
-}
-
-static int ch7006_encoder_mode_valid(struct drm_encoder *encoder,
-				     const struct drm_display_mode *mode)
-{
-	if (ch7006_lookup_mode(encoder, mode))
-		return MODE_OK;
-	else
-		return MODE_BAD;
-}
-
-static void ch7006_encoder_mode_set(struct drm_encoder *encoder,
-				     struct drm_display_mode *drm_mode,
-				     struct drm_display_mode *adjusted_mode)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	struct ch7006_encoder_params *params = &priv->params;
-	struct ch7006_state *state = &priv->state;
-	uint8_t *regs = state->regs;
-	const struct ch7006_mode *mode = priv->mode;
-	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
-	int start_active;
-
-	ch7006_dbg(client, "\n");
-
-	regs[CH7006_DISPMODE] = norm->dispmode | mode->dispmode;
-	regs[CH7006_BWIDTH] = 0;
-	regs[CH7006_INPUT_FORMAT] = bitf(CH7006_INPUT_FORMAT_FORMAT,
-					 params->input_format);
-
-	regs[CH7006_CLKMODE] = CH7006_CLKMODE_SUBC_LOCK
-		| bitf(CH7006_CLKMODE_XCM, params->xcm)
-		| bitf(CH7006_CLKMODE_PCM, params->pcm);
-	if (params->clock_mode)
-		regs[CH7006_CLKMODE] |= CH7006_CLKMODE_MASTER;
-	if (params->clock_edge)
-		regs[CH7006_CLKMODE] |= CH7006_CLKMODE_POS_EDGE;
-
-	start_active = (drm_mode->htotal & ~0x7) - (drm_mode->hsync_start & ~0x7);
-	regs[CH7006_POV] = bitf(CH7006_POV_START_ACTIVE_8, start_active);
-	regs[CH7006_START_ACTIVE] = bitf(CH7006_START_ACTIVE_0, start_active);
-
-	regs[CH7006_INPUT_SYNC] = 0;
-	if (params->sync_direction)
-		regs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_OUTPUT;
-	if (params->sync_encoding)
-		regs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_EMBEDDED;
-	if (drm_mode->flags & DRM_MODE_FLAG_PVSYNC)
-		regs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_PVSYNC;
-	if (drm_mode->flags & DRM_MODE_FLAG_PHSYNC)
-		regs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_PHSYNC;
-
-	regs[CH7006_DETECT] = 0;
-	regs[CH7006_BCLKOUT] = 0;
-
-	regs[CH7006_SUBC_INC3] = 0;
-	if (params->pout_level)
-		regs[CH7006_SUBC_INC3] |= CH7006_SUBC_INC3_POUT_3_3V;
-
-	regs[CH7006_SUBC_INC4] = 0;
-	if (params->active_detect)
-		regs[CH7006_SUBC_INC4] |= CH7006_SUBC_INC4_DS_INPUT;
-
-	regs[CH7006_PLL_CONTROL] = priv->saved_state.regs[CH7006_PLL_CONTROL];
-
-	ch7006_setup_levels(encoder);
-	ch7006_setup_subcarrier(encoder);
-	ch7006_setup_pll(encoder);
-	ch7006_setup_power_state(encoder);
-	ch7006_setup_properties(encoder);
-
-	ch7006_state_load(client, state);
-}
-
-static enum drm_connector_status ch7006_encoder_detect(struct drm_encoder *encoder,
-						       struct drm_connector *connector)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	struct ch7006_state *state = &priv->state;
-	int det;
-
-	ch7006_dbg(client, "\n");
-
-	ch7006_save_reg(client, state, CH7006_DETECT);
-	ch7006_save_reg(client, state, CH7006_POWER);
-	ch7006_save_reg(client, state, CH7006_CLKMODE);
-
-	ch7006_write(client, CH7006_POWER, CH7006_POWER_RESET |
-					   bitfs(CH7006_POWER_LEVEL, NORMAL));
-	ch7006_write(client, CH7006_CLKMODE, CH7006_CLKMODE_MASTER);
-
-	ch7006_write(client, CH7006_DETECT, CH7006_DETECT_SENSE);
-
-	ch7006_write(client, CH7006_DETECT, 0);
-
-	det = ch7006_read(client, CH7006_DETECT);
-
-	ch7006_load_reg(client, state, CH7006_CLKMODE);
-	ch7006_load_reg(client, state, CH7006_POWER);
-	ch7006_load_reg(client, state, CH7006_DETECT);
-
-	if ((det & (CH7006_DETECT_SVIDEO_Y_TEST|
-		    CH7006_DETECT_SVIDEO_C_TEST|
-		    CH7006_DETECT_CVBS_TEST)) == 0)
-		priv->subconnector = DRM_MODE_SUBCONNECTOR_SCART;
-	else if ((det & (CH7006_DETECT_SVIDEO_Y_TEST|
-			 CH7006_DETECT_SVIDEO_C_TEST)) == 0)
-		priv->subconnector = DRM_MODE_SUBCONNECTOR_SVIDEO;
-	else if ((det & CH7006_DETECT_CVBS_TEST) == 0)
-		priv->subconnector = DRM_MODE_SUBCONNECTOR_Composite;
-	else
-		priv->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;
-
-	drm_object_property_set_value(&connector->base,
-			encoder->dev->mode_config.tv_subconnector_property,
-							priv->subconnector);
-
-	return priv->subconnector ? connector_status_connected :
-					connector_status_disconnected;
-}
-
-static int ch7006_encoder_get_modes(struct drm_encoder *encoder,
-				    struct drm_connector *connector)
-{
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	const struct ch7006_mode *mode;
-	int n = 0;
-
-	for (mode = ch7006_modes; mode->mode.clock; mode++) {
-		if (~mode->valid_scales & 1<<priv->scale ||
-		    ~mode->valid_norms & 1<<priv->norm)
-			continue;
-
-		drm_mode_probed_add(connector,
-				drm_mode_duplicate(encoder->dev, &mode->mode));
-
-		n++;
-	}
-
-	return n;
-}
-
-static int ch7006_encoder_create_resources(struct drm_encoder *encoder,
-					   struct drm_connector *connector)
-{
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	struct drm_device *dev = encoder->dev;
-	struct drm_mode_config *conf = &dev->mode_config;
-
-	drm_mode_create_tv_properties_legacy(dev, NUM_TV_NORMS, ch7006_tv_norm_names);
-
-	priv->scale_property = drm_property_create_range(dev, 0, "scale", 0, 2);
-	if (!priv->scale_property)
-		return -ENOMEM;
-
-	drm_object_attach_property(&connector->base, conf->tv_select_subconnector_property,
-				      priv->select_subconnector);
-	drm_object_attach_property(&connector->base, conf->tv_subconnector_property,
-				      priv->subconnector);
-	drm_object_attach_property(&connector->base, conf->tv_left_margin_property,
-				      priv->hmargin);
-	drm_object_attach_property(&connector->base, conf->tv_bottom_margin_property,
-				      priv->vmargin);
-	drm_object_attach_property(&connector->base, conf->legacy_tv_mode_property,
-				   priv->norm);
-	drm_object_attach_property(&connector->base, conf->tv_brightness_property,
-				      priv->brightness);
-	drm_object_attach_property(&connector->base, conf->tv_contrast_property,
-				      priv->contrast);
-	drm_object_attach_property(&connector->base, conf->tv_flicker_reduction_property,
-				      priv->flicker);
-	drm_object_attach_property(&connector->base, priv->scale_property,
-				      priv->scale);
-
-	return 0;
-}
-
-static int ch7006_encoder_set_property(struct drm_encoder *encoder,
-				       struct drm_connector *connector,
-				       struct drm_property *property,
-				       uint64_t val)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	struct ch7006_state *state = &priv->state;
-	struct drm_mode_config *conf = &encoder->dev->mode_config;
-	struct drm_crtc *crtc = encoder->crtc;
-	bool modes_changed = false;
-
-	ch7006_dbg(client, "\n");
-
-	if (property == conf->tv_select_subconnector_property) {
-		priv->select_subconnector = val;
-
-		ch7006_setup_power_state(encoder);
-
-		ch7006_load_reg(client, state, CH7006_POWER);
-
-	} else if (property == conf->tv_left_margin_property) {
-		priv->hmargin = val;
-
-		ch7006_setup_properties(encoder);
-
-		ch7006_load_reg(client, state, CH7006_POV);
-		ch7006_load_reg(client, state, CH7006_HPOS);
-
-	} else if (property == conf->tv_bottom_margin_property) {
-		priv->vmargin = val;
-
-		ch7006_setup_properties(encoder);
-
-		ch7006_load_reg(client, state, CH7006_POV);
-		ch7006_load_reg(client, state, CH7006_VPOS);
-
-	} else if (property == conf->legacy_tv_mode_property) {
-		if (connector->dpms != DRM_MODE_DPMS_OFF)
-			return -EINVAL;
-
-		priv->norm = val;
-
-		modes_changed = true;
-
-	} else if (property == conf->tv_brightness_property) {
-		priv->brightness = val;
-
-		ch7006_setup_levels(encoder);
-
-		ch7006_load_reg(client, state, CH7006_BLACK_LEVEL);
-
-	} else if (property == conf->tv_contrast_property) {
-		priv->contrast = val;
-
-		ch7006_setup_properties(encoder);
-
-		ch7006_load_reg(client, state, CH7006_CONTRAST);
-
-	} else if (property == conf->tv_flicker_reduction_property) {
-		priv->flicker = val;
-
-		ch7006_setup_properties(encoder);
-
-		ch7006_load_reg(client, state, CH7006_FFILTER);
-
-	} else if (property == priv->scale_property) {
-		if (connector->dpms != DRM_MODE_DPMS_OFF)
-			return -EINVAL;
-
-		priv->scale = val;
-
-		modes_changed = true;
-
-	} else {
-		return -EINVAL;
-	}
-
-	if (modes_changed) {
-		drm_helper_probe_single_connector_modes(connector, 0, 0);
-
-		if (crtc)
-			drm_crtc_helper_set_mode(crtc, &crtc->mode,
-						 crtc->x, crtc->y,
-						 crtc->primary->fb);
-	}
-
-	return 0;
-}
-
-static const struct drm_encoder_slave_funcs ch7006_encoder_funcs = {
-	.set_config = ch7006_encoder_set_config,
-	.destroy = ch7006_encoder_destroy,
-	.dpms = ch7006_encoder_dpms,
-	.save = ch7006_encoder_save,
-	.restore = ch7006_encoder_restore,
-	.mode_fixup = ch7006_encoder_mode_fixup,
-	.mode_valid = ch7006_encoder_mode_valid,
-	.mode_set = ch7006_encoder_mode_set,
-	.detect = ch7006_encoder_detect,
-	.get_modes = ch7006_encoder_get_modes,
-	.create_resources = ch7006_encoder_create_resources,
-	.set_property = ch7006_encoder_set_property,
-};
-
-
-/* I2C driver functions */
-
-static int ch7006_probe(struct i2c_client *client)
-{
-	uint8_t addr = CH7006_VERSION_ID;
-	uint8_t val;
-	int ret;
-
-	ch7006_dbg(client, "\n");
-
-	ret = i2c_master_send(client, &addr, sizeof(addr));
-	if (ret < 0)
-		goto fail;
-
-	ret = i2c_master_recv(client, &val, sizeof(val));
-	if (ret < 0)
-		goto fail;
-
-	ch7006_info(client, "Detected version ID: %x\n", val);
-
-	/* I don't know what this is for, but otherwise I get no
-	 * signal.
-	 */
-	ch7006_write(client, 0x3d, 0x0);
-
-	return 0;
-
-fail:
-	ch7006_err(client, "Error %d reading version ID\n", ret);
-
-	return -ENODEV;
-}
-
-static void ch7006_remove(struct i2c_client *client)
-{
-	ch7006_dbg(client, "\n");
-}
-
-static int ch7006_resume(struct device *dev)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-
-	ch7006_dbg(client, "\n");
-
-	ch7006_write(client, 0x3d, 0x0);
-
-	return 0;
-}
-
-static int ch7006_encoder_init(struct i2c_client *client,
-			       struct drm_device *dev,
-			       struct drm_encoder_slave *encoder)
-{
-	struct ch7006_priv *priv;
-	int i;
-
-	ch7006_dbg(client, "\n");
-
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	encoder->slave_priv = priv;
-	encoder->slave_funcs = &ch7006_encoder_funcs;
-
-	priv->norm = TV_NORM_PAL;
-	priv->select_subconnector = DRM_MODE_SUBCONNECTOR_Automatic;
-	priv->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;
-	priv->scale = 1;
-	priv->contrast = 50;
-	priv->brightness = 50;
-	priv->flicker = 50;
-	priv->hmargin = 50;
-	priv->vmargin = 50;
-	priv->last_dpms = -1;
-	priv->chip_version = ch7006_read(client, CH7006_VERSION_ID);
-
-	if (ch7006_tv_norm) {
-		for (i = 0; i < NUM_TV_NORMS; i++) {
-			if (!strcmp(ch7006_tv_norm_names[i], ch7006_tv_norm)) {
-				priv->norm = i;
-				break;
-			}
-		}
-
-		if (i == NUM_TV_NORMS)
-			ch7006_err(client, "Invalid TV norm setting \"%s\".\n",
-				   ch7006_tv_norm);
-	}
-
-	if (ch7006_scale >= 0 && ch7006_scale <= 2)
-		priv->scale = ch7006_scale;
-	else
-		ch7006_err(client, "Invalid scale setting \"%d\".\n",
-			   ch7006_scale);
-
-	return 0;
-}
-
-static const struct i2c_device_id ch7006_ids[] = {
-	{ "ch7006" },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, ch7006_ids);
-
-static const struct dev_pm_ops ch7006_pm_ops = {
-	.resume = ch7006_resume,
-};
-
-static struct drm_i2c_encoder_driver ch7006_driver = {
-	.i2c_driver = {
-		.probe = ch7006_probe,
-		.remove = ch7006_remove,
-
-		.driver = {
-			.name = "ch7006",
-			.pm = &ch7006_pm_ops,
-		},
-
-		.id_table = ch7006_ids,
-	},
-
-	.encoder_init = ch7006_encoder_init,
-};
-
-
-/* Module initialization */
-
-static int __init ch7006_init(void)
-{
-	return drm_i2c_encoder_register(THIS_MODULE, &ch7006_driver);
-}
-
-static void __exit ch7006_exit(void)
-{
-	drm_i2c_encoder_unregister(&ch7006_driver);
-}
-
-int ch7006_debug;
-module_param_named(debug, ch7006_debug, int, 0600);
-MODULE_PARM_DESC(debug, "Enable debug output.");
-
-char *ch7006_tv_norm;
-module_param_named(tv_norm, ch7006_tv_norm, charp, 0600);
-MODULE_PARM_DESC(tv_norm, "Default TV norm.\n"
-		 "\t\tSupported: PAL, PAL-M, PAL-N, PAL-Nc, PAL-60, NTSC-M, NTSC-J.\n"
-		 "\t\tDefault: PAL");
-
-int ch7006_scale = 1;
-module_param_named(scale, ch7006_scale, int, 0600);
-MODULE_PARM_DESC(scale, "Default scale.\n"
-		 "\t\tSupported: 0 -> Select video modes with a higher blanking ratio.\n"
-		 "\t\t\t1 -> Select default video modes.\n"
-		 "\t\t\t2 -> Select video modes with a lower blanking ratio.");
-
-MODULE_AUTHOR("Francisco Jerez <currojerez@riseup.net>");
-MODULE_DESCRIPTION("Chrontel ch7006 TV encoder driver");
-MODULE_LICENSE("GPL and additional rights");
-
-module_init(ch7006_init);
-module_exit(ch7006_exit);
diff --git a/drivers/gpu/drm/i2c/ch7006_mode.c b/drivers/gpu/drm/i2c/ch7006_mode.c
deleted file mode 100644
index 6afe6d0ee630..000000000000
--- a/drivers/gpu/drm/i2c/ch7006_mode.c
+++ /dev/null
@@ -1,470 +0,0 @@
-/*
- * Copyright (C) 2009 Francisco Jerez.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "ch7006_priv.h"
-
-const char * const ch7006_tv_norm_names[] = {
-	[TV_NORM_PAL] = "PAL",
-	[TV_NORM_PAL_M] = "PAL-M",
-	[TV_NORM_PAL_N] = "PAL-N",
-	[TV_NORM_PAL_NC] = "PAL-Nc",
-	[TV_NORM_PAL_60] = "PAL-60",
-	[TV_NORM_NTSC_M] = "NTSC-M",
-	[TV_NORM_NTSC_J] = "NTSC-J",
-};
-
-#define NTSC_LIKE_TIMINGS .vrefresh = 60 * fixed1/1.001,		\
-		.vdisplay = 480,					\
-		.vtotal = 525,						\
-		.hvirtual = 660
-
-#define PAL_LIKE_TIMINGS .vrefresh = 50 * fixed1,		\
-		.vdisplay = 576,				\
-		.vtotal = 625,					\
-		.hvirtual = 810
-
-const struct ch7006_tv_norm_info ch7006_tv_norms[] = {
-	[TV_NORM_NTSC_M] = {
-		NTSC_LIKE_TIMINGS,
-		.black_level = 0.339 * fixed1,
-		.subc_freq = 3579545 * fixed1,
-		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, NTSC),
-		.voffset = 0,
-	},
-	[TV_NORM_NTSC_J] = {
-		NTSC_LIKE_TIMINGS,
-		.black_level = 0.286 * fixed1,
-		.subc_freq = 3579545 * fixed1,
-		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, NTSC_J),
-		.voffset = 0,
-	},
-	[TV_NORM_PAL] = {
-		PAL_LIKE_TIMINGS,
-		.black_level = 0.3 * fixed1,
-		.subc_freq = 4433618.75 * fixed1,
-		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL),
-		.voffset = 0,
-	},
-	[TV_NORM_PAL_M] = {
-		NTSC_LIKE_TIMINGS,
-		.black_level = 0.339 * fixed1,
-		.subc_freq = 3575611.433 * fixed1,
-		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL_M),
-		.voffset = 16,
-	},
-
-	/* The following modes seem to work right but they're
-	 * undocumented */
-
-	[TV_NORM_PAL_N] = {
-		PAL_LIKE_TIMINGS,
-		.black_level = 0.339 * fixed1,
-		.subc_freq = 4433618.75 * fixed1,
-		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL),
-		.voffset = 0,
-	},
-	[TV_NORM_PAL_NC] = {
-		PAL_LIKE_TIMINGS,
-		.black_level = 0.3 * fixed1,
-		.subc_freq = 3582056.25 * fixed1,
-		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL),
-		.voffset = 0,
-	},
-	[TV_NORM_PAL_60] = {
-		NTSC_LIKE_TIMINGS,
-		.black_level = 0.3 * fixed1,
-		.subc_freq = 4433618.75 * fixed1,
-		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL_M),
-		.voffset = 16,
-	},
-};
-
-#define __MODE(f, hd, vd, ht, vt, hsynp, vsynp,				\
-	       subc, scale, scale_mask, norm_mask, e_hd, e_vd) {	\
-		.mode = {						\
-			.name = #hd "x" #vd,				\
-			.status = 0,					\
-			.type = DRM_MODE_TYPE_DRIVER,			\
-			.clock = f,					\
-			.hdisplay = hd,					\
-			.hsync_start = e_hd + 16,			\
-			.hsync_end = e_hd + 80,				\
-			.htotal = ht,					\
-			.hskew = 0,					\
-			.vdisplay = vd,					\
-			.vsync_start = vd + 10,				\
-			.vsync_end = vd + 26,				\
-			.vtotal = vt,					\
-			.vscan = 0,					\
-			.flags = DRM_MODE_FLAG_##hsynp##HSYNC |		\
-				DRM_MODE_FLAG_##vsynp##VSYNC,		\
-		},							\
-		.enc_hdisp = e_hd,					\
-		.enc_vdisp = e_vd,					\
-		.subc_coeff = subc * fixed1,				\
-		.dispmode = bitfs(CH7006_DISPMODE_SCALING_RATIO, scale) | \
-			    bitfs(CH7006_DISPMODE_INPUT_RES, e_hd##x##e_vd), \
-		.valid_scales = scale_mask,				\
-		.valid_norms = norm_mask				\
-	 }
-
-#define MODE(f, hd, vd, ht, vt, hsynp, vsynp,				\
-	     subc, scale, scale_mask, norm_mask)			\
-	__MODE(f, hd, vd, ht, vt, hsynp, vsynp, subc, scale,		\
-	       scale_mask, norm_mask, hd, vd)
-
-#define NTSC_LIKE (1 << TV_NORM_NTSC_M | 1 << TV_NORM_NTSC_J |		\
-		   1 << TV_NORM_PAL_M | 1 << TV_NORM_PAL_60)
-
-#define PAL_LIKE (1 << TV_NORM_PAL | 1 << TV_NORM_PAL_N | 1 << TV_NORM_PAL_NC)
-
-const struct ch7006_mode ch7006_modes[] = {
-	MODE(21000, 512, 384, 840, 500, N, N, 181.797557582, 5_4, 0x6, PAL_LIKE),
-	MODE(26250, 512, 384, 840, 625, N, N, 145.438046066, 1_1, 0x1, PAL_LIKE),
-	MODE(20140, 512, 384, 800, 420, N, N, 213.257083791, 5_4, 0x4, NTSC_LIKE),
-	MODE(24671, 512, 384, 784, 525, N, N, 174.0874153, 1_1, 0x3, NTSC_LIKE),
-	MODE(28125, 720, 400, 1125, 500, N, N, 135.742176298, 5_4, 0x6, PAL_LIKE),
-	MODE(34875, 720, 400, 1116, 625, N, N, 109.469496898, 1_1, 0x1, PAL_LIKE),
-	MODE(23790, 720, 400, 945, 420, N, N, 160.475642016, 5_4, 0x4, NTSC_LIKE),
-	MODE(29455, 720, 400, 936, 525, N, N, 129.614941843, 1_1, 0x3, NTSC_LIKE),
-	MODE(25000, 640, 400, 1000, 500, N, N, 152.709948279, 5_4, 0x6, PAL_LIKE),
-	MODE(31500, 640, 400, 1008, 625, N, N, 121.198371646, 1_1, 0x1, PAL_LIKE),
-	MODE(21147, 640, 400, 840, 420, N, N, 180.535097338, 5_4, 0x4, NTSC_LIKE),
-	MODE(26434, 640, 400, 840, 525, N, N, 144.42807787, 1_1, 0x2, NTSC_LIKE),
-	MODE(30210, 640, 400, 840, 600, N, N, 126.374568276, 7_8, 0x1, NTSC_LIKE),
-	MODE(21000, 640, 480, 840, 500, N, N, 181.797557582, 5_4, 0x4, PAL_LIKE),
-	MODE(26250, 640, 480, 840, 625, N, N, 145.438046066, 1_1, 0x2, PAL_LIKE),
-	MODE(31500, 640, 480, 840, 750, N, N, 121.198371646, 5_6, 0x1, PAL_LIKE),
-	MODE(24671, 640, 480, 784, 525, N, N, 174.0874153, 1_1, 0x4, NTSC_LIKE),
-	MODE(28196, 640, 480, 784, 600, N, N, 152.326488422, 7_8, 0x2, NTSC_LIKE),
-	MODE(30210, 640, 480, 800, 630, N, N, 142.171389101, 5_6, 0x1, NTSC_LIKE),
-	__MODE(29500, 720, 576, 944, 625, P, P, 145.592111636, 1_1, 0x7, PAL_LIKE, 800, 600),
-	MODE(36000, 800, 600, 960, 750, P, P, 119.304647022, 5_6, 0x6, PAL_LIKE),
-	MODE(39000, 800, 600, 936, 836, P, P, 110.127366499, 3_4, 0x1, PAL_LIKE),
-	MODE(39273, 800, 600, 1040, 630, P, P, 145.816809399, 5_6, 0x4, NTSC_LIKE),
-	MODE(43636, 800, 600, 1040, 700, P, P, 131.235128487, 3_4, 0x2, NTSC_LIKE),
-	MODE(47832, 800, 600, 1064, 750, P, P, 119.723275165, 7_10, 0x1, NTSC_LIKE),
-	{}
-};
-
-const struct ch7006_mode *ch7006_lookup_mode(struct drm_encoder *encoder,
-					     const struct drm_display_mode *drm_mode)
-{
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	const struct ch7006_mode *mode;
-
-	for (mode = ch7006_modes; mode->mode.clock; mode++) {
-
-		if (~mode->valid_norms & 1<<priv->norm)
-			continue;
-
-		if (mode->mode.hdisplay != drm_mode->hdisplay ||
-		    mode->mode.vdisplay != drm_mode->vdisplay ||
-		    mode->mode.vtotal != drm_mode->vtotal ||
-		    mode->mode.htotal != drm_mode->htotal ||
-		    mode->mode.clock != drm_mode->clock)
-			continue;
-
-		return mode;
-	}
-
-	return NULL;
-}
-
-/* Some common HW state calculation code */
-
-void ch7006_setup_levels(struct drm_encoder *encoder)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	uint8_t *regs = priv->state.regs;
-	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
-	int gain;
-	int black_level;
-
-	/* Set DAC_GAIN if the voltage drop between white and black is
-	 * high enough. */
-	if (norm->black_level < 339*fixed1/1000) {
-		gain = 76;
-
-		regs[CH7006_INPUT_FORMAT] |= CH7006_INPUT_FORMAT_DAC_GAIN;
-	} else {
-		gain = 71;
-
-		regs[CH7006_INPUT_FORMAT] &= ~CH7006_INPUT_FORMAT_DAC_GAIN;
-	}
-
-	black_level = round_fixed(norm->black_level*26625)/gain;
-
-	/* Correct it with the specified brightness. */
-	black_level = interpolate(90, black_level, 208, priv->brightness);
-
-	regs[CH7006_BLACK_LEVEL] = bitf(CH7006_BLACK_LEVEL_0, black_level);
-
-	ch7006_dbg(client, "black level: %d\n", black_level);
-}
-
-void ch7006_setup_subcarrier(struct drm_encoder *encoder)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	struct ch7006_state *state = &priv->state;
-	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
-	const struct ch7006_mode *mode = priv->mode;
-	uint32_t subc_inc;
-
-	subc_inc = round_fixed((mode->subc_coeff >> 8)
-			       * (norm->subc_freq >> 24));
-
-	setbitf(state, CH7006_SUBC_INC0, 28, subc_inc);
-	setbitf(state, CH7006_SUBC_INC1, 24, subc_inc);
-	setbitf(state, CH7006_SUBC_INC2, 20, subc_inc);
-	setbitf(state, CH7006_SUBC_INC3, 16, subc_inc);
-	setbitf(state, CH7006_SUBC_INC4, 12, subc_inc);
-	setbitf(state, CH7006_SUBC_INC5, 8, subc_inc);
-	setbitf(state, CH7006_SUBC_INC6, 4, subc_inc);
-	setbitf(state, CH7006_SUBC_INC7, 0, subc_inc);
-
-	ch7006_dbg(client, "subcarrier inc: %u\n", subc_inc);
-}
-
-void ch7006_setup_pll(struct drm_encoder *encoder)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	uint8_t *regs = priv->state.regs;
-	const struct ch7006_mode *mode = priv->mode;
-	int n, best_n = 0;
-	int m, best_m = 0;
-	int freq, best_freq = 0;
-
-	for (n = 0; n < CH7006_MAXN; n++) {
-		for (m = 0; m < CH7006_MAXM; m++) {
-			freq = CH7006_FREQ0*(n+2)/(m+2);
-
-			if (abs(freq - mode->mode.clock) <
-			    abs(best_freq - mode->mode.clock)) {
-				best_freq = freq;
-				best_n = n;
-				best_m = m;
-			}
-		}
-	}
-
-	regs[CH7006_PLLOV] = bitf(CH7006_PLLOV_N_8, best_n) |
-		bitf(CH7006_PLLOV_M_8, best_m);
-
-	regs[CH7006_PLLM] = bitf(CH7006_PLLM_0, best_m);
-	regs[CH7006_PLLN] = bitf(CH7006_PLLN_0, best_n);
-
-	if (best_n < 108)
-		regs[CH7006_PLL_CONTROL] |= CH7006_PLL_CONTROL_CAPACITOR;
-	else
-		regs[CH7006_PLL_CONTROL] &= ~CH7006_PLL_CONTROL_CAPACITOR;
-
-	ch7006_dbg(client, "n=%d m=%d f=%d c=%d\n",
-		   best_n, best_m, best_freq, best_n < 108);
-}
-
-void ch7006_setup_power_state(struct drm_encoder *encoder)
-{
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	uint8_t *power = &priv->state.regs[CH7006_POWER];
-	int subconnector;
-
-	subconnector = priv->select_subconnector ? priv->select_subconnector :
-							priv->subconnector;
-
-	*power = CH7006_POWER_RESET;
-
-	if (priv->last_dpms == DRM_MODE_DPMS_ON) {
-		switch (subconnector) {
-		case DRM_MODE_SUBCONNECTOR_SVIDEO:
-			*power |= bitfs(CH7006_POWER_LEVEL, CVBS_OFF);
-			break;
-		case DRM_MODE_SUBCONNECTOR_Composite:
-			*power |= bitfs(CH7006_POWER_LEVEL, SVIDEO_OFF);
-			break;
-		case DRM_MODE_SUBCONNECTOR_SCART:
-			*power |= bitfs(CH7006_POWER_LEVEL, NORMAL) |
-				CH7006_POWER_SCART;
-			break;
-		}
-
-	} else {
-		if (priv->chip_version >= 0x20)
-			*power |= bitfs(CH7006_POWER_LEVEL, FULL_POWER_OFF);
-		else
-			*power |= bitfs(CH7006_POWER_LEVEL, POWER_OFF);
-	}
-}
-
-void ch7006_setup_properties(struct drm_encoder *encoder)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-	struct ch7006_priv *priv = to_ch7006_priv(encoder);
-	struct ch7006_state *state = &priv->state;
-	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
-	const struct ch7006_mode *ch_mode = priv->mode;
-	const struct drm_display_mode *mode = &ch_mode->mode;
-	uint8_t *regs = state->regs;
-	int flicker, contrast, hpos, vpos;
-	uint64_t scale, aspect;
-
-	flicker = interpolate(0, 2, 3, priv->flicker);
-	regs[CH7006_FFILTER] = bitf(CH7006_FFILTER_TEXT, flicker) |
-		bitf(CH7006_FFILTER_LUMA, flicker) |
-		bitf(CH7006_FFILTER_CHROMA, 1);
-
-	contrast = interpolate(0, 5, 7, priv->contrast);
-	regs[CH7006_CONTRAST] = bitf(CH7006_CONTRAST_0, contrast);
-
-	scale = norm->vtotal*fixed1;
-	do_div(scale, mode->vtotal);
-
-	aspect = ch_mode->enc_hdisp*fixed1;
-	do_div(aspect, ch_mode->enc_vdisp);
-
-	hpos = round_fixed((norm->hvirtual * aspect - mode->hdisplay * scale)
-			   * priv->hmargin * mode->vtotal) / norm->vtotal / 100 / 4;
-
-	setbitf(state, CH7006_POV, HPOS_8, hpos);
-	setbitf(state, CH7006_HPOS, 0, hpos);
-
-	vpos = max(0, norm->vdisplay - round_fixed(mode->vdisplay*scale)
-		   + norm->voffset) * priv->vmargin / 100 / 2;
-
-	setbitf(state, CH7006_POV, VPOS_8, vpos);
-	setbitf(state, CH7006_VPOS, 0, vpos);
-
-	ch7006_dbg(client, "hpos: %d, vpos: %d\n", hpos, vpos);
-}
-
-/* HW access functions */
-
-void ch7006_write(struct i2c_client *client, uint8_t addr, uint8_t val)
-{
-	uint8_t buf[] = {addr, val};
-	int ret;
-
-	ret = i2c_master_send(client, buf, ARRAY_SIZE(buf));
-	if (ret < 0)
-		ch7006_err(client, "Error %d writing to subaddress 0x%x\n",
-			   ret, addr);
-}
-
-uint8_t ch7006_read(struct i2c_client *client, uint8_t addr)
-{
-	uint8_t val;
-	int ret;
-
-	ret = i2c_master_send(client, &addr, sizeof(addr));
-	if (ret < 0)
-		goto fail;
-
-	ret = i2c_master_recv(client, &val, sizeof(val));
-	if (ret < 0)
-		goto fail;
-
-	return val;
-
-fail:
-	ch7006_err(client, "Error %d reading from subaddress 0x%x\n",
-		   ret, addr);
-	return 0;
-}
-
-void ch7006_state_load(struct i2c_client *client,
-		       struct ch7006_state *state)
-{
-	ch7006_load_reg(client, state, CH7006_POWER);
-
-	ch7006_load_reg(client, state, CH7006_DISPMODE);
-	ch7006_load_reg(client, state, CH7006_FFILTER);
-	ch7006_load_reg(client, state, CH7006_BWIDTH);
-	ch7006_load_reg(client, state, CH7006_INPUT_FORMAT);
-	ch7006_load_reg(client, state, CH7006_CLKMODE);
-	ch7006_load_reg(client, state, CH7006_START_ACTIVE);
-	ch7006_load_reg(client, state, CH7006_POV);
-	ch7006_load_reg(client, state, CH7006_BLACK_LEVEL);
-	ch7006_load_reg(client, state, CH7006_HPOS);
-	ch7006_load_reg(client, state, CH7006_VPOS);
-	ch7006_load_reg(client, state, CH7006_INPUT_SYNC);
-	ch7006_load_reg(client, state, CH7006_DETECT);
-	ch7006_load_reg(client, state, CH7006_CONTRAST);
-	ch7006_load_reg(client, state, CH7006_PLLOV);
-	ch7006_load_reg(client, state, CH7006_PLLM);
-	ch7006_load_reg(client, state, CH7006_PLLN);
-	ch7006_load_reg(client, state, CH7006_BCLKOUT);
-	ch7006_load_reg(client, state, CH7006_SUBC_INC0);
-	ch7006_load_reg(client, state, CH7006_SUBC_INC1);
-	ch7006_load_reg(client, state, CH7006_SUBC_INC2);
-	ch7006_load_reg(client, state, CH7006_SUBC_INC3);
-	ch7006_load_reg(client, state, CH7006_SUBC_INC4);
-	ch7006_load_reg(client, state, CH7006_SUBC_INC5);
-	ch7006_load_reg(client, state, CH7006_SUBC_INC6);
-	ch7006_load_reg(client, state, CH7006_SUBC_INC7);
-	ch7006_load_reg(client, state, CH7006_PLL_CONTROL);
-	ch7006_load_reg(client, state, CH7006_CALC_SUBC_INC0);
-}
-
-void ch7006_state_save(struct i2c_client *client,
-		       struct ch7006_state *state)
-{
-	ch7006_save_reg(client, state, CH7006_POWER);
-
-	ch7006_save_reg(client, state, CH7006_DISPMODE);
-	ch7006_save_reg(client, state, CH7006_FFILTER);
-	ch7006_save_reg(client, state, CH7006_BWIDTH);
-	ch7006_save_reg(client, state, CH7006_INPUT_FORMAT);
-	ch7006_save_reg(client, state, CH7006_CLKMODE);
-	ch7006_save_reg(client, state, CH7006_START_ACTIVE);
-	ch7006_save_reg(client, state, CH7006_POV);
-	ch7006_save_reg(client, state, CH7006_BLACK_LEVEL);
-	ch7006_save_reg(client, state, CH7006_HPOS);
-	ch7006_save_reg(client, state, CH7006_VPOS);
-	ch7006_save_reg(client, state, CH7006_INPUT_SYNC);
-	ch7006_save_reg(client, state, CH7006_DETECT);
-	ch7006_save_reg(client, state, CH7006_CONTRAST);
-	ch7006_save_reg(client, state, CH7006_PLLOV);
-	ch7006_save_reg(client, state, CH7006_PLLM);
-	ch7006_save_reg(client, state, CH7006_PLLN);
-	ch7006_save_reg(client, state, CH7006_BCLKOUT);
-	ch7006_save_reg(client, state, CH7006_SUBC_INC0);
-	ch7006_save_reg(client, state, CH7006_SUBC_INC1);
-	ch7006_save_reg(client, state, CH7006_SUBC_INC2);
-	ch7006_save_reg(client, state, CH7006_SUBC_INC3);
-	ch7006_save_reg(client, state, CH7006_SUBC_INC4);
-	ch7006_save_reg(client, state, CH7006_SUBC_INC5);
-	ch7006_save_reg(client, state, CH7006_SUBC_INC6);
-	ch7006_save_reg(client, state, CH7006_SUBC_INC7);
-	ch7006_save_reg(client, state, CH7006_PLL_CONTROL);
-	ch7006_save_reg(client, state, CH7006_CALC_SUBC_INC0);
-
-	state->regs[CH7006_FFILTER] = (state->regs[CH7006_FFILTER] & 0xf0) |
-		(state->regs[CH7006_FFILTER] & 0x0c) >> 2 |
-		(state->regs[CH7006_FFILTER] & 0x03) << 2;
-}
diff --git a/drivers/gpu/drm/i2c/ch7006_priv.h b/drivers/gpu/drm/i2c/ch7006_priv.h
deleted file mode 100644
index 052bdc48a339..000000000000
--- a/drivers/gpu/drm/i2c/ch7006_priv.h
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Copyright (C) 2009 Francisco Jerez.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __DRM_I2C_CH7006_PRIV_H__
-#define __DRM_I2C_CH7006_PRIV_H__
-
-#include <drm/drm_encoder_slave.h>
-#include <drm/drm_probe_helper.h>
-#include <drm/i2c/ch7006.h>
-
-typedef int64_t fixed;
-#define fixed1 (1LL << 32)
-
-enum ch7006_tv_norm {
-	TV_NORM_PAL,
-	TV_NORM_PAL_M,
-	TV_NORM_PAL_N,
-	TV_NORM_PAL_NC,
-	TV_NORM_PAL_60,
-	TV_NORM_NTSC_M,
-	TV_NORM_NTSC_J,
-	NUM_TV_NORMS
-};
-
-struct ch7006_tv_norm_info {
-	fixed vrefresh;
-	int vdisplay;
-	int vtotal;
-	int hvirtual;
-
-	fixed subc_freq;
-	fixed black_level;
-
-	uint32_t dispmode;
-	int voffset;
-};
-
-struct ch7006_mode {
-	struct drm_display_mode mode;
-
-	int enc_hdisp;
-	int enc_vdisp;
-
-	fixed subc_coeff;
-	uint32_t dispmode;
-
-	uint32_t valid_scales;
-	uint32_t valid_norms;
-};
-
-struct ch7006_state {
-	uint8_t regs[0x26];
-};
-
-struct ch7006_priv {
-	struct ch7006_encoder_params params;
-	const struct ch7006_mode *mode;
-
-	struct ch7006_state state;
-	struct ch7006_state saved_state;
-
-	struct drm_property *scale_property;
-
-	int select_subconnector;
-	int subconnector;
-	int hmargin;
-	int vmargin;
-	enum ch7006_tv_norm norm;
-	int brightness;
-	int contrast;
-	int flicker;
-	int scale;
-
-	int chip_version;
-	int last_dpms;
-};
-
-#define to_ch7006_priv(x) \
-	((struct ch7006_priv *)to_encoder_slave(x)->slave_priv)
-
-extern int ch7006_debug;
-extern char *ch7006_tv_norm;
-extern int ch7006_scale;
-
-extern const char * const ch7006_tv_norm_names[];
-extern const struct ch7006_tv_norm_info ch7006_tv_norms[];
-extern const struct ch7006_mode ch7006_modes[];
-
-const struct ch7006_mode *ch7006_lookup_mode(struct drm_encoder *encoder,
-					     const struct drm_display_mode *drm_mode);
-
-void ch7006_setup_levels(struct drm_encoder *encoder);
-void ch7006_setup_subcarrier(struct drm_encoder *encoder);
-void ch7006_setup_pll(struct drm_encoder *encoder);
-void ch7006_setup_power_state(struct drm_encoder *encoder);
-void ch7006_setup_properties(struct drm_encoder *encoder);
-
-void ch7006_write(struct i2c_client *client, uint8_t addr, uint8_t val);
-uint8_t ch7006_read(struct i2c_client *client, uint8_t addr);
-
-void ch7006_state_load(struct i2c_client *client,
-		       struct ch7006_state *state);
-void ch7006_state_save(struct i2c_client *client,
-		       struct ch7006_state *state);
-
-/* Some helper macros */
-
-#define ch7006_dbg(client, format, ...) do {				\
-		if (ch7006_debug)					\
-			dev_printk(KERN_DEBUG, &client->dev,		\
-				   "%s: " format, __func__, ## __VA_ARGS__); \
-	} while (0)
-#define ch7006_info(client, format, ...) \
-				dev_info(&client->dev, format, __VA_ARGS__)
-#define ch7006_err(client, format, ...) \
-				dev_err(&client->dev, format, __VA_ARGS__)
-
-#define __mask(src, bitfield) \
-		(((2 << (1 ? bitfield)) - 1) & ~((1 << (0 ? bitfield)) - 1))
-#define mask(bitfield) __mask(bitfield)
-
-#define __bitf(src, bitfield, x) \
-		(((x) >> (src) << (0 ? bitfield)) &  __mask(src, bitfield))
-#define bitf(bitfield, x) __bitf(bitfield, x)
-#define bitfs(bitfield, s) __bitf(bitfield, bitfield##_##s)
-#define setbitf(state, reg, bitfield, x)				\
-	state->regs[reg] = (state->regs[reg] & ~mask(reg##_##bitfield))	\
-		| bitf(reg##_##bitfield, x)
-
-#define __unbitf(src, bitfield, x) \
-		((x & __mask(src, bitfield)) >> (0 ? bitfield) << (src))
-#define unbitf(bitfield, x) __unbitf(bitfield, x)
-
-static inline int interpolate(int y0, int y1, int y2, int x)
-{
-	return y1 + (x < 50 ? y1 - y0 : y2 - y1) * (x - 50) / 50;
-}
-
-static inline int32_t round_fixed(fixed x)
-{
-	return (x + fixed1/2) >> 32;
-}
-
-#define ch7006_load_reg(client, state, reg) ch7006_write(client, reg, state->regs[reg])
-#define ch7006_save_reg(client, state, reg) state->regs[reg] = ch7006_read(client, reg)
-
-/* Fixed hardware specs */
-
-#define CH7006_FREQ0				14318
-#define CH7006_MAXN				650
-#define CH7006_MAXM				315
-
-/* Register definitions */
-
-#define CH7006_DISPMODE				0x00
-#define CH7006_DISPMODE_INPUT_RES		0, 7:5
-#define CH7006_DISPMODE_INPUT_RES_512x384	0x0
-#define CH7006_DISPMODE_INPUT_RES_720x400	0x1
-#define CH7006_DISPMODE_INPUT_RES_640x400	0x2
-#define CH7006_DISPMODE_INPUT_RES_640x480	0x3
-#define CH7006_DISPMODE_INPUT_RES_800x600	0x4
-#define CH7006_DISPMODE_INPUT_RES_NATIVE	0x5
-#define CH7006_DISPMODE_OUTPUT_STD		0, 4:3
-#define CH7006_DISPMODE_OUTPUT_STD_PAL		0x0
-#define CH7006_DISPMODE_OUTPUT_STD_NTSC		0x1
-#define CH7006_DISPMODE_OUTPUT_STD_PAL_M	0x2
-#define CH7006_DISPMODE_OUTPUT_STD_NTSC_J	0x3
-#define CH7006_DISPMODE_SCALING_RATIO		0, 2:0
-#define CH7006_DISPMODE_SCALING_RATIO_5_4	0x0
-#define CH7006_DISPMODE_SCALING_RATIO_1_1	0x1
-#define CH7006_DISPMODE_SCALING_RATIO_7_8	0x2
-#define CH7006_DISPMODE_SCALING_RATIO_5_6	0x3
-#define CH7006_DISPMODE_SCALING_RATIO_3_4	0x4
-#define CH7006_DISPMODE_SCALING_RATIO_7_10	0x5
-
-#define CH7006_FFILTER				0x01
-#define CH7006_FFILTER_TEXT			0, 5:4
-#define CH7006_FFILTER_LUMA			0, 3:2
-#define CH7006_FFILTER_CHROMA			0, 1:0
-#define CH7006_FFILTER_CHROMA_NO_DCRAWL		0x3
-
-#define CH7006_BWIDTH				0x03
-#define CH7006_BWIDTH_5L_FFILER			(1 << 7)
-#define CH7006_BWIDTH_CVBS_NO_CHROMA		(1 << 6)
-#define CH7006_BWIDTH_CHROMA			0, 5:4
-#define CH7006_BWIDTH_SVIDEO_YPEAK		(1 << 3)
-#define CH7006_BWIDTH_SVIDEO_LUMA		0, 2:1
-#define CH7006_BWIDTH_CVBS_LUMA			0, 0:0
-
-#define CH7006_INPUT_FORMAT			0x04
-#define CH7006_INPUT_FORMAT_DAC_GAIN		(1 << 6)
-#define CH7006_INPUT_FORMAT_RGB_PASS_THROUGH	(1 << 5)
-#define CH7006_INPUT_FORMAT_FORMAT		0, 3:0
-#define CH7006_INPUT_FORMAT_FORMAT_RGB16	0x0
-#define CH7006_INPUT_FORMAT_FORMAT_YCrCb24m16	0x1
-#define CH7006_INPUT_FORMAT_FORMAT_RGB24m16	0x2
-#define CH7006_INPUT_FORMAT_FORMAT_RGB15	0x3
-#define CH7006_INPUT_FORMAT_FORMAT_RGB24m12C	0x4
-#define CH7006_INPUT_FORMAT_FORMAT_RGB24m12I	0x5
-#define CH7006_INPUT_FORMAT_FORMAT_RGB24m8	0x6
-#define CH7006_INPUT_FORMAT_FORMAT_RGB16m8	0x7
-#define CH7006_INPUT_FORMAT_FORMAT_RGB15m8	0x8
-#define CH7006_INPUT_FORMAT_FORMAT_YCrCb24m8	0x9
-
-#define CH7006_CLKMODE				0x06
-#define CH7006_CLKMODE_SUBC_LOCK		(1 << 7)
-#define CH7006_CLKMODE_MASTER			(1 << 6)
-#define CH7006_CLKMODE_POS_EDGE			(1 << 4)
-#define CH7006_CLKMODE_XCM			0, 3:2
-#define CH7006_CLKMODE_PCM			0, 1:0
-
-#define CH7006_START_ACTIVE			0x07
-#define CH7006_START_ACTIVE_0			0, 7:0
-
-#define CH7006_POV				0x08
-#define CH7006_POV_START_ACTIVE_8		8, 2:2
-#define CH7006_POV_HPOS_8			8, 1:1
-#define CH7006_POV_VPOS_8			8, 0:0
-
-#define CH7006_BLACK_LEVEL			0x09
-#define CH7006_BLACK_LEVEL_0			0, 7:0
-
-#define CH7006_HPOS				0x0a
-#define CH7006_HPOS_0				0, 7:0
-
-#define CH7006_VPOS				0x0b
-#define CH7006_VPOS_0				0, 7:0
-
-#define CH7006_INPUT_SYNC			0x0d
-#define CH7006_INPUT_SYNC_EMBEDDED		(1 << 3)
-#define CH7006_INPUT_SYNC_OUTPUT		(1 << 2)
-#define CH7006_INPUT_SYNC_PVSYNC		(1 << 1)
-#define CH7006_INPUT_SYNC_PHSYNC		(1 << 0)
-
-#define CH7006_POWER				0x0e
-#define CH7006_POWER_SCART			(1 << 4)
-#define CH7006_POWER_RESET			(1 << 3)
-#define CH7006_POWER_LEVEL			0, 2:0
-#define CH7006_POWER_LEVEL_CVBS_OFF		0x0
-#define CH7006_POWER_LEVEL_POWER_OFF		0x1
-#define CH7006_POWER_LEVEL_SVIDEO_OFF		0x2
-#define CH7006_POWER_LEVEL_NORMAL		0x3
-#define CH7006_POWER_LEVEL_FULL_POWER_OFF	0x4
-
-#define CH7006_DETECT				0x10
-#define CH7006_DETECT_SVIDEO_Y_TEST		(1 << 3)
-#define CH7006_DETECT_SVIDEO_C_TEST		(1 << 2)
-#define CH7006_DETECT_CVBS_TEST			(1 << 1)
-#define CH7006_DETECT_SENSE			(1 << 0)
-
-#define CH7006_CONTRAST				0x11
-#define CH7006_CONTRAST_0			0, 2:0
-
-#define CH7006_PLLOV	 			0x13
-#define CH7006_PLLOV_N_8	 		8, 2:1
-#define CH7006_PLLOV_M_8	 		8, 0:0
-
-#define CH7006_PLLM	 			0x14
-#define CH7006_PLLM_0	 			0, 7:0
-
-#define CH7006_PLLN	 			0x15
-#define CH7006_PLLN_0	 			0, 7:0
-
-#define CH7006_BCLKOUT	 			0x17
-
-#define CH7006_SUBC_INC0			0x18
-#define CH7006_SUBC_INC0_28			28, 3:0
-
-#define CH7006_SUBC_INC1			0x19
-#define CH7006_SUBC_INC1_24			24, 3:0
-
-#define CH7006_SUBC_INC2			0x1a
-#define CH7006_SUBC_INC2_20			20, 3:0
-
-#define CH7006_SUBC_INC3			0x1b
-#define CH7006_SUBC_INC3_GPIO1_VAL		(1 << 7)
-#define CH7006_SUBC_INC3_GPIO0_VAL		(1 << 6)
-#define CH7006_SUBC_INC3_POUT_3_3V		(1 << 5)
-#define CH7006_SUBC_INC3_POUT_INV		(1 << 4)
-#define CH7006_SUBC_INC3_16			16, 3:0
-
-#define CH7006_SUBC_INC4			0x1c
-#define CH7006_SUBC_INC4_GPIO1_IN		(1 << 7)
-#define CH7006_SUBC_INC4_GPIO0_IN		(1 << 6)
-#define CH7006_SUBC_INC4_DS_INPUT		(1 << 4)
-#define CH7006_SUBC_INC4_12			12, 3:0
-
-#define CH7006_SUBC_INC5			0x1d
-#define CH7006_SUBC_INC5_8			8, 3:0
-
-#define CH7006_SUBC_INC6			0x1e
-#define CH7006_SUBC_INC6_4			4, 3:0
-
-#define CH7006_SUBC_INC7			0x1f
-#define CH7006_SUBC_INC7_0			0, 3:0
-
-#define CH7006_PLL_CONTROL			0x20
-#define CH7006_PLL_CONTROL_CPI			(1 << 5)
-#define CH7006_PLL_CONTROL_CAPACITOR		(1 << 4)
-#define CH7006_PLL_CONTROL_7STAGES		(1 << 3)
-#define CH7006_PLL_CONTROL_DIGITAL_5V		(1 << 2)
-#define CH7006_PLL_CONTROL_ANALOG_5V		(1 << 1)
-#define CH7006_PLL_CONTROL_MEMORY_5V		(1 << 0)
-
-#define CH7006_CALC_SUBC_INC0			0x21
-#define CH7006_CALC_SUBC_INC0_24		24, 4:3
-#define CH7006_CALC_SUBC_INC0_HYST		0, 2:1
-#define CH7006_CALC_SUBC_INC0_AUTO		(1 << 0)
-
-#define CH7006_CALC_SUBC_INC1			0x22
-#define CH7006_CALC_SUBC_INC1_16		16, 7:0
-
-#define CH7006_CALC_SUBC_INC2			0x23
-#define CH7006_CALC_SUBC_INC2_8			8, 7:0
-
-#define CH7006_CALC_SUBC_INC3			0x24
-#define CH7006_CALC_SUBC_INC3_0			0, 7:0
-
-#define CH7006_VERSION_ID			0x25
-
-#endif
diff --git a/drivers/gpu/drm/i2c/sil164_drv.c b/drivers/gpu/drm/i2c/sil164_drv.c
deleted file mode 100644
index 6e5da2c5762f..000000000000
--- a/drivers/gpu/drm/i2c/sil164_drv.c
+++ /dev/null
@@ -1,451 +0,0 @@
-/*
- * Copyright (C) 2010 Francisco Jerez.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <linux/module.h>
-
-#include <drm/drm_drv.h>
-#include <drm/drm_encoder_slave.h>
-#include <drm/drm_print.h>
-#include <drm/drm_probe_helper.h>
-#include <drm/i2c/sil164.h>
-
-struct sil164_priv {
-	struct sil164_encoder_params config;
-	struct i2c_client *duallink_slave;
-
-	uint8_t saved_state[0x10];
-	uint8_t saved_slave_state[0x10];
-};
-
-#define to_sil164_priv(x) \
-	((struct sil164_priv *)to_encoder_slave(x)->slave_priv)
-
-#define sil164_dbg(client, format, ...) do {				\
-		if (drm_debug_enabled(DRM_UT_KMS))			\
-			dev_printk(KERN_DEBUG, &client->dev,		\
-				   "%s: " format, __func__, ## __VA_ARGS__); \
-	} while (0)
-#define sil164_info(client, format, ...)		\
-	dev_info(&client->dev, format, __VA_ARGS__)
-#define sil164_err(client, format, ...)			\
-	dev_err(&client->dev, format, __VA_ARGS__)
-
-#define SIL164_I2C_ADDR_MASTER			0x38
-#define SIL164_I2C_ADDR_SLAVE			0x39
-
-/* HW register definitions */
-
-#define SIL164_VENDOR_LO			0x0
-#define SIL164_VENDOR_HI			0x1
-#define SIL164_DEVICE_LO			0x2
-#define SIL164_DEVICE_HI			0x3
-#define SIL164_REVISION				0x4
-#define SIL164_FREQ_MIN				0x6
-#define SIL164_FREQ_MAX				0x7
-#define SIL164_CONTROL0				0x8
-#  define SIL164_CONTROL0_POWER_ON		0x01
-#  define SIL164_CONTROL0_EDGE_RISING		0x02
-#  define SIL164_CONTROL0_INPUT_24BIT		0x04
-#  define SIL164_CONTROL0_DUAL_EDGE		0x08
-#  define SIL164_CONTROL0_HSYNC_ON		0x10
-#  define SIL164_CONTROL0_VSYNC_ON		0x20
-#define SIL164_DETECT				0x9
-#  define SIL164_DETECT_INTR_STAT		0x01
-#  define SIL164_DETECT_HOTPLUG_STAT		0x02
-#  define SIL164_DETECT_RECEIVER_STAT		0x04
-#  define SIL164_DETECT_INTR_MODE_RECEIVER	0x00
-#  define SIL164_DETECT_INTR_MODE_HOTPLUG	0x08
-#  define SIL164_DETECT_OUT_MODE_HIGH		0x00
-#  define SIL164_DETECT_OUT_MODE_INTR		0x10
-#  define SIL164_DETECT_OUT_MODE_RECEIVER	0x20
-#  define SIL164_DETECT_OUT_MODE_HOTPLUG	0x30
-#  define SIL164_DETECT_VSWING_STAT		0x80
-#define SIL164_CONTROL1				0xa
-#  define SIL164_CONTROL1_DESKEW_ENABLE		0x10
-#  define SIL164_CONTROL1_DESKEW_INCR_SHIFT	5
-#define SIL164_GPIO				0xb
-#define SIL164_CONTROL2				0xc
-#  define SIL164_CONTROL2_FILTER_ENABLE		0x01
-#  define SIL164_CONTROL2_FILTER_SETTING_SHIFT	1
-#  define SIL164_CONTROL2_DUALLINK_MASTER	0x40
-#  define SIL164_CONTROL2_SYNC_CONT		0x80
-#define SIL164_DUALLINK				0xd
-#  define SIL164_DUALLINK_ENABLE		0x10
-#  define SIL164_DUALLINK_SKEW_SHIFT		5
-#define SIL164_PLLZONE				0xe
-#  define SIL164_PLLZONE_STAT			0x08
-#  define SIL164_PLLZONE_FORCE_ON		0x10
-#  define SIL164_PLLZONE_FORCE_HIGH		0x20
-
-/* HW access functions */
-
-static void
-sil164_write(struct i2c_client *client, uint8_t addr, uint8_t val)
-{
-	uint8_t buf[] = {addr, val};
-	int ret;
-
-	ret = i2c_master_send(client, buf, ARRAY_SIZE(buf));
-	if (ret < 0)
-		sil164_err(client, "Error %d writing to subaddress 0x%x\n",
-			   ret, addr);
-}
-
-static uint8_t
-sil164_read(struct i2c_client *client, uint8_t addr)
-{
-	uint8_t val;
-	int ret;
-
-	ret = i2c_master_send(client, &addr, sizeof(addr));
-	if (ret < 0)
-		goto fail;
-
-	ret = i2c_master_recv(client, &val, sizeof(val));
-	if (ret < 0)
-		goto fail;
-
-	return val;
-
-fail:
-	sil164_err(client, "Error %d reading from subaddress 0x%x\n",
-		   ret, addr);
-	return 0;
-}
-
-static void
-sil164_save_state(struct i2c_client *client, uint8_t *state)
-{
-	int i;
-
-	for (i = 0x8; i <= 0xe; i++)
-		state[i] = sil164_read(client, i);
-}
-
-static void
-sil164_restore_state(struct i2c_client *client, uint8_t *state)
-{
-	int i;
-
-	for (i = 0x8; i <= 0xe; i++)
-		sil164_write(client, i, state[i]);
-}
-
-static void
-sil164_set_power_state(struct i2c_client *client, bool on)
-{
-	uint8_t control0 = sil164_read(client, SIL164_CONTROL0);
-
-	if (on)
-		control0 |= SIL164_CONTROL0_POWER_ON;
-	else
-		control0 &= ~SIL164_CONTROL0_POWER_ON;
-
-	sil164_write(client, SIL164_CONTROL0, control0);
-}
-
-static void
-sil164_init_state(struct i2c_client *client,
-		  struct sil164_encoder_params *config,
-		  bool duallink)
-{
-	sil164_write(client, SIL164_CONTROL0,
-		     SIL164_CONTROL0_HSYNC_ON |
-		     SIL164_CONTROL0_VSYNC_ON |
-		     (config->input_edge ? SIL164_CONTROL0_EDGE_RISING : 0) |
-		     (config->input_width ? SIL164_CONTROL0_INPUT_24BIT : 0) |
-		     (config->input_dual ? SIL164_CONTROL0_DUAL_EDGE : 0));
-
-	sil164_write(client, SIL164_DETECT,
-		     SIL164_DETECT_INTR_STAT |
-		     SIL164_DETECT_OUT_MODE_RECEIVER);
-
-	sil164_write(client, SIL164_CONTROL1,
-		     (config->input_skew ? SIL164_CONTROL1_DESKEW_ENABLE : 0) |
-		     (((config->input_skew + 4) & 0x7)
-		      << SIL164_CONTROL1_DESKEW_INCR_SHIFT));
-
-	sil164_write(client, SIL164_CONTROL2,
-		     SIL164_CONTROL2_SYNC_CONT |
-		     (config->pll_filter ? 0 : SIL164_CONTROL2_FILTER_ENABLE) |
-		     (4 << SIL164_CONTROL2_FILTER_SETTING_SHIFT));
-
-	sil164_write(client, SIL164_PLLZONE, 0);
-
-	if (duallink)
-		sil164_write(client, SIL164_DUALLINK,
-			     SIL164_DUALLINK_ENABLE |
-			     (((config->duallink_skew + 4) & 0x7)
-			      << SIL164_DUALLINK_SKEW_SHIFT));
-	else
-		sil164_write(client, SIL164_DUALLINK, 0);
-}
-
-/* DRM encoder functions */
-
-static void
-sil164_encoder_set_config(struct drm_encoder *encoder, void *params)
-{
-	struct sil164_priv *priv = to_sil164_priv(encoder);
-
-	priv->config = *(struct sil164_encoder_params *)params;
-}
-
-static void
-sil164_encoder_dpms(struct drm_encoder *encoder, int mode)
-{
-	struct sil164_priv *priv = to_sil164_priv(encoder);
-	bool on = (mode == DRM_MODE_DPMS_ON);
-	bool duallink = (on && encoder->crtc->mode.clock > 165000);
-
-	sil164_set_power_state(drm_i2c_encoder_get_client(encoder), on);
-
-	if (priv->duallink_slave)
-		sil164_set_power_state(priv->duallink_slave, duallink);
-}
-
-static void
-sil164_encoder_save(struct drm_encoder *encoder)
-{
-	struct sil164_priv *priv = to_sil164_priv(encoder);
-
-	sil164_save_state(drm_i2c_encoder_get_client(encoder),
-			  priv->saved_state);
-
-	if (priv->duallink_slave)
-		sil164_save_state(priv->duallink_slave,
-				  priv->saved_slave_state);
-}
-
-static void
-sil164_encoder_restore(struct drm_encoder *encoder)
-{
-	struct sil164_priv *priv = to_sil164_priv(encoder);
-
-	sil164_restore_state(drm_i2c_encoder_get_client(encoder),
-			     priv->saved_state);
-
-	if (priv->duallink_slave)
-		sil164_restore_state(priv->duallink_slave,
-				     priv->saved_slave_state);
-}
-
-static int
-sil164_encoder_mode_valid(struct drm_encoder *encoder,
-			  const struct drm_display_mode *mode)
-{
-	struct sil164_priv *priv = to_sil164_priv(encoder);
-
-	if (mode->clock < 32000)
-		return MODE_CLOCK_LOW;
-
-	if (mode->clock > 330000 ||
-	    (mode->clock > 165000 && !priv->duallink_slave))
-		return MODE_CLOCK_HIGH;
-
-	return MODE_OK;
-}
-
-static void
-sil164_encoder_mode_set(struct drm_encoder *encoder,
-			struct drm_display_mode *mode,
-			struct drm_display_mode *adjusted_mode)
-{
-	struct sil164_priv *priv = to_sil164_priv(encoder);
-	bool duallink = adjusted_mode->clock > 165000;
-
-	sil164_init_state(drm_i2c_encoder_get_client(encoder),
-			  &priv->config, duallink);
-
-	if (priv->duallink_slave)
-		sil164_init_state(priv->duallink_slave,
-				  &priv->config, duallink);
-
-	sil164_encoder_dpms(encoder, DRM_MODE_DPMS_ON);
-}
-
-static enum drm_connector_status
-sil164_encoder_detect(struct drm_encoder *encoder,
-		      struct drm_connector *connector)
-{
-	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
-
-	if (sil164_read(client, SIL164_DETECT) & SIL164_DETECT_HOTPLUG_STAT)
-		return connector_status_connected;
-	else
-		return connector_status_disconnected;
-}
-
-static int
-sil164_encoder_get_modes(struct drm_encoder *encoder,
-			 struct drm_connector *connector)
-{
-	return 0;
-}
-
-static int
-sil164_encoder_create_resources(struct drm_encoder *encoder,
-				struct drm_connector *connector)
-{
-	return 0;
-}
-
-static int
-sil164_encoder_set_property(struct drm_encoder *encoder,
-			    struct drm_connector *connector,
-			    struct drm_property *property,
-			    uint64_t val)
-{
-	return 0;
-}
-
-static void
-sil164_encoder_destroy(struct drm_encoder *encoder)
-{
-	struct sil164_priv *priv = to_sil164_priv(encoder);
-
-	i2c_unregister_device(priv->duallink_slave);
-
-	kfree(priv);
-	drm_i2c_encoder_destroy(encoder);
-}
-
-static const struct drm_encoder_slave_funcs sil164_encoder_funcs = {
-	.set_config = sil164_encoder_set_config,
-	.destroy = sil164_encoder_destroy,
-	.dpms = sil164_encoder_dpms,
-	.save = sil164_encoder_save,
-	.restore = sil164_encoder_restore,
-	.mode_valid = sil164_encoder_mode_valid,
-	.mode_set = sil164_encoder_mode_set,
-	.detect = sil164_encoder_detect,
-	.get_modes = sil164_encoder_get_modes,
-	.create_resources = sil164_encoder_create_resources,
-	.set_property = sil164_encoder_set_property,
-};
-
-/* I2C driver functions */
-
-static int
-sil164_probe(struct i2c_client *client)
-{
-	int vendor = sil164_read(client, SIL164_VENDOR_HI) << 8 |
-		sil164_read(client, SIL164_VENDOR_LO);
-	int device = sil164_read(client, SIL164_DEVICE_HI) << 8 |
-		sil164_read(client, SIL164_DEVICE_LO);
-	int rev = sil164_read(client, SIL164_REVISION);
-
-	if (vendor != 0x1 || device != 0x6) {
-		sil164_dbg(client, "Unknown device %x:%x.%x\n",
-			   vendor, device, rev);
-		return -ENODEV;
-	}
-
-	sil164_info(client, "Detected device %x:%x.%x\n",
-		    vendor, device, rev);
-
-	return 0;
-}
-
-static struct i2c_client *
-sil164_detect_slave(struct i2c_client *client)
-{
-	struct i2c_adapter *adap = client->adapter;
-	struct i2c_msg msg = {
-		.addr = SIL164_I2C_ADDR_SLAVE,
-		.len = 0,
-	};
-	const struct i2c_board_info info = {
-		I2C_BOARD_INFO("sil164", SIL164_I2C_ADDR_SLAVE)
-	};
-
-	if (i2c_transfer(adap, &msg, 1) != 1) {
-		sil164_dbg(adap, "No dual-link slave found.");
-		return NULL;
-	}
-
-	return i2c_new_client_device(adap, &info);
-}
-
-static int
-sil164_encoder_init(struct i2c_client *client,
-		    struct drm_device *dev,
-		    struct drm_encoder_slave *encoder)
-{
-	struct sil164_priv *priv;
-	struct i2c_client *slave_client;
-
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	encoder->slave_priv = priv;
-	encoder->slave_funcs = &sil164_encoder_funcs;
-
-	slave_client = sil164_detect_slave(client);
-	if (!IS_ERR(slave_client))
-		priv->duallink_slave = slave_client;
-
-	return 0;
-}
-
-static const struct i2c_device_id sil164_ids[] = {
-	{ "sil164" },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, sil164_ids);
-
-static struct drm_i2c_encoder_driver sil164_driver = {
-	.i2c_driver = {
-		.probe = sil164_probe,
-		.driver = {
-			.name = "sil164",
-		},
-		.id_table = sil164_ids,
-	},
-	.encoder_init = sil164_encoder_init,
-};
-
-/* Module initialization */
-
-static int __init
-sil164_init(void)
-{
-	return drm_i2c_encoder_register(THIS_MODULE, &sil164_driver);
-}
-
-static void __exit
-sil164_exit(void)
-{
-	drm_i2c_encoder_unregister(&sil164_driver);
-}
-
-MODULE_AUTHOR("Francisco Jerez <currojerez@riseup.net>");
-MODULE_DESCRIPTION("Silicon Image sil164 TMDS transmitter driver");
-MODULE_LICENSE("GPL and additional rights");
-
-module_init(sil164_init);
-module_exit(sil164_exit);
diff --git a/drivers/gpu/drm/nouveau/Kconfig b/drivers/gpu/drm/nouveau/Kconfig
index 1050a4617fc1..7b3e979c51ec 100644
--- a/drivers/gpu/drm/nouveau/Kconfig
+++ b/drivers/gpu/drm/nouveau/Kconfig
@@ -110,3 +110,21 @@ config DRM_NOUVEAU_GSP_DEFAULT
 	help
 	  Say Y here if you want to use the GSP codepaths by default on
 	  Turing and Ampere GPUs.
+
+config DRM_NOUVEAU_CH7006
+	tristate "Chrontel ch7006 TV encoder"
+	depends on DRM_NOUVEAU
+	default m
+	help
+	  Support for Chrontel ch7006 and similar TV encoders.
+
+	  This driver is currently only useful if you're also using
+	  the nouveau driver.
+
+config DRM_NOUVEAU_SIL164
+	tristate "Silicon Image sil164 TMDS transmitter"
+	depends on DRM_NOUVEAU
+	default m
+	help
+	  Support for sil164 and similar single-link (or dual-link
+	  when used in pairs) TMDS transmitters.
diff --git a/drivers/gpu/drm/nouveau/dispnv04/Kbuild b/drivers/gpu/drm/nouveau/dispnv04/Kbuild
index 975c4e226936..949802882ebd 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/Kbuild
+++ b/drivers/gpu/drm/nouveau/dispnv04/Kbuild
@@ -10,3 +10,5 @@ nouveau-y += dispnv04/overlay.o
 nouveau-y += dispnv04/tvmodesnv17.o
 nouveau-y += dispnv04/tvnv04.o
 nouveau-y += dispnv04/tvnv17.o
+
+include $(src)/dispnv04/i2c/Kbuild
diff --git a/drivers/gpu/drm/nouveau/dispnv04/dfp.c b/drivers/gpu/drm/nouveau/dispnv04/dfp.c
index 504c421aa176..25fa41edcb3c 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/dfp.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/dfp.c
@@ -35,7 +35,7 @@
 #include "hw.h"
 #include "nvreg.h"
 
-#include <drm/i2c/sil164.h>
+#include <dispnv04/i2c/sil164.h>
 
 #include <subdev/i2c.h>
 
diff --git a/drivers/gpu/drm/nouveau/dispnv04/i2c/Kbuild b/drivers/gpu/drm/nouveau/dispnv04/i2c/Kbuild
new file mode 100644
index 000000000000..3fddfc97bcb3
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv04/i2c/Kbuild
@@ -0,0 +1,5 @@
+ch7006-y := dispnv04/i2c/ch7006_drv.o dispnv04/i2c/ch7006_mode.o
+obj-$(CONFIG_DRM_NOUVEAU_CH7006) += ch7006.o
+
+sil164-y := dispnv04/i2c/sil164_drv.o
+obj-$(CONFIG_DRM_NOUVEAU_SIL164) += sil164.o
diff --git a/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_drv.c b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_drv.c
new file mode 100644
index 000000000000..db4f95020fae
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_drv.c
@@ -0,0 +1,549 @@
+/*
+ * Copyright (C) 2009 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/module.h>
+
+#include <drm/drm_crtc_helper.h>
+
+#include "ch7006_priv.h"
+
+/* DRM encoder functions */
+
+static void ch7006_encoder_set_config(struct drm_encoder *encoder,
+				      void *params)
+{
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+
+	priv->params = *(struct ch7006_encoder_params *)params;
+}
+
+static void ch7006_encoder_destroy(struct drm_encoder *encoder)
+{
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+
+	drm_property_destroy(encoder->dev, priv->scale_property);
+
+	kfree(priv);
+	to_encoder_slave(encoder)->slave_priv = NULL;
+
+	drm_i2c_encoder_destroy(encoder);
+}
+
+static void  ch7006_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	struct ch7006_state *state = &priv->state;
+
+	ch7006_dbg(client, "\n");
+
+	if (mode == priv->last_dpms)
+		return;
+	priv->last_dpms = mode;
+
+	ch7006_setup_power_state(encoder);
+
+	ch7006_load_reg(client, state, CH7006_POWER);
+}
+
+static void ch7006_encoder_save(struct drm_encoder *encoder)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+
+	ch7006_dbg(client, "\n");
+
+	ch7006_state_save(client, &priv->saved_state);
+}
+
+static void ch7006_encoder_restore(struct drm_encoder *encoder)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+
+	ch7006_dbg(client, "\n");
+
+	ch7006_state_load(client, &priv->saved_state);
+}
+
+static bool ch7006_encoder_mode_fixup(struct drm_encoder *encoder,
+				      const struct drm_display_mode *mode,
+				      struct drm_display_mode *adjusted_mode)
+{
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+
+	/* The ch7006 is painfully picky with the input timings so no
+	 * custom modes for now... */
+
+	priv->mode = ch7006_lookup_mode(encoder, mode);
+
+	return !!priv->mode;
+}
+
+static int ch7006_encoder_mode_valid(struct drm_encoder *encoder,
+				     const struct drm_display_mode *mode)
+{
+	if (ch7006_lookup_mode(encoder, mode))
+		return MODE_OK;
+	else
+		return MODE_BAD;
+}
+
+static void ch7006_encoder_mode_set(struct drm_encoder *encoder,
+				     struct drm_display_mode *drm_mode,
+				     struct drm_display_mode *adjusted_mode)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	struct ch7006_encoder_params *params = &priv->params;
+	struct ch7006_state *state = &priv->state;
+	uint8_t *regs = state->regs;
+	const struct ch7006_mode *mode = priv->mode;
+	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
+	int start_active;
+
+	ch7006_dbg(client, "\n");
+
+	regs[CH7006_DISPMODE] = norm->dispmode | mode->dispmode;
+	regs[CH7006_BWIDTH] = 0;
+	regs[CH7006_INPUT_FORMAT] = bitf(CH7006_INPUT_FORMAT_FORMAT,
+					 params->input_format);
+
+	regs[CH7006_CLKMODE] = CH7006_CLKMODE_SUBC_LOCK
+		| bitf(CH7006_CLKMODE_XCM, params->xcm)
+		| bitf(CH7006_CLKMODE_PCM, params->pcm);
+	if (params->clock_mode)
+		regs[CH7006_CLKMODE] |= CH7006_CLKMODE_MASTER;
+	if (params->clock_edge)
+		regs[CH7006_CLKMODE] |= CH7006_CLKMODE_POS_EDGE;
+
+	start_active = (drm_mode->htotal & ~0x7) - (drm_mode->hsync_start & ~0x7);
+	regs[CH7006_POV] = bitf(CH7006_POV_START_ACTIVE_8, start_active);
+	regs[CH7006_START_ACTIVE] = bitf(CH7006_START_ACTIVE_0, start_active);
+
+	regs[CH7006_INPUT_SYNC] = 0;
+	if (params->sync_direction)
+		regs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_OUTPUT;
+	if (params->sync_encoding)
+		regs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_EMBEDDED;
+	if (drm_mode->flags & DRM_MODE_FLAG_PVSYNC)
+		regs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_PVSYNC;
+	if (drm_mode->flags & DRM_MODE_FLAG_PHSYNC)
+		regs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_PHSYNC;
+
+	regs[CH7006_DETECT] = 0;
+	regs[CH7006_BCLKOUT] = 0;
+
+	regs[CH7006_SUBC_INC3] = 0;
+	if (params->pout_level)
+		regs[CH7006_SUBC_INC3] |= CH7006_SUBC_INC3_POUT_3_3V;
+
+	regs[CH7006_SUBC_INC4] = 0;
+	if (params->active_detect)
+		regs[CH7006_SUBC_INC4] |= CH7006_SUBC_INC4_DS_INPUT;
+
+	regs[CH7006_PLL_CONTROL] = priv->saved_state.regs[CH7006_PLL_CONTROL];
+
+	ch7006_setup_levels(encoder);
+	ch7006_setup_subcarrier(encoder);
+	ch7006_setup_pll(encoder);
+	ch7006_setup_power_state(encoder);
+	ch7006_setup_properties(encoder);
+
+	ch7006_state_load(client, state);
+}
+
+static enum drm_connector_status ch7006_encoder_detect(struct drm_encoder *encoder,
+						       struct drm_connector *connector)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	struct ch7006_state *state = &priv->state;
+	int det;
+
+	ch7006_dbg(client, "\n");
+
+	ch7006_save_reg(client, state, CH7006_DETECT);
+	ch7006_save_reg(client, state, CH7006_POWER);
+	ch7006_save_reg(client, state, CH7006_CLKMODE);
+
+	ch7006_write(client, CH7006_POWER, CH7006_POWER_RESET |
+					   bitfs(CH7006_POWER_LEVEL, NORMAL));
+	ch7006_write(client, CH7006_CLKMODE, CH7006_CLKMODE_MASTER);
+
+	ch7006_write(client, CH7006_DETECT, CH7006_DETECT_SENSE);
+
+	ch7006_write(client, CH7006_DETECT, 0);
+
+	det = ch7006_read(client, CH7006_DETECT);
+
+	ch7006_load_reg(client, state, CH7006_CLKMODE);
+	ch7006_load_reg(client, state, CH7006_POWER);
+	ch7006_load_reg(client, state, CH7006_DETECT);
+
+	if ((det & (CH7006_DETECT_SVIDEO_Y_TEST|
+		    CH7006_DETECT_SVIDEO_C_TEST|
+		    CH7006_DETECT_CVBS_TEST)) == 0)
+		priv->subconnector = DRM_MODE_SUBCONNECTOR_SCART;
+	else if ((det & (CH7006_DETECT_SVIDEO_Y_TEST|
+			 CH7006_DETECT_SVIDEO_C_TEST)) == 0)
+		priv->subconnector = DRM_MODE_SUBCONNECTOR_SVIDEO;
+	else if ((det & CH7006_DETECT_CVBS_TEST) == 0)
+		priv->subconnector = DRM_MODE_SUBCONNECTOR_Composite;
+	else
+		priv->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;
+
+	drm_object_property_set_value(&connector->base,
+			encoder->dev->mode_config.tv_subconnector_property,
+							priv->subconnector);
+
+	return priv->subconnector ? connector_status_connected :
+					connector_status_disconnected;
+}
+
+static int ch7006_encoder_get_modes(struct drm_encoder *encoder,
+				    struct drm_connector *connector)
+{
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	const struct ch7006_mode *mode;
+	int n = 0;
+
+	for (mode = ch7006_modes; mode->mode.clock; mode++) {
+		if (~mode->valid_scales & 1<<priv->scale ||
+		    ~mode->valid_norms & 1<<priv->norm)
+			continue;
+
+		drm_mode_probed_add(connector,
+				drm_mode_duplicate(encoder->dev, &mode->mode));
+
+		n++;
+	}
+
+	return n;
+}
+
+static int ch7006_encoder_create_resources(struct drm_encoder *encoder,
+					   struct drm_connector *connector)
+{
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	struct drm_device *dev = encoder->dev;
+	struct drm_mode_config *conf = &dev->mode_config;
+
+	drm_mode_create_tv_properties_legacy(dev, NUM_TV_NORMS, ch7006_tv_norm_names);
+
+	priv->scale_property = drm_property_create_range(dev, 0, "scale", 0, 2);
+	if (!priv->scale_property)
+		return -ENOMEM;
+
+	drm_object_attach_property(&connector->base, conf->tv_select_subconnector_property,
+				      priv->select_subconnector);
+	drm_object_attach_property(&connector->base, conf->tv_subconnector_property,
+				      priv->subconnector);
+	drm_object_attach_property(&connector->base, conf->tv_left_margin_property,
+				      priv->hmargin);
+	drm_object_attach_property(&connector->base, conf->tv_bottom_margin_property,
+				      priv->vmargin);
+	drm_object_attach_property(&connector->base, conf->legacy_tv_mode_property,
+				   priv->norm);
+	drm_object_attach_property(&connector->base, conf->tv_brightness_property,
+				      priv->brightness);
+	drm_object_attach_property(&connector->base, conf->tv_contrast_property,
+				      priv->contrast);
+	drm_object_attach_property(&connector->base, conf->tv_flicker_reduction_property,
+				      priv->flicker);
+	drm_object_attach_property(&connector->base, priv->scale_property,
+				      priv->scale);
+
+	return 0;
+}
+
+static int ch7006_encoder_set_property(struct drm_encoder *encoder,
+				       struct drm_connector *connector,
+				       struct drm_property *property,
+				       uint64_t val)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	struct ch7006_state *state = &priv->state;
+	struct drm_mode_config *conf = &encoder->dev->mode_config;
+	struct drm_crtc *crtc = encoder->crtc;
+	bool modes_changed = false;
+
+	ch7006_dbg(client, "\n");
+
+	if (property == conf->tv_select_subconnector_property) {
+		priv->select_subconnector = val;
+
+		ch7006_setup_power_state(encoder);
+
+		ch7006_load_reg(client, state, CH7006_POWER);
+
+	} else if (property == conf->tv_left_margin_property) {
+		priv->hmargin = val;
+
+		ch7006_setup_properties(encoder);
+
+		ch7006_load_reg(client, state, CH7006_POV);
+		ch7006_load_reg(client, state, CH7006_HPOS);
+
+	} else if (property == conf->tv_bottom_margin_property) {
+		priv->vmargin = val;
+
+		ch7006_setup_properties(encoder);
+
+		ch7006_load_reg(client, state, CH7006_POV);
+		ch7006_load_reg(client, state, CH7006_VPOS);
+
+	} else if (property == conf->legacy_tv_mode_property) {
+		if (connector->dpms != DRM_MODE_DPMS_OFF)
+			return -EINVAL;
+
+		priv->norm = val;
+
+		modes_changed = true;
+
+	} else if (property == conf->tv_brightness_property) {
+		priv->brightness = val;
+
+		ch7006_setup_levels(encoder);
+
+		ch7006_load_reg(client, state, CH7006_BLACK_LEVEL);
+
+	} else if (property == conf->tv_contrast_property) {
+		priv->contrast = val;
+
+		ch7006_setup_properties(encoder);
+
+		ch7006_load_reg(client, state, CH7006_CONTRAST);
+
+	} else if (property == conf->tv_flicker_reduction_property) {
+		priv->flicker = val;
+
+		ch7006_setup_properties(encoder);
+
+		ch7006_load_reg(client, state, CH7006_FFILTER);
+
+	} else if (property == priv->scale_property) {
+		if (connector->dpms != DRM_MODE_DPMS_OFF)
+			return -EINVAL;
+
+		priv->scale = val;
+
+		modes_changed = true;
+
+	} else {
+		return -EINVAL;
+	}
+
+	if (modes_changed) {
+		drm_helper_probe_single_connector_modes(connector, 0, 0);
+
+		if (crtc)
+			drm_crtc_helper_set_mode(crtc, &crtc->mode,
+						 crtc->x, crtc->y,
+						 crtc->primary->fb);
+	}
+
+	return 0;
+}
+
+static const struct drm_encoder_slave_funcs ch7006_encoder_funcs = {
+	.set_config = ch7006_encoder_set_config,
+	.destroy = ch7006_encoder_destroy,
+	.dpms = ch7006_encoder_dpms,
+	.save = ch7006_encoder_save,
+	.restore = ch7006_encoder_restore,
+	.mode_fixup = ch7006_encoder_mode_fixup,
+	.mode_valid = ch7006_encoder_mode_valid,
+	.mode_set = ch7006_encoder_mode_set,
+	.detect = ch7006_encoder_detect,
+	.get_modes = ch7006_encoder_get_modes,
+	.create_resources = ch7006_encoder_create_resources,
+	.set_property = ch7006_encoder_set_property,
+};
+
+
+/* I2C driver functions */
+
+static int ch7006_probe(struct i2c_client *client)
+{
+	uint8_t addr = CH7006_VERSION_ID;
+	uint8_t val;
+	int ret;
+
+	ch7006_dbg(client, "\n");
+
+	ret = i2c_master_send(client, &addr, sizeof(addr));
+	if (ret < 0)
+		goto fail;
+
+	ret = i2c_master_recv(client, &val, sizeof(val));
+	if (ret < 0)
+		goto fail;
+
+	ch7006_info(client, "Detected version ID: %x\n", val);
+
+	/* I don't know what this is for, but otherwise I get no
+	 * signal.
+	 */
+	ch7006_write(client, 0x3d, 0x0);
+
+	return 0;
+
+fail:
+	ch7006_err(client, "Error %d reading version ID\n", ret);
+
+	return -ENODEV;
+}
+
+static void ch7006_remove(struct i2c_client *client)
+{
+	ch7006_dbg(client, "\n");
+}
+
+static int ch7006_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	ch7006_dbg(client, "\n");
+
+	ch7006_write(client, 0x3d, 0x0);
+
+	return 0;
+}
+
+static int ch7006_encoder_init(struct i2c_client *client,
+			       struct drm_device *dev,
+			       struct drm_encoder_slave *encoder)
+{
+	struct ch7006_priv *priv;
+	int i;
+
+	ch7006_dbg(client, "\n");
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	encoder->slave_priv = priv;
+	encoder->slave_funcs = &ch7006_encoder_funcs;
+
+	priv->norm = TV_NORM_PAL;
+	priv->select_subconnector = DRM_MODE_SUBCONNECTOR_Automatic;
+	priv->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;
+	priv->scale = 1;
+	priv->contrast = 50;
+	priv->brightness = 50;
+	priv->flicker = 50;
+	priv->hmargin = 50;
+	priv->vmargin = 50;
+	priv->last_dpms = -1;
+	priv->chip_version = ch7006_read(client, CH7006_VERSION_ID);
+
+	if (ch7006_tv_norm) {
+		for (i = 0; i < NUM_TV_NORMS; i++) {
+			if (!strcmp(ch7006_tv_norm_names[i], ch7006_tv_norm)) {
+				priv->norm = i;
+				break;
+			}
+		}
+
+		if (i == NUM_TV_NORMS)
+			ch7006_err(client, "Invalid TV norm setting \"%s\".\n",
+				   ch7006_tv_norm);
+	}
+
+	if (ch7006_scale >= 0 && ch7006_scale <= 2)
+		priv->scale = ch7006_scale;
+	else
+		ch7006_err(client, "Invalid scale setting \"%d\".\n",
+			   ch7006_scale);
+
+	return 0;
+}
+
+static const struct i2c_device_id ch7006_ids[] = {
+	{ "ch7006" },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ch7006_ids);
+
+static const struct dev_pm_ops ch7006_pm_ops = {
+	.resume = ch7006_resume,
+};
+
+static struct drm_i2c_encoder_driver ch7006_driver = {
+	.i2c_driver = {
+		.probe = ch7006_probe,
+		.remove = ch7006_remove,
+
+		.driver = {
+			.name = "ch7006",
+			.pm = &ch7006_pm_ops,
+		},
+
+		.id_table = ch7006_ids,
+	},
+
+	.encoder_init = ch7006_encoder_init,
+};
+
+
+/* Module initialization */
+
+static int __init ch7006_init(void)
+{
+	return drm_i2c_encoder_register(THIS_MODULE, &ch7006_driver);
+}
+
+static void __exit ch7006_exit(void)
+{
+	drm_i2c_encoder_unregister(&ch7006_driver);
+}
+
+int ch7006_debug;
+module_param_named(debug, ch7006_debug, int, 0600);
+MODULE_PARM_DESC(debug, "Enable debug output.");
+
+char *ch7006_tv_norm;
+module_param_named(tv_norm, ch7006_tv_norm, charp, 0600);
+MODULE_PARM_DESC(tv_norm, "Default TV norm.\n"
+		 "\t\tSupported: PAL, PAL-M, PAL-N, PAL-Nc, PAL-60, NTSC-M, NTSC-J.\n"
+		 "\t\tDefault: PAL");
+
+int ch7006_scale = 1;
+module_param_named(scale, ch7006_scale, int, 0600);
+MODULE_PARM_DESC(scale, "Default scale.\n"
+		 "\t\tSupported: 0 -> Select video modes with a higher blanking ratio.\n"
+		 "\t\t\t1 -> Select default video modes.\n"
+		 "\t\t\t2 -> Select video modes with a lower blanking ratio.");
+
+MODULE_AUTHOR("Francisco Jerez <currojerez@riseup.net>");
+MODULE_DESCRIPTION("Chrontel ch7006 TV encoder driver");
+MODULE_LICENSE("GPL and additional rights");
+
+module_init(ch7006_init);
+module_exit(ch7006_exit);
diff --git a/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_mode.c b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_mode.c
new file mode 100644
index 000000000000..6afe6d0ee630
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_mode.c
@@ -0,0 +1,470 @@
+/*
+ * Copyright (C) 2009 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "ch7006_priv.h"
+
+const char * const ch7006_tv_norm_names[] = {
+	[TV_NORM_PAL] = "PAL",
+	[TV_NORM_PAL_M] = "PAL-M",
+	[TV_NORM_PAL_N] = "PAL-N",
+	[TV_NORM_PAL_NC] = "PAL-Nc",
+	[TV_NORM_PAL_60] = "PAL-60",
+	[TV_NORM_NTSC_M] = "NTSC-M",
+	[TV_NORM_NTSC_J] = "NTSC-J",
+};
+
+#define NTSC_LIKE_TIMINGS .vrefresh = 60 * fixed1/1.001,		\
+		.vdisplay = 480,					\
+		.vtotal = 525,						\
+		.hvirtual = 660
+
+#define PAL_LIKE_TIMINGS .vrefresh = 50 * fixed1,		\
+		.vdisplay = 576,				\
+		.vtotal = 625,					\
+		.hvirtual = 810
+
+const struct ch7006_tv_norm_info ch7006_tv_norms[] = {
+	[TV_NORM_NTSC_M] = {
+		NTSC_LIKE_TIMINGS,
+		.black_level = 0.339 * fixed1,
+		.subc_freq = 3579545 * fixed1,
+		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, NTSC),
+		.voffset = 0,
+	},
+	[TV_NORM_NTSC_J] = {
+		NTSC_LIKE_TIMINGS,
+		.black_level = 0.286 * fixed1,
+		.subc_freq = 3579545 * fixed1,
+		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, NTSC_J),
+		.voffset = 0,
+	},
+	[TV_NORM_PAL] = {
+		PAL_LIKE_TIMINGS,
+		.black_level = 0.3 * fixed1,
+		.subc_freq = 4433618.75 * fixed1,
+		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL),
+		.voffset = 0,
+	},
+	[TV_NORM_PAL_M] = {
+		NTSC_LIKE_TIMINGS,
+		.black_level = 0.339 * fixed1,
+		.subc_freq = 3575611.433 * fixed1,
+		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL_M),
+		.voffset = 16,
+	},
+
+	/* The following modes seem to work right but they're
+	 * undocumented */
+
+	[TV_NORM_PAL_N] = {
+		PAL_LIKE_TIMINGS,
+		.black_level = 0.339 * fixed1,
+		.subc_freq = 4433618.75 * fixed1,
+		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL),
+		.voffset = 0,
+	},
+	[TV_NORM_PAL_NC] = {
+		PAL_LIKE_TIMINGS,
+		.black_level = 0.3 * fixed1,
+		.subc_freq = 3582056.25 * fixed1,
+		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL),
+		.voffset = 0,
+	},
+	[TV_NORM_PAL_60] = {
+		NTSC_LIKE_TIMINGS,
+		.black_level = 0.3 * fixed1,
+		.subc_freq = 4433618.75 * fixed1,
+		.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL_M),
+		.voffset = 16,
+	},
+};
+
+#define __MODE(f, hd, vd, ht, vt, hsynp, vsynp,				\
+	       subc, scale, scale_mask, norm_mask, e_hd, e_vd) {	\
+		.mode = {						\
+			.name = #hd "x" #vd,				\
+			.status = 0,					\
+			.type = DRM_MODE_TYPE_DRIVER,			\
+			.clock = f,					\
+			.hdisplay = hd,					\
+			.hsync_start = e_hd + 16,			\
+			.hsync_end = e_hd + 80,				\
+			.htotal = ht,					\
+			.hskew = 0,					\
+			.vdisplay = vd,					\
+			.vsync_start = vd + 10,				\
+			.vsync_end = vd + 26,				\
+			.vtotal = vt,					\
+			.vscan = 0,					\
+			.flags = DRM_MODE_FLAG_##hsynp##HSYNC |		\
+				DRM_MODE_FLAG_##vsynp##VSYNC,		\
+		},							\
+		.enc_hdisp = e_hd,					\
+		.enc_vdisp = e_vd,					\
+		.subc_coeff = subc * fixed1,				\
+		.dispmode = bitfs(CH7006_DISPMODE_SCALING_RATIO, scale) | \
+			    bitfs(CH7006_DISPMODE_INPUT_RES, e_hd##x##e_vd), \
+		.valid_scales = scale_mask,				\
+		.valid_norms = norm_mask				\
+	 }
+
+#define MODE(f, hd, vd, ht, vt, hsynp, vsynp,				\
+	     subc, scale, scale_mask, norm_mask)			\
+	__MODE(f, hd, vd, ht, vt, hsynp, vsynp, subc, scale,		\
+	       scale_mask, norm_mask, hd, vd)
+
+#define NTSC_LIKE (1 << TV_NORM_NTSC_M | 1 << TV_NORM_NTSC_J |		\
+		   1 << TV_NORM_PAL_M | 1 << TV_NORM_PAL_60)
+
+#define PAL_LIKE (1 << TV_NORM_PAL | 1 << TV_NORM_PAL_N | 1 << TV_NORM_PAL_NC)
+
+const struct ch7006_mode ch7006_modes[] = {
+	MODE(21000, 512, 384, 840, 500, N, N, 181.797557582, 5_4, 0x6, PAL_LIKE),
+	MODE(26250, 512, 384, 840, 625, N, N, 145.438046066, 1_1, 0x1, PAL_LIKE),
+	MODE(20140, 512, 384, 800, 420, N, N, 213.257083791, 5_4, 0x4, NTSC_LIKE),
+	MODE(24671, 512, 384, 784, 525, N, N, 174.0874153, 1_1, 0x3, NTSC_LIKE),
+	MODE(28125, 720, 400, 1125, 500, N, N, 135.742176298, 5_4, 0x6, PAL_LIKE),
+	MODE(34875, 720, 400, 1116, 625, N, N, 109.469496898, 1_1, 0x1, PAL_LIKE),
+	MODE(23790, 720, 400, 945, 420, N, N, 160.475642016, 5_4, 0x4, NTSC_LIKE),
+	MODE(29455, 720, 400, 936, 525, N, N, 129.614941843, 1_1, 0x3, NTSC_LIKE),
+	MODE(25000, 640, 400, 1000, 500, N, N, 152.709948279, 5_4, 0x6, PAL_LIKE),
+	MODE(31500, 640, 400, 1008, 625, N, N, 121.198371646, 1_1, 0x1, PAL_LIKE),
+	MODE(21147, 640, 400, 840, 420, N, N, 180.535097338, 5_4, 0x4, NTSC_LIKE),
+	MODE(26434, 640, 400, 840, 525, N, N, 144.42807787, 1_1, 0x2, NTSC_LIKE),
+	MODE(30210, 640, 400, 840, 600, N, N, 126.374568276, 7_8, 0x1, NTSC_LIKE),
+	MODE(21000, 640, 480, 840, 500, N, N, 181.797557582, 5_4, 0x4, PAL_LIKE),
+	MODE(26250, 640, 480, 840, 625, N, N, 145.438046066, 1_1, 0x2, PAL_LIKE),
+	MODE(31500, 640, 480, 840, 750, N, N, 121.198371646, 5_6, 0x1, PAL_LIKE),
+	MODE(24671, 640, 480, 784, 525, N, N, 174.0874153, 1_1, 0x4, NTSC_LIKE),
+	MODE(28196, 640, 480, 784, 600, N, N, 152.326488422, 7_8, 0x2, NTSC_LIKE),
+	MODE(30210, 640, 480, 800, 630, N, N, 142.171389101, 5_6, 0x1, NTSC_LIKE),
+	__MODE(29500, 720, 576, 944, 625, P, P, 145.592111636, 1_1, 0x7, PAL_LIKE, 800, 600),
+	MODE(36000, 800, 600, 960, 750, P, P, 119.304647022, 5_6, 0x6, PAL_LIKE),
+	MODE(39000, 800, 600, 936, 836, P, P, 110.127366499, 3_4, 0x1, PAL_LIKE),
+	MODE(39273, 800, 600, 1040, 630, P, P, 145.816809399, 5_6, 0x4, NTSC_LIKE),
+	MODE(43636, 800, 600, 1040, 700, P, P, 131.235128487, 3_4, 0x2, NTSC_LIKE),
+	MODE(47832, 800, 600, 1064, 750, P, P, 119.723275165, 7_10, 0x1, NTSC_LIKE),
+	{}
+};
+
+const struct ch7006_mode *ch7006_lookup_mode(struct drm_encoder *encoder,
+					     const struct drm_display_mode *drm_mode)
+{
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	const struct ch7006_mode *mode;
+
+	for (mode = ch7006_modes; mode->mode.clock; mode++) {
+
+		if (~mode->valid_norms & 1<<priv->norm)
+			continue;
+
+		if (mode->mode.hdisplay != drm_mode->hdisplay ||
+		    mode->mode.vdisplay != drm_mode->vdisplay ||
+		    mode->mode.vtotal != drm_mode->vtotal ||
+		    mode->mode.htotal != drm_mode->htotal ||
+		    mode->mode.clock != drm_mode->clock)
+			continue;
+
+		return mode;
+	}
+
+	return NULL;
+}
+
+/* Some common HW state calculation code */
+
+void ch7006_setup_levels(struct drm_encoder *encoder)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	uint8_t *regs = priv->state.regs;
+	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
+	int gain;
+	int black_level;
+
+	/* Set DAC_GAIN if the voltage drop between white and black is
+	 * high enough. */
+	if (norm->black_level < 339*fixed1/1000) {
+		gain = 76;
+
+		regs[CH7006_INPUT_FORMAT] |= CH7006_INPUT_FORMAT_DAC_GAIN;
+	} else {
+		gain = 71;
+
+		regs[CH7006_INPUT_FORMAT] &= ~CH7006_INPUT_FORMAT_DAC_GAIN;
+	}
+
+	black_level = round_fixed(norm->black_level*26625)/gain;
+
+	/* Correct it with the specified brightness. */
+	black_level = interpolate(90, black_level, 208, priv->brightness);
+
+	regs[CH7006_BLACK_LEVEL] = bitf(CH7006_BLACK_LEVEL_0, black_level);
+
+	ch7006_dbg(client, "black level: %d\n", black_level);
+}
+
+void ch7006_setup_subcarrier(struct drm_encoder *encoder)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	struct ch7006_state *state = &priv->state;
+	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
+	const struct ch7006_mode *mode = priv->mode;
+	uint32_t subc_inc;
+
+	subc_inc = round_fixed((mode->subc_coeff >> 8)
+			       * (norm->subc_freq >> 24));
+
+	setbitf(state, CH7006_SUBC_INC0, 28, subc_inc);
+	setbitf(state, CH7006_SUBC_INC1, 24, subc_inc);
+	setbitf(state, CH7006_SUBC_INC2, 20, subc_inc);
+	setbitf(state, CH7006_SUBC_INC3, 16, subc_inc);
+	setbitf(state, CH7006_SUBC_INC4, 12, subc_inc);
+	setbitf(state, CH7006_SUBC_INC5, 8, subc_inc);
+	setbitf(state, CH7006_SUBC_INC6, 4, subc_inc);
+	setbitf(state, CH7006_SUBC_INC7, 0, subc_inc);
+
+	ch7006_dbg(client, "subcarrier inc: %u\n", subc_inc);
+}
+
+void ch7006_setup_pll(struct drm_encoder *encoder)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	uint8_t *regs = priv->state.regs;
+	const struct ch7006_mode *mode = priv->mode;
+	int n, best_n = 0;
+	int m, best_m = 0;
+	int freq, best_freq = 0;
+
+	for (n = 0; n < CH7006_MAXN; n++) {
+		for (m = 0; m < CH7006_MAXM; m++) {
+			freq = CH7006_FREQ0*(n+2)/(m+2);
+
+			if (abs(freq - mode->mode.clock) <
+			    abs(best_freq - mode->mode.clock)) {
+				best_freq = freq;
+				best_n = n;
+				best_m = m;
+			}
+		}
+	}
+
+	regs[CH7006_PLLOV] = bitf(CH7006_PLLOV_N_8, best_n) |
+		bitf(CH7006_PLLOV_M_8, best_m);
+
+	regs[CH7006_PLLM] = bitf(CH7006_PLLM_0, best_m);
+	regs[CH7006_PLLN] = bitf(CH7006_PLLN_0, best_n);
+
+	if (best_n < 108)
+		regs[CH7006_PLL_CONTROL] |= CH7006_PLL_CONTROL_CAPACITOR;
+	else
+		regs[CH7006_PLL_CONTROL] &= ~CH7006_PLL_CONTROL_CAPACITOR;
+
+	ch7006_dbg(client, "n=%d m=%d f=%d c=%d\n",
+		   best_n, best_m, best_freq, best_n < 108);
+}
+
+void ch7006_setup_power_state(struct drm_encoder *encoder)
+{
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	uint8_t *power = &priv->state.regs[CH7006_POWER];
+	int subconnector;
+
+	subconnector = priv->select_subconnector ? priv->select_subconnector :
+							priv->subconnector;
+
+	*power = CH7006_POWER_RESET;
+
+	if (priv->last_dpms == DRM_MODE_DPMS_ON) {
+		switch (subconnector) {
+		case DRM_MODE_SUBCONNECTOR_SVIDEO:
+			*power |= bitfs(CH7006_POWER_LEVEL, CVBS_OFF);
+			break;
+		case DRM_MODE_SUBCONNECTOR_Composite:
+			*power |= bitfs(CH7006_POWER_LEVEL, SVIDEO_OFF);
+			break;
+		case DRM_MODE_SUBCONNECTOR_SCART:
+			*power |= bitfs(CH7006_POWER_LEVEL, NORMAL) |
+				CH7006_POWER_SCART;
+			break;
+		}
+
+	} else {
+		if (priv->chip_version >= 0x20)
+			*power |= bitfs(CH7006_POWER_LEVEL, FULL_POWER_OFF);
+		else
+			*power |= bitfs(CH7006_POWER_LEVEL, POWER_OFF);
+	}
+}
+
+void ch7006_setup_properties(struct drm_encoder *encoder)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+	struct ch7006_priv *priv = to_ch7006_priv(encoder);
+	struct ch7006_state *state = &priv->state;
+	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
+	const struct ch7006_mode *ch_mode = priv->mode;
+	const struct drm_display_mode *mode = &ch_mode->mode;
+	uint8_t *regs = state->regs;
+	int flicker, contrast, hpos, vpos;
+	uint64_t scale, aspect;
+
+	flicker = interpolate(0, 2, 3, priv->flicker);
+	regs[CH7006_FFILTER] = bitf(CH7006_FFILTER_TEXT, flicker) |
+		bitf(CH7006_FFILTER_LUMA, flicker) |
+		bitf(CH7006_FFILTER_CHROMA, 1);
+
+	contrast = interpolate(0, 5, 7, priv->contrast);
+	regs[CH7006_CONTRAST] = bitf(CH7006_CONTRAST_0, contrast);
+
+	scale = norm->vtotal*fixed1;
+	do_div(scale, mode->vtotal);
+
+	aspect = ch_mode->enc_hdisp*fixed1;
+	do_div(aspect, ch_mode->enc_vdisp);
+
+	hpos = round_fixed((norm->hvirtual * aspect - mode->hdisplay * scale)
+			   * priv->hmargin * mode->vtotal) / norm->vtotal / 100 / 4;
+
+	setbitf(state, CH7006_POV, HPOS_8, hpos);
+	setbitf(state, CH7006_HPOS, 0, hpos);
+
+	vpos = max(0, norm->vdisplay - round_fixed(mode->vdisplay*scale)
+		   + norm->voffset) * priv->vmargin / 100 / 2;
+
+	setbitf(state, CH7006_POV, VPOS_8, vpos);
+	setbitf(state, CH7006_VPOS, 0, vpos);
+
+	ch7006_dbg(client, "hpos: %d, vpos: %d\n", hpos, vpos);
+}
+
+/* HW access functions */
+
+void ch7006_write(struct i2c_client *client, uint8_t addr, uint8_t val)
+{
+	uint8_t buf[] = {addr, val};
+	int ret;
+
+	ret = i2c_master_send(client, buf, ARRAY_SIZE(buf));
+	if (ret < 0)
+		ch7006_err(client, "Error %d writing to subaddress 0x%x\n",
+			   ret, addr);
+}
+
+uint8_t ch7006_read(struct i2c_client *client, uint8_t addr)
+{
+	uint8_t val;
+	int ret;
+
+	ret = i2c_master_send(client, &addr, sizeof(addr));
+	if (ret < 0)
+		goto fail;
+
+	ret = i2c_master_recv(client, &val, sizeof(val));
+	if (ret < 0)
+		goto fail;
+
+	return val;
+
+fail:
+	ch7006_err(client, "Error %d reading from subaddress 0x%x\n",
+		   ret, addr);
+	return 0;
+}
+
+void ch7006_state_load(struct i2c_client *client,
+		       struct ch7006_state *state)
+{
+	ch7006_load_reg(client, state, CH7006_POWER);
+
+	ch7006_load_reg(client, state, CH7006_DISPMODE);
+	ch7006_load_reg(client, state, CH7006_FFILTER);
+	ch7006_load_reg(client, state, CH7006_BWIDTH);
+	ch7006_load_reg(client, state, CH7006_INPUT_FORMAT);
+	ch7006_load_reg(client, state, CH7006_CLKMODE);
+	ch7006_load_reg(client, state, CH7006_START_ACTIVE);
+	ch7006_load_reg(client, state, CH7006_POV);
+	ch7006_load_reg(client, state, CH7006_BLACK_LEVEL);
+	ch7006_load_reg(client, state, CH7006_HPOS);
+	ch7006_load_reg(client, state, CH7006_VPOS);
+	ch7006_load_reg(client, state, CH7006_INPUT_SYNC);
+	ch7006_load_reg(client, state, CH7006_DETECT);
+	ch7006_load_reg(client, state, CH7006_CONTRAST);
+	ch7006_load_reg(client, state, CH7006_PLLOV);
+	ch7006_load_reg(client, state, CH7006_PLLM);
+	ch7006_load_reg(client, state, CH7006_PLLN);
+	ch7006_load_reg(client, state, CH7006_BCLKOUT);
+	ch7006_load_reg(client, state, CH7006_SUBC_INC0);
+	ch7006_load_reg(client, state, CH7006_SUBC_INC1);
+	ch7006_load_reg(client, state, CH7006_SUBC_INC2);
+	ch7006_load_reg(client, state, CH7006_SUBC_INC3);
+	ch7006_load_reg(client, state, CH7006_SUBC_INC4);
+	ch7006_load_reg(client, state, CH7006_SUBC_INC5);
+	ch7006_load_reg(client, state, CH7006_SUBC_INC6);
+	ch7006_load_reg(client, state, CH7006_SUBC_INC7);
+	ch7006_load_reg(client, state, CH7006_PLL_CONTROL);
+	ch7006_load_reg(client, state, CH7006_CALC_SUBC_INC0);
+}
+
+void ch7006_state_save(struct i2c_client *client,
+		       struct ch7006_state *state)
+{
+	ch7006_save_reg(client, state, CH7006_POWER);
+
+	ch7006_save_reg(client, state, CH7006_DISPMODE);
+	ch7006_save_reg(client, state, CH7006_FFILTER);
+	ch7006_save_reg(client, state, CH7006_BWIDTH);
+	ch7006_save_reg(client, state, CH7006_INPUT_FORMAT);
+	ch7006_save_reg(client, state, CH7006_CLKMODE);
+	ch7006_save_reg(client, state, CH7006_START_ACTIVE);
+	ch7006_save_reg(client, state, CH7006_POV);
+	ch7006_save_reg(client, state, CH7006_BLACK_LEVEL);
+	ch7006_save_reg(client, state, CH7006_HPOS);
+	ch7006_save_reg(client, state, CH7006_VPOS);
+	ch7006_save_reg(client, state, CH7006_INPUT_SYNC);
+	ch7006_save_reg(client, state, CH7006_DETECT);
+	ch7006_save_reg(client, state, CH7006_CONTRAST);
+	ch7006_save_reg(client, state, CH7006_PLLOV);
+	ch7006_save_reg(client, state, CH7006_PLLM);
+	ch7006_save_reg(client, state, CH7006_PLLN);
+	ch7006_save_reg(client, state, CH7006_BCLKOUT);
+	ch7006_save_reg(client, state, CH7006_SUBC_INC0);
+	ch7006_save_reg(client, state, CH7006_SUBC_INC1);
+	ch7006_save_reg(client, state, CH7006_SUBC_INC2);
+	ch7006_save_reg(client, state, CH7006_SUBC_INC3);
+	ch7006_save_reg(client, state, CH7006_SUBC_INC4);
+	ch7006_save_reg(client, state, CH7006_SUBC_INC5);
+	ch7006_save_reg(client, state, CH7006_SUBC_INC6);
+	ch7006_save_reg(client, state, CH7006_SUBC_INC7);
+	ch7006_save_reg(client, state, CH7006_PLL_CONTROL);
+	ch7006_save_reg(client, state, CH7006_CALC_SUBC_INC0);
+
+	state->regs[CH7006_FFILTER] = (state->regs[CH7006_FFILTER] & 0xf0) |
+		(state->regs[CH7006_FFILTER] & 0x0c) >> 2 |
+		(state->regs[CH7006_FFILTER] & 0x03) << 2;
+}
diff --git a/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_priv.h b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_priv.h
new file mode 100644
index 000000000000..d7a91e17510f
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_priv.h
@@ -0,0 +1,345 @@
+/*
+ * Copyright (C) 2009 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __NOUVEAU_I2C_CH7006_PRIV_H__
+#define __NOUVEAU_I2C_CH7006_PRIV_H__
+
+#include <drm/drm_encoder_slave.h>
+#include <drm/drm_probe_helper.h>
+
+#include <dispnv04/i2c/ch7006.h>
+
+typedef int64_t fixed;
+#define fixed1 (1LL << 32)
+
+enum ch7006_tv_norm {
+	TV_NORM_PAL,
+	TV_NORM_PAL_M,
+	TV_NORM_PAL_N,
+	TV_NORM_PAL_NC,
+	TV_NORM_PAL_60,
+	TV_NORM_NTSC_M,
+	TV_NORM_NTSC_J,
+	NUM_TV_NORMS
+};
+
+struct ch7006_tv_norm_info {
+	fixed vrefresh;
+	int vdisplay;
+	int vtotal;
+	int hvirtual;
+
+	fixed subc_freq;
+	fixed black_level;
+
+	uint32_t dispmode;
+	int voffset;
+};
+
+struct ch7006_mode {
+	struct drm_display_mode mode;
+
+	int enc_hdisp;
+	int enc_vdisp;
+
+	fixed subc_coeff;
+	uint32_t dispmode;
+
+	uint32_t valid_scales;
+	uint32_t valid_norms;
+};
+
+struct ch7006_state {
+	uint8_t regs[0x26];
+};
+
+struct ch7006_priv {
+	struct ch7006_encoder_params params;
+	const struct ch7006_mode *mode;
+
+	struct ch7006_state state;
+	struct ch7006_state saved_state;
+
+	struct drm_property *scale_property;
+
+	int select_subconnector;
+	int subconnector;
+	int hmargin;
+	int vmargin;
+	enum ch7006_tv_norm norm;
+	int brightness;
+	int contrast;
+	int flicker;
+	int scale;
+
+	int chip_version;
+	int last_dpms;
+};
+
+#define to_ch7006_priv(x) \
+	((struct ch7006_priv *)to_encoder_slave(x)->slave_priv)
+
+extern int ch7006_debug;
+extern char *ch7006_tv_norm;
+extern int ch7006_scale;
+
+extern const char * const ch7006_tv_norm_names[];
+extern const struct ch7006_tv_norm_info ch7006_tv_norms[];
+extern const struct ch7006_mode ch7006_modes[];
+
+const struct ch7006_mode *ch7006_lookup_mode(struct drm_encoder *encoder,
+					     const struct drm_display_mode *drm_mode);
+
+void ch7006_setup_levels(struct drm_encoder *encoder);
+void ch7006_setup_subcarrier(struct drm_encoder *encoder);
+void ch7006_setup_pll(struct drm_encoder *encoder);
+void ch7006_setup_power_state(struct drm_encoder *encoder);
+void ch7006_setup_properties(struct drm_encoder *encoder);
+
+void ch7006_write(struct i2c_client *client, uint8_t addr, uint8_t val);
+uint8_t ch7006_read(struct i2c_client *client, uint8_t addr);
+
+void ch7006_state_load(struct i2c_client *client,
+		       struct ch7006_state *state);
+void ch7006_state_save(struct i2c_client *client,
+		       struct ch7006_state *state);
+
+/* Some helper macros */
+
+#define ch7006_dbg(client, format, ...) do {				\
+		if (ch7006_debug)					\
+			dev_printk(KERN_DEBUG, &client->dev,		\
+				   "%s: " format, __func__, ## __VA_ARGS__); \
+	} while (0)
+#define ch7006_info(client, format, ...) \
+				dev_info(&client->dev, format, __VA_ARGS__)
+#define ch7006_err(client, format, ...) \
+				dev_err(&client->dev, format, __VA_ARGS__)
+
+#define __mask(src, bitfield) \
+		(((2 << (1 ? bitfield)) - 1) & ~((1 << (0 ? bitfield)) - 1))
+#define mask(bitfield) __mask(bitfield)
+
+#define __bitf(src, bitfield, x) \
+		(((x) >> (src) << (0 ? bitfield)) &  __mask(src, bitfield))
+#define bitf(bitfield, x) __bitf(bitfield, x)
+#define bitfs(bitfield, s) __bitf(bitfield, bitfield##_##s)
+#define setbitf(state, reg, bitfield, x)				\
+	state->regs[reg] = (state->regs[reg] & ~mask(reg##_##bitfield))	\
+		| bitf(reg##_##bitfield, x)
+
+#define __unbitf(src, bitfield, x) \
+		((x & __mask(src, bitfield)) >> (0 ? bitfield) << (src))
+#define unbitf(bitfield, x) __unbitf(bitfield, x)
+
+static inline int interpolate(int y0, int y1, int y2, int x)
+{
+	return y1 + (x < 50 ? y1 - y0 : y2 - y1) * (x - 50) / 50;
+}
+
+static inline int32_t round_fixed(fixed x)
+{
+	return (x + fixed1/2) >> 32;
+}
+
+#define ch7006_load_reg(client, state, reg) ch7006_write(client, reg, state->regs[reg])
+#define ch7006_save_reg(client, state, reg) state->regs[reg] = ch7006_read(client, reg)
+
+/* Fixed hardware specs */
+
+#define CH7006_FREQ0				14318
+#define CH7006_MAXN				650
+#define CH7006_MAXM				315
+
+/* Register definitions */
+
+#define CH7006_DISPMODE				0x00
+#define CH7006_DISPMODE_INPUT_RES		0, 7:5
+#define CH7006_DISPMODE_INPUT_RES_512x384	0x0
+#define CH7006_DISPMODE_INPUT_RES_720x400	0x1
+#define CH7006_DISPMODE_INPUT_RES_640x400	0x2
+#define CH7006_DISPMODE_INPUT_RES_640x480	0x3
+#define CH7006_DISPMODE_INPUT_RES_800x600	0x4
+#define CH7006_DISPMODE_INPUT_RES_NATIVE	0x5
+#define CH7006_DISPMODE_OUTPUT_STD		0, 4:3
+#define CH7006_DISPMODE_OUTPUT_STD_PAL		0x0
+#define CH7006_DISPMODE_OUTPUT_STD_NTSC		0x1
+#define CH7006_DISPMODE_OUTPUT_STD_PAL_M	0x2
+#define CH7006_DISPMODE_OUTPUT_STD_NTSC_J	0x3
+#define CH7006_DISPMODE_SCALING_RATIO		0, 2:0
+#define CH7006_DISPMODE_SCALING_RATIO_5_4	0x0
+#define CH7006_DISPMODE_SCALING_RATIO_1_1	0x1
+#define CH7006_DISPMODE_SCALING_RATIO_7_8	0x2
+#define CH7006_DISPMODE_SCALING_RATIO_5_6	0x3
+#define CH7006_DISPMODE_SCALING_RATIO_3_4	0x4
+#define CH7006_DISPMODE_SCALING_RATIO_7_10	0x5
+
+#define CH7006_FFILTER				0x01
+#define CH7006_FFILTER_TEXT			0, 5:4
+#define CH7006_FFILTER_LUMA			0, 3:2
+#define CH7006_FFILTER_CHROMA			0, 1:0
+#define CH7006_FFILTER_CHROMA_NO_DCRAWL		0x3
+
+#define CH7006_BWIDTH				0x03
+#define CH7006_BWIDTH_5L_FFILER			(1 << 7)
+#define CH7006_BWIDTH_CVBS_NO_CHROMA		(1 << 6)
+#define CH7006_BWIDTH_CHROMA			0, 5:4
+#define CH7006_BWIDTH_SVIDEO_YPEAK		(1 << 3)
+#define CH7006_BWIDTH_SVIDEO_LUMA		0, 2:1
+#define CH7006_BWIDTH_CVBS_LUMA			0, 0:0
+
+#define CH7006_INPUT_FORMAT			0x04
+#define CH7006_INPUT_FORMAT_DAC_GAIN		(1 << 6)
+#define CH7006_INPUT_FORMAT_RGB_PASS_THROUGH	(1 << 5)
+#define CH7006_INPUT_FORMAT_FORMAT		0, 3:0
+#define CH7006_INPUT_FORMAT_FORMAT_RGB16	0x0
+#define CH7006_INPUT_FORMAT_FORMAT_YCrCb24m16	0x1
+#define CH7006_INPUT_FORMAT_FORMAT_RGB24m16	0x2
+#define CH7006_INPUT_FORMAT_FORMAT_RGB15	0x3
+#define CH7006_INPUT_FORMAT_FORMAT_RGB24m12C	0x4
+#define CH7006_INPUT_FORMAT_FORMAT_RGB24m12I	0x5
+#define CH7006_INPUT_FORMAT_FORMAT_RGB24m8	0x6
+#define CH7006_INPUT_FORMAT_FORMAT_RGB16m8	0x7
+#define CH7006_INPUT_FORMAT_FORMAT_RGB15m8	0x8
+#define CH7006_INPUT_FORMAT_FORMAT_YCrCb24m8	0x9
+
+#define CH7006_CLKMODE				0x06
+#define CH7006_CLKMODE_SUBC_LOCK		(1 << 7)
+#define CH7006_CLKMODE_MASTER			(1 << 6)
+#define CH7006_CLKMODE_POS_EDGE			(1 << 4)
+#define CH7006_CLKMODE_XCM			0, 3:2
+#define CH7006_CLKMODE_PCM			0, 1:0
+
+#define CH7006_START_ACTIVE			0x07
+#define CH7006_START_ACTIVE_0			0, 7:0
+
+#define CH7006_POV				0x08
+#define CH7006_POV_START_ACTIVE_8		8, 2:2
+#define CH7006_POV_HPOS_8			8, 1:1
+#define CH7006_POV_VPOS_8			8, 0:0
+
+#define CH7006_BLACK_LEVEL			0x09
+#define CH7006_BLACK_LEVEL_0			0, 7:0
+
+#define CH7006_HPOS				0x0a
+#define CH7006_HPOS_0				0, 7:0
+
+#define CH7006_VPOS				0x0b
+#define CH7006_VPOS_0				0, 7:0
+
+#define CH7006_INPUT_SYNC			0x0d
+#define CH7006_INPUT_SYNC_EMBEDDED		(1 << 3)
+#define CH7006_INPUT_SYNC_OUTPUT		(1 << 2)
+#define CH7006_INPUT_SYNC_PVSYNC		(1 << 1)
+#define CH7006_INPUT_SYNC_PHSYNC		(1 << 0)
+
+#define CH7006_POWER				0x0e
+#define CH7006_POWER_SCART			(1 << 4)
+#define CH7006_POWER_RESET			(1 << 3)
+#define CH7006_POWER_LEVEL			0, 2:0
+#define CH7006_POWER_LEVEL_CVBS_OFF		0x0
+#define CH7006_POWER_LEVEL_POWER_OFF		0x1
+#define CH7006_POWER_LEVEL_SVIDEO_OFF		0x2
+#define CH7006_POWER_LEVEL_NORMAL		0x3
+#define CH7006_POWER_LEVEL_FULL_POWER_OFF	0x4
+
+#define CH7006_DETECT				0x10
+#define CH7006_DETECT_SVIDEO_Y_TEST		(1 << 3)
+#define CH7006_DETECT_SVIDEO_C_TEST		(1 << 2)
+#define CH7006_DETECT_CVBS_TEST			(1 << 1)
+#define CH7006_DETECT_SENSE			(1 << 0)
+
+#define CH7006_CONTRAST				0x11
+#define CH7006_CONTRAST_0			0, 2:0
+
+#define CH7006_PLLOV	 			0x13
+#define CH7006_PLLOV_N_8	 		8, 2:1
+#define CH7006_PLLOV_M_8	 		8, 0:0
+
+#define CH7006_PLLM	 			0x14
+#define CH7006_PLLM_0	 			0, 7:0
+
+#define CH7006_PLLN	 			0x15
+#define CH7006_PLLN_0	 			0, 7:0
+
+#define CH7006_BCLKOUT	 			0x17
+
+#define CH7006_SUBC_INC0			0x18
+#define CH7006_SUBC_INC0_28			28, 3:0
+
+#define CH7006_SUBC_INC1			0x19
+#define CH7006_SUBC_INC1_24			24, 3:0
+
+#define CH7006_SUBC_INC2			0x1a
+#define CH7006_SUBC_INC2_20			20, 3:0
+
+#define CH7006_SUBC_INC3			0x1b
+#define CH7006_SUBC_INC3_GPIO1_VAL		(1 << 7)
+#define CH7006_SUBC_INC3_GPIO0_VAL		(1 << 6)
+#define CH7006_SUBC_INC3_POUT_3_3V		(1 << 5)
+#define CH7006_SUBC_INC3_POUT_INV		(1 << 4)
+#define CH7006_SUBC_INC3_16			16, 3:0
+
+#define CH7006_SUBC_INC4			0x1c
+#define CH7006_SUBC_INC4_GPIO1_IN		(1 << 7)
+#define CH7006_SUBC_INC4_GPIO0_IN		(1 << 6)
+#define CH7006_SUBC_INC4_DS_INPUT		(1 << 4)
+#define CH7006_SUBC_INC4_12			12, 3:0
+
+#define CH7006_SUBC_INC5			0x1d
+#define CH7006_SUBC_INC5_8			8, 3:0
+
+#define CH7006_SUBC_INC6			0x1e
+#define CH7006_SUBC_INC6_4			4, 3:0
+
+#define CH7006_SUBC_INC7			0x1f
+#define CH7006_SUBC_INC7_0			0, 3:0
+
+#define CH7006_PLL_CONTROL			0x20
+#define CH7006_PLL_CONTROL_CPI			(1 << 5)
+#define CH7006_PLL_CONTROL_CAPACITOR		(1 << 4)
+#define CH7006_PLL_CONTROL_7STAGES		(1 << 3)
+#define CH7006_PLL_CONTROL_DIGITAL_5V		(1 << 2)
+#define CH7006_PLL_CONTROL_ANALOG_5V		(1 << 1)
+#define CH7006_PLL_CONTROL_MEMORY_5V		(1 << 0)
+
+#define CH7006_CALC_SUBC_INC0			0x21
+#define CH7006_CALC_SUBC_INC0_24		24, 4:3
+#define CH7006_CALC_SUBC_INC0_HYST		0, 2:1
+#define CH7006_CALC_SUBC_INC0_AUTO		(1 << 0)
+
+#define CH7006_CALC_SUBC_INC1			0x22
+#define CH7006_CALC_SUBC_INC1_16		16, 7:0
+
+#define CH7006_CALC_SUBC_INC2			0x23
+#define CH7006_CALC_SUBC_INC2_8			8, 7:0
+
+#define CH7006_CALC_SUBC_INC3			0x24
+#define CH7006_CALC_SUBC_INC3_0			0, 7:0
+
+#define CH7006_VERSION_ID			0x25
+
+#endif
diff --git a/drivers/gpu/drm/nouveau/dispnv04/i2c/sil164_drv.c b/drivers/gpu/drm/nouveau/dispnv04/i2c/sil164_drv.c
new file mode 100644
index 000000000000..39b01c897518
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv04/i2c/sil164_drv.c
@@ -0,0 +1,452 @@
+/*
+ * Copyright (C) 2010 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/module.h>
+
+#include <drm/drm_drv.h>
+#include <drm/drm_encoder_slave.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+
+#include <dispnv04/i2c/sil164.h>
+
+struct sil164_priv {
+	struct sil164_encoder_params config;
+	struct i2c_client *duallink_slave;
+
+	uint8_t saved_state[0x10];
+	uint8_t saved_slave_state[0x10];
+};
+
+#define to_sil164_priv(x) \
+	((struct sil164_priv *)to_encoder_slave(x)->slave_priv)
+
+#define sil164_dbg(client, format, ...) do {				\
+		if (drm_debug_enabled(DRM_UT_KMS))			\
+			dev_printk(KERN_DEBUG, &client->dev,		\
+				   "%s: " format, __func__, ## __VA_ARGS__); \
+	} while (0)
+#define sil164_info(client, format, ...)		\
+	dev_info(&client->dev, format, __VA_ARGS__)
+#define sil164_err(client, format, ...)			\
+	dev_err(&client->dev, format, __VA_ARGS__)
+
+#define SIL164_I2C_ADDR_MASTER			0x38
+#define SIL164_I2C_ADDR_SLAVE			0x39
+
+/* HW register definitions */
+
+#define SIL164_VENDOR_LO			0x0
+#define SIL164_VENDOR_HI			0x1
+#define SIL164_DEVICE_LO			0x2
+#define SIL164_DEVICE_HI			0x3
+#define SIL164_REVISION				0x4
+#define SIL164_FREQ_MIN				0x6
+#define SIL164_FREQ_MAX				0x7
+#define SIL164_CONTROL0				0x8
+#  define SIL164_CONTROL0_POWER_ON		0x01
+#  define SIL164_CONTROL0_EDGE_RISING		0x02
+#  define SIL164_CONTROL0_INPUT_24BIT		0x04
+#  define SIL164_CONTROL0_DUAL_EDGE		0x08
+#  define SIL164_CONTROL0_HSYNC_ON		0x10
+#  define SIL164_CONTROL0_VSYNC_ON		0x20
+#define SIL164_DETECT				0x9
+#  define SIL164_DETECT_INTR_STAT		0x01
+#  define SIL164_DETECT_HOTPLUG_STAT		0x02
+#  define SIL164_DETECT_RECEIVER_STAT		0x04
+#  define SIL164_DETECT_INTR_MODE_RECEIVER	0x00
+#  define SIL164_DETECT_INTR_MODE_HOTPLUG	0x08
+#  define SIL164_DETECT_OUT_MODE_HIGH		0x00
+#  define SIL164_DETECT_OUT_MODE_INTR		0x10
+#  define SIL164_DETECT_OUT_MODE_RECEIVER	0x20
+#  define SIL164_DETECT_OUT_MODE_HOTPLUG	0x30
+#  define SIL164_DETECT_VSWING_STAT		0x80
+#define SIL164_CONTROL1				0xa
+#  define SIL164_CONTROL1_DESKEW_ENABLE		0x10
+#  define SIL164_CONTROL1_DESKEW_INCR_SHIFT	5
+#define SIL164_GPIO				0xb
+#define SIL164_CONTROL2				0xc
+#  define SIL164_CONTROL2_FILTER_ENABLE		0x01
+#  define SIL164_CONTROL2_FILTER_SETTING_SHIFT	1
+#  define SIL164_CONTROL2_DUALLINK_MASTER	0x40
+#  define SIL164_CONTROL2_SYNC_CONT		0x80
+#define SIL164_DUALLINK				0xd
+#  define SIL164_DUALLINK_ENABLE		0x10
+#  define SIL164_DUALLINK_SKEW_SHIFT		5
+#define SIL164_PLLZONE				0xe
+#  define SIL164_PLLZONE_STAT			0x08
+#  define SIL164_PLLZONE_FORCE_ON		0x10
+#  define SIL164_PLLZONE_FORCE_HIGH		0x20
+
+/* HW access functions */
+
+static void
+sil164_write(struct i2c_client *client, uint8_t addr, uint8_t val)
+{
+	uint8_t buf[] = {addr, val};
+	int ret;
+
+	ret = i2c_master_send(client, buf, ARRAY_SIZE(buf));
+	if (ret < 0)
+		sil164_err(client, "Error %d writing to subaddress 0x%x\n",
+			   ret, addr);
+}
+
+static uint8_t
+sil164_read(struct i2c_client *client, uint8_t addr)
+{
+	uint8_t val;
+	int ret;
+
+	ret = i2c_master_send(client, &addr, sizeof(addr));
+	if (ret < 0)
+		goto fail;
+
+	ret = i2c_master_recv(client, &val, sizeof(val));
+	if (ret < 0)
+		goto fail;
+
+	return val;
+
+fail:
+	sil164_err(client, "Error %d reading from subaddress 0x%x\n",
+		   ret, addr);
+	return 0;
+}
+
+static void
+sil164_save_state(struct i2c_client *client, uint8_t *state)
+{
+	int i;
+
+	for (i = 0x8; i <= 0xe; i++)
+		state[i] = sil164_read(client, i);
+}
+
+static void
+sil164_restore_state(struct i2c_client *client, uint8_t *state)
+{
+	int i;
+
+	for (i = 0x8; i <= 0xe; i++)
+		sil164_write(client, i, state[i]);
+}
+
+static void
+sil164_set_power_state(struct i2c_client *client, bool on)
+{
+	uint8_t control0 = sil164_read(client, SIL164_CONTROL0);
+
+	if (on)
+		control0 |= SIL164_CONTROL0_POWER_ON;
+	else
+		control0 &= ~SIL164_CONTROL0_POWER_ON;
+
+	sil164_write(client, SIL164_CONTROL0, control0);
+}
+
+static void
+sil164_init_state(struct i2c_client *client,
+		  struct sil164_encoder_params *config,
+		  bool duallink)
+{
+	sil164_write(client, SIL164_CONTROL0,
+		     SIL164_CONTROL0_HSYNC_ON |
+		     SIL164_CONTROL0_VSYNC_ON |
+		     (config->input_edge ? SIL164_CONTROL0_EDGE_RISING : 0) |
+		     (config->input_width ? SIL164_CONTROL0_INPUT_24BIT : 0) |
+		     (config->input_dual ? SIL164_CONTROL0_DUAL_EDGE : 0));
+
+	sil164_write(client, SIL164_DETECT,
+		     SIL164_DETECT_INTR_STAT |
+		     SIL164_DETECT_OUT_MODE_RECEIVER);
+
+	sil164_write(client, SIL164_CONTROL1,
+		     (config->input_skew ? SIL164_CONTROL1_DESKEW_ENABLE : 0) |
+		     (((config->input_skew + 4) & 0x7)
+		      << SIL164_CONTROL1_DESKEW_INCR_SHIFT));
+
+	sil164_write(client, SIL164_CONTROL2,
+		     SIL164_CONTROL2_SYNC_CONT |
+		     (config->pll_filter ? 0 : SIL164_CONTROL2_FILTER_ENABLE) |
+		     (4 << SIL164_CONTROL2_FILTER_SETTING_SHIFT));
+
+	sil164_write(client, SIL164_PLLZONE, 0);
+
+	if (duallink)
+		sil164_write(client, SIL164_DUALLINK,
+			     SIL164_DUALLINK_ENABLE |
+			     (((config->duallink_skew + 4) & 0x7)
+			      << SIL164_DUALLINK_SKEW_SHIFT));
+	else
+		sil164_write(client, SIL164_DUALLINK, 0);
+}
+
+/* DRM encoder functions */
+
+static void
+sil164_encoder_set_config(struct drm_encoder *encoder, void *params)
+{
+	struct sil164_priv *priv = to_sil164_priv(encoder);
+
+	priv->config = *(struct sil164_encoder_params *)params;
+}
+
+static void
+sil164_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	struct sil164_priv *priv = to_sil164_priv(encoder);
+	bool on = (mode == DRM_MODE_DPMS_ON);
+	bool duallink = (on && encoder->crtc->mode.clock > 165000);
+
+	sil164_set_power_state(drm_i2c_encoder_get_client(encoder), on);
+
+	if (priv->duallink_slave)
+		sil164_set_power_state(priv->duallink_slave, duallink);
+}
+
+static void
+sil164_encoder_save(struct drm_encoder *encoder)
+{
+	struct sil164_priv *priv = to_sil164_priv(encoder);
+
+	sil164_save_state(drm_i2c_encoder_get_client(encoder),
+			  priv->saved_state);
+
+	if (priv->duallink_slave)
+		sil164_save_state(priv->duallink_slave,
+				  priv->saved_slave_state);
+}
+
+static void
+sil164_encoder_restore(struct drm_encoder *encoder)
+{
+	struct sil164_priv *priv = to_sil164_priv(encoder);
+
+	sil164_restore_state(drm_i2c_encoder_get_client(encoder),
+			     priv->saved_state);
+
+	if (priv->duallink_slave)
+		sil164_restore_state(priv->duallink_slave,
+				     priv->saved_slave_state);
+}
+
+static int
+sil164_encoder_mode_valid(struct drm_encoder *encoder,
+			  const struct drm_display_mode *mode)
+{
+	struct sil164_priv *priv = to_sil164_priv(encoder);
+
+	if (mode->clock < 32000)
+		return MODE_CLOCK_LOW;
+
+	if (mode->clock > 330000 ||
+	    (mode->clock > 165000 && !priv->duallink_slave))
+		return MODE_CLOCK_HIGH;
+
+	return MODE_OK;
+}
+
+static void
+sil164_encoder_mode_set(struct drm_encoder *encoder,
+			struct drm_display_mode *mode,
+			struct drm_display_mode *adjusted_mode)
+{
+	struct sil164_priv *priv = to_sil164_priv(encoder);
+	bool duallink = adjusted_mode->clock > 165000;
+
+	sil164_init_state(drm_i2c_encoder_get_client(encoder),
+			  &priv->config, duallink);
+
+	if (priv->duallink_slave)
+		sil164_init_state(priv->duallink_slave,
+				  &priv->config, duallink);
+
+	sil164_encoder_dpms(encoder, DRM_MODE_DPMS_ON);
+}
+
+static enum drm_connector_status
+sil164_encoder_detect(struct drm_encoder *encoder,
+		      struct drm_connector *connector)
+{
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
+
+	if (sil164_read(client, SIL164_DETECT) & SIL164_DETECT_HOTPLUG_STAT)
+		return connector_status_connected;
+	else
+		return connector_status_disconnected;
+}
+
+static int
+sil164_encoder_get_modes(struct drm_encoder *encoder,
+			 struct drm_connector *connector)
+{
+	return 0;
+}
+
+static int
+sil164_encoder_create_resources(struct drm_encoder *encoder,
+				struct drm_connector *connector)
+{
+	return 0;
+}
+
+static int
+sil164_encoder_set_property(struct drm_encoder *encoder,
+			    struct drm_connector *connector,
+			    struct drm_property *property,
+			    uint64_t val)
+{
+	return 0;
+}
+
+static void
+sil164_encoder_destroy(struct drm_encoder *encoder)
+{
+	struct sil164_priv *priv = to_sil164_priv(encoder);
+
+	i2c_unregister_device(priv->duallink_slave);
+
+	kfree(priv);
+	drm_i2c_encoder_destroy(encoder);
+}
+
+static const struct drm_encoder_slave_funcs sil164_encoder_funcs = {
+	.set_config = sil164_encoder_set_config,
+	.destroy = sil164_encoder_destroy,
+	.dpms = sil164_encoder_dpms,
+	.save = sil164_encoder_save,
+	.restore = sil164_encoder_restore,
+	.mode_valid = sil164_encoder_mode_valid,
+	.mode_set = sil164_encoder_mode_set,
+	.detect = sil164_encoder_detect,
+	.get_modes = sil164_encoder_get_modes,
+	.create_resources = sil164_encoder_create_resources,
+	.set_property = sil164_encoder_set_property,
+};
+
+/* I2C driver functions */
+
+static int
+sil164_probe(struct i2c_client *client)
+{
+	int vendor = sil164_read(client, SIL164_VENDOR_HI) << 8 |
+		sil164_read(client, SIL164_VENDOR_LO);
+	int device = sil164_read(client, SIL164_DEVICE_HI) << 8 |
+		sil164_read(client, SIL164_DEVICE_LO);
+	int rev = sil164_read(client, SIL164_REVISION);
+
+	if (vendor != 0x1 || device != 0x6) {
+		sil164_dbg(client, "Unknown device %x:%x.%x\n",
+			   vendor, device, rev);
+		return -ENODEV;
+	}
+
+	sil164_info(client, "Detected device %x:%x.%x\n",
+		    vendor, device, rev);
+
+	return 0;
+}
+
+static struct i2c_client *
+sil164_detect_slave(struct i2c_client *client)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msg = {
+		.addr = SIL164_I2C_ADDR_SLAVE,
+		.len = 0,
+	};
+	const struct i2c_board_info info = {
+		I2C_BOARD_INFO("sil164", SIL164_I2C_ADDR_SLAVE)
+	};
+
+	if (i2c_transfer(adap, &msg, 1) != 1) {
+		sil164_dbg(adap, "No dual-link slave found.");
+		return NULL;
+	}
+
+	return i2c_new_client_device(adap, &info);
+}
+
+static int
+sil164_encoder_init(struct i2c_client *client,
+		    struct drm_device *dev,
+		    struct drm_encoder_slave *encoder)
+{
+	struct sil164_priv *priv;
+	struct i2c_client *slave_client;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	encoder->slave_priv = priv;
+	encoder->slave_funcs = &sil164_encoder_funcs;
+
+	slave_client = sil164_detect_slave(client);
+	if (!IS_ERR(slave_client))
+		priv->duallink_slave = slave_client;
+
+	return 0;
+}
+
+static const struct i2c_device_id sil164_ids[] = {
+	{ "sil164" },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sil164_ids);
+
+static struct drm_i2c_encoder_driver sil164_driver = {
+	.i2c_driver = {
+		.probe = sil164_probe,
+		.driver = {
+			.name = "sil164",
+		},
+		.id_table = sil164_ids,
+	},
+	.encoder_init = sil164_encoder_init,
+};
+
+/* Module initialization */
+
+static int __init
+sil164_init(void)
+{
+	return drm_i2c_encoder_register(THIS_MODULE, &sil164_driver);
+}
+
+static void __exit
+sil164_exit(void)
+{
+	drm_i2c_encoder_unregister(&sil164_driver);
+}
+
+MODULE_AUTHOR("Francisco Jerez <currojerez@riseup.net>");
+MODULE_DESCRIPTION("Silicon Image sil164 TMDS transmitter driver");
+MODULE_LICENSE("GPL and additional rights");
+
+module_init(sil164_init);
+module_exit(sil164_exit);
diff --git a/drivers/gpu/drm/nouveau/dispnv04/tvnv04.c b/drivers/gpu/drm/nouveau/dispnv04/tvnv04.c
index d3014027a812..4ffd8af6bf8b 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/tvnv04.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/tvnv04.c
@@ -32,7 +32,7 @@
 #include "hw.h"
 #include <drm/drm_modeset_helper_vtables.h>
 
-#include <drm/i2c/ch7006.h>
+#include <dispnv04/i2c/ch7006.h>
 
 static struct nvkm_i2c_bus_probe nv04_tv_encoder_info[] = {
 	{
diff --git a/drivers/gpu/drm/nouveau/include/dispnv04/i2c/ch7006.h b/drivers/gpu/drm/nouveau/include/dispnv04/i2c/ch7006.h
new file mode 100644
index 000000000000..1a6fa405f85b
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/dispnv04/i2c/ch7006.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2009 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __NOUVEAU_I2C_CH7006_H__
+#define __NOUVEAU_I2C_CH7006_H__
+
+/**
+ * struct ch7006_encoder_params
+ *
+ * Describes how the ch7006 is wired up with the GPU. It should be
+ * used as the @params parameter of its @set_config method.
+ *
+ * See "http://www.chrontel.com/pdf/7006.pdf" for their precise
+ * meaning.
+ */
+struct ch7006_encoder_params {
+	/* private: FIXME: document the members */
+	enum {
+		CH7006_FORMAT_RGB16 = 0,
+		CH7006_FORMAT_YCrCb24m16,
+		CH7006_FORMAT_RGB24m16,
+		CH7006_FORMAT_RGB15,
+		CH7006_FORMAT_RGB24m12C,
+		CH7006_FORMAT_RGB24m12I,
+		CH7006_FORMAT_RGB24m8,
+		CH7006_FORMAT_RGB16m8,
+		CH7006_FORMAT_RGB15m8,
+		CH7006_FORMAT_YCrCb24m8,
+	} input_format;
+
+	enum {
+		CH7006_CLOCK_SLAVE = 0,
+		CH7006_CLOCK_MASTER,
+	} clock_mode;
+
+	enum {
+		CH7006_CLOCK_EDGE_NEG = 0,
+		CH7006_CLOCK_EDGE_POS,
+	} clock_edge;
+
+	int xcm, pcm;
+
+	enum {
+		CH7006_SYNC_SLAVE = 0,
+		CH7006_SYNC_MASTER,
+	} sync_direction;
+
+	enum {
+		CH7006_SYNC_SEPARATED = 0,
+		CH7006_SYNC_EMBEDDED,
+	} sync_encoding;
+
+	enum {
+		CH7006_POUT_1_8V = 0,
+		CH7006_POUT_3_3V,
+	} pout_level;
+
+	enum {
+		CH7006_ACTIVE_HSYNC = 0,
+		CH7006_ACTIVE_DSTART,
+	} active_detect;
+};
+
+#endif
diff --git a/drivers/gpu/drm/nouveau/include/dispnv04/i2c/sil164.h b/drivers/gpu/drm/nouveau/include/dispnv04/i2c/sil164.h
new file mode 100644
index 000000000000..b86750d7abe1
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/dispnv04/i2c/sil164.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2010 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __NOUVEAU_I2C_SIL164_H__
+#define __NOUVEAU_I2C_SIL164_H__
+
+/**
+ * struct sil164_encoder_params
+ *
+ * Describes how the sil164 is connected to the GPU. It should be used
+ * as the @params parameter of its @set_config method.
+ *
+ * See "http://www.siliconimage.com/docs/SiI-DS-0021-E-164.pdf".
+ */
+struct sil164_encoder_params {
+	/* private: FIXME: document the members */
+	enum {
+		SIL164_INPUT_EDGE_FALLING = 0,
+		SIL164_INPUT_EDGE_RISING
+	} input_edge;
+
+	enum {
+		SIL164_INPUT_WIDTH_12BIT = 0,
+		SIL164_INPUT_WIDTH_24BIT
+	} input_width;
+
+	enum {
+		SIL164_INPUT_SINGLE_EDGE = 0,
+		SIL164_INPUT_DUAL_EDGE
+	} input_dual;
+
+	enum {
+		SIL164_PLL_FILTER_ON = 0,
+		SIL164_PLL_FILTER_OFF,
+	} pll_filter;
+
+	int input_skew; /** < Allowed range [-4, 3], use 0 for no de-skew. */
+	int duallink_skew; /** < Allowed range [-4, 3]. */
+};
+
+#endif
diff --git a/include/drm/i2c/ch7006.h b/include/drm/i2c/ch7006.h
deleted file mode 100644
index 5305b9797f93..000000000000
--- a/include/drm/i2c/ch7006.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2009 Francisco Jerez.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __DRM_I2C_CH7006_H__
-#define __DRM_I2C_CH7006_H__
-
-/**
- * struct ch7006_encoder_params
- *
- * Describes how the ch7006 is wired up with the GPU. It should be
- * used as the @params parameter of its @set_config method.
- *
- * See "http://www.chrontel.com/pdf/7006.pdf" for their precise
- * meaning.
- */
-struct ch7006_encoder_params {
-	/* private: FIXME: document the members */
-	enum {
-		CH7006_FORMAT_RGB16 = 0,
-		CH7006_FORMAT_YCrCb24m16,
-		CH7006_FORMAT_RGB24m16,
-		CH7006_FORMAT_RGB15,
-		CH7006_FORMAT_RGB24m12C,
-		CH7006_FORMAT_RGB24m12I,
-		CH7006_FORMAT_RGB24m8,
-		CH7006_FORMAT_RGB16m8,
-		CH7006_FORMAT_RGB15m8,
-		CH7006_FORMAT_YCrCb24m8,
-	} input_format;
-
-	enum {
-		CH7006_CLOCK_SLAVE = 0,
-		CH7006_CLOCK_MASTER,
-	} clock_mode;
-
-	enum {
-		CH7006_CLOCK_EDGE_NEG = 0,
-		CH7006_CLOCK_EDGE_POS,
-	} clock_edge;
-
-	int xcm, pcm;
-
-	enum {
-		CH7006_SYNC_SLAVE = 0,
-		CH7006_SYNC_MASTER,
-	} sync_direction;
-
-	enum {
-		CH7006_SYNC_SEPARATED = 0,
-		CH7006_SYNC_EMBEDDED,
-	} sync_encoding;
-
-	enum {
-		CH7006_POUT_1_8V = 0,
-		CH7006_POUT_3_3V,
-	} pout_level;
-
-	enum {
-		CH7006_ACTIVE_HSYNC = 0,
-		CH7006_ACTIVE_DSTART,
-	} active_detect;
-};
-
-#endif
diff --git a/include/drm/i2c/sil164.h b/include/drm/i2c/sil164.h
deleted file mode 100644
index ddf248693c8b..000000000000
--- a/include/drm/i2c/sil164.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2010 Francisco Jerez.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __DRM_I2C_SIL164_H__
-#define __DRM_I2C_SIL164_H__
-
-/**
- * struct sil164_encoder_params
- *
- * Describes how the sil164 is connected to the GPU. It should be used
- * as the @params parameter of its @set_config method.
- *
- * See "http://www.siliconimage.com/docs/SiI-DS-0021-E-164.pdf".
- */
-struct sil164_encoder_params {
-	/* private: FIXME: document the members */
-	enum {
-		SIL164_INPUT_EDGE_FALLING = 0,
-		SIL164_INPUT_EDGE_RISING
-	} input_edge;
-
-	enum {
-		SIL164_INPUT_WIDTH_12BIT = 0,
-		SIL164_INPUT_WIDTH_24BIT
-	} input_width;
-
-	enum {
-		SIL164_INPUT_SINGLE_EDGE = 0,
-		SIL164_INPUT_DUAL_EDGE
-	} input_dual;
-
-	enum {
-		SIL164_PLL_FILTER_ON = 0,
-		SIL164_PLL_FILTER_OFF,
-	} pll_filter;
-
-	int input_skew; /** < Allowed range [-4, 3], use 0 for no de-skew. */
-	int duallink_skew; /** < Allowed range [-4, 3]. */
-};
-
-#endif
-- 
2.52.0

