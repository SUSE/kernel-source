From: Saeed Mahameed <saeedm@nvidia.com>
Date: Mon, 16 Aug 2021 11:58:19 -0700
Subject: net/mlx5e: Remove mlx5e dependency from E-Switch sample
Patch-mainline: v5.15-rc1
Git-commit: 5024fa95a144ef4ce9c0039155a553e59c3850be
References: jsc#SLE-19253

mlx5/esw/sample.c doesn't really need mlx5e_priv object, we can remove
this redundant dependency by passing the eswitch object directly to
the sample object constructor.

Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
Reviewed-by: Roi Dayan <roid@nvidia.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/en_tc.c      |    2 -
 drivers/net/ethernet/mellanox/mlx5/core/esw/sample.c |   25 +++++++++----------
 drivers/net/ethernet/mellanox/mlx5/core/esw/sample.h |    4 ---
 3 files changed, 14 insertions(+), 17 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -4976,7 +4976,7 @@ int mlx5e_tc_esw_init(struct rhashtable
 					       MLX5_FLOW_NAMESPACE_FDB);
 
 #if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
-	uplink_priv->esw_psample = mlx5_esw_sample_init(netdev_priv(priv->netdev));
+	uplink_priv->esw_psample = mlx5_esw_sample_init(esw);
 #endif
 
 	mapping_id = mlx5_query_nic_system_image_guid(esw->dev);
--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/sample.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/sample.c
@@ -18,7 +18,7 @@ static const struct esw_vport_tbl_namesp
 };
 
 struct mlx5_esw_psample {
-	struct mlx5e_priv *priv;
+	struct mlx5_eswitch *esw;
 	struct mlx5_flow_table *termtbl;
 	struct mlx5_flow_handle *termtbl_rule;
 	DECLARE_HASHTABLE(hashtbl, 8);
@@ -55,10 +55,10 @@ struct mlx5_sample_restore {
 static int
 sampler_termtbl_create(struct mlx5_esw_psample *esw_psample)
 {
-	struct mlx5_core_dev *dev = esw_psample->priv->mdev;
-	struct mlx5_eswitch *esw = dev->priv.eswitch;
+	struct mlx5_eswitch *esw = esw_psample->esw;
 	struct mlx5_flow_table_attr ft_attr = {};
 	struct mlx5_flow_destination dest = {};
+	struct mlx5_core_dev *dev = esw->dev;
 	struct mlx5_flow_namespace *root_ns;
 	struct mlx5_flow_act act = {};
 	int err;
@@ -187,7 +187,7 @@ sampler_get(struct mlx5_esw_psample *esw
 	sampler->default_table_id = default_table_id;
 	sampler->sample_ratio = sample_ratio;
 
-	err = sampler_obj_create(esw_psample->priv->mdev, sampler);
+	err = sampler_obj_create(esw_psample->esw->dev, sampler);
 	if (err)
 		goto err_create;
 
@@ -211,7 +211,7 @@ sampler_put(struct mlx5_esw_psample *esw
 	mutex_lock(&esw_psample->ht_lock);
 	if (--sampler->count == 0) {
 		hash_del(&sampler->hlist);
-		sampler_obj_destroy(esw_psample->priv->mdev, sampler->sampler_id);
+		sampler_obj_destroy(esw_psample->esw->dev, sampler->sampler_id);
 		kfree(sampler);
 	}
 	mutex_unlock(&esw_psample->ht_lock);
@@ -249,8 +249,8 @@ err_set_regc0:
 static struct mlx5_sample_restore *
 sample_restore_get(struct mlx5_esw_psample *esw_psample, u32 obj_id)
 {
-	struct mlx5_core_dev *mdev = esw_psample->priv->mdev;
-	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+	struct mlx5_eswitch *esw = esw_psample->esw;
+	struct mlx5_core_dev *mdev = esw->dev;
 	struct mlx5_sample_restore *restore;
 	struct mlx5_modify_hdr *modify_hdr;
 	int err;
@@ -305,7 +305,7 @@ sample_restore_put(struct mlx5_esw_psamp
 
 	if (!restore->count) {
 		mlx5_del_flow_rules(restore->rule);
-		mlx5_modify_header_dealloc(esw_psample->priv->mdev, restore->modify_hdr);
+		mlx5_modify_header_dealloc(esw_psample->esw->dev, restore->modify_hdr);
 		kfree(restore);
 	}
 }
@@ -384,7 +384,7 @@ mlx5_esw_sample_offload(struct mlx5_esw_
 	/* If slow path flag is set, eg. when the neigh is invalid for encap,
 	 * don't offload sample action.
 	 */
-	esw = esw_psample->priv->mdev->priv.eswitch;
+	esw = esw_psample->esw;
 	if (attr->flags & MLX5_ESW_ATTR_FLAG_SLOW_PATH)
 		return mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
 
@@ -522,7 +522,7 @@ mlx5_esw_sample_unoffload(struct mlx5_es
 	/* If slow path flag is set, sample action is not offloaded.
 	 * No need to delete sample rule.
 	 */
-	esw = esw_psample->priv->mdev->priv.eswitch;
+	esw = esw_psample->esw;
 	if (attr->flags & MLX5_ESW_ATTR_FLAG_SLOW_PATH) {
 		mlx5_eswitch_del_offloaded_rule(esw, rule, attr);
 		return;
@@ -531,7 +531,6 @@ mlx5_esw_sample_unoffload(struct mlx5_es
 	sample_flow = esw_attr->sample->sample_flow;
 	pre_attr = sample_flow->pre_attr;
 	memset(pre_attr, 0, sizeof(*pre_attr));
-	esw = esw_psample->priv->mdev->priv.eswitch;
 	mlx5_eswitch_del_offloaded_rule(esw, sample_flow->pre_rule, pre_attr);
 	mlx5_eswitch_del_offloaded_rule(esw, sample_flow->rule, attr);
 
@@ -550,7 +549,7 @@ mlx5_esw_sample_unoffload(struct mlx5_es
 }
 
 struct mlx5_esw_psample *
-mlx5_esw_sample_init(struct mlx5e_priv *priv)
+mlx5_esw_sample_init(struct mlx5_eswitch *esw)
 {
 	struct mlx5_esw_psample *esw_psample;
 	int err;
@@ -558,7 +557,7 @@ mlx5_esw_sample_init(struct mlx5e_priv *
 	esw_psample = kzalloc(sizeof(*esw_psample), GFP_KERNEL);
 	if (!esw_psample)
 		return ERR_PTR(-ENOMEM);
-	esw_psample->priv = priv;
+	esw_psample->esw = esw;
 	err = sampler_termtbl_create(esw_psample);
 	if (err)
 		goto err_termtbl;
--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/sample.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/sample.h
@@ -4,10 +4,8 @@
 #ifndef __MLX5_EN_TC_SAMPLE_H__
 #define __MLX5_EN_TC_SAMPLE_H__
 
-#include "en.h"
 #include "eswitch.h"
 
-struct mlx5e_priv;
 struct mlx5_flow_attr;
 struct mlx5_esw_psample;
 
@@ -34,7 +32,7 @@ mlx5_esw_sample_unoffload(struct mlx5_es
 			  struct mlx5_flow_attr *attr);
 
 struct mlx5_esw_psample *
-mlx5_esw_sample_init(struct mlx5e_priv *priv);
+mlx5_esw_sample_init(struct mlx5_eswitch *esw);
 
 void
 mlx5_esw_sample_cleanup(struct mlx5_esw_psample *esw_psample);
