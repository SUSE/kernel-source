From 5c06c1df3582102e837dc7d6e8a462323277e57b Mon Sep 17 00:00:00 2001
From: Samson Tam <Samson.Tam@amd.com>
Date: Thu, 23 Jan 2025 14:36:57 -0500
Subject: drm/amd/display: Move SPL to a new path
Git-commit: 5c06c1df3582102e837dc7d6e8a462323277e57b
Patch-mainline: v6.15-rc1
References: jsc#PED-13979 jsc#PED-14039 jsc#PED-14046 jsc#PED-14211 jsc#PED-14333 jsc#PED-14487 jsc#PED-14488 jsc#PED-14497 jsc#PED-14499

[WHY & HOW]
- Move SPL from dc/spl to dc/sspl
- Update build files and header paths
- Remove dc/spl files

Reviewed-by: George Zhang <george.zhang@amd.com>
Signed-off-by: Samson Tam <Samson.Tam@amd.com>
Signed-off-by: Alex Hung <alex.hung@amd.com>
Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>

---
 drivers/gpu/drm/amd/display/dc/Makefile       |    2 +-
 drivers/gpu/drm/amd/display/dc/dc.h           |    2 -
 .../gpu/drm/amd/display/dc/dc_spl_translate.c |    1 -
 .../drm/amd/display/dc/dpp/dcn20/dcn20_dpp.h  |    1 -
 .../drm/amd/display/dc/dpp/dcn32/dcn32_dpp.h  |    1 -
 .../gpu/drm/amd/display/dc/inc/core_types.h   |    2 +-
 .../gpu/drm/amd/display/dc/inc/hw/transform.h |    2 +-
 drivers/gpu/drm/amd/display/dc/inc/resource.h |    1 -
 .../dc/resource/dcn401/dcn401_resource.c      |    4 +-
 drivers/gpu/drm/amd/display/dc/spl/Makefile   |   33 -
 drivers/gpu/drm/amd/display/dc/spl/dc_spl.c   | 1874 -----------------
 drivers/gpu/drm/amd/display/dc/spl/dc_spl.h   |   18 -
 .../drm/amd/display/dc/spl/dc_spl_filters.c   |   15 -
 .../drm/amd/display/dc/spl/dc_spl_filters.h   |   15 -
 .../display/dc/spl/dc_spl_isharp_filters.c    |  757 -------
 .../display/dc/spl/dc_spl_isharp_filters.h    |   50 -
 .../display/dc/spl/dc_spl_scl_easf_filters.c  | 1726 ---------------
 .../display/dc/spl/dc_spl_scl_easf_filters.h  |   38 -
 .../amd/display/dc/spl/dc_spl_scl_filters.c   | 1451 -------------
 .../amd/display/dc/spl/dc_spl_scl_filters.h   |   22 -
 .../gpu/drm/amd/display/dc/spl/dc_spl_types.h |  543 -----
 .../drm/amd/display/dc/spl/spl_custom_float.c |  151 --
 .../drm/amd/display/dc/spl/spl_custom_float.h |   29 -
 .../gpu/drm/amd/display/dc/spl/spl_debug.h    |   30 -
 .../drm/amd/display/dc/spl/spl_fixpt31_32.c   |  497 -----
 .../drm/amd/display/dc/spl/spl_fixpt31_32.h   |  522 -----
 .../gpu/drm/amd/display/dc/spl/spl_os_types.h |   56 -
 drivers/gpu/drm/amd/display/dc/sspl/Makefile  |   33 +
 drivers/gpu/drm/amd/display/dc/sspl/dc_spl.c  | 1874 +++++++++++++++++
 drivers/gpu/drm/amd/display/dc/sspl/dc_spl.h  |   18 +
 .../drm/amd/display/dc/sspl/dc_spl_filters.c  |   15 +
 .../drm/amd/display/dc/sspl/dc_spl_filters.h  |   15 +
 .../display/dc/sspl/dc_spl_isharp_filters.c   |  757 +++++++
 .../display/dc/sspl/dc_spl_isharp_filters.h   |   50 +
 .../display/dc/sspl/dc_spl_scl_easf_filters.c | 1726 +++++++++++++++
 .../display/dc/sspl/dc_spl_scl_easf_filters.h |   38 +
 .../amd/display/dc/sspl/dc_spl_scl_filters.c  | 1451 +++++++++++++
 .../amd/display/dc/sspl/dc_spl_scl_filters.h  |   22 +
 .../drm/amd/display/dc/sspl/dc_spl_types.h    |  543 +++++
 .../amd/display/dc/sspl/spl_custom_float.c    |  151 ++
 .../amd/display/dc/sspl/spl_custom_float.h    |   29 +
 .../gpu/drm/amd/display/dc/sspl/spl_debug.h   |   30 +
 .../drm/amd/display/dc/sspl/spl_fixpt31_32.c  |  497 +++++
 .../drm/amd/display/dc/sspl/spl_fixpt31_32.h  |  522 +++++
 .../drm/amd/display/dc/sspl/spl_os_types.h    |   56 +
 45 files changed, 7832 insertions(+), 7838 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/Makefile
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl_filters.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl_filters.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl_isharp_filters.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl_isharp_filters.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_easf_filters.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_easf_filters.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_filters.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_filters.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/dc_spl_types.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/spl_custom_float.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/spl_custom_float.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/spl_debug.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/spl_fixpt31_32.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/spl_fixpt31_32.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/spl/spl_os_types.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/Makefile
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl_filters.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl_filters.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_easf_filters.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_easf_filters.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_filters.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_filters.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/dc_spl_types.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/spl_custom_float.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/spl_custom_float.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/spl_debug.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/spl_fixpt31_32.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/spl_fixpt31_32.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/sspl/spl_os_types.h

diff --git a/drivers/gpu/drm/amd/display/dc/Makefile b/drivers/gpu/drm/amd/display/dc/Makefile
index 8992e697759f..3e1f5b689718 100644
--- a/drivers/gpu/drm/amd/display/dc/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/Makefile
@@ -52,7 +52,7 @@ endif
 DC_LIBS += hdcp
 
 ifdef CONFIG_DRM_AMD_DC_FP
-DC_LIBS += spl
+DC_LIBS += sspl
 DC_SPL_TRANS += dc_spl_translate.o
 endif
 
diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 559446dcd431..9ac299fb1034 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -46,8 +46,6 @@
 
 #include "dmub/inc/dmub_cmd.h"
 
-#include "spl/dc_spl_types.h"
-
 struct abm_save_restore;
 
 /* forward declaration */
diff --git a/drivers/gpu/drm/amd/display/dc/dc_spl_translate.c b/drivers/gpu/drm/amd/display/dc/dc_spl_translate.c
index 3518eb1b8cd1..e3a8283b4098 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_spl_translate.c
+++ b/drivers/gpu/drm/amd/display/dc/dc_spl_translate.c
@@ -3,7 +3,6 @@
 // Copyright 2024 Advanced Micro Devices, Inc.
 
 #include "dc_spl_translate.h"
-#include "spl/dc_spl_types.h"
 #include "dcn20/dcn20_dpp.h"
 #include "dcn32/dcn32_dpp.h"
 #include "dcn401/dcn401_dpp.h"
diff --git a/drivers/gpu/drm/amd/display/dc/dpp/dcn20/dcn20_dpp.h b/drivers/gpu/drm/amd/display/dc/dpp/dcn20/dcn20_dpp.h
index f09cba8e29cc..85f359b5da67 100644
--- a/drivers/gpu/drm/amd/display/dc/dpp/dcn20/dcn20_dpp.h
+++ b/drivers/gpu/drm/amd/display/dc/dpp/dcn20/dcn20_dpp.h
@@ -26,7 +26,6 @@
 #define __DCN20_DPP_H__
 
 #include "dcn10/dcn10_dpp.h"
-#include "spl/dc_spl_types.h"
 #define TO_DCN20_DPP(dpp)\
 	container_of(dpp, struct dcn20_dpp, base)
 
diff --git a/drivers/gpu/drm/amd/display/dc/dpp/dcn32/dcn32_dpp.h b/drivers/gpu/drm/amd/display/dc/dpp/dcn32/dcn32_dpp.h
index 992df172378c..f33dddbfcc31 100644
--- a/drivers/gpu/drm/amd/display/dc/dpp/dcn32/dcn32_dpp.h
+++ b/drivers/gpu/drm/amd/display/dc/dpp/dcn32/dcn32_dpp.h
@@ -27,7 +27,6 @@
 
 #include "dcn20/dcn20_dpp.h"
 #include "dcn30/dcn30_dpp.h"
-#include "spl/dc_spl_types.h"
 
 bool dpp32_construct(struct dcn3_dpp *dpp3,
 	struct dc_context *ctx,
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index 37632be09e09..d0021f25f3d8 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -39,7 +39,7 @@
 #include "panel_cntl.h"
 #include "dmub/inc/dmub_cmd.h"
 #include "pg_cntl.h"
-#include "spl/dc_spl.h"
+#include "sspl/dc_spl.h"
 
 #define MAX_CLOCK_SOURCES 7
 #define MAX_SVP_PHANTOM_STREAMS 2
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h b/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h
index 45262cba675e..5a1d9b708a9d 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h
@@ -29,7 +29,7 @@
 #include "hw_shared.h"
 #include "dc_hw_types.h"
 #include "fixed31_32.h"
-#include "spl/dc_spl_types.h"
+#include "sspl/dc_spl_types.h"
 
 #define CSC_TEMPERATURE_MATRIX_SIZE 12
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/resource.h b/drivers/gpu/drm/amd/display/dc/inc/resource.h
index b32d07ce0f08..042e04f924a2 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/resource.h
@@ -29,7 +29,6 @@
 #include "core_status.h"
 #include "dal_asic_id.h"
 #include "dm_pp_smu.h"
-#include "spl/dc_spl.h"
 
 #define MEMORY_TYPE_MULTIPLIER_CZ 4
 #define MEMORY_TYPE_HBM 2
diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
index c1ebc6b1c937..5cb0e0191a16 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
@@ -76,8 +76,8 @@
 
 #include "dml2/dml2_wrapper.h"
 
-#include "spl/dc_spl_scl_easf_filters.h"
-#include "spl/dc_spl_isharp_filters.h"
+#include "sspl/dc_spl_scl_easf_filters.h"
+#include "sspl/dc_spl_isharp_filters.h"
 
 #define DC_LOGGER_INIT(logger)
 
diff --git a/drivers/gpu/drm/amd/display/dc/spl/Makefile b/drivers/gpu/drm/amd/display/dc/spl/Makefile
deleted file mode 100644
index 5edf3c6cf3e2..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/Makefile
+++ /dev/null
@@ -1,33 +0,0 @@
-#
-# Copyright 2017 Advanced Micro Devices, Inc.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
-# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-# OTHER DEALINGS IN THE SOFTWARE.
-#
-#
-# Makefile for the 'spl' sub-component of DAL.
-# It provides the scaling library interface.
-
-SPL = dc_spl.o dc_spl_scl_filters.o dc_spl_scl_easf_filters.o dc_spl_isharp_filters.o dc_spl_filters.o spl_fixpt31_32.o spl_custom_float.o
-
-AMD_DAL_SPL = $(addprefix $(AMDDALPATH)/dc/spl/,$(SPL))
-
-AMD_DISPLAY_FILES += $(AMD_DAL_SPL)
-
-
-
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl.c b/drivers/gpu/drm/amd/display/dc/spl/dc_spl.c
deleted file mode 100644
index 38a9a0d68058..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl.c
+++ /dev/null
@@ -1,1874 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#include "dc_spl.h"
-#include "dc_spl_scl_filters.h"
-#include "dc_spl_scl_easf_filters.h"
-#include "dc_spl_isharp_filters.h"
-#include "spl_debug.h"
-
-#define IDENTITY_RATIO(ratio) (spl_fixpt_u2d19(ratio) == (1 << 19))
-#define MIN_VIEWPORT_SIZE 12
-
-static bool spl_is_yuv420(enum spl_pixel_format format)
-{
-	if ((format >= SPL_PIXEL_FORMAT_420BPP8) &&
-		(format <= SPL_PIXEL_FORMAT_420BPP10))
-		return true;
-
-	return false;
-}
-
-static bool spl_is_rgb8(enum spl_pixel_format format)
-{
-	if (format == SPL_PIXEL_FORMAT_ARGB8888)
-		return true;
-
-	return false;
-}
-
-static bool spl_is_video_format(enum spl_pixel_format format)
-{
-	if (format >= SPL_PIXEL_FORMAT_VIDEO_BEGIN
-		&& format <= SPL_PIXEL_FORMAT_VIDEO_END)
-		return true;
-	else
-		return false;
-}
-
-static bool spl_is_subsampled_format(enum spl_pixel_format format)
-{
-	if (format >= SPL_PIXEL_FORMAT_SUBSAMPLED_BEGIN
-		&& format <= SPL_PIXEL_FORMAT_SUBSAMPLED_END)
-		return true;
-	else
-		return false;
-}
-
-static struct spl_rect intersect_rec(const struct spl_rect *r0, const struct spl_rect *r1)
-{
-	struct spl_rect rec;
-	int r0_x_end = r0->x + r0->width;
-	int r1_x_end = r1->x + r1->width;
-	int r0_y_end = r0->y + r0->height;
-	int r1_y_end = r1->y + r1->height;
-
-	rec.x = r0->x > r1->x ? r0->x : r1->x;
-	rec.width = r0_x_end > r1_x_end ? r1_x_end - rec.x : r0_x_end - rec.x;
-	rec.y = r0->y > r1->y ? r0->y : r1->y;
-	rec.height = r0_y_end > r1_y_end ? r1_y_end - rec.y : r0_y_end - rec.y;
-
-	/* in case that there is no intersection */
-	if (rec.width < 0 || rec.height < 0)
-		memset(&rec, 0, sizeof(rec));
-
-	return rec;
-}
-
-static struct spl_rect shift_rec(const struct spl_rect *rec_in, int x, int y)
-{
-	struct spl_rect rec_out = *rec_in;
-
-	rec_out.x += x;
-	rec_out.y += y;
-
-	return rec_out;
-}
-
-static struct spl_rect calculate_plane_rec_in_timing_active(
-		struct spl_in *spl_in,
-		const struct spl_rect *rec_in)
-{
-	/*
-	 * The following diagram shows an example where we map a 1920x1200
-	 * desktop to a 2560x1440 timing with a plane rect in the middle
-	 * of the screen. To map a plane rect from Stream Source to Timing
-	 * Active space, we first multiply stream scaling ratios (i.e 2304/1920
-	 * horizontal and 1440/1200 vertical) to the plane's x and y, then
-	 * we add stream destination offsets (i.e 128 horizontal, 0 vertical).
-	 * This will give us a plane rect's position in Timing Active. However
-	 * we have to remove the fractional. The rule is that we find left/right
-	 * and top/bottom positions and round the value to the adjacent integer.
-	 *
-	 * Stream Source Space
-	 * ------------
-	 *        __________________________________________________
-	 *       |Stream Source (1920 x 1200) ^                     |
-	 *       |                            y                     |
-	 *       |         <------- w --------|>                    |
-	 *       |          __________________V                     |
-	 *       |<-- x -->|Plane//////////////| ^                  |
-	 *       |         |(pre scale)////////| |                  |
-	 *       |         |///////////////////| |                  |
-	 *       |         |///////////////////| h                  |
-	 *       |         |///////////////////| |                  |
-	 *       |         |///////////////////| |                  |
-	 *       |         |///////////////////| V                  |
-	 *       |                                                  |
-	 *       |                                                  |
-	 *       |__________________________________________________|
-	 *
-	 *
-	 * Timing Active Space
-	 * ---------------------------------
-	 *
-	 *       Timing Active (2560 x 1440)
-	 *        __________________________________________________
-	 *       |*****|  Stteam Destination (2304 x 1440)    |*****|
-	 *       |*****|                                      |*****|
-	 *       |<128>|                                      |*****|
-	 *       |*****|     __________________               |*****|
-	 *       |*****|    |Plane/////////////|              |*****|
-	 *       |*****|    |(post scale)//////|              |*****|
-	 *       |*****|    |//////////////////|              |*****|
-	 *       |*****|    |//////////////////|              |*****|
-	 *       |*****|    |//////////////////|              |*****|
-	 *       |*****|    |//////////////////|              |*****|
-	 *       |*****|                                      |*****|
-	 *       |*****|                                      |*****|
-	 *       |*****|                                      |*****|
-	 *       |*****|______________________________________|*****|
-	 *
-	 * So the resulting formulas are shown below:
-	 *
-	 * recout_x = 128 + round(plane_x * 2304 / 1920)
-	 * recout_w = 128 + round((plane_x + plane_w) * 2304 / 1920) - recout_x
-	 * recout_y = 0 + round(plane_y * 1440 / 1200)
-	 * recout_h = 0 + round((plane_y + plane_h) * 1440 / 1200) - recout_y
-	 *
-	 * NOTE: fixed point division is not error free. To reduce errors
-	 * introduced by fixed point division, we divide only after
-	 * multiplication is complete.
-	 */
-	const struct spl_rect *stream_src = &spl_in->basic_out.src_rect;
-	const struct spl_rect *stream_dst = &spl_in->basic_out.dst_rect;
-	struct spl_rect rec_out = {0};
-	struct spl_fixed31_32 temp;
-
-
-	temp = spl_fixpt_from_fraction(rec_in->x * (long long)stream_dst->width,
-			stream_src->width);
-	rec_out.x = stream_dst->x + spl_fixpt_round(temp);
-
-	temp = spl_fixpt_from_fraction(
-			(rec_in->x + rec_in->width) * (long long)stream_dst->width,
-			stream_src->width);
-	rec_out.width = stream_dst->x + spl_fixpt_round(temp) - rec_out.x;
-
-	temp = spl_fixpt_from_fraction(rec_in->y * (long long)stream_dst->height,
-			stream_src->height);
-	rec_out.y = stream_dst->y + spl_fixpt_round(temp);
-
-	temp = spl_fixpt_from_fraction(
-			(rec_in->y + rec_in->height) * (long long)stream_dst->height,
-			stream_src->height);
-	rec_out.height = stream_dst->y + spl_fixpt_round(temp) - rec_out.y;
-
-	return rec_out;
-}
-
-static struct spl_rect calculate_mpc_slice_in_timing_active(
-		struct spl_in *spl_in,
-		struct spl_rect *plane_clip_rec)
-{
-	bool use_recout_width_aligned =
-		spl_in->basic_in.num_h_slices_recout_width_align.use_recout_width_aligned;
-	int mpc_slice_count =
-		spl_in->basic_in.num_h_slices_recout_width_align.num_slices_recout_width.mpc_num_h_slices;
-	int recout_width_align =
-		spl_in->basic_in.num_h_slices_recout_width_align.num_slices_recout_width.mpc_recout_width_align;
-	int mpc_slice_idx = spl_in->basic_in.mpc_h_slice_index;
-	int epimo = mpc_slice_count - plane_clip_rec->width % mpc_slice_count - 1;
-	struct spl_rect mpc_rec;
-
-	if (use_recout_width_aligned) {
-		mpc_rec.width = recout_width_align;
-		if ((mpc_rec.width * (mpc_slice_idx + 1)) > plane_clip_rec->width) {
-			mpc_rec.width = plane_clip_rec->width % recout_width_align;
-			mpc_rec.x = plane_clip_rec->x + recout_width_align * mpc_slice_idx;
-		} else
-			mpc_rec.x = plane_clip_rec->x + mpc_rec.width * mpc_slice_idx;
-		mpc_rec.height = plane_clip_rec->height;
-		mpc_rec.y = plane_clip_rec->y;
-
-	} else {
-		mpc_rec.width = plane_clip_rec->width / mpc_slice_count;
-		mpc_rec.x = plane_clip_rec->x + mpc_rec.width * mpc_slice_idx;
-		mpc_rec.height = plane_clip_rec->height;
-		mpc_rec.y = plane_clip_rec->y;
-	}
-	SPL_ASSERT(mpc_slice_count == 1 ||
-			spl_in->basic_out.view_format != SPL_VIEW_3D_SIDE_BY_SIDE ||
-			mpc_rec.width % 2 == 0);
-
-	/* extra pixels in the division remainder need to go to pipes after
-	 * the extra pixel index minus one(epimo) defined here as:
-	 */
-	if (mpc_slice_idx > epimo) {
-		mpc_rec.x += mpc_slice_idx - epimo - 1;
-		mpc_rec.width += 1;
-	}
-
-	if (spl_in->basic_out.view_format == SPL_VIEW_3D_TOP_AND_BOTTOM) {
-		SPL_ASSERT(mpc_rec.height % 2 == 0);
-		mpc_rec.height /= 2;
-	}
-	return mpc_rec;
-}
-
-static struct spl_rect calculate_odm_slice_in_timing_active(struct spl_in *spl_in)
-{
-	int odm_slice_count = spl_in->basic_out.odm_combine_factor;
-	int odm_slice_idx = spl_in->odm_slice_index;
-	bool is_last_odm_slice = (odm_slice_idx + 1) == odm_slice_count;
-	int h_active = spl_in->basic_out.output_size.width;
-	int v_active = spl_in->basic_out.output_size.height;
-	int odm_slice_width;
-	struct spl_rect odm_rec;
-
-	if (spl_in->basic_out.odm_combine_factor > 0) {
-		odm_slice_width = h_active / odm_slice_count;
-		/*
-		 * deprecated, caller must pass in odm slice rect i.e OPP input
-		 * rect in timing active for the new interface.
-		 */
-		if (spl_in->basic_out.use_two_pixels_per_container && (odm_slice_width % 2))
-			odm_slice_width++;
-
-		odm_rec.x = odm_slice_width * odm_slice_idx;
-		odm_rec.width = is_last_odm_slice ?
-				/* last slice width is the reminder of h_active */
-				h_active - odm_slice_width * (odm_slice_count - 1) :
-				/* odm slice width is the floor of h_active / count */
-				odm_slice_width;
-		odm_rec.y = 0;
-		odm_rec.height = v_active;
-
-		return odm_rec;
-	}
-
-	return spl_in->basic_out.odm_slice_rect;
-}
-
-static void spl_calculate_recout(struct spl_in *spl_in, struct spl_scratch *spl_scratch, struct spl_out *spl_out)
-{
-	/*
-	 * A plane clip represents the desired plane size and position in Stream
-	 * Source Space. Stream Source is the destination where all planes are
-	 * blended (i.e. positioned, scaled and overlaid). It is a canvas where
-	 * all planes associated with the current stream are drawn together.
-	 * After Stream Source is completed, we will further scale and
-	 * reposition the entire canvas of the stream source to Stream
-	 * Destination in Timing Active Space. This could be due to display
-	 * overscan adjustment where we will need to rescale and reposition all
-	 * the planes so they can fit into a TV with overscan or downscale
-	 * upscale features such as GPU scaling or VSR.
-	 *
-	 * This two step blending is a virtual procedure in software. In
-	 * hardware there is no such thing as Stream Source. all planes are
-	 * blended once in Timing Active Space. Software virtualizes a Stream
-	 * Source space to decouple the math complicity so scaling param
-	 * calculation focuses on one step at a time.
-	 *
-	 * In the following two diagrams, user applied 10% overscan adjustment
-	 * so the Stream Source needs to be scaled down a little before mapping
-	 * to Timing Active Space. As a result the Plane Clip is also scaled
-	 * down by the same ratio, Plane Clip position (i.e. x and y) with
-	 * respect to Stream Source is also scaled down. To map it in Timing
-	 * Active Space additional x and y offsets from Stream Destination are
-	 * added to Plane Clip as well.
-	 *
-	 * Stream Source Space
-	 * ------------
-	 *        __________________________________________________
-	 *       |Stream Source (3840 x 2160) ^                     |
-	 *       |                            y                     |
-	 *       |                            |                     |
-	 *       |          __________________V                     |
-	 *       |<-- x -->|Plane Clip/////////|                    |
-	 *       |         |(pre scale)////////|                    |
-	 *       |         |///////////////////|                    |
-	 *       |         |///////////////////|                    |
-	 *       |         |///////////////////|                    |
-	 *       |         |///////////////////|                    |
-	 *       |         |///////////////////|                    |
-	 *       |                                                  |
-	 *       |                                                  |
-	 *       |__________________________________________________|
-	 *
-	 *
-	 * Timing Active Space (3840 x 2160)
-	 * ---------------------------------
-	 *
-	 *       Timing Active
-	 *        __________________________________________________
-	 *       | y_____________________________________________   |
-	 *       |x |Stream Destination (3456 x 1944)            |  |
-	 *       |  |                                            |  |
-	 *       |  |        __________________                  |  |
-	 *       |  |       |Plane Clip////////|                 |  |
-	 *       |  |       |(post scale)//////|                 |  |
-	 *       |  |       |//////////////////|                 |  |
-	 *       |  |       |//////////////////|                 |  |
-	 *       |  |       |//////////////////|                 |  |
-	 *       |  |       |//////////////////|                 |  |
-	 *       |  |                                            |  |
-	 *       |  |                                            |  |
-	 *       |  |____________________________________________|  |
-	 *       |__________________________________________________|
-	 *
-	 *
-	 * In Timing Active Space a plane clip could be further sliced into
-	 * pieces called MPC slices. Each Pipe Context is responsible for
-	 * processing only one MPC slice so the plane processing workload can be
-	 * distributed to multiple DPP Pipes. MPC slices could be blended
-	 * together to a single ODM slice. Each ODM slice is responsible for
-	 * processing a portion of Timing Active divided horizontally so the
-	 * output pixel processing workload can be distributed to multiple OPP
-	 * pipes. All ODM slices are mapped together in ODM block so all MPC
-	 * slices belong to different ODM slices could be pieced together to
-	 * form a single image in Timing Active. MPC slices must belong to
-	 * single ODM slice. If an MPC slice goes across ODM slice boundary, it
-	 * needs to be divided into two MPC slices one for each ODM slice.
-	 *
-	 * In the following diagram the output pixel processing workload is
-	 * divided horizontally into two ODM slices one for each OPP blend tree.
-	 * OPP0 blend tree is responsible for processing left half of Timing
-	 * Active, while OPP2 blend tree is responsible for processing right
-	 * half.
-	 *
-	 * The plane has two MPC slices. However since the right MPC slice goes
-	 * across ODM boundary, two DPP pipes are needed one for each OPP blend
-	 * tree. (i.e. DPP1 for OPP0 blend tree and DPP2 for OPP2 blend tree).
-	 *
-	 * Assuming that we have a Pipe Context associated with OPP0 and DPP1
-	 * working on processing the plane in the diagram. We want to know the
-	 * width and height of the shaded rectangle and its relative position
-	 * with respect to the ODM slice0. This is called the recout of the pipe
-	 * context.
-	 *
-	 * Planes can be at arbitrary size and position and there could be an
-	 * arbitrary number of MPC and ODM slices. The algorithm needs to take
-	 * all scenarios into account.
-	 *
-	 * Timing Active Space (3840 x 2160)
-	 * ---------------------------------
-	 *
-	 *       Timing Active
-	 *        __________________________________________________
-	 *       |OPP0(ODM slice0)^        |OPP2(ODM slice1)        |
-	 *       |                y        |                        |
-	 *       |                |  <- w ->                        |
-	 *       |           _____V________|____                    |
-	 *       |          |DPP0 ^  |DPP1 |DPP2|                   |
-	 *       |<------ x |-----|->|/////|    |                   |
-	 *       |          |     |  |/////|    |                   |
-	 *       |          |     h  |/////|    |                   |
-	 *       |          |     |  |/////|    |                   |
-	 *       |          |_____V__|/////|____|                   |
-	 *       |                         |                        |
-	 *       |                         |                        |
-	 *       |                         |                        |
-	 *       |_________________________|________________________|
-	 *
-	 *
-	 */
-	struct spl_rect plane_clip;
-	struct spl_rect mpc_slice_of_plane_clip;
-	struct spl_rect odm_slice;
-	struct spl_rect overlapping_area;
-
-	plane_clip = calculate_plane_rec_in_timing_active(spl_in,
-			&spl_in->basic_in.clip_rect);
-	/* guard plane clip from drawing beyond stream dst here */
-	plane_clip = intersect_rec(&plane_clip,
-				&spl_in->basic_out.dst_rect);
-	mpc_slice_of_plane_clip = calculate_mpc_slice_in_timing_active(
-			spl_in, &plane_clip);
-	odm_slice = calculate_odm_slice_in_timing_active(spl_in);
-	overlapping_area = intersect_rec(&mpc_slice_of_plane_clip, &odm_slice);
-
-	if (overlapping_area.height > 0 &&
-			overlapping_area.width > 0) {
-		/* shift the overlapping area so it is with respect to current
-		 * ODM slice's position
-		 */
-		spl_scratch->scl_data.recout = shift_rec(
-				&overlapping_area,
-				-odm_slice.x, -odm_slice.y);
-		spl_scratch->scl_data.recout.height -=
-			spl_in->debug.visual_confirm_base_offset;
-		spl_scratch->scl_data.recout.height -=
-			spl_in->debug.visual_confirm_dpp_offset;
-	} else
-		/* if there is no overlap, zero recout */
-		memset(&spl_scratch->scl_data.recout, 0,
-				sizeof(struct spl_rect));
-}
-
-/* Calculate scaling ratios */
-static void spl_calculate_scaling_ratios(struct spl_in *spl_in,
-		struct spl_scratch *spl_scratch,
-		struct spl_out *spl_out)
-{
-	const int in_w = spl_in->basic_out.src_rect.width;
-	const int in_h = spl_in->basic_out.src_rect.height;
-	const int out_w = spl_in->basic_out.dst_rect.width;
-	const int out_h = spl_in->basic_out.dst_rect.height;
-	struct spl_rect surf_src = spl_in->basic_in.src_rect;
-
-	/*Swap surf_src height and width since scaling ratios are in recout rotation*/
-	if (spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_90 ||
-		spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_270)
-		spl_swap(surf_src.height, surf_src.width);
-
-	spl_scratch->scl_data.ratios.horz = spl_fixpt_from_fraction(
-					surf_src.width,
-					spl_in->basic_in.dst_rect.width);
-	spl_scratch->scl_data.ratios.vert = spl_fixpt_from_fraction(
-					surf_src.height,
-					spl_in->basic_in.dst_rect.height);
-
-	if (spl_in->basic_out.view_format == SPL_VIEW_3D_SIDE_BY_SIDE)
-		spl_scratch->scl_data.ratios.horz.value *= 2;
-	else if (spl_in->basic_out.view_format == SPL_VIEW_3D_TOP_AND_BOTTOM)
-		spl_scratch->scl_data.ratios.vert.value *= 2;
-
-	spl_scratch->scl_data.ratios.vert.value = spl_div64_s64(
-		spl_scratch->scl_data.ratios.vert.value * in_h, out_h);
-	spl_scratch->scl_data.ratios.horz.value = spl_div64_s64(
-		spl_scratch->scl_data.ratios.horz.value * in_w, out_w);
-
-	spl_scratch->scl_data.ratios.horz_c = spl_scratch->scl_data.ratios.horz;
-	spl_scratch->scl_data.ratios.vert_c = spl_scratch->scl_data.ratios.vert;
-
-	if (spl_is_yuv420(spl_in->basic_in.format)) {
-		spl_scratch->scl_data.ratios.horz_c.value /= 2;
-		spl_scratch->scl_data.ratios.vert_c.value /= 2;
-	}
-	spl_scratch->scl_data.ratios.horz = spl_fixpt_truncate(
-			spl_scratch->scl_data.ratios.horz, 19);
-	spl_scratch->scl_data.ratios.vert = spl_fixpt_truncate(
-			spl_scratch->scl_data.ratios.vert, 19);
-	spl_scratch->scl_data.ratios.horz_c = spl_fixpt_truncate(
-			spl_scratch->scl_data.ratios.horz_c, 19);
-	spl_scratch->scl_data.ratios.vert_c = spl_fixpt_truncate(
-			spl_scratch->scl_data.ratios.vert_c, 19);
-
-	/*
-	 * Coefficient table and some registers are different based on ratio
-	 * that is output/input.  Currently we calculate input/output
-	 * Store 1/ratio in recip_ratio for those lookups
-	 */
-	spl_scratch->scl_data.recip_ratios.horz = spl_fixpt_recip(
-			spl_scratch->scl_data.ratios.horz);
-	spl_scratch->scl_data.recip_ratios.vert = spl_fixpt_recip(
-			spl_scratch->scl_data.ratios.vert);
-	spl_scratch->scl_data.recip_ratios.horz_c = spl_fixpt_recip(
-			spl_scratch->scl_data.ratios.horz_c);
-	spl_scratch->scl_data.recip_ratios.vert_c = spl_fixpt_recip(
-			spl_scratch->scl_data.ratios.vert_c);
-}
-
-/* Calculate Viewport size */
-static void spl_calculate_viewport_size(struct spl_in *spl_in, struct spl_scratch *spl_scratch)
-{
-	spl_scratch->scl_data.viewport.width = spl_fixpt_ceil(spl_fixpt_mul_int(spl_scratch->scl_data.ratios.horz,
-							spl_scratch->scl_data.recout.width));
-	spl_scratch->scl_data.viewport.height = spl_fixpt_ceil(spl_fixpt_mul_int(spl_scratch->scl_data.ratios.vert,
-							spl_scratch->scl_data.recout.height));
-	spl_scratch->scl_data.viewport_c.width = spl_fixpt_ceil(spl_fixpt_mul_int(spl_scratch->scl_data.ratios.horz_c,
-						spl_scratch->scl_data.recout.width));
-	spl_scratch->scl_data.viewport_c.height = spl_fixpt_ceil(spl_fixpt_mul_int(spl_scratch->scl_data.ratios.vert_c,
-						spl_scratch->scl_data.recout.height));
-	if (spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_90 ||
-			spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_270) {
-		spl_swap(spl_scratch->scl_data.viewport.width, spl_scratch->scl_data.viewport.height);
-		spl_swap(spl_scratch->scl_data.viewport_c.width, spl_scratch->scl_data.viewport_c.height);
-	}
-}
-
-static void spl_get_vp_scan_direction(enum spl_rotation_angle rotation,
-			   bool horizontal_mirror,
-			   bool *orthogonal_rotation,
-			   bool *flip_vert_scan_dir,
-			   bool *flip_horz_scan_dir)
-{
-	*orthogonal_rotation = false;
-	*flip_vert_scan_dir = false;
-	*flip_horz_scan_dir = false;
-	if (rotation == SPL_ROTATION_ANGLE_180) {
-		*flip_vert_scan_dir = true;
-		*flip_horz_scan_dir = true;
-	} else if (rotation == SPL_ROTATION_ANGLE_90) {
-		*orthogonal_rotation = true;
-		*flip_horz_scan_dir = true;
-	} else if (rotation == SPL_ROTATION_ANGLE_270) {
-		*orthogonal_rotation = true;
-		*flip_vert_scan_dir = true;
-	}
-
-	if (horizontal_mirror)
-		*flip_horz_scan_dir = !*flip_horz_scan_dir;
-}
-
-/*
- * We completely calculate vp offset, size and inits here based entirely on scaling
- * ratios and recout for pixel perfect pipe combine.
- */
-static void spl_calculate_init_and_vp(bool flip_scan_dir,
-				int recout_offset_within_recout_full,
-				int recout_size,
-				int src_size,
-				int taps,
-				struct spl_fixed31_32 ratio,
-				struct spl_fixed31_32 init_adj,
-				struct spl_fixed31_32 *init,
-				int *vp_offset,
-				int *vp_size)
-{
-	struct spl_fixed31_32 temp;
-	int int_part;
-
-	/*
-	 * First of the taps starts sampling pixel number <init_int_part> corresponding to recout
-	 * pixel 1. Next recout pixel samples int part of <init + scaling ratio> and so on.
-	 * All following calculations are based on this logic.
-	 *
-	 * Init calculated according to formula:
-	 * init = (scaling_ratio + number_of_taps + 1) / 2
-	 * init_bot = init + scaling_ratio
-	 * to get pixel perfect combine add the fraction from calculating vp offset
-	 */
-	temp = spl_fixpt_mul_int(ratio, recout_offset_within_recout_full);
-	*vp_offset = spl_fixpt_floor(temp);
-	temp.value &= 0xffffffff;
-	*init = spl_fixpt_add(spl_fixpt_div_int(spl_fixpt_add_int(ratio, taps + 1), 2), temp);
-	*init = spl_fixpt_add(*init, init_adj);
-	*init = spl_fixpt_truncate(*init, 19);
-
-	/*
-	 * If viewport has non 0 offset and there are more taps than covered by init then
-	 * we should decrease the offset and increase init so we are never sampling
-	 * outside of viewport.
-	 */
-	int_part = spl_fixpt_floor(*init);
-	if (int_part < taps) {
-		int_part = taps - int_part;
-		if (int_part > *vp_offset)
-			int_part = *vp_offset;
-		*vp_offset -= int_part;
-		*init = spl_fixpt_add_int(*init, int_part);
-	}
-	/*
-	 * If taps are sampling outside of viewport at end of recout and there are more pixels
-	 * available in the surface we should increase the viewport size, regardless set vp to
-	 * only what is used.
-	 */
-	temp = spl_fixpt_add(*init, spl_fixpt_mul_int(ratio, recout_size - 1));
-	*vp_size = spl_fixpt_floor(temp);
-	if (*vp_size + *vp_offset > src_size)
-		*vp_size = src_size - *vp_offset;
-
-	/* We did all the math assuming we are scanning same direction as display does,
-	 * however mirror/rotation changes how vp scans vs how it is offset. If scan direction
-	 * is flipped we simply need to calculate offset from the other side of plane.
-	 * Note that outside of viewport all scaling hardware works in recout space.
-	 */
-	if (flip_scan_dir)
-		*vp_offset = src_size - *vp_offset - *vp_size;
-}
-
-/*Calculate inits and viewport */
-static void spl_calculate_inits_and_viewports(struct spl_in *spl_in,
-		struct spl_scratch *spl_scratch)
-{
-	struct spl_rect src = spl_in->basic_in.src_rect;
-	struct spl_rect recout_dst_in_active_timing;
-	struct spl_rect recout_clip_in_active_timing;
-	struct spl_rect recout_clip_in_recout_dst;
-	struct spl_rect overlap_in_active_timing;
-	struct spl_rect odm_slice = calculate_odm_slice_in_timing_active(spl_in);
-	int vpc_div = spl_is_subsampled_format(spl_in->basic_in.format) ? 2 : 1;
-	bool orthogonal_rotation, flip_vert_scan_dir, flip_horz_scan_dir;
-	struct spl_fixed31_32 init_adj_h = spl_fixpt_zero;
-	struct spl_fixed31_32 init_adj_v = spl_fixpt_zero;
-
-	recout_clip_in_active_timing = shift_rec(
-			&spl_scratch->scl_data.recout, odm_slice.x, odm_slice.y);
-	recout_dst_in_active_timing = calculate_plane_rec_in_timing_active(
-			spl_in, &spl_in->basic_in.dst_rect);
-	overlap_in_active_timing = intersect_rec(&recout_clip_in_active_timing,
-			&recout_dst_in_active_timing);
-	if (overlap_in_active_timing.width > 0 &&
-			overlap_in_active_timing.height > 0)
-		recout_clip_in_recout_dst = shift_rec(&overlap_in_active_timing,
-				-recout_dst_in_active_timing.x,
-				-recout_dst_in_active_timing.y);
-	else
-		memset(&recout_clip_in_recout_dst, 0, sizeof(struct spl_rect));
-	/*
-	 * Work in recout rotation since that requires less transformations
-	 */
-	spl_get_vp_scan_direction(
-			spl_in->basic_in.rotation,
-			spl_in->basic_in.horizontal_mirror,
-			&orthogonal_rotation,
-			&flip_vert_scan_dir,
-			&flip_horz_scan_dir);
-
-	if (spl_is_subsampled_format(spl_in->basic_in.format)) {
-		/* this gives the direction of the cositing (negative will move
-		 * left, right otherwise)
-		 */
-		int sign = 1;
-
-		switch (spl_in->basic_in.cositing) {
-
-		case CHROMA_COSITING_TOPLEFT:
-			init_adj_h = spl_fixpt_from_fraction(sign, 4);
-			init_adj_v = spl_fixpt_from_fraction(sign, 4);
-			break;
-		case CHROMA_COSITING_LEFT:
-			init_adj_h = spl_fixpt_from_fraction(sign, 4);
-			init_adj_v = spl_fixpt_zero;
-			break;
-		case CHROMA_COSITING_NONE:
-		default:
-			init_adj_h = spl_fixpt_zero;
-			init_adj_v = spl_fixpt_zero;
-			break;
-		}
-	}
-
-	if (orthogonal_rotation) {
-		spl_swap(src.width, src.height);
-		spl_swap(flip_vert_scan_dir, flip_horz_scan_dir);
-		spl_swap(init_adj_h, init_adj_v);
-	}
-
-	spl_calculate_init_and_vp(
-			flip_horz_scan_dir,
-			recout_clip_in_recout_dst.x,
-			spl_scratch->scl_data.recout.width,
-			src.width,
-			spl_scratch->scl_data.taps.h_taps,
-			spl_scratch->scl_data.ratios.horz,
-			spl_fixpt_zero,
-			&spl_scratch->scl_data.inits.h,
-			&spl_scratch->scl_data.viewport.x,
-			&spl_scratch->scl_data.viewport.width);
-	spl_calculate_init_and_vp(
-			flip_horz_scan_dir,
-			recout_clip_in_recout_dst.x,
-			spl_scratch->scl_data.recout.width,
-			src.width / vpc_div,
-			spl_scratch->scl_data.taps.h_taps_c,
-			spl_scratch->scl_data.ratios.horz_c,
-			init_adj_h,
-			&spl_scratch->scl_data.inits.h_c,
-			&spl_scratch->scl_data.viewport_c.x,
-			&spl_scratch->scl_data.viewport_c.width);
-	spl_calculate_init_and_vp(
-			flip_vert_scan_dir,
-			recout_clip_in_recout_dst.y,
-			spl_scratch->scl_data.recout.height,
-			src.height,
-			spl_scratch->scl_data.taps.v_taps,
-			spl_scratch->scl_data.ratios.vert,
-			spl_fixpt_zero,
-			&spl_scratch->scl_data.inits.v,
-			&spl_scratch->scl_data.viewport.y,
-			&spl_scratch->scl_data.viewport.height);
-	spl_calculate_init_and_vp(
-			flip_vert_scan_dir,
-			recout_clip_in_recout_dst.y,
-			spl_scratch->scl_data.recout.height,
-			src.height / vpc_div,
-			spl_scratch->scl_data.taps.v_taps_c,
-			spl_scratch->scl_data.ratios.vert_c,
-			init_adj_v,
-			&spl_scratch->scl_data.inits.v_c,
-			&spl_scratch->scl_data.viewport_c.y,
-			&spl_scratch->scl_data.viewport_c.height);
-	if (orthogonal_rotation) {
-		spl_swap(spl_scratch->scl_data.viewport.x, spl_scratch->scl_data.viewport.y);
-		spl_swap(spl_scratch->scl_data.viewport.width, spl_scratch->scl_data.viewport.height);
-		spl_swap(spl_scratch->scl_data.viewport_c.x, spl_scratch->scl_data.viewport_c.y);
-		spl_swap(spl_scratch->scl_data.viewport_c.width, spl_scratch->scl_data.viewport_c.height);
-	}
-	spl_scratch->scl_data.viewport.x += src.x;
-	spl_scratch->scl_data.viewport.y += src.y;
-	SPL_ASSERT(src.x % vpc_div == 0 && src.y % vpc_div == 0);
-	spl_scratch->scl_data.viewport_c.x += src.x / vpc_div;
-	spl_scratch->scl_data.viewport_c.y += src.y / vpc_div;
-}
-
-static void spl_handle_3d_recout(struct spl_in *spl_in, struct spl_rect *recout)
-{
-	/*
-	 * Handle side by side and top bottom 3d recout offsets after vp calculation
-	 * since 3d is special and needs to calculate vp as if there is no recout offset
-	 * This may break with rotation, good thing we aren't mixing hw rotation and 3d
-	 */
-	if (spl_in->basic_in.mpc_h_slice_index) {
-		SPL_ASSERT(spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_0 ||
-			(spl_in->basic_out.view_format != SPL_VIEW_3D_TOP_AND_BOTTOM &&
-					spl_in->basic_out.view_format != SPL_VIEW_3D_SIDE_BY_SIDE));
-		if (spl_in->basic_out.view_format == SPL_VIEW_3D_TOP_AND_BOTTOM)
-			recout->y += recout->height;
-		else if (spl_in->basic_out.view_format == SPL_VIEW_3D_SIDE_BY_SIDE)
-			recout->x += recout->width;
-	}
-}
-
-static void spl_clamp_viewport(struct spl_rect *viewport)
-{
-	/* Clamp minimum viewport size */
-	if (viewport->height < MIN_VIEWPORT_SIZE)
-		viewport->height = MIN_VIEWPORT_SIZE;
-	if (viewport->width < MIN_VIEWPORT_SIZE)
-		viewport->width = MIN_VIEWPORT_SIZE;
-}
-
-static enum scl_mode spl_get_dscl_mode(const struct spl_in *spl_in,
-				const struct spl_scaler_data *data,
-				bool enable_isharp, bool enable_easf)
-{
-	const long long one = spl_fixpt_one.value;
-	enum spl_pixel_format pixel_format = spl_in->basic_in.format;
-
-	/* Bypass if ratio is 1:1 with no ISHARP or force scale on */
-	if (data->ratios.horz.value == one
-			&& data->ratios.vert.value == one
-			&& data->ratios.horz_c.value == one
-			&& data->ratios.vert_c.value == one
-			&& !spl_in->basic_out.always_scale
-			&& !enable_isharp)
-		return SCL_MODE_SCALING_444_BYPASS;
-
-	if (!spl_is_subsampled_format(pixel_format)) {
-		if (spl_is_video_format(pixel_format))
-			return SCL_MODE_SCALING_444_YCBCR_ENABLE;
-		else
-			return SCL_MODE_SCALING_444_RGB_ENABLE;
-	}
-
-	/*
-	 * Bypass YUV if Y is 1:1 with no ISHARP
-	 * Do not bypass UV at 1:1 for cositing to be applied
-	 */
-	if (!enable_isharp) {
-		if (data->ratios.horz.value == one && data->ratios.vert.value == one)
-			return SCL_MODE_SCALING_420_LUMA_BYPASS;
-	}
-
-	return SCL_MODE_SCALING_420_YCBCR_ENABLE;
-}
-
-static bool spl_choose_lls_policy(enum spl_pixel_format format,
-	enum spl_transfer_func_type tf_type,
-	enum spl_transfer_func_predefined tf_predefined_type,
-	enum linear_light_scaling *lls_pref)
-{
-	if (spl_is_video_format(format)) {
-		*lls_pref = LLS_PREF_NO;
-		if ((tf_type == SPL_TF_TYPE_PREDEFINED) ||
-			(tf_type == SPL_TF_TYPE_DISTRIBUTED_POINTS))
-			return true;
-	} else { /* RGB or YUV444 */
-		if ((tf_type == SPL_TF_TYPE_PREDEFINED) ||
-			(tf_type == SPL_TF_TYPE_BYPASS)) {
-			*lls_pref = LLS_PREF_YES;
-			return true;
-		}
-	}
-	*lls_pref = LLS_PREF_NO;
-	return false;
-}
-
-/* Enable EASF ?*/
-static bool enable_easf(struct spl_in *spl_in, struct spl_scratch *spl_scratch)
-{
-	int vratio = 0;
-	int hratio = 0;
-	bool skip_easf = false;
-	bool lls_enable_easf = true;
-
-	if (spl_in->disable_easf)
-		skip_easf = true;
-
-	vratio = spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert);
-	hratio = spl_fixpt_ceil(spl_scratch->scl_data.ratios.horz);
-
-	/*
-	 * No EASF support for downscaling > 2:1
-	 * EASF support for upscaling or downscaling up to 2:1
-	 */
-	if ((vratio > 2) || (hratio > 2))
-		skip_easf = true;
-
-	/*
-	 * If lls_pref is LLS_PREF_DONT_CARE, then use pixel format and transfer
-	 *  function to determine whether to use LINEAR or NONLINEAR scaling
-	 */
-	if (spl_in->lls_pref == LLS_PREF_DONT_CARE)
-		lls_enable_easf = spl_choose_lls_policy(spl_in->basic_in.format,
-			spl_in->basic_in.tf_type, spl_in->basic_in.tf_predefined_type,
-			&spl_in->lls_pref);
-
-	if (!lls_enable_easf)
-		skip_easf = true;
-
-	/* Check for linear scaling or EASF preferred */
-	if (spl_in->lls_pref != LLS_PREF_YES && !spl_in->prefer_easf)
-		skip_easf = true;
-
-	return skip_easf;
-}
-
-/* Check if video is in fullscreen mode */
-static bool spl_is_video_fullscreen(struct spl_in *spl_in)
-{
-	if (spl_is_video_format(spl_in->basic_in.format) && spl_in->is_fullscreen)
-		return true;
-	return false;
-}
-
-static bool spl_get_isharp_en(struct spl_in *spl_in,
-	struct spl_scratch *spl_scratch)
-{
-	bool enable_isharp = false;
-	int vratio = 0;
-	int hratio = 0;
-	struct spl_taps taps = spl_scratch->scl_data.taps;
-	bool fullscreen = spl_is_video_fullscreen(spl_in);
-
-	/* Return if adaptive sharpness is disabled */
-	if (spl_in->adaptive_sharpness.enable == false)
-		return enable_isharp;
-
-	vratio = spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert);
-	hratio = spl_fixpt_ceil(spl_scratch->scl_data.ratios.horz);
-
-	/* No iSHARP support for downscaling */
-	if (vratio > 1 || hratio > 1)
-		return enable_isharp;
-
-	// Scaling is up to 1:1 (no scaling) or upscaling
-
-	/*
-	 * Apply sharpness to RGB and YUV (NV12/P010)
-	 *  surfaces based on policy setting
-	 */
-	if (!spl_is_video_format(spl_in->basic_in.format) &&
-		(spl_in->sharpen_policy == SHARPEN_YUV))
-		return enable_isharp;
-	else if ((spl_is_video_format(spl_in->basic_in.format) && !fullscreen) &&
-		(spl_in->sharpen_policy == SHARPEN_RGB_FULLSCREEN_YUV))
-		return enable_isharp;
-	else if (!spl_in->is_fullscreen &&
-			spl_in->sharpen_policy == SHARPEN_FULLSCREEN_ALL)
-		return enable_isharp;
-
-	/*
-	 * Apply sharpness if supports horizontal taps 4,6 AND
-	 *  vertical taps 3, 4, 6
-	 */
-	if ((taps.h_taps == 4 || taps.h_taps == 6) &&
-		(taps.v_taps == 3 || taps.v_taps == 4 || taps.v_taps == 6))
-		enable_isharp = true;
-
-	return enable_isharp;
-}
-
-/* Calculate number of tap with adaptive scaling off */
-static void spl_get_taps_non_adaptive_scaler(
-	  struct spl_scratch *spl_scratch, const struct spl_taps *in_taps)
-{
-	if (in_taps->h_taps == 0) {
-		if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.horz) > 1)
-			spl_scratch->scl_data.taps.h_taps = spl_min(2 * spl_fixpt_ceil(
-				spl_scratch->scl_data.ratios.horz), 8);
-		else
-			spl_scratch->scl_data.taps.h_taps = 4;
-	} else
-		spl_scratch->scl_data.taps.h_taps = in_taps->h_taps;
-
-	if (in_taps->v_taps == 0) {
-		if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert) > 1)
-			spl_scratch->scl_data.taps.v_taps = spl_min(2 * spl_fixpt_ceil(
-				spl_scratch->scl_data.ratios.vert), 8);
-		else
-			spl_scratch->scl_data.taps.v_taps = 4;
-	} else
-		spl_scratch->scl_data.taps.v_taps = in_taps->v_taps;
-
-	if (in_taps->v_taps_c == 0) {
-		if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert_c) > 1)
-			spl_scratch->scl_data.taps.v_taps_c = spl_min(2 * spl_fixpt_ceil(
-				spl_scratch->scl_data.ratios.vert_c), 8);
-		else
-			spl_scratch->scl_data.taps.v_taps_c = 4;
-	} else
-		spl_scratch->scl_data.taps.v_taps_c = in_taps->v_taps_c;
-
-	if (in_taps->h_taps_c == 0) {
-		if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.horz_c) > 1)
-			spl_scratch->scl_data.taps.h_taps_c = spl_min(2 * spl_fixpt_ceil(
-				spl_scratch->scl_data.ratios.horz_c), 8);
-		else
-			spl_scratch->scl_data.taps.h_taps_c = 4;
-	} else if ((in_taps->h_taps_c % 2) != 0 && in_taps->h_taps_c != 1)
-		/* Only 1 and even h_taps_c are supported by hw */
-		spl_scratch->scl_data.taps.h_taps_c = in_taps->h_taps_c - 1;
-	else
-		spl_scratch->scl_data.taps.h_taps_c = in_taps->h_taps_c;
-
-	if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz))
-		spl_scratch->scl_data.taps.h_taps = 1;
-	if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert))
-		spl_scratch->scl_data.taps.v_taps = 1;
-	if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz_c))
-		spl_scratch->scl_data.taps.h_taps_c = 1;
-	if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert_c))
-		spl_scratch->scl_data.taps.v_taps_c = 1;
-
-}
-
-/* Calculate optimal number of taps */
-static bool spl_get_optimal_number_of_taps(
-	  int max_downscale_src_width, struct spl_in *spl_in, struct spl_scratch *spl_scratch,
-	  const struct spl_taps *in_taps, bool *enable_easf_v, bool *enable_easf_h,
-	  bool *enable_isharp)
-{
-	int num_part_y, num_part_c;
-	int max_taps_y, max_taps_c;
-	int min_taps_y, min_taps_c;
-	enum lb_memory_config lb_config;
-	bool skip_easf = false;
-	bool is_subsampled = spl_is_subsampled_format(spl_in->basic_in.format);
-
-	if (spl_scratch->scl_data.viewport.width > spl_scratch->scl_data.h_active &&
-		max_downscale_src_width != 0 &&
-		spl_scratch->scl_data.viewport.width > max_downscale_src_width) {
-		spl_get_taps_non_adaptive_scaler(spl_scratch, in_taps);
-		*enable_easf_v = false;
-		*enable_easf_h = false;
-		*enable_isharp = false;
-		return false;
-	}
-
-	/* Disable adaptive scaler and sharpener when integer scaling is enabled */
-	if (spl_in->scaling_quality.integer_scaling) {
-		spl_get_taps_non_adaptive_scaler(spl_scratch, in_taps);
-		*enable_easf_v = false;
-		*enable_easf_h = false;
-		*enable_isharp = false;
-		return true;
-	}
-
-	/* Check if we are using EASF or not */
-	skip_easf = enable_easf(spl_in, spl_scratch);
-
-	/*
-	 * Set default taps if none are provided
-	 * From programming guide: taps = min{ ceil(2*H_RATIO,1), 8} for downscaling
-	 * taps = 4 for upscaling
-	 */
-	if (skip_easf)
-		spl_get_taps_non_adaptive_scaler(spl_scratch, in_taps);
-	else {
-		if (spl_is_video_format(spl_in->basic_in.format)) {
-			spl_scratch->scl_data.taps.h_taps = 6;
-			spl_scratch->scl_data.taps.v_taps = 6;
-			spl_scratch->scl_data.taps.h_taps_c = 4;
-			spl_scratch->scl_data.taps.v_taps_c = 4;
-		} else { /* RGB */
-			spl_scratch->scl_data.taps.h_taps = 6;
-			spl_scratch->scl_data.taps.v_taps = 6;
-			spl_scratch->scl_data.taps.h_taps_c = 6;
-			spl_scratch->scl_data.taps.v_taps_c = 6;
-		}
-	}
-
-	/*Ensure we can support the requested number of vtaps*/
-	min_taps_y = spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert);
-	min_taps_c = spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert_c);
-
-	/* Use LB_MEMORY_CONFIG_3 for 4:2:0 */
-	if (spl_is_yuv420(spl_in->basic_in.format))
-		lb_config = LB_MEMORY_CONFIG_3;
-	else
-		lb_config = LB_MEMORY_CONFIG_0;
-	// Determine max vtap support by calculating how much line buffer can fit
-	spl_in->callbacks.spl_calc_lb_num_partitions(spl_in->basic_out.alpha_en, &spl_scratch->scl_data,
-			lb_config, &num_part_y, &num_part_c);
-	/* MAX_V_TAPS = MIN (NUM_LINES - MAX(CEILING(V_RATIO,1)-2, 0), 8) */
-	if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert) > 2)
-		max_taps_y = num_part_y - (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert) - 2);
-	else
-		max_taps_y = num_part_y;
-
-	if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert_c) > 2)
-		max_taps_c = num_part_c - (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert_c) - 2);
-	else
-		max_taps_c = num_part_c;
-
-	if (max_taps_y < min_taps_y)
-		return false;
-	else if (max_taps_c < min_taps_c)
-		return false;
-
-	if (spl_scratch->scl_data.taps.v_taps > max_taps_y)
-		spl_scratch->scl_data.taps.v_taps = max_taps_y;
-
-	if (spl_scratch->scl_data.taps.v_taps_c > max_taps_c)
-		spl_scratch->scl_data.taps.v_taps_c = max_taps_c;
-
-	if (!skip_easf) {
-		/*
-		 * RGB ( L + NL ) and Linear HDR support 6x6, 6x4, 6x3, 4x4, 4x3
-		 * NL YUV420 only supports 6x6, 6x4 for Y and 4x4 for UV
-		 *
-		 * If LB does not support 3, 4, or 6 taps, then disable EASF_V
-		 *  and only enable EASF_H.  So for RGB, support 6x2, 4x2
-		 *  and for NL YUV420, support 6x2 for Y and 4x2 for UV
-		 *
-		 * All other cases, have to disable EASF_V and EASF_H
-		 *
-		 * If optimal no of taps is 5, then set it to 4
-		 * If optimal no of taps is 7 or 8, then fine since max tap is 6
-		 *
-		 */
-		if (spl_scratch->scl_data.taps.v_taps == 5)
-			spl_scratch->scl_data.taps.v_taps = 4;
-
-		if (spl_scratch->scl_data.taps.v_taps_c == 5)
-			spl_scratch->scl_data.taps.v_taps_c = 4;
-
-		if (spl_scratch->scl_data.taps.h_taps == 5)
-			spl_scratch->scl_data.taps.h_taps = 4;
-
-		if (spl_scratch->scl_data.taps.h_taps_c == 5)
-			spl_scratch->scl_data.taps.h_taps_c = 4;
-
-		if (spl_is_video_format(spl_in->basic_in.format)) {
-			if (spl_scratch->scl_data.taps.h_taps <= 4) {
-				*enable_easf_v = false;
-				*enable_easf_h = false;
-			} else if (spl_scratch->scl_data.taps.v_taps <= 3) {
-				*enable_easf_v = false;
-				*enable_easf_h = true;
-			} else {
-				*enable_easf_v = true;
-				*enable_easf_h = true;
-			}
-			SPL_ASSERT((spl_scratch->scl_data.taps.v_taps > 1) &&
-				(spl_scratch->scl_data.taps.v_taps_c > 1));
-		} else { /* RGB */
-			if (spl_scratch->scl_data.taps.h_taps <= 3) {
-				*enable_easf_v = false;
-				*enable_easf_h = false;
-			} else if (spl_scratch->scl_data.taps.v_taps < 3) {
-				*enable_easf_v = false;
-				*enable_easf_h = true;
-			} else {
-				*enable_easf_v = true;
-				*enable_easf_h = true;
-			}
-			SPL_ASSERT(spl_scratch->scl_data.taps.v_taps > 1);
-		}
-	} else {
-		*enable_easf_v = false;
-		*enable_easf_h = false;
-	} // end of if prefer_easf
-
-	/* Sharpener requires scaler to be enabled, including for 1:1
-	 * Check if ISHARP can be enabled
-	 * If ISHARP is not enabled, set taps to 1 if ratio is 1:1
-	 *  except for chroma taps.  Keep previous taps so it can
-	 *  handle cositing
-	 */
-
-	*enable_isharp = spl_get_isharp_en(spl_in, spl_scratch);
-	if (!*enable_isharp && !spl_in->basic_out.always_scale)	{
-		if ((IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz)) &&
-			(IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert))) {
-			spl_scratch->scl_data.taps.h_taps = 1;
-			spl_scratch->scl_data.taps.v_taps = 1;
-
-			if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz_c) && !is_subsampled)
-				spl_scratch->scl_data.taps.h_taps_c = 1;
-
-			if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert_c) && !is_subsampled)
-				spl_scratch->scl_data.taps.v_taps_c = 1;
-
-			*enable_easf_v = false;
-			*enable_easf_h = false;
-		} else {
-			if ((!*enable_easf_h) &&
-				(IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz)))
-				spl_scratch->scl_data.taps.h_taps = 1;
-
-			if ((!*enable_easf_v) &&
-				(IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert)))
-				spl_scratch->scl_data.taps.v_taps = 1;
-
-			if ((!*enable_easf_h) && !is_subsampled &&
-				(IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz_c)))
-				spl_scratch->scl_data.taps.h_taps_c = 1;
-
-			if ((!*enable_easf_v) && !is_subsampled &&
-				(IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert_c)))
-				spl_scratch->scl_data.taps.v_taps_c = 1;
-		}
-	}
-	return true;
-}
-
-static void spl_set_black_color_data(enum spl_pixel_format format,
-			struct scl_black_color *scl_black_color)
-{
-	bool ycbcr = spl_is_video_format(format);
-	if (ycbcr)	{
-		scl_black_color->offset_rgb_y = BLACK_OFFSET_RGB_Y;
-		scl_black_color->offset_rgb_cbcr = BLACK_OFFSET_CBCR;
-	}	else {
-		scl_black_color->offset_rgb_y = 0x0;
-		scl_black_color->offset_rgb_cbcr = 0x0;
-	}
-}
-
-static void spl_set_manual_ratio_init_data(struct dscl_prog_data *dscl_prog_data,
-		const struct spl_scaler_data *scl_data)
-{
-	struct spl_fixed31_32 bot;
-
-	dscl_prog_data->ratios.h_scale_ratio = spl_fixpt_u3d19(scl_data->ratios.horz) << 5;
-	dscl_prog_data->ratios.v_scale_ratio = spl_fixpt_u3d19(scl_data->ratios.vert) << 5;
-	dscl_prog_data->ratios.h_scale_ratio_c = spl_fixpt_u3d19(scl_data->ratios.horz_c) << 5;
-	dscl_prog_data->ratios.v_scale_ratio_c = spl_fixpt_u3d19(scl_data->ratios.vert_c) << 5;
-	/*
-	 * 0.24 format for fraction, first five bits zeroed
-	 */
-	dscl_prog_data->init.h_filter_init_frac =
-			spl_fixpt_u0d19(scl_data->inits.h) << 5;
-	dscl_prog_data->init.h_filter_init_int =
-			spl_fixpt_floor(scl_data->inits.h);
-	dscl_prog_data->init.h_filter_init_frac_c =
-			spl_fixpt_u0d19(scl_data->inits.h_c) << 5;
-	dscl_prog_data->init.h_filter_init_int_c =
-			spl_fixpt_floor(scl_data->inits.h_c);
-	dscl_prog_data->init.v_filter_init_frac =
-			spl_fixpt_u0d19(scl_data->inits.v) << 5;
-	dscl_prog_data->init.v_filter_init_int =
-			spl_fixpt_floor(scl_data->inits.v);
-	dscl_prog_data->init.v_filter_init_frac_c =
-			spl_fixpt_u0d19(scl_data->inits.v_c) << 5;
-	dscl_prog_data->init.v_filter_init_int_c =
-			spl_fixpt_floor(scl_data->inits.v_c);
-
-	bot = spl_fixpt_add(scl_data->inits.v, scl_data->ratios.vert);
-	dscl_prog_data->init.v_filter_init_bot_frac = spl_fixpt_u0d19(bot) << 5;
-	dscl_prog_data->init.v_filter_init_bot_int = spl_fixpt_floor(bot);
-	bot = spl_fixpt_add(scl_data->inits.v_c, scl_data->ratios.vert_c);
-	dscl_prog_data->init.v_filter_init_bot_frac_c = spl_fixpt_u0d19(bot) << 5;
-	dscl_prog_data->init.v_filter_init_bot_int_c = spl_fixpt_floor(bot);
-}
-
-static void spl_set_taps_data(struct dscl_prog_data *dscl_prog_data,
-		const struct spl_scaler_data *scl_data)
-{
-	dscl_prog_data->taps.v_taps = scl_data->taps.v_taps - 1;
-	dscl_prog_data->taps.h_taps = scl_data->taps.h_taps - 1;
-	dscl_prog_data->taps.v_taps_c = scl_data->taps.v_taps_c - 1;
-	dscl_prog_data->taps.h_taps_c = scl_data->taps.h_taps_c - 1;
-}
-
-/* Populate dscl prog data structure from scaler data calculated by SPL */
-static void spl_set_dscl_prog_data(struct spl_in *spl_in, struct spl_scratch *spl_scratch,
-	struct spl_out *spl_out, bool enable_easf_v, bool enable_easf_h, bool enable_isharp)
-{
-	struct dscl_prog_data *dscl_prog_data = spl_out->dscl_prog_data;
-
-	const struct spl_scaler_data *data = &spl_scratch->scl_data;
-
-	struct scl_black_color *scl_black_color = &dscl_prog_data->scl_black_color;
-
-	bool enable_easf = enable_easf_v || enable_easf_h;
-
-	// Set values for recout
-	dscl_prog_data->recout = spl_scratch->scl_data.recout;
-	// Set values for MPC Size
-	dscl_prog_data->mpc_size.width = spl_scratch->scl_data.h_active;
-	dscl_prog_data->mpc_size.height = spl_scratch->scl_data.v_active;
-
-	// SCL_MODE - Set SCL_MODE data
-	dscl_prog_data->dscl_mode = spl_get_dscl_mode(spl_in, data, enable_isharp,
-		enable_easf);
-
-	// SCL_BLACK_COLOR
-	spl_set_black_color_data(spl_in->basic_in.format, scl_black_color);
-
-	/* Manually calculate scale ratio and init values */
-	spl_set_manual_ratio_init_data(dscl_prog_data, data);
-
-	// Set HTaps/VTaps
-	spl_set_taps_data(dscl_prog_data, data);
-	// Set viewport
-	dscl_prog_data->viewport = spl_scratch->scl_data.viewport;
-	// Set viewport_c
-	dscl_prog_data->viewport_c = spl_scratch->scl_data.viewport_c;
-	// Set filters data
-	spl_set_filters_data(dscl_prog_data, data, enable_easf_v, enable_easf_h);
-}
-
-/* Calculate C0-C3 coefficients based on HDR_mult */
-static void spl_calculate_c0_c3_hdr(struct dscl_prog_data *dscl_prog_data, uint32_t sdr_white_level_nits)
-{
-	struct spl_fixed31_32 hdr_mult, c0_mult, c1_mult, c2_mult;
-	struct spl_fixed31_32 c0_calc, c1_calc, c2_calc;
-	struct spl_custom_float_format fmt;
-	uint32_t hdr_multx100_int;
-
-	if ((sdr_white_level_nits >= 80) && (sdr_white_level_nits <= 480))
-		hdr_multx100_int = sdr_white_level_nits * 100 / 80;
-	else
-		hdr_multx100_int = 100; /* default for 80 nits otherwise */
-
-	hdr_mult = spl_fixpt_from_fraction((long long)hdr_multx100_int, 100LL);
-	c0_mult = spl_fixpt_from_fraction(2126LL, 10000LL);
-	c1_mult = spl_fixpt_from_fraction(7152LL, 10000LL);
-	c2_mult = spl_fixpt_from_fraction(722LL, 10000LL);
-
-	c0_calc = spl_fixpt_mul(hdr_mult, spl_fixpt_mul(c0_mult, spl_fixpt_from_fraction(
-		16384LL, 125LL)));
-	c1_calc = spl_fixpt_mul(hdr_mult, spl_fixpt_mul(c1_mult, spl_fixpt_from_fraction(
-		16384LL, 125LL)));
-	c2_calc = spl_fixpt_mul(hdr_mult, spl_fixpt_mul(c2_mult, spl_fixpt_from_fraction(
-		16384LL, 125LL)));
-
-	fmt.exponenta_bits = 5;
-	fmt.mantissa_bits = 10;
-	fmt.sign = true;
-
-	// fp1.5.10, C0 coefficient (LN_rec709:  HDR_MULT * 0.212600 * 2^14/125)
-	spl_convert_to_custom_float_format(c0_calc, &fmt, &dscl_prog_data->easf_matrix_c0);
-	// fp1.5.10, C1 coefficient (LN_rec709:  HDR_MULT * 0.715200 * 2^14/125)
-	spl_convert_to_custom_float_format(c1_calc, &fmt, &dscl_prog_data->easf_matrix_c1);
-	// fp1.5.10, C2 coefficient (LN_rec709:  HDR_MULT * 0.072200 * 2^14/125)
-	spl_convert_to_custom_float_format(c2_calc, &fmt, &dscl_prog_data->easf_matrix_c2);
-	dscl_prog_data->easf_matrix_c3 = 0x0; // fp1.5.10, C3 coefficient
-}
-
-/* Set EASF data */
-static void spl_set_easf_data(struct spl_scratch *spl_scratch, struct spl_out *spl_out, bool enable_easf_v,
-	bool enable_easf_h, enum linear_light_scaling lls_pref,
-	enum spl_pixel_format format, enum system_setup setup,
-	uint32_t sdr_white_level_nits)
-{
-	struct dscl_prog_data *dscl_prog_data = spl_out->dscl_prog_data;
-	if (enable_easf_v) {
-		dscl_prog_data->easf_v_en = true;
-		dscl_prog_data->easf_v_ring = 0;
-		dscl_prog_data->easf_v_sharp_factor = 0;
-		dscl_prog_data->easf_v_bf1_en = 1;	// 1-bit, BF1 calculation enable, 0=disable, 1=enable
-		dscl_prog_data->easf_v_bf2_mode = 0xF;	// 4-bit, BF2 calculation mode
-		/* 2-bit, BF3 chroma mode correction calculation mode */
-		dscl_prog_data->easf_v_bf3_mode = spl_get_v_bf3_mode(
-			spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10 [ minCoef ]*/
-		dscl_prog_data->easf_v_ringest_3tap_dntilt_uptilt =
-			spl_get_3tap_dntilt_uptilt_offset(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10 [ upTiltMaxVal ]*/
-		dscl_prog_data->easf_v_ringest_3tap_uptilt_max =
-			spl_get_3tap_uptilt_maxval(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10 [ dnTiltSlope ]*/
-		dscl_prog_data->easf_v_ringest_3tap_dntilt_slope =
-			spl_get_3tap_dntilt_slope(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10 [ upTilt1Slope ]*/
-		dscl_prog_data->easf_v_ringest_3tap_uptilt1_slope =
-			spl_get_3tap_uptilt1_slope(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10 [ upTilt2Slope ]*/
-		dscl_prog_data->easf_v_ringest_3tap_uptilt2_slope =
-			spl_get_3tap_uptilt2_slope(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10 [ upTilt2Offset ]*/
-		dscl_prog_data->easf_v_ringest_3tap_uptilt2_offset =
-			spl_get_3tap_uptilt2_offset(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10; (2.0) Ring reducer gain for 4 or 6-tap mode [H_REDUCER_GAIN4] */
-		dscl_prog_data->easf_v_ringest_eventap_reduceg1 =
-			spl_get_reducer_gain4(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10; (2.5) Ring reducer gain for 6-tap mode [V_REDUCER_GAIN6] */
-		dscl_prog_data->easf_v_ringest_eventap_reduceg2 =
-			spl_get_reducer_gain6(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10; (-0.135742) Ring gain for 6-tap set to -139/1024 */
-		dscl_prog_data->easf_v_ringest_eventap_gain1 =
-			spl_get_gainRing4(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		/* FP1.5.10; (-0.024414) Ring gain for 6-tap set to -25/1024 */
-		dscl_prog_data->easf_v_ringest_eventap_gain2 =
-			spl_get_gainRing6(spl_scratch->scl_data.taps.v_taps,
-				spl_scratch->scl_data.recip_ratios.vert);
-		dscl_prog_data->easf_v_bf_maxa = 63; //Vertical Max BF value A in U0.6 format.Selected if V_FCNTL == 0
-		dscl_prog_data->easf_v_bf_maxb = 63; //Vertical Max BF value A in U0.6 format.Selected if V_FCNTL == 1
-		dscl_prog_data->easf_v_bf_mina = 0;	//Vertical Min BF value A in U0.6 format.Selected if V_FCNTL == 0
-		dscl_prog_data->easf_v_bf_minb = 0;	//Vertical Min BF value A in U0.6 format.Selected if V_FCNTL == 1
-		if (lls_pref == LLS_PREF_YES)	{
-			dscl_prog_data->easf_v_bf2_flat1_gain = 4;	// U1.3, BF2 Flat1 Gain control
-			dscl_prog_data->easf_v_bf2_flat2_gain = 8;	// U4.0, BF2 Flat2 Gain control
-			dscl_prog_data->easf_v_bf2_roc_gain = 4;	// U2.2, Rate Of Change control
-
-			dscl_prog_data->easf_v_bf1_pwl_in_seg0 = 0x600;	// S0.10, BF1 PWL Segment 0 = -512
-			dscl_prog_data->easf_v_bf1_pwl_base_seg0 = 0;	// U0.6, BF1 Base PWL Segment 0
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg0 = 3;	// S7.3, BF1 Slope PWL Segment 0
-			dscl_prog_data->easf_v_bf1_pwl_in_seg1 = 0x7EC;	// S0.10, BF1 PWL Segment 1 = -20
-			dscl_prog_data->easf_v_bf1_pwl_base_seg1 = 12;	// U0.6, BF1 Base PWL Segment 1
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg1 = 326;	// S7.3, BF1 Slope PWL Segment 1
-			dscl_prog_data->easf_v_bf1_pwl_in_seg2 = 0;	// S0.10, BF1 PWL Segment 2
-			dscl_prog_data->easf_v_bf1_pwl_base_seg2 = 63;	// U0.6, BF1 Base PWL Segment 2
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg2 = 0;	// S7.3, BF1 Slope PWL Segment 2
-			dscl_prog_data->easf_v_bf1_pwl_in_seg3 = 16;	// S0.10, BF1 PWL Segment 3
-			dscl_prog_data->easf_v_bf1_pwl_base_seg3 = 63;	// U0.6, BF1 Base PWL Segment 3
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg3 = 0x7C8;	// S7.3, BF1 Slope PWL Segment 3 = -56
-			dscl_prog_data->easf_v_bf1_pwl_in_seg4 = 32;	// S0.10, BF1 PWL Segment 4
-			dscl_prog_data->easf_v_bf1_pwl_base_seg4 = 56;	// U0.6, BF1 Base PWL Segment 4
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg4 = 0x7D0;	// S7.3, BF1 Slope PWL Segment 4 = -48
-			dscl_prog_data->easf_v_bf1_pwl_in_seg5 = 48;	// S0.10, BF1 PWL Segment 5
-			dscl_prog_data->easf_v_bf1_pwl_base_seg5 = 50;	// U0.6, BF1 Base PWL Segment 5
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg5 = 0x710;	// S7.3, BF1 Slope PWL Segment 5 = -240
-			dscl_prog_data->easf_v_bf1_pwl_in_seg6 = 64;	// S0.10, BF1 PWL Segment 6
-			dscl_prog_data->easf_v_bf1_pwl_base_seg6 = 20;	// U0.6, BF1 Base PWL Segment 6
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg6 = 0x760;	// S7.3, BF1 Slope PWL Segment 6 = -160
-			dscl_prog_data->easf_v_bf1_pwl_in_seg7 = 80;	// S0.10, BF1 PWL Segment 7
-			dscl_prog_data->easf_v_bf1_pwl_base_seg7 = 0;	// U0.6, BF1 Base PWL Segment 7
-
-			dscl_prog_data->easf_v_bf3_pwl_in_set0 = 0x000;	// FP0.6.6, BF3 Input value PWL Segment 0
-			dscl_prog_data->easf_v_bf3_pwl_base_set0 = 63;	// S0.6, BF3 Base PWL Segment 0
-			dscl_prog_data->easf_v_bf3_pwl_slope_set0 = 0x12C5;	// FP1.6.6, BF3 Slope PWL Segment 0
-			dscl_prog_data->easf_v_bf3_pwl_in_set1 =
-				0x0B37; // FP0.6.6, BF3 Input value PWL Segment 1 (0.0078125 * 125^3)
-			dscl_prog_data->easf_v_bf3_pwl_base_set1 = 62;	// S0.6, BF3 Base PWL Segment 1
-			dscl_prog_data->easf_v_bf3_pwl_slope_set1 =
-				0x13B8;	// FP1.6.6, BF3 Slope PWL Segment 1
-			dscl_prog_data->easf_v_bf3_pwl_in_set2 =
-				0x0BB7;	// FP0.6.6, BF3 Input value PWL Segment 2 (0.03125 * 125^3)
-			dscl_prog_data->easf_v_bf3_pwl_base_set2 = 20;	// S0.6, BF3 Base PWL Segment 2
-			dscl_prog_data->easf_v_bf3_pwl_slope_set2 =
-				0x1356;	// FP1.6.6, BF3 Slope PWL Segment 2
-			dscl_prog_data->easf_v_bf3_pwl_in_set3 =
-				0x0BF7;	// FP0.6.6, BF3 Input value PWL Segment 3 (0.0625 * 125^3)
-			dscl_prog_data->easf_v_bf3_pwl_base_set3 = 0;	// S0.6, BF3 Base PWL Segment 3
-			dscl_prog_data->easf_v_bf3_pwl_slope_set3 =
-				0x136B;	// FP1.6.6, BF3 Slope PWL Segment 3
-			dscl_prog_data->easf_v_bf3_pwl_in_set4 =
-				0x0C37;	// FP0.6.6, BF3 Input value PWL Segment 4 (0.125 * 125^3)
-			dscl_prog_data->easf_v_bf3_pwl_base_set4 = 0x4E;	// S0.6, BF3 Base PWL Segment 4 = -50
-			dscl_prog_data->easf_v_bf3_pwl_slope_set4 =
-				0x1200;	// FP1.6.6, BF3 Slope PWL Segment 4
-			dscl_prog_data->easf_v_bf3_pwl_in_set5 =
-				0x0CF7;	// FP0.6.6, BF3 Input value PWL Segment 5 (1.0 * 125^3)
-			dscl_prog_data->easf_v_bf3_pwl_base_set5 = 0x41;	// S0.6, BF3 Base PWL Segment 5 = -63
-		}	else	{
-			dscl_prog_data->easf_v_bf2_flat1_gain = 13;	// U1.3, BF2 Flat1 Gain control
-			dscl_prog_data->easf_v_bf2_flat2_gain = 15;	// U4.0, BF2 Flat2 Gain control
-			dscl_prog_data->easf_v_bf2_roc_gain = 14;	// U2.2, Rate Of Change control
-
-			dscl_prog_data->easf_v_bf1_pwl_in_seg0 = 0x440;	// S0.10, BF1 PWL Segment 0 = -960
-			dscl_prog_data->easf_v_bf1_pwl_base_seg0 = 0;	// U0.6, BF1 Base PWL Segment 0
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg0 = 2;	// S7.3, BF1 Slope PWL Segment 0
-			dscl_prog_data->easf_v_bf1_pwl_in_seg1 = 0x7C4;	// S0.10, BF1 PWL Segment 1 = -60
-			dscl_prog_data->easf_v_bf1_pwl_base_seg1 = 12;	// U0.6, BF1 Base PWL Segment 1
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg1 = 109;	// S7.3, BF1 Slope PWL Segment 1
-			dscl_prog_data->easf_v_bf1_pwl_in_seg2 = 0;	// S0.10, BF1 PWL Segment 2
-			dscl_prog_data->easf_v_bf1_pwl_base_seg2 = 63;	// U0.6, BF1 Base PWL Segment 2
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg2 = 0;	// S7.3, BF1 Slope PWL Segment 2
-			dscl_prog_data->easf_v_bf1_pwl_in_seg3 = 48;	// S0.10, BF1 PWL Segment 3
-			dscl_prog_data->easf_v_bf1_pwl_base_seg3 = 63;	// U0.6, BF1 Base PWL Segment 3
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg3 = 0x7ED;	// S7.3, BF1 Slope PWL Segment 3 = -19
-			dscl_prog_data->easf_v_bf1_pwl_in_seg4 = 96;	// S0.10, BF1 PWL Segment 4
-			dscl_prog_data->easf_v_bf1_pwl_base_seg4 = 56;	// U0.6, BF1 Base PWL Segment 4
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg4 = 0x7F0;	// S7.3, BF1 Slope PWL Segment 4 = -16
-			dscl_prog_data->easf_v_bf1_pwl_in_seg5 = 144;	// S0.10, BF1 PWL Segment 5
-			dscl_prog_data->easf_v_bf1_pwl_base_seg5 = 50;	// U0.6, BF1 Base PWL Segment 5
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg5 = 0x7B0;	// S7.3, BF1 Slope PWL Segment 5 = -80
-			dscl_prog_data->easf_v_bf1_pwl_in_seg6 = 192;	// S0.10, BF1 PWL Segment 6
-			dscl_prog_data->easf_v_bf1_pwl_base_seg6 = 20;	// U0.6, BF1 Base PWL Segment 6
-			dscl_prog_data->easf_v_bf1_pwl_slope_seg6 = 0x7CB;	// S7.3, BF1 Slope PWL Segment 6 = -53
-			dscl_prog_data->easf_v_bf1_pwl_in_seg7 = 240;	// S0.10, BF1 PWL Segment 7
-			dscl_prog_data->easf_v_bf1_pwl_base_seg7 = 0;	// U0.6, BF1 Base PWL Segment 7
-
-			dscl_prog_data->easf_v_bf3_pwl_in_set0 = 0x000;	// FP0.6.6, BF3 Input value PWL Segment 0
-			dscl_prog_data->easf_v_bf3_pwl_base_set0 = 63;	// S0.6, BF3 Base PWL Segment 0
-			dscl_prog_data->easf_v_bf3_pwl_slope_set0 = 0x0000;	// FP1.6.6, BF3 Slope PWL Segment 0
-			dscl_prog_data->easf_v_bf3_pwl_in_set1 =
-				0x06C0; // FP0.6.6, BF3 Input value PWL Segment 1 (0.0625)
-			dscl_prog_data->easf_v_bf3_pwl_base_set1 = 63;	// S0.6, BF3 Base PWL Segment 1
-			dscl_prog_data->easf_v_bf3_pwl_slope_set1 = 0x1896;	// FP1.6.6, BF3 Slope PWL Segment 1
-			dscl_prog_data->easf_v_bf3_pwl_in_set2 =
-				0x0700;	// FP0.6.6, BF3 Input value PWL Segment 2 (0.125)
-			dscl_prog_data->easf_v_bf3_pwl_base_set2 = 20;	// S0.6, BF3 Base PWL Segment 2
-			dscl_prog_data->easf_v_bf3_pwl_slope_set2 = 0x1810;	// FP1.6.6, BF3 Slope PWL Segment 2
-			dscl_prog_data->easf_v_bf3_pwl_in_set3 =
-				0x0740;	// FP0.6.6, BF3 Input value PWL Segment 3 (0.25)
-			dscl_prog_data->easf_v_bf3_pwl_base_set3 = 0;	// S0.6, BF3 Base PWL Segment 3
-			dscl_prog_data->easf_v_bf3_pwl_slope_set3 =
-				0x1878;	// FP1.6.6, BF3 Slope PWL Segment 3
-			dscl_prog_data->easf_v_bf3_pwl_in_set4 =
-				0x0761;	// FP0.6.6, BF3 Input value PWL Segment 4 (0.375)
-			dscl_prog_data->easf_v_bf3_pwl_base_set4 = 0x44;	// S0.6, BF3 Base PWL Segment 4 = -60
-			dscl_prog_data->easf_v_bf3_pwl_slope_set4 = 0x1760;	// FP1.6.6, BF3 Slope PWL Segment 4
-			dscl_prog_data->easf_v_bf3_pwl_in_set5 =
-				0x0780;	// FP0.6.6, BF3 Input value PWL Segment 5 (0.5)
-			dscl_prog_data->easf_v_bf3_pwl_base_set5 = 0x41;	// S0.6, BF3 Base PWL Segment 5 = -63
-		}
-	} else
-		dscl_prog_data->easf_v_en = false;
-
-	if (enable_easf_h) {
-		dscl_prog_data->easf_h_en = true;
-		dscl_prog_data->easf_h_ring = 0;
-		dscl_prog_data->easf_h_sharp_factor = 0;
-		dscl_prog_data->easf_h_bf1_en =
-			1;	// 1-bit, BF1 calculation enable, 0=disable, 1=enable
-		dscl_prog_data->easf_h_bf2_mode =
-			0xF;	// 4-bit, BF2 calculation mode
-		/* 2-bit, BF3 chroma mode correction calculation mode */
-		dscl_prog_data->easf_h_bf3_mode = spl_get_h_bf3_mode(
-			spl_scratch->scl_data.recip_ratios.horz);
-		/* FP1.5.10; (2.0) Ring reducer gain for 4 or 6-tap mode [H_REDUCER_GAIN4] */
-		dscl_prog_data->easf_h_ringest_eventap_reduceg1 =
-			spl_get_reducer_gain4(spl_scratch->scl_data.taps.h_taps,
-				spl_scratch->scl_data.recip_ratios.horz);
-		/* FP1.5.10; (2.5) Ring reducer gain for 6-tap mode [V_REDUCER_GAIN6] */
-		dscl_prog_data->easf_h_ringest_eventap_reduceg2 =
-			spl_get_reducer_gain6(spl_scratch->scl_data.taps.h_taps,
-				spl_scratch->scl_data.recip_ratios.horz);
-		/* FP1.5.10; (-0.135742) Ring gain for 6-tap set to -139/1024 */
-		dscl_prog_data->easf_h_ringest_eventap_gain1 =
-			spl_get_gainRing4(spl_scratch->scl_data.taps.h_taps,
-				spl_scratch->scl_data.recip_ratios.horz);
-		/* FP1.5.10; (-0.024414) Ring gain for 6-tap set to -25/1024 */
-		dscl_prog_data->easf_h_ringest_eventap_gain2 =
-			spl_get_gainRing6(spl_scratch->scl_data.taps.h_taps,
-				spl_scratch->scl_data.recip_ratios.horz);
-		dscl_prog_data->easf_h_bf_maxa = 63; //Horz Max BF value A in U0.6 format.Selected if H_FCNTL==0
-		dscl_prog_data->easf_h_bf_maxb = 63; //Horz Max BF value B in U0.6 format.Selected if H_FCNTL==1
-		dscl_prog_data->easf_h_bf_mina = 0;	//Horz Min BF value B in U0.6 format.Selected if H_FCNTL==0
-		dscl_prog_data->easf_h_bf_minb = 0;	//Horz Min BF value B in U0.6 format.Selected if H_FCNTL==1
-		if (lls_pref == LLS_PREF_YES)	{
-			dscl_prog_data->easf_h_bf2_flat1_gain = 4;	// U1.3, BF2 Flat1 Gain control
-			dscl_prog_data->easf_h_bf2_flat2_gain = 8;	// U4.0, BF2 Flat2 Gain control
-			dscl_prog_data->easf_h_bf2_roc_gain = 4;	// U2.2, Rate Of Change control
-
-			dscl_prog_data->easf_h_bf1_pwl_in_seg0 = 0x600;	// S0.10, BF1 PWL Segment 0 = -512
-			dscl_prog_data->easf_h_bf1_pwl_base_seg0 = 0;	// U0.6, BF1 Base PWL Segment 0
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg0 = 3;	// S7.3, BF1 Slope PWL Segment 0
-			dscl_prog_data->easf_h_bf1_pwl_in_seg1 = 0x7EC;	// S0.10, BF1 PWL Segment 1 = -20
-			dscl_prog_data->easf_h_bf1_pwl_base_seg1 = 12;	// U0.6, BF1 Base PWL Segment 1
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg1 = 326;	// S7.3, BF1 Slope PWL Segment 1
-			dscl_prog_data->easf_h_bf1_pwl_in_seg2 = 0;	// S0.10, BF1 PWL Segment 2
-			dscl_prog_data->easf_h_bf1_pwl_base_seg2 = 63;	// U0.6, BF1 Base PWL Segment 2
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg2 = 0;	// S7.3, BF1 Slope PWL Segment 2
-			dscl_prog_data->easf_h_bf1_pwl_in_seg3 = 16;	// S0.10, BF1 PWL Segment 3
-			dscl_prog_data->easf_h_bf1_pwl_base_seg3 = 63;	// U0.6, BF1 Base PWL Segment 3
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg3 = 0x7C8;	// S7.3, BF1 Slope PWL Segment 3 = -56
-			dscl_prog_data->easf_h_bf1_pwl_in_seg4 = 32;	// S0.10, BF1 PWL Segment 4
-			dscl_prog_data->easf_h_bf1_pwl_base_seg4 = 56;	// U0.6, BF1 Base PWL Segment 4
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg4 = 0x7D0;	// S7.3, BF1 Slope PWL Segment 4 = -48
-			dscl_prog_data->easf_h_bf1_pwl_in_seg5 = 48;	// S0.10, BF1 PWL Segment 5
-			dscl_prog_data->easf_h_bf1_pwl_base_seg5 = 50;	// U0.6, BF1 Base PWL Segment 5
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg5 = 0x710;	// S7.3, BF1 Slope PWL Segment 5 = -240
-			dscl_prog_data->easf_h_bf1_pwl_in_seg6 = 64;	// S0.10, BF1 PWL Segment 6
-			dscl_prog_data->easf_h_bf1_pwl_base_seg6 = 20;	// U0.6, BF1 Base PWL Segment 6
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg6 = 0x760;	// S7.3, BF1 Slope PWL Segment 6 = -160
-			dscl_prog_data->easf_h_bf1_pwl_in_seg7 = 80;	// S0.10, BF1 PWL Segment 7
-			dscl_prog_data->easf_h_bf1_pwl_base_seg7 = 0;	// U0.6, BF1 Base PWL Segment 7
-
-			dscl_prog_data->easf_h_bf3_pwl_in_set0 = 0x000;	// FP0.6.6, BF3 Input value PWL Segment 0
-			dscl_prog_data->easf_h_bf3_pwl_base_set0 = 63;	// S0.6, BF3 Base PWL Segment 0
-			dscl_prog_data->easf_h_bf3_pwl_slope_set0 = 0x12C5;	// FP1.6.6, BF3 Slope PWL Segment 0
-			dscl_prog_data->easf_h_bf3_pwl_in_set1 =
-				0x0B37;	// FP0.6.6, BF3 Input value PWL Segment 1 (0.0078125 * 125^3)
-			dscl_prog_data->easf_h_bf3_pwl_base_set1 = 62;	// S0.6, BF3 Base PWL Segment 1
-			dscl_prog_data->easf_h_bf3_pwl_slope_set1 =	0x13B8;	// FP1.6.6, BF3 Slope PWL Segment 1
-			dscl_prog_data->easf_h_bf3_pwl_in_set2 =
-				0x0BB7;	// FP0.6.6, BF3 Input value PWL Segment 2 (0.03125 * 125^3)
-			dscl_prog_data->easf_h_bf3_pwl_base_set2 = 20;	// S0.6, BF3 Base PWL Segment 2
-			dscl_prog_data->easf_h_bf3_pwl_slope_set2 =	0x1356;	// FP1.6.6, BF3 Slope PWL Segment 2
-			dscl_prog_data->easf_h_bf3_pwl_in_set3 =
-				0x0BF7;	// FP0.6.6, BF3 Input value PWL Segment 3 (0.0625 * 125^3)
-			dscl_prog_data->easf_h_bf3_pwl_base_set3 = 0;	// S0.6, BF3 Base PWL Segment 3
-			dscl_prog_data->easf_h_bf3_pwl_slope_set3 =	0x136B;	// FP1.6.6, BF3 Slope PWL Segment 3
-			dscl_prog_data->easf_h_bf3_pwl_in_set4 =
-				0x0C37;	// FP0.6.6, BF3 Input value PWL Segment 4 (0.125 * 125^3)
-			dscl_prog_data->easf_h_bf3_pwl_base_set4 = 0x4E;	// S0.6, BF3 Base PWL Segment 4 = -50
-			dscl_prog_data->easf_h_bf3_pwl_slope_set4 = 0x1200;	// FP1.6.6, BF3 Slope PWL Segment 4
-			dscl_prog_data->easf_h_bf3_pwl_in_set5 =
-				0x0CF7;	// FP0.6.6, BF3 Input value PWL Segment 5 (1.0 * 125^3)
-			dscl_prog_data->easf_h_bf3_pwl_base_set5 = 0x41;	// S0.6, BF3 Base PWL Segment 5 = -63
-		} else {
-			dscl_prog_data->easf_h_bf2_flat1_gain = 13;	// U1.3, BF2 Flat1 Gain control
-			dscl_prog_data->easf_h_bf2_flat2_gain = 15;	// U4.0, BF2 Flat2 Gain control
-			dscl_prog_data->easf_h_bf2_roc_gain = 14;	// U2.2, Rate Of Change control
-
-			dscl_prog_data->easf_h_bf1_pwl_in_seg0 = 0x440;	// S0.10, BF1 PWL Segment 0 = -960
-			dscl_prog_data->easf_h_bf1_pwl_base_seg0 = 0;	// U0.6, BF1 Base PWL Segment 0
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg0 = 2;	// S7.3, BF1 Slope PWL Segment 0
-			dscl_prog_data->easf_h_bf1_pwl_in_seg1 = 0x7C4;	// S0.10, BF1 PWL Segment 1 = -60
-			dscl_prog_data->easf_h_bf1_pwl_base_seg1 = 12;	// U0.6, BF1 Base PWL Segment 1
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg1 = 109;	// S7.3, BF1 Slope PWL Segment 1
-			dscl_prog_data->easf_h_bf1_pwl_in_seg2 = 0;	// S0.10, BF1 PWL Segment 2
-			dscl_prog_data->easf_h_bf1_pwl_base_seg2 = 63;	// U0.6, BF1 Base PWL Segment 2
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg2 = 0;	// S7.3, BF1 Slope PWL Segment 2
-			dscl_prog_data->easf_h_bf1_pwl_in_seg3 = 48;	// S0.10, BF1 PWL Segment 3
-			dscl_prog_data->easf_h_bf1_pwl_base_seg3 = 63;	// U0.6, BF1 Base PWL Segment 3
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg3 = 0x7ED;	// S7.3, BF1 Slope PWL Segment 3 = -19
-			dscl_prog_data->easf_h_bf1_pwl_in_seg4 = 96;	// S0.10, BF1 PWL Segment 4
-			dscl_prog_data->easf_h_bf1_pwl_base_seg4 = 56;	// U0.6, BF1 Base PWL Segment 4
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg4 = 0x7F0;	// S7.3, BF1 Slope PWL Segment 4 = -16
-			dscl_prog_data->easf_h_bf1_pwl_in_seg5 = 144;	// S0.10, BF1 PWL Segment 5
-			dscl_prog_data->easf_h_bf1_pwl_base_seg5 = 50;	// U0.6, BF1 Base PWL Segment 5
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg5 = 0x7B0;	// S7.3, BF1 Slope PWL Segment 5 = -80
-			dscl_prog_data->easf_h_bf1_pwl_in_seg6 = 192;	// S0.10, BF1 PWL Segment 6
-			dscl_prog_data->easf_h_bf1_pwl_base_seg6 = 20;	// U0.6, BF1 Base PWL Segment 6
-			dscl_prog_data->easf_h_bf1_pwl_slope_seg6 = 0x7CB;	// S7.3, BF1 Slope PWL Segment 6 = -53
-			dscl_prog_data->easf_h_bf1_pwl_in_seg7 = 240;	// S0.10, BF1 PWL Segment 7
-			dscl_prog_data->easf_h_bf1_pwl_base_seg7 = 0;	// U0.6, BF1 Base PWL Segment 7
-
-			dscl_prog_data->easf_h_bf3_pwl_in_set0 = 0x000;	// FP0.6.6, BF3 Input value PWL Segment 0
-			dscl_prog_data->easf_h_bf3_pwl_base_set0 = 63;	// S0.6, BF3 Base PWL Segment 0
-			dscl_prog_data->easf_h_bf3_pwl_slope_set0 = 0x0000;	// FP1.6.6, BF3 Slope PWL Segment 0
-			dscl_prog_data->easf_h_bf3_pwl_in_set1 =
-				0x06C0;	// FP0.6.6, BF3 Input value PWL Segment 1 (0.0625)
-			dscl_prog_data->easf_h_bf3_pwl_base_set1 = 63;	// S0.6, BF3 Base PWL Segment 1
-			dscl_prog_data->easf_h_bf3_pwl_slope_set1 = 0x1896;	// FP1.6.6, BF3 Slope PWL Segment 1
-			dscl_prog_data->easf_h_bf3_pwl_in_set2 =
-				0x0700;	// FP0.6.6, BF3 Input value PWL Segment 2 (0.125)
-			dscl_prog_data->easf_h_bf3_pwl_base_set2 = 20;	// S0.6, BF3 Base PWL Segment 2
-			dscl_prog_data->easf_h_bf3_pwl_slope_set2 = 0x1810;	// FP1.6.6, BF3 Slope PWL Segment 2
-			dscl_prog_data->easf_h_bf3_pwl_in_set3 =
-				0x0740;	// FP0.6.6, BF3 Input value PWL Segment 3 (0.25)
-			dscl_prog_data->easf_h_bf3_pwl_base_set3 = 0;	// S0.6, BF3 Base PWL Segment 3
-			dscl_prog_data->easf_h_bf3_pwl_slope_set3 = 0x1878;	// FP1.6.6, BF3 Slope PWL Segment 3
-			dscl_prog_data->easf_h_bf3_pwl_in_set4 =
-				0x0761;	// FP0.6.6, BF3 Input value PWL Segment 4 (0.375)
-			dscl_prog_data->easf_h_bf3_pwl_base_set4 = 0x44;	// S0.6, BF3 Base PWL Segment 4 = -60
-			dscl_prog_data->easf_h_bf3_pwl_slope_set4 = 0x1760;	// FP1.6.6, BF3 Slope PWL Segment 4
-			dscl_prog_data->easf_h_bf3_pwl_in_set5 =
-				0x0780;	// FP0.6.6, BF3 Input value PWL Segment 5 (0.5)
-			dscl_prog_data->easf_h_bf3_pwl_base_set5 = 0x41;	// S0.6, BF3 Base PWL Segment 5 = -63
-		} // if (lls_pref == LLS_PREF_YES)
-	} else
-		dscl_prog_data->easf_h_en = false;
-
-	if (lls_pref == LLS_PREF_YES)	{
-		dscl_prog_data->easf_ltonl_en = 1;	// Linear input
-		if ((setup == HDR_L) && (spl_is_rgb8(format))) {
-			/* Calculate C0-C3 coefficients based on HDR multiplier */
-			spl_calculate_c0_c3_hdr(dscl_prog_data, sdr_white_level_nits);
-		} else { // HDR_L ( DWM ) and SDR_L
-			dscl_prog_data->easf_matrix_c0 =
-				0x4EF7;	// fp1.5.10, C0 coefficient (LN_rec709:  0.2126 * (2^14)/125 = 27.86590720)
-			dscl_prog_data->easf_matrix_c1 =
-				0x55DC;	// fp1.5.10, C1 coefficient (LN_rec709:  0.7152 * (2^14)/125 = 93.74269440)
-			dscl_prog_data->easf_matrix_c2 =
-				0x48BB;	// fp1.5.10, C2 coefficient (LN_rec709:  0.0722 * (2^14)/125 = 9.46339840)
-			dscl_prog_data->easf_matrix_c3 =
-				0x0;	// fp1.5.10, C3 coefficient
-		}
-	}	else	{
-		dscl_prog_data->easf_ltonl_en = 0;	// Non-Linear input
-		dscl_prog_data->easf_matrix_c0 =
-			0x3434;	// fp1.5.10, C0 coefficient (LN_BT2020:  0.262695312500000)
-		dscl_prog_data->easf_matrix_c1 =
-			0x396D;	// fp1.5.10, C1 coefficient (LN_BT2020:  0.678222656250000)
-		dscl_prog_data->easf_matrix_c2 =
-			0x2B97;	// fp1.5.10, C2 coefficient (LN_BT2020:  0.059295654296875)
-		dscl_prog_data->easf_matrix_c3 =
-			0x0;	// fp1.5.10, C3 coefficient
-	}
-
-	if (spl_is_subsampled_format(format)) { /* TODO: 0 = RGB, 1 = YUV */
-		dscl_prog_data->easf_matrix_mode = 1;
-		/*
-		 * 2-bit, BF3 chroma mode correction calculation mode
-		 * Needs to be disabled for YUV420 mode
-		 * Override lookup value
-		 */
-		dscl_prog_data->easf_v_bf3_mode = 0;
-		dscl_prog_data->easf_h_bf3_mode = 0;
-	} else
-		dscl_prog_data->easf_matrix_mode = 0;
-
-}
-
-/*Set isharp noise detection */
-static void spl_set_isharp_noise_det_mode(struct dscl_prog_data *dscl_prog_data,
-	const struct spl_scaler_data *data)
-{
-	// ISHARP_NOISEDET_MODE
-	// 0: 3x5 as VxH
-	// 1: 4x5 as VxH
-	// 2:
-	// 3: 5x5 as VxH
-	if (data->taps.v_taps == 6)
-		dscl_prog_data->isharp_noise_det.mode = 3;
-	else if (data->taps.v_taps == 4)
-		dscl_prog_data->isharp_noise_det.mode = 1;
-	else if (data->taps.v_taps == 3)
-		dscl_prog_data->isharp_noise_det.mode = 0;
-};
-/* Set Sharpener data */
-static void spl_set_isharp_data(struct dscl_prog_data *dscl_prog_data,
-		struct adaptive_sharpness adp_sharpness, bool enable_isharp,
-		enum linear_light_scaling lls_pref, enum spl_pixel_format format,
-		const struct spl_scaler_data *data, struct spl_fixed31_32 ratio,
-		enum system_setup setup, enum scale_to_sharpness_policy scale_to_sharpness_policy)
-{
-	/* Turn off sharpener if not required */
-	if (!enable_isharp) {
-		dscl_prog_data->isharp_en = 0;
-		return;
-	}
-
-	spl_build_isharp_1dlut_from_reference_curve(ratio, setup, adp_sharpness,
-		scale_to_sharpness_policy);
-	memcpy(dscl_prog_data->isharp_delta, spl_get_pregen_filter_isharp_1D_lut(setup),
-		sizeof(uint32_t) * ISHARP_LUT_TABLE_SIZE);
-	dscl_prog_data->sharpness_level = adp_sharpness.sharpness_level;
-
-	dscl_prog_data->isharp_en = 1;	// ISHARP_EN
-	// Set ISHARP_NOISEDET_MODE if htaps = 6-tap
-	if (data->taps.h_taps == 6) {
-		dscl_prog_data->isharp_noise_det.enable = 1;	/* ISHARP_NOISEDET_EN */
-		spl_set_isharp_noise_det_mode(dscl_prog_data, data);	/* ISHARP_NOISEDET_MODE */
-	} else
-		dscl_prog_data->isharp_noise_det.enable = 0;	// ISHARP_NOISEDET_EN
-	// Program noise detection threshold
-	dscl_prog_data->isharp_noise_det.uthreshold = 24;	// ISHARP_NOISEDET_UTHRE
-	dscl_prog_data->isharp_noise_det.dthreshold = 4;	// ISHARP_NOISEDET_DTHRE
-	// Program noise detection gain
-	dscl_prog_data->isharp_noise_det.pwl_start_in = 3;	// ISHARP_NOISEDET_PWL_START_IN
-	dscl_prog_data->isharp_noise_det.pwl_end_in = 13;	// ISHARP_NOISEDET_PWL_END_IN
-	dscl_prog_data->isharp_noise_det.pwl_slope = 1623;	// ISHARP_NOISEDET_PWL_SLOPE
-
-	if (lls_pref == LLS_PREF_NO) /* ISHARP_FMT_MODE */
-		dscl_prog_data->isharp_fmt.mode = 1;
-	else
-		dscl_prog_data->isharp_fmt.mode = 0;
-
-	dscl_prog_data->isharp_fmt.norm = 0x3C00;	// ISHARP_FMT_NORM
-	dscl_prog_data->isharp_lba.mode = 0;	// ISHARP_LBA_MODE
-
-	if (setup == SDR_L) {
-		// ISHARP_LBA_PWL_SEG0: ISHARP Local Brightness Adjustment PWL Segment 0
-		dscl_prog_data->isharp_lba.in_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[0] = 62;	// ISHARP LBA for Seg 0. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG1: ISHARP LBA PWL Segment 1
-		dscl_prog_data->isharp_lba.in_seg[1] = 130;	// ISHARP LBA PWL for Seg 1. INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[1] = 63; // ISHARP LBA PWL for Seg 1. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[1] = 0; // ISHARP LBA for Seg 1. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG2: ISHARP LBA PWL Segment 2
-		dscl_prog_data->isharp_lba.in_seg[2] = 450; // ISHARP LBA PWL for Seg 2. INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[2] = 63; // ISHARP LBA PWL for Seg 2. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[2] = 0x18D; // ISHARP LBA for Seg 2. SLOPE value in S5.3 format = -115
-		// ISHARP_LBA_PWL_SEG3: ISHARP LBA PWL Segment 3
-		dscl_prog_data->isharp_lba.in_seg[3] = 520; // ISHARP LBA PWL for Seg 3.INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[3] = 0; // ISHARP LBA PWL for Seg 3. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[3] = 0; // ISHARP LBA for Seg 3. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG4: ISHARP LBA PWL Segment 4
-		dscl_prog_data->isharp_lba.in_seg[4] = 520; // ISHARP LBA PWL for Seg 4.INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[4] = 0; // ISHARP LBA PWL for Seg 4. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[4] = 0; // ISHARP LBA for Seg 4. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG5: ISHARP LBA PWL Segment 5
-		dscl_prog_data->isharp_lba.in_seg[5] = 520; // ISHARP LBA PWL for Seg 5.INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[5] = 0;	// ISHARP LBA PWL for Seg 5. BASE value in U0.6 format
-	} else if (setup == HDR_L) {
-		// ISHARP_LBA_PWL_SEG0: ISHARP Local Brightness Adjustment PWL Segment 0
-		dscl_prog_data->isharp_lba.in_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[0] = 32;	// ISHARP LBA for Seg 0. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG1: ISHARP LBA PWL Segment 1
-		dscl_prog_data->isharp_lba.in_seg[1] = 254;	// ISHARP LBA PWL for Seg 1. INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[1] = 63; // ISHARP LBA PWL for Seg 1. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[1] = 0; // ISHARP LBA for Seg 1. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG2: ISHARP LBA PWL Segment 2
-		dscl_prog_data->isharp_lba.in_seg[2] = 559; // ISHARP LBA PWL for Seg 2. INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[2] = 63; // ISHARP LBA PWL for Seg 2. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[2] = 0x10C; // ISHARP LBA for Seg 2. SLOPE value in S5.3 format = -244
-		// ISHARP_LBA_PWL_SEG3: ISHARP LBA PWL Segment 3
-		dscl_prog_data->isharp_lba.in_seg[3] = 592; // ISHARP LBA PWL for Seg 3.INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[3] = 0; // ISHARP LBA PWL for Seg 3. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[3] = 0; // ISHARP LBA for Seg 3. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG4: ISHARP LBA PWL Segment 4
-		dscl_prog_data->isharp_lba.in_seg[4] = 1023; // ISHARP LBA PWL for Seg 4.INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[4] = 0; // ISHARP LBA PWL for Seg 4. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[4] = 0; // ISHARP LBA for Seg 4. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG5: ISHARP LBA PWL Segment 5
-		dscl_prog_data->isharp_lba.in_seg[5] = 1023; // ISHARP LBA PWL for Seg 5.INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[5] = 0;	// ISHARP LBA PWL for Seg 5. BASE value in U0.6 format
-	} else {
-		// ISHARP_LBA_PWL_SEG0: ISHARP Local Brightness Adjustment PWL Segment 0
-		dscl_prog_data->isharp_lba.in_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[0] = 40;	// ISHARP LBA for Seg 0. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG1: ISHARP LBA PWL Segment 1
-		dscl_prog_data->isharp_lba.in_seg[1] = 204;	// ISHARP LBA PWL for Seg 1. INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[1] = 63; // ISHARP LBA PWL for Seg 1. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[1] = 0; // ISHARP LBA for Seg 1. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG2: ISHARP LBA PWL Segment 2
-		dscl_prog_data->isharp_lba.in_seg[2] = 818; // ISHARP LBA PWL for Seg 2. INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[2] = 63; // ISHARP LBA PWL for Seg 2. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[2] = 0x1D9; // ISHARP LBA for Seg 2. SLOPE value in S5.3 format = -39
-		// ISHARP_LBA_PWL_SEG3: ISHARP LBA PWL Segment 3
-		dscl_prog_data->isharp_lba.in_seg[3] = 1023; // ISHARP LBA PWL for Seg 3.INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[3] = 0; // ISHARP LBA PWL for Seg 3. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[3] = 0; // ISHARP LBA for Seg 3. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG4: ISHARP LBA PWL Segment 4
-		dscl_prog_data->isharp_lba.in_seg[4] = 1023; // ISHARP LBA PWL for Seg 4.INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[4] = 0; // ISHARP LBA PWL for Seg 4. BASE value in U0.6 format
-		dscl_prog_data->isharp_lba.slope_seg[4] = 0; // ISHARP LBA for Seg 4. SLOPE value in S5.3 format
-		// ISHARP_LBA_PWL_SEG5: ISHARP LBA PWL Segment 5
-		dscl_prog_data->isharp_lba.in_seg[5] = 1023; // ISHARP LBA PWL for Seg 5.INPUT value in U0.10 format
-		dscl_prog_data->isharp_lba.base_seg[5] = 0;	// ISHARP LBA PWL for Seg 5. BASE value in U0.6 format
-	}
-
-	// Program the nldelta soft clip values
-	if (lls_pref == LLS_PREF_YES) {
-		dscl_prog_data->isharp_nldelta_sclip.enable_p = 0;	/* ISHARP_NLDELTA_SCLIP_EN_P */
-		dscl_prog_data->isharp_nldelta_sclip.pivot_p = 0;	/* ISHARP_NLDELTA_SCLIP_PIVOT_P */
-		dscl_prog_data->isharp_nldelta_sclip.slope_p = 0;	/* ISHARP_NLDELTA_SCLIP_SLOPE_P */
-		dscl_prog_data->isharp_nldelta_sclip.enable_n = 1;	/* ISHARP_NLDELTA_SCLIP_EN_N */
-		dscl_prog_data->isharp_nldelta_sclip.pivot_n = 71;	/* ISHARP_NLDELTA_SCLIP_PIVOT_N */
-		dscl_prog_data->isharp_nldelta_sclip.slope_n = 16;	/* ISHARP_NLDELTA_SCLIP_SLOPE_N */
-	} else {
-		dscl_prog_data->isharp_nldelta_sclip.enable_p = 1;	/* ISHARP_NLDELTA_SCLIP_EN_P */
-		dscl_prog_data->isharp_nldelta_sclip.pivot_p = 70;	/* ISHARP_NLDELTA_SCLIP_PIVOT_P */
-		dscl_prog_data->isharp_nldelta_sclip.slope_p = 24;	/* ISHARP_NLDELTA_SCLIP_SLOPE_P */
-		dscl_prog_data->isharp_nldelta_sclip.enable_n = 1;	/* ISHARP_NLDELTA_SCLIP_EN_N */
-		dscl_prog_data->isharp_nldelta_sclip.pivot_n = 70;	/* ISHARP_NLDELTA_SCLIP_PIVOT_N */
-		dscl_prog_data->isharp_nldelta_sclip.slope_n = 24;	/* ISHARP_NLDELTA_SCLIP_SLOPE_N */
-	}
-
-	// Set the values as per lookup table
-	spl_set_blur_scale_data(dscl_prog_data, data);
-}
-
-/* Calculate recout, scaling ratio, and viewport, then get optimal number of taps */
-static bool spl_calculate_number_of_taps(struct spl_in *spl_in, struct spl_scratch *spl_scratch, struct spl_out *spl_out,
-	bool *enable_easf_v, bool *enable_easf_h, bool *enable_isharp)
-{
-	bool res = false;
-
-	memset(spl_scratch, 0, sizeof(struct spl_scratch));
-	spl_scratch->scl_data.h_active = spl_in->h_active;
-	spl_scratch->scl_data.v_active = spl_in->v_active;
-
-	// All SPL calls
-	/* recout calculation */
-	/* depends on h_active */
-	spl_calculate_recout(spl_in, spl_scratch, spl_out);
-	/* depends on pixel format */
-	spl_calculate_scaling_ratios(spl_in, spl_scratch, spl_out);
-	/* depends on scaling ratios and recout, does not calculate offset yet */
-	spl_calculate_viewport_size(spl_in, spl_scratch);
-
-	res = spl_get_optimal_number_of_taps(
-			  spl_in->basic_out.max_downscale_src_width, spl_in,
-			  spl_scratch, &spl_in->scaling_quality, enable_easf_v,
-			  enable_easf_h, enable_isharp);
-	return res;
-}
-
-/* Calculate scaler parameters */
-bool spl_calculate_scaler_params(struct spl_in *spl_in, struct spl_out *spl_out)
-{
-	bool res = false;
-	bool enable_easf_v = false;
-	bool enable_easf_h = false;
-	int vratio = 0;
-	int hratio = 0;
-	struct spl_scratch spl_scratch;
-	struct spl_fixed31_32 isharp_scale_ratio;
-	enum system_setup setup;
-	bool enable_isharp = false;
-	const struct spl_scaler_data *data = &spl_scratch.scl_data;
-
-	res = spl_calculate_number_of_taps(spl_in, &spl_scratch, spl_out,
-		&enable_easf_v, &enable_easf_h, &enable_isharp);
-
-	/*
-	 * Depends on recout, scaling ratios, h_active and taps
-	 * May need to re-check lb size after this in some obscure scenario
-	 */
-	if (res)
-		spl_calculate_inits_and_viewports(spl_in, &spl_scratch);
-	// Handle 3d recout
-	spl_handle_3d_recout(spl_in, &spl_scratch.scl_data.recout);
-	// Clamp
-	spl_clamp_viewport(&spl_scratch.scl_data.viewport);
-
-	// Save all calculated parameters in dscl_prog_data structure to program hw registers
-	spl_set_dscl_prog_data(spl_in, &spl_scratch, spl_out, enable_easf_v, enable_easf_h, enable_isharp);
-
-	if (!res)
-		return res;
-
-	if (spl_in->lls_pref == LLS_PREF_YES) {
-		if (spl_in->is_hdr_on)
-			setup = HDR_L;
-		else
-			setup = SDR_L;
-	} else {
-		if (spl_in->is_hdr_on)
-			setup = HDR_NL;
-		else
-			setup = SDR_NL;
-	}
-
-	// Set EASF
-	spl_set_easf_data(&spl_scratch, spl_out, enable_easf_v, enable_easf_h, spl_in->lls_pref,
-		spl_in->basic_in.format, setup, spl_in->sdr_white_level_nits);
-
-	// Set iSHARP
-	vratio = spl_fixpt_ceil(spl_scratch.scl_data.ratios.vert);
-	hratio = spl_fixpt_ceil(spl_scratch.scl_data.ratios.horz);
-	if (vratio <= hratio)
-		isharp_scale_ratio = spl_scratch.scl_data.recip_ratios.vert;
-	else
-		isharp_scale_ratio = spl_scratch.scl_data.recip_ratios.horz;
-
-	spl_set_isharp_data(spl_out->dscl_prog_data, spl_in->adaptive_sharpness, enable_isharp,
-		spl_in->lls_pref, spl_in->basic_in.format, data, isharp_scale_ratio, setup,
-		spl_in->debug.scale_to_sharpness_policy);
-
-	return res;
-}
-
-/* External interface to get number of taps only */
-bool spl_get_number_of_taps(struct spl_in *spl_in, struct spl_out *spl_out)
-{
-	bool res = false;
-	bool enable_easf_v = false;
-	bool enable_easf_h = false;
-	bool enable_isharp = false;
-	struct spl_scratch spl_scratch;
-	struct dscl_prog_data *dscl_prog_data = spl_out->dscl_prog_data;
-	const struct spl_scaler_data *data = &spl_scratch.scl_data;
-
-	res = spl_calculate_number_of_taps(spl_in, &spl_scratch, spl_out,
-		&enable_easf_v, &enable_easf_h, &enable_isharp);
-	spl_set_taps_data(dscl_prog_data, data);
-	return res;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl.h b/drivers/gpu/drm/amd/display/dc/spl/dc_spl.h
deleted file mode 100644
index 02a2d6725ed5..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl.h
+++ /dev/null
@@ -1,18 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#ifndef __DC_SPL_H__
-#define __DC_SPL_H__
-
-#include "dc_spl_types.h"
-#define BLACK_OFFSET_RGB_Y 0x0
-#define BLACK_OFFSET_CBCR  0x8000
-
-/* SPL interfaces */
-
-bool spl_calculate_scaler_params(struct spl_in *spl_in, struct spl_out *spl_out);
-
-bool spl_get_number_of_taps(struct spl_in *spl_in, struct spl_out *spl_out);
-
-#endif /* __DC_SPL_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_filters.c b/drivers/gpu/drm/amd/display/dc/spl/dc_spl_filters.c
deleted file mode 100644
index 99238644e0a1..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_filters.c
+++ /dev/null
@@ -1,15 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#include "dc_spl_filters.h"
-
-void convert_filter_s1_10_to_s1_12(const uint16_t *s1_10_filter,
-	uint16_t *s1_12_filter, int num_taps)
-{
-	int num_entries = NUM_PHASES_COEFF * num_taps;
-	int i;
-
-	for (i = 0; i < num_entries; i++)
-		*(s1_12_filter + i) = *(s1_10_filter + i) * 4;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_filters.h b/drivers/gpu/drm/amd/display/dc/spl/dc_spl_filters.h
deleted file mode 100644
index 20439cdbdb10..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_filters.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-
-/* Copyright 2024 Advanced Micro Devices, Inc. */
-
-#ifndef __DC_SPL_FILTERS_H__
-#define __DC_SPL_FILTERS_H__
-
-#include "dc_spl_types.h"
-
-#define NUM_PHASES_COEFF 33
-
-void convert_filter_s1_10_to_s1_12(const uint16_t *s1_10_filter,
-	uint16_t *s1_12_filter, int num_taps);
-
-#endif /* __DC_SPL_FILTERS_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_isharp_filters.c b/drivers/gpu/drm/amd/display/dc/spl/dc_spl_isharp_filters.c
deleted file mode 100644
index e0572252c640..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_isharp_filters.c
+++ /dev/null
@@ -1,757 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#include "spl_debug.h"
-#include "dc_spl_filters.h"
-#include "dc_spl_isharp_filters.h"
-
-//========================================
-// Delta Gain 1DLUT
-// LUT content is packed as 4-bytes into one DWORD/entry
-// A_start = 0.000000
-// A_end   = 10.000000
-// A_gain  = 2.000000
-// B_start = 11.000000
-// B_end   = 86.000000
-// C_start = 40.000000
-// C_end   = 64.000000
-//========================================
-static const uint32_t filter_isharp_1D_lut_0[ISHARP_LUT_TABLE_SIZE] = {
-0x02010000,
-0x0A070503,
-0x1614100D,
-0x1C1B1918,
-0x22211F1E,
-0x27262423,
-0x2A2A2928,
-0x2D2D2C2B,
-0x302F2F2E,
-0x31313030,
-0x31313131,
-0x31313131,
-0x30303031,
-0x292D2F2F,
-0x191D2125,
-0x050A0F14,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-};
-//========================================
-// Delta Gain 1DLUT
-// LUT content is packed as 4-bytes into one DWORD/entry
-// A_start = 0.000000
-// A_end   = 10.000000
-// A_gain  = 0.500000
-// B_start = 11.000000
-// B_end   = 127.000000
-// C_start = 96.000000
-// C_end   = 127.000000
-//========================================
-
-static const uint32_t filter_isharp_1D_lut_0p5x[ISHARP_LUT_TABLE_SIZE] = {
-0x00000000,
-0x02020101,
-0x06050403,
-0x07070606,
-0x09080808,
-0x0A0A0A09,
-0x0C0B0B0B,
-0x0D0D0C0C,
-0x0E0E0D0D,
-0x0F0F0E0E,
-0x100F0F0F,
-0x10101010,
-0x11111010,
-0x11111111,
-0x11111111,
-0x11111111,
-0x11111111,
-0x11111111,
-0x11111111,
-0x10101111,
-0x10101010,
-0x0F0F0F10,
-0x0E0E0F0F,
-0x0D0D0E0E,
-0x0C0C0D0D,
-0x0B0B0B0C,
-0x090A0A0A,
-0x08080809,
-0x06060707,
-0x04050506,
-0x02030304,
-0x00010102,
-};
-//========================================
-// Delta Gain 1DLUT
-// LUT content is packed as 4-bytes into one DWORD/entry
-// A_start = 0.000000
-// A_end   = 10.000000
-// A_gain  = 1.000000
-// B_start = 11.000000
-// B_end   = 127.000000
-// C_start = 96.000000
-// C_end   = 127.000000
-//========================================
-static const uint32_t filter_isharp_1D_lut_1p0x[ISHARP_LUT_TABLE_SIZE] = {
-0x01000000,
-0x05040302,
-0x0B0A0806,
-0x0E0E0D0C,
-0x1211100F,
-0x15141312,
-0x17171615,
-0x1A191918,
-0x1C1B1B1A,
-0x1E1D1D1C,
-0x1F1F1E1E,
-0x2020201F,
-0x21212121,
-0x22222222,
-0x23232222,
-0x23232323,
-0x23232323,
-0x22222323,
-0x22222222,
-0x21212121,
-0x1F202020,
-0x1E1E1F1F,
-0x1C1D1D1E,
-0x1A1B1B1C,
-0x1819191A,
-0x15161717,
-0x12131415,
-0x0F101112,
-0x0C0D0E0E,
-0x08090A0B,
-0x04050607,
-0x00010203,
-};
-//========================================
-// Delta Gain 1DLUT
-// LUT content is packed as 4-bytes into one DWORD/entry
-// A_start = 0.000000
-// A_end   = 10.000000
-// A_gain  = 1.500000
-// B_start = 11.000000
-// B_end   = 127.000000
-// C_start = 96.000000
-// C_end   = 127.000000
-//========================================
-static const uint32_t filter_isharp_1D_lut_1p5x[ISHARP_LUT_TABLE_SIZE] = {
-0x01010000,
-0x07050402,
-0x110F0C0A,
-0x16141312,
-0x1B191817,
-0x1F1E1D1C,
-0x23222120,
-0x26262524,
-0x2A292827,
-0x2C2C2B2A,
-0x2F2E2E2D,
-0x3130302F,
-0x32323131,
-0x33333332,
-0x34343433,
-0x34343434,
-0x34343434,
-0x33343434,
-0x32333333,
-0x31313232,
-0x2F303031,
-0x2D2E2E2F,
-0x2A2B2C2C,
-0x2728292A,
-0x24252626,
-0x20212223,
-0x1C1D1E1F,
-0x1718191B,
-0x12131416,
-0x0C0E0F10,
-0x0608090B,
-0x00020305
-};
-//========================================
-// Delta Gain 1DLUT
-// LUT content is packed as 4-bytes into one DWORD/entry
-// A_start = 0.000000
-// A_end   = 10.000000
-// A_gain  = 2.000000
-// B_start = 11.000000
-// B_end   = 127.000000
-// C_start = 40.000000
-// C_end   = 127.000000
-//========================================
-static const uint32_t filter_isharp_1D_lut_2p0x[ISHARP_LUT_TABLE_SIZE] = {
-0x02010000,
-0x0A070503,
-0x1614100D,
-0x1D1B1A18,
-0x2322201F,
-0x29282625,
-0x2F2D2C2B,
-0x33323130,
-0x38373534,
-0x3B3A3938,
-0x3E3E3D3C,
-0x4140403F,
-0x43424241,
-0x44444443,
-0x45454545,
-0x46454545,
-0x45454546,
-0x45454545,
-0x43444444,
-0x41424243,
-0x3F404041,
-0x3C3D3E3E,
-0x38393A3B,
-0x34353738,
-0x30313233,
-0x2B2C2D2F,
-0x25262829,
-0x1F202223,
-0x181A1B1D,
-0x10121416,
-0x080B0D0E,
-0x00020406,
-};
-//========================================
-// Delta Gain 1DLUT
-// LUT content is packed as 4-bytes into one DWORD/entry
-// A_start = 0.000000
-// A_end   = 10.000000
-// A_gain  = 3.000000
-// B_start = 11.000000
-// B_end   = 127.000000
-// C_start = 40.000000
-// C_end   = 127.000000
-//========================================
-static const uint32_t filter_isharp_1D_lut_3p0x[ISHARP_LUT_TABLE_SIZE] = {
-0x03010000,
-0x0F0B0805,
-0x211E1813,
-0x2B292624,
-0x3533302E,
-0x3E3C3A37,
-0x46444240,
-0x4D4B4A48,
-0x5352504F,
-0x59575655,
-0x5D5C5B5A,
-0x61605F5E,
-0x64646362,
-0x66666565,
-0x68686767,
-0x68686868,
-0x68686868,
-0x67676868,
-0x65656666,
-0x62636464,
-0x5E5F6061,
-0x5A5B5C5D,
-0x55565759,
-0x4F505253,
-0x484A4B4D,
-0x40424446,
-0x373A3C3E,
-0x2E303335,
-0x2426292B,
-0x191B1E21,
-0x0D101316,
-0x0003060A,
-};
-
-//========================================
-// Wide scaler coefficients
-//========================================================
-// <using>			gen_scaler_coeffs.m
-// <date>			15-Dec-2021
-// <coeffDescrip>	6t_64p_LanczosEd_p_1_p_10qb_
-// <num_taps>		6
-// <num_phases>		64
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t filter_isharp_wide_6tap_64p[198] = {
-0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000,
-0x0003, 0x0FF3, 0x0400, 0x000D, 0x0FFD, 0x0000,
-0x0006, 0x0FE7, 0x03FE, 0x001C, 0x0FF9, 0x0000,
-0x0009, 0x0FDB, 0x03FC, 0x002B, 0x0FF5, 0x0000,
-0x000C, 0x0FD0, 0x03F9, 0x003A, 0x0FF1, 0x0000,
-0x000E, 0x0FC5, 0x03F5, 0x004A, 0x0FED, 0x0001,
-0x0011, 0x0FBB, 0x03F0, 0x005A, 0x0FE9, 0x0001,
-0x0013, 0x0FB2, 0x03EB, 0x006A, 0x0FE5, 0x0001,
-0x0015, 0x0FA9, 0x03E4, 0x007B, 0x0FE1, 0x0002,
-0x0017, 0x0FA1, 0x03DD, 0x008D, 0x0FDC, 0x0002,
-0x0018, 0x0F99, 0x03D4, 0x00A0, 0x0FD8, 0x0003,
-0x001A, 0x0F92, 0x03CB, 0x00B2, 0x0FD3, 0x0004,
-0x001B, 0x0F8C, 0x03C1, 0x00C6, 0x0FCE, 0x0004,
-0x001C, 0x0F86, 0x03B7, 0x00D9, 0x0FC9, 0x0005,
-0x001D, 0x0F80, 0x03AB, 0x00EE, 0x0FC4, 0x0006,
-0x001E, 0x0F7C, 0x039F, 0x0101, 0x0FBF, 0x0007,
-0x001F, 0x0F78, 0x0392, 0x0115, 0x0FBA, 0x0008,
-0x001F, 0x0F74, 0x0385, 0x012B, 0x0FB5, 0x0008,
-0x0020, 0x0F71, 0x0376, 0x0140, 0x0FB0, 0x0009,
-0x0020, 0x0F6E, 0x0367, 0x0155, 0x0FAB, 0x000B,
-0x0020, 0x0F6C, 0x0357, 0x016B, 0x0FA6, 0x000C,
-0x0020, 0x0F6A, 0x0347, 0x0180, 0x0FA2, 0x000D,
-0x0020, 0x0F69, 0x0336, 0x0196, 0x0F9D, 0x000E,
-0x0020, 0x0F69, 0x0325, 0x01AB, 0x0F98, 0x000F,
-0x001F, 0x0F68, 0x0313, 0x01C3, 0x0F93, 0x0010,
-0x001F, 0x0F69, 0x0300, 0x01D8, 0x0F8F, 0x0011,
-0x001E, 0x0F69, 0x02ED, 0x01EF, 0x0F8B, 0x0012,
-0x001D, 0x0F6A, 0x02D9, 0x0205, 0x0F87, 0x0014,
-0x001D, 0x0F6C, 0x02C5, 0x021A, 0x0F83, 0x0015,
-0x001C, 0x0F6E, 0x02B1, 0x0230, 0x0F7F, 0x0016,
-0x001B, 0x0F70, 0x029C, 0x0247, 0x0F7B, 0x0017,
-0x001A, 0x0F72, 0x0287, 0x025D, 0x0F78, 0x0018,
-0x0019, 0x0F75, 0x0272, 0x0272, 0x0F75, 0x0019
-};
-// Blur and scale coefficients
-//========================================================
-// <using>			gen_BlurScale_coeffs.m
-// <date>			25-Apr-2022
-// <num_taps>		4
-// <num_phases>		64
-// <CoefType>		Blur & Scale LPF
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t filter_isharp_bs_4tap_in_6_64p[198] = {
-0x0000, 0x00E5, 0x0237, 0x00E4, 0x0000, 0x0000,
-0x0000, 0x00DE, 0x0237, 0x00EB, 0x0000, 0x0000,
-0x0000, 0x00D7, 0x0236, 0x00F2, 0x0001, 0x0000,
-0x0000, 0x00D0, 0x0235, 0x00FA, 0x0001, 0x0000,
-0x0000, 0x00C9, 0x0234, 0x0101, 0x0002, 0x0000,
-0x0000, 0x00C2, 0x0233, 0x0108, 0x0003, 0x0000,
-0x0000, 0x00BB, 0x0232, 0x0110, 0x0003, 0x0000,
-0x0000, 0x00B5, 0x0230, 0x0117, 0x0004, 0x0000,
-0x0000, 0x00AE, 0x022E, 0x011F, 0x0005, 0x0000,
-0x0000, 0x00A8, 0x022C, 0x0126, 0x0006, 0x0000,
-0x0000, 0x00A2, 0x022A, 0x012D, 0x0007, 0x0000,
-0x0000, 0x009C, 0x0228, 0x0134, 0x0008, 0x0000,
-0x0000, 0x0096, 0x0225, 0x013C, 0x0009, 0x0000,
-0x0000, 0x0090, 0x0222, 0x0143, 0x000B, 0x0000,
-0x0000, 0x008A, 0x021F, 0x014B, 0x000C, 0x0000,
-0x0000, 0x0085, 0x021C, 0x0151, 0x000E, 0x0000,
-0x0000, 0x007F, 0x0218, 0x015A, 0x000F, 0x0000,
-0x0000, 0x007A, 0x0215, 0x0160, 0x0011, 0x0000,
-0x0000, 0x0074, 0x0211, 0x0168, 0x0013, 0x0000,
-0x0000, 0x006F, 0x020D, 0x016F, 0x0015, 0x0000,
-0x0000, 0x006A, 0x0209, 0x0176, 0x0017, 0x0000,
-0x0000, 0x0065, 0x0204, 0x017E, 0x0019, 0x0000,
-0x0000, 0x0060, 0x0200, 0x0185, 0x001B, 0x0000,
-0x0000, 0x005C, 0x01FB, 0x018C, 0x001D, 0x0000,
-0x0000, 0x0057, 0x01F6, 0x0193, 0x0020, 0x0000,
-0x0000, 0x0053, 0x01F1, 0x019A, 0x0022, 0x0000,
-0x0000, 0x004E, 0x01EC, 0x01A1, 0x0025, 0x0000,
-0x0000, 0x004A, 0x01E6, 0x01A8, 0x0028, 0x0000,
-0x0000, 0x0046, 0x01E1, 0x01AF, 0x002A, 0x0000,
-0x0000, 0x0042, 0x01DB, 0x01B6, 0x002D, 0x0000,
-0x0000, 0x003F, 0x01D5, 0x01BB, 0x0031, 0x0000,
-0x0000, 0x003B, 0x01CF, 0x01C2, 0x0034, 0x0000,
-0x0000, 0x0037, 0x01C9, 0x01C9, 0x0037, 0x0000
-};
-//========================================================
-// <using>			gen_BlurScale_coeffs.m
-// <date>			25-Apr-2022
-// <num_taps>		4
-// <num_phases>		64
-// <CoefType>		Blur & Scale LPF
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t filter_isharp_bs_4tap_64p[132] = {
-0x00E5, 0x0237, 0x00E4, 0x0000,
-0x00DE, 0x0237, 0x00EB, 0x0000,
-0x00D7, 0x0236, 0x00F2, 0x0001,
-0x00D0, 0x0235, 0x00FA, 0x0001,
-0x00C9, 0x0234, 0x0101, 0x0002,
-0x00C2, 0x0233, 0x0108, 0x0003,
-0x00BB, 0x0232, 0x0110, 0x0003,
-0x00B5, 0x0230, 0x0117, 0x0004,
-0x00AE, 0x022E, 0x011F, 0x0005,
-0x00A8, 0x022C, 0x0126, 0x0006,
-0x00A2, 0x022A, 0x012D, 0x0007,
-0x009C, 0x0228, 0x0134, 0x0008,
-0x0096, 0x0225, 0x013C, 0x0009,
-0x0090, 0x0222, 0x0143, 0x000B,
-0x008A, 0x021F, 0x014B, 0x000C,
-0x0085, 0x021C, 0x0151, 0x000E,
-0x007F, 0x0218, 0x015A, 0x000F,
-0x007A, 0x0215, 0x0160, 0x0011,
-0x0074, 0x0211, 0x0168, 0x0013,
-0x006F, 0x020D, 0x016F, 0x0015,
-0x006A, 0x0209, 0x0176, 0x0017,
-0x0065, 0x0204, 0x017E, 0x0019,
-0x0060, 0x0200, 0x0185, 0x001B,
-0x005C, 0x01FB, 0x018C, 0x001D,
-0x0057, 0x01F6, 0x0193, 0x0020,
-0x0053, 0x01F1, 0x019A, 0x0022,
-0x004E, 0x01EC, 0x01A1, 0x0025,
-0x004A, 0x01E6, 0x01A8, 0x0028,
-0x0046, 0x01E1, 0x01AF, 0x002A,
-0x0042, 0x01DB, 0x01B6, 0x002D,
-0x003F, 0x01D5, 0x01BB, 0x0031,
-0x003B, 0x01CF, 0x01C2, 0x0034,
-0x0037, 0x01C9, 0x01C9, 0x0037,
-};
-//========================================================
-// <using>			gen_BlurScale_coeffs.m
-// <date>			09-Jun-2022
-// <num_taps>		3
-// <num_phases>		64
-// <CoefType>		Blur & Scale LPF
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t filter_isharp_bs_3tap_64p[99] = {
-0x0200, 0x0200, 0x0000,
-0x01F6, 0x0206, 0x0004,
-0x01EC, 0x020B, 0x0009,
-0x01E2, 0x0211, 0x000D,
-0x01D8, 0x0216, 0x0012,
-0x01CE, 0x021C, 0x0016,
-0x01C4, 0x0221, 0x001B,
-0x01BA, 0x0226, 0x0020,
-0x01B0, 0x022A, 0x0026,
-0x01A6, 0x022F, 0x002B,
-0x019C, 0x0233, 0x0031,
-0x0192, 0x0238, 0x0036,
-0x0188, 0x023C, 0x003C,
-0x017E, 0x0240, 0x0042,
-0x0174, 0x0244, 0x0048,
-0x016A, 0x0248, 0x004E,
-0x0161, 0x024A, 0x0055,
-0x0157, 0x024E, 0x005B,
-0x014D, 0x0251, 0x0062,
-0x0144, 0x0253, 0x0069,
-0x013A, 0x0256, 0x0070,
-0x0131, 0x0258, 0x0077,
-0x0127, 0x025B, 0x007E,
-0x011E, 0x025C, 0x0086,
-0x0115, 0x025E, 0x008D,
-0x010B, 0x0260, 0x0095,
-0x0102, 0x0262, 0x009C,
-0x00F9, 0x0263, 0x00A4,
-0x00F0, 0x0264, 0x00AC,
-0x00E7, 0x0265, 0x00B4,
-0x00DF, 0x0264, 0x00BD,
-0x00D6, 0x0265, 0x00C5,
-0x00CD, 0x0266, 0x00CD,
-};
-
-/* Converted Blur & Scale coeff tables from S1.10 to S1.12 */
-static uint16_t filter_isharp_bs_4tap_in_6_64p_s1_12[198];
-static uint16_t filter_isharp_bs_4tap_64p_s1_12[132];
-static uint16_t filter_isharp_bs_3tap_64p_s1_12[99];
-
-/* Pre-generated 1DLUT for given setup and sharpness level */
-struct isharp_1D_lut_pregen filter_isharp_1D_lut_pregen[NUM_SHARPNESS_SETUPS] = {
-	{
-		0, 0,
-		{
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-		}
-	},
-	{
-		0, 0,
-		{
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-		}
-	},
-	{
-		0, 0,
-		{
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-		}
-	},
-	{
-		0, 0,
-		{
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0,
-		}
-	},
-};
-
-struct scale_ratio_to_sharpness_level_adj sharpness_level_adj[NUM_SHARPNESS_ADJ_LEVELS] = {
-	{1125, 1000, 0},
-	{11, 10, 1},
-	{1075, 1000, 2},
-	{105, 100, 3},
-	{1025, 1000, 4},
-	{1, 1, 5},
-};
-
-const uint32_t *spl_get_filter_isharp_1D_lut_0(void)
-{
-	return filter_isharp_1D_lut_0;
-}
-const uint32_t *spl_get_filter_isharp_1D_lut_0p5x(void)
-{
-	return filter_isharp_1D_lut_0p5x;
-}
-const uint32_t *spl_get_filter_isharp_1D_lut_1p0x(void)
-{
-	return filter_isharp_1D_lut_1p0x;
-}
-const uint32_t *spl_get_filter_isharp_1D_lut_1p5x(void)
-{
-	return filter_isharp_1D_lut_1p5x;
-}
-const uint32_t *spl_get_filter_isharp_1D_lut_2p0x(void)
-{
-	return filter_isharp_1D_lut_2p0x;
-}
-const uint32_t *spl_get_filter_isharp_1D_lut_3p0x(void)
-{
-	return filter_isharp_1D_lut_3p0x;
-}
-const uint16_t *spl_get_filter_isharp_wide_6tap_64p(void)
-{
-	return filter_isharp_wide_6tap_64p;
-}
-uint16_t *spl_get_filter_isharp_bs_4tap_in_6_64p(void)
-{
-	return filter_isharp_bs_4tap_in_6_64p_s1_12;
-}
-uint16_t *spl_get_filter_isharp_bs_4tap_64p(void)
-{
-	return filter_isharp_bs_4tap_64p_s1_12;
-}
-uint16_t *spl_get_filter_isharp_bs_3tap_64p(void)
-{
-	return filter_isharp_bs_3tap_64p_s1_12;
-}
-
-static unsigned int spl_calculate_sharpness_level_adj(struct spl_fixed31_32 ratio)
-{
-	int j;
-	struct spl_fixed31_32 ratio_level;
-	struct scale_ratio_to_sharpness_level_adj *lookup_ptr;
-	unsigned int sharpness_level_down_adj;
-
-	/*
-	 * Adjust sharpness level based on current scaling ratio
-	 *
-	 * We have 5 discrete scaling ratios which we will use to adjust the
-	 *  sharpness level down by 1 as we pass each ratio.  The ratios
-	 *  are
-	 *
-	 * 1.125 upscale and higher - no adj
-	 * 1.100 - under 1.125 - adj level down 1
-	 * 1.075 - under 1.100 - adj level down 2
-	 * 1.050 - under 1.075 - adj level down 3
-	 * 1.025 - under 1.050 - adj level down 4
-	 * 1.000 - under 1.025 - adj level down 5
-	 *
-	 */
-	j = 0;
-	sharpness_level_down_adj = 0;
-	lookup_ptr = sharpness_level_adj;
-	while (j < NUM_SHARPNESS_ADJ_LEVELS) {
-		ratio_level = spl_fixpt_from_fraction(lookup_ptr->ratio_numer,
-			lookup_ptr->ratio_denom);
-		if (ratio.value >= ratio_level.value) {
-			sharpness_level_down_adj = lookup_ptr->level_down_adj;
-			break;
-		}
-		lookup_ptr++;
-		j++;
-	}
-	return sharpness_level_down_adj;
-}
-
-static unsigned int spl_calculate_sharpness_level(struct spl_fixed31_32 ratio,
-		int discrete_sharpness_level, enum system_setup setup,
-		struct spl_sharpness_range sharpness_range,
-		enum scale_to_sharpness_policy scale_to_sharpness_policy)
-{
-	unsigned int sharpness_level = 0;
-	unsigned int sharpness_level_down_adj = 0;
-
-	int min_sharpness, max_sharpness, mid_sharpness;
-
-	/*
-	 * Adjust sharpness level if policy requires we adjust it based on
-	 *  scale ratio.  Based on scale ratio, we may adjust the sharpness
-	 *  level down by a certain number of steps.  We will not select
-	 *  a sharpness value of 0 so the lowest sharpness level will be
-	 *  0 or 1 depending on what the min_sharpness is
-	 *
-	 * If the policy is no required, this code maybe removed at a later
-	 *  date
-	 */
-	switch (setup) {
-
-	case HDR_L:
-		min_sharpness = sharpness_range.hdr_rgb_min;
-		max_sharpness = sharpness_range.hdr_rgb_max;
-		mid_sharpness = sharpness_range.hdr_rgb_mid;
-		if (scale_to_sharpness_policy == SCALE_TO_SHARPNESS_ADJ_ALL)
-			sharpness_level_down_adj = spl_calculate_sharpness_level_adj(ratio);
-		break;
-	case HDR_NL:
-		/* currently no use case, use Non-linear SDR values for now */
-	case SDR_NL:
-		min_sharpness = sharpness_range.sdr_yuv_min;
-		max_sharpness = sharpness_range.sdr_yuv_max;
-		mid_sharpness = sharpness_range.sdr_yuv_mid;
-		if (scale_to_sharpness_policy >= SCALE_TO_SHARPNESS_ADJ_YUV)
-			sharpness_level_down_adj = spl_calculate_sharpness_level_adj(ratio);
-		break;
-	case SDR_L:
-	default:
-		min_sharpness = sharpness_range.sdr_rgb_min;
-		max_sharpness = sharpness_range.sdr_rgb_max;
-		mid_sharpness = sharpness_range.sdr_rgb_mid;
-		if (scale_to_sharpness_policy == SCALE_TO_SHARPNESS_ADJ_ALL)
-			sharpness_level_down_adj = spl_calculate_sharpness_level_adj(ratio);
-		break;
-	}
-
-	if ((min_sharpness == 0) && (sharpness_level_down_adj >= discrete_sharpness_level))
-		discrete_sharpness_level = 1;
-	else if (sharpness_level_down_adj >= discrete_sharpness_level)
-		discrete_sharpness_level = 0;
-	else
-		discrete_sharpness_level -= sharpness_level_down_adj;
-
-	int lower_half_step_size = (mid_sharpness - min_sharpness) / 5;
-	int upper_half_step_size = (max_sharpness - mid_sharpness) / 5;
-
-	// lower half linear approximation
-	if (discrete_sharpness_level < 5)
-		sharpness_level = min_sharpness + (lower_half_step_size * discrete_sharpness_level);
-	// upper half linear approximation
-	else
-		sharpness_level = mid_sharpness + (upper_half_step_size * (discrete_sharpness_level - 5));
-
-	return sharpness_level;
-}
-
-void spl_build_isharp_1dlut_from_reference_curve(struct spl_fixed31_32 ratio, enum system_setup setup,
-	struct adaptive_sharpness sharpness, enum scale_to_sharpness_policy scale_to_sharpness_policy)
-{
-	uint8_t *byte_ptr_1dlut_src, *byte_ptr_1dlut_dst;
-	struct spl_fixed31_32 sharp_base, sharp_calc, sharp_level;
-	int j;
-	int size_1dlut;
-	int sharp_calc_int;
-	uint32_t filter_pregen_store[ISHARP_LUT_TABLE_SIZE];
-
-	/* Custom sharpnessX1000 value */
-	unsigned int sharpnessX1000 = spl_calculate_sharpness_level(ratio,
-			sharpness.sharpness_level, setup,
-			sharpness.sharpness_range, scale_to_sharpness_policy);
-	sharp_level = spl_fixpt_from_fraction(sharpnessX1000, 1000);
-
-	/*
-	 * Check if pregen 1dlut table is already precalculated
-	 * If numer/denom is different, then recalculate
-	 */
-	if ((filter_isharp_1D_lut_pregen[setup].sharpness_numer == sharpnessX1000) &&
-		(filter_isharp_1D_lut_pregen[setup].sharpness_denom == 1000))
-		return;
-
-	/*
-	 * Calculate LUT_128_gained with this equation:
-	 *
-	 * LUT_128_gained[i] = (uint8)(0.5 + min(255,(double)(LUT_128[i])*sharpLevel/iGain))
-	 *  where LUT_128[i] is contents of 3p0x isharp 1dlut
-	 *  where sharpLevel is desired sharpness level
-	 *  where iGain is base sharpness level 3.0
-	 *  where LUT_128_gained[i] is adjusted 1dlut value based on desired sharpness level
-	 */
-	byte_ptr_1dlut_src = (uint8_t *)filter_isharp_1D_lut_3p0x;
-	byte_ptr_1dlut_dst = (uint8_t *)filter_pregen_store;
-	size_1dlut = sizeof(filter_isharp_1D_lut_3p0x);
-	memset(byte_ptr_1dlut_dst, 0, size_1dlut);
-	for (j = 0; j < size_1dlut; j++) {
-		sharp_base = spl_fixpt_from_int((int)*byte_ptr_1dlut_src);
-		sharp_calc = spl_fixpt_mul(sharp_base, sharp_level);
-		sharp_calc = spl_fixpt_div(sharp_calc, spl_fixpt_from_int(3));
-		sharp_calc = spl_fixpt_min(spl_fixpt_from_int(255), sharp_calc);
-		sharp_calc = spl_fixpt_add(sharp_calc, spl_fixpt_from_fraction(1, 2));
-		sharp_calc_int = spl_fixpt_floor(sharp_calc);
-		/* Clamp it at 0x7F so it doesn't wrap */
-		if (sharp_calc_int > 127)
-			sharp_calc_int = 127;
-		*byte_ptr_1dlut_dst = (uint8_t)sharp_calc_int;
-
-		byte_ptr_1dlut_src++;
-		byte_ptr_1dlut_dst++;
-	}
-
-	/* Update 1dlut table and sharpness level */
-	memcpy((void *)filter_isharp_1D_lut_pregen[setup].value, (void *)filter_pregen_store, size_1dlut);
-	filter_isharp_1D_lut_pregen[setup].sharpness_numer = sharpnessX1000;
-	filter_isharp_1D_lut_pregen[setup].sharpness_denom = 1000;
-}
-
-uint32_t *spl_get_pregen_filter_isharp_1D_lut(enum system_setup setup)
-{
-	return filter_isharp_1D_lut_pregen[setup].value;
-}
-
-void spl_init_blur_scale_coeffs(void)
-{
-	convert_filter_s1_10_to_s1_12(filter_isharp_bs_3tap_64p,
-		filter_isharp_bs_3tap_64p_s1_12, 3);
-	convert_filter_s1_10_to_s1_12(filter_isharp_bs_4tap_64p,
-		filter_isharp_bs_4tap_64p_s1_12, 4);
-	convert_filter_s1_10_to_s1_12(filter_isharp_bs_4tap_in_6_64p,
-		filter_isharp_bs_4tap_in_6_64p_s1_12, 6);
-}
-
-uint16_t *spl_dscl_get_blur_scale_coeffs_64p(int taps)
-{
-	if (taps == 3)
-		return spl_get_filter_isharp_bs_3tap_64p();
-	else if (taps == 4)
-		return spl_get_filter_isharp_bs_4tap_64p();
-	else if (taps == 6)
-		return spl_get_filter_isharp_bs_4tap_in_6_64p();
-	else {
-		/* should never happen, bug */
-		SPL_BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-}
-
-void spl_set_blur_scale_data(struct dscl_prog_data *dscl_prog_data,
-		const struct spl_scaler_data *data)
-{
-	dscl_prog_data->filter_blur_scale_h =
-		spl_dscl_get_blur_scale_coeffs_64p(data->taps.h_taps);
-
-	dscl_prog_data->filter_blur_scale_v =
-		spl_dscl_get_blur_scale_coeffs_64p(data->taps.v_taps);
-}
-
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_isharp_filters.h b/drivers/gpu/drm/amd/display/dc/spl/dc_spl_isharp_filters.h
deleted file mode 100644
index 89af91e19b6c..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_isharp_filters.h
+++ /dev/null
@@ -1,50 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#ifndef __DC_SPL_ISHARP_FILTERS_H__
-#define __DC_SPL_ISHARP_FILTERS_H__
-
-#include "dc_spl_types.h"
-
-const uint32_t *spl_get_filter_isharp_1D_lut_0(void);
-const uint32_t *spl_get_filter_isharp_1D_lut_0p5x(void);
-const uint32_t *spl_get_filter_isharp_1D_lut_1p0x(void);
-const uint32_t *spl_get_filter_isharp_1D_lut_1p5x(void);
-const uint32_t *spl_get_filter_isharp_1D_lut_2p0x(void);
-const uint32_t *spl_get_filter_isharp_1D_lut_3p0x(void);
-uint16_t *spl_get_filter_isharp_bs_4tap_in_6_64p(void);
-uint16_t *spl_get_filter_isharp_bs_4tap_64p(void);
-uint16_t *spl_get_filter_isharp_bs_3tap_64p(void);
-const uint16_t *spl_get_filter_isharp_wide_6tap_64p(void);
-uint16_t *spl_dscl_get_blur_scale_coeffs_64p(int taps);
-
-#define NUM_SHARPNESS_ADJ_LEVELS 6
-struct scale_ratio_to_sharpness_level_adj {
-	unsigned int ratio_numer;
-	unsigned int ratio_denom;
-	unsigned int level_down_adj; /* adjust sharpness level down */
-};
-
-struct isharp_1D_lut_pregen {
-	unsigned int sharpness_numer;
-	unsigned int sharpness_denom;
-	uint32_t value[ISHARP_LUT_TABLE_SIZE];
-};
-
-enum system_setup {
-	SDR_NL = 0,
-	SDR_L,
-	HDR_NL,
-	HDR_L,
-	NUM_SHARPNESS_SETUPS
-};
-
-void spl_init_blur_scale_coeffs(void);
-void spl_set_blur_scale_data(struct dscl_prog_data *dscl_prog_data,
-	const struct spl_scaler_data *data);
-
-void spl_build_isharp_1dlut_from_reference_curve(struct spl_fixed31_32 ratio, enum system_setup setup,
-	struct adaptive_sharpness sharpness, enum scale_to_sharpness_policy scale_to_sharpness_policy);
-uint32_t *spl_get_pregen_filter_isharp_1D_lut(enum system_setup setup);
-#endif /* __DC_SPL_ISHARP_FILTERS_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_easf_filters.c b/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_easf_filters.c
deleted file mode 100644
index 09bf82f7d468..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_easf_filters.c
+++ /dev/null
@@ -1,1726 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#include "spl_debug.h"
-#include "dc_spl_filters.h"
-#include "dc_spl_scl_filters.h"
-#include "dc_spl_scl_easf_filters.h"
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	3t_64p_LanczosEd_p_0.3_p_10qb_
-// <num_taps>		3
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.300000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_3tap_64p_ratio_0_30[99] = {
-	0x0200, 0x0200, 0x0000,
-	0x01F6, 0x0206, 0x0004,
-	0x01EC, 0x020B, 0x0009,
-	0x01E2, 0x0211, 0x000D,
-	0x01D8, 0x0216, 0x0012,
-	0x01CE, 0x021C, 0x0016,
-	0x01C4, 0x0221, 0x001B,
-	0x01BA, 0x0226, 0x0020,
-	0x01B0, 0x022A, 0x0026,
-	0x01A6, 0x022F, 0x002B,
-	0x019C, 0x0233, 0x0031,
-	0x0192, 0x0238, 0x0036,
-	0x0188, 0x023C, 0x003C,
-	0x017E, 0x0240, 0x0042,
-	0x0174, 0x0244, 0x0048,
-	0x016A, 0x0248, 0x004E,
-	0x0161, 0x024A, 0x0055,
-	0x0157, 0x024E, 0x005B,
-	0x014D, 0x0251, 0x0062,
-	0x0144, 0x0253, 0x0069,
-	0x013A, 0x0256, 0x0070,
-	0x0131, 0x0258, 0x0077,
-	0x0127, 0x025B, 0x007E,
-	0x011E, 0x025C, 0x0086,
-	0x0115, 0x025E, 0x008D,
-	0x010B, 0x0260, 0x0095,
-	0x0102, 0x0262, 0x009C,
-	0x00F9, 0x0263, 0x00A4,
-	0x00F0, 0x0264, 0x00AC,
-	0x00E7, 0x0265, 0x00B4,
-	0x00DF, 0x0264, 0x00BD,
-	0x00D6, 0x0265, 0x00C5,
-	0x00CD, 0x0266, 0x00CD,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	3t_64p_LanczosEd_p_0.4_p_10qb_
-// <num_taps>		3
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.400000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_3tap_64p_ratio_0_40[99] = {
-	0x0200, 0x0200, 0x0000,
-	0x01F6, 0x0206, 0x0004,
-	0x01EB, 0x020E, 0x0007,
-	0x01E1, 0x0214, 0x000B,
-	0x01D7, 0x021A, 0x000F,
-	0x01CD, 0x0220, 0x0013,
-	0x01C2, 0x0226, 0x0018,
-	0x01B8, 0x022C, 0x001C,
-	0x01AE, 0x0231, 0x0021,
-	0x01A3, 0x0237, 0x0026,
-	0x0199, 0x023C, 0x002B,
-	0x018F, 0x0240, 0x0031,
-	0x0185, 0x0245, 0x0036,
-	0x017A, 0x024A, 0x003C,
-	0x0170, 0x024F, 0x0041,
-	0x0166, 0x0253, 0x0047,
-	0x015C, 0x0257, 0x004D,
-	0x0152, 0x025A, 0x0054,
-	0x0148, 0x025E, 0x005A,
-	0x013E, 0x0261, 0x0061,
-	0x0134, 0x0264, 0x0068,
-	0x012B, 0x0266, 0x006F,
-	0x0121, 0x0269, 0x0076,
-	0x0117, 0x026C, 0x007D,
-	0x010E, 0x026E, 0x0084,
-	0x0104, 0x0270, 0x008C,
-	0x00FB, 0x0271, 0x0094,
-	0x00F2, 0x0272, 0x009C,
-	0x00E9, 0x0273, 0x00A4,
-	0x00E0, 0x0274, 0x00AC,
-	0x00D7, 0x0275, 0x00B4,
-	0x00CE, 0x0275, 0x00BD,
-	0x00C5, 0x0276, 0x00C5,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	3t_64p_LanczosEd_p_0.5_p_10qb_
-// <num_taps>		3
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.500000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_3tap_64p_ratio_0_50[99] = {
-	0x0200, 0x0200, 0x0000,
-	0x01F5, 0x0209, 0x0002,
-	0x01EA, 0x0211, 0x0005,
-	0x01DF, 0x021A, 0x0007,
-	0x01D4, 0x0222, 0x000A,
-	0x01C9, 0x022A, 0x000D,
-	0x01BE, 0x0232, 0x0010,
-	0x01B3, 0x0239, 0x0014,
-	0x01A8, 0x0241, 0x0017,
-	0x019D, 0x0248, 0x001B,
-	0x0192, 0x024F, 0x001F,
-	0x0187, 0x0255, 0x0024,
-	0x017C, 0x025C, 0x0028,
-	0x0171, 0x0262, 0x002D,
-	0x0166, 0x0268, 0x0032,
-	0x015B, 0x026E, 0x0037,
-	0x0150, 0x0273, 0x003D,
-	0x0146, 0x0278, 0x0042,
-	0x013B, 0x027D, 0x0048,
-	0x0130, 0x0282, 0x004E,
-	0x0126, 0x0286, 0x0054,
-	0x011B, 0x028A, 0x005B,
-	0x0111, 0x028D, 0x0062,
-	0x0107, 0x0290, 0x0069,
-	0x00FD, 0x0293, 0x0070,
-	0x00F3, 0x0296, 0x0077,
-	0x00E9, 0x0298, 0x007F,
-	0x00DF, 0x029A, 0x0087,
-	0x00D5, 0x029C, 0x008F,
-	0x00CC, 0x029D, 0x0097,
-	0x00C3, 0x029E, 0x009F,
-	0x00BA, 0x029E, 0x00A8,
-	0x00B1, 0x029E, 0x00B1,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	3t_64p_LanczosEd_p_0.6_p_10qb_
-// <num_taps>		3
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.600000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_3tap_64p_ratio_0_60[99] = {
-	0x0200, 0x0200, 0x0000,
-	0x01F4, 0x020B, 0x0001,
-	0x01E8, 0x0216, 0x0002,
-	0x01DC, 0x0221, 0x0003,
-	0x01D0, 0x022B, 0x0005,
-	0x01C4, 0x0235, 0x0007,
-	0x01B8, 0x0240, 0x0008,
-	0x01AC, 0x0249, 0x000B,
-	0x01A0, 0x0253, 0x000D,
-	0x0194, 0x025C, 0x0010,
-	0x0188, 0x0265, 0x0013,
-	0x017C, 0x026E, 0x0016,
-	0x0170, 0x0277, 0x0019,
-	0x0164, 0x027F, 0x001D,
-	0x0158, 0x0287, 0x0021,
-	0x014C, 0x028F, 0x0025,
-	0x0140, 0x0297, 0x0029,
-	0x0135, 0x029D, 0x002E,
-	0x0129, 0x02A4, 0x0033,
-	0x011D, 0x02AB, 0x0038,
-	0x0112, 0x02B0, 0x003E,
-	0x0107, 0x02B5, 0x0044,
-	0x00FC, 0x02BA, 0x004A,
-	0x00F1, 0x02BF, 0x0050,
-	0x00E6, 0x02C3, 0x0057,
-	0x00DB, 0x02C7, 0x005E,
-	0x00D1, 0x02CA, 0x0065,
-	0x00C7, 0x02CC, 0x006D,
-	0x00BD, 0x02CE, 0x0075,
-	0x00B3, 0x02D0, 0x007D,
-	0x00A9, 0x02D2, 0x0085,
-	0x00A0, 0x02D2, 0x008E,
-	0x0097, 0x02D2, 0x0097,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	3t_64p_LanczosEd_p_0.7_p_10qb_
-// <num_taps>		3
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.700000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_3tap_64p_ratio_0_70[99] = {
-	0x0200, 0x0200, 0x0000,
-	0x01F3, 0x020D, 0x0000,
-	0x01E5, 0x021B, 0x0000,
-	0x01D8, 0x0228, 0x0000,
-	0x01CB, 0x0235, 0x0000,
-	0x01BD, 0x0243, 0x0000,
-	0x01B0, 0x024F, 0x0001,
-	0x01A2, 0x025C, 0x0002,
-	0x0195, 0x0268, 0x0003,
-	0x0187, 0x0275, 0x0004,
-	0x017A, 0x0280, 0x0006,
-	0x016D, 0x028C, 0x0007,
-	0x015F, 0x0298, 0x0009,
-	0x0152, 0x02A2, 0x000C,
-	0x0145, 0x02AD, 0x000E,
-	0x0138, 0x02B7, 0x0011,
-	0x012B, 0x02C0, 0x0015,
-	0x011E, 0x02CA, 0x0018,
-	0x0111, 0x02D3, 0x001C,
-	0x0105, 0x02DB, 0x0020,
-	0x00F8, 0x02E3, 0x0025,
-	0x00EC, 0x02EA, 0x002A,
-	0x00E0, 0x02F1, 0x002F,
-	0x00D5, 0x02F6, 0x0035,
-	0x00C9, 0x02FC, 0x003B,
-	0x00BE, 0x0301, 0x0041,
-	0x00B3, 0x0305, 0x0048,
-	0x00A8, 0x0309, 0x004F,
-	0x009E, 0x030C, 0x0056,
-	0x0094, 0x030E, 0x005E,
-	0x008A, 0x0310, 0x0066,
-	0x0081, 0x0310, 0x006F,
-	0x0077, 0x0312, 0x0077,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	3t_64p_LanczosEd_p_0.8_p_10qb_
-// <num_taps>		3
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.800000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_3tap_64p_ratio_0_80[99] = {
-	0x0200, 0x0200, 0x0000,
-	0x01F1, 0x0210, 0x0FFF,
-	0x01E2, 0x0220, 0x0FFE,
-	0x01D2, 0x0232, 0x0FFC,
-	0x01C3, 0x0241, 0x0FFC,
-	0x01B4, 0x0251, 0x0FFB,
-	0x01A4, 0x0262, 0x0FFA,
-	0x0195, 0x0271, 0x0FFA,
-	0x0186, 0x0281, 0x0FF9,
-	0x0176, 0x0291, 0x0FF9,
-	0x0167, 0x02A0, 0x0FF9,
-	0x0158, 0x02AE, 0x0FFA,
-	0x0149, 0x02BD, 0x0FFA,
-	0x013A, 0x02CB, 0x0FFB,
-	0x012C, 0x02D7, 0x0FFD,
-	0x011D, 0x02E5, 0x0FFE,
-	0x010F, 0x02F1, 0x0000,
-	0x0101, 0x02FD, 0x0002,
-	0x00F3, 0x0308, 0x0005,
-	0x00E5, 0x0313, 0x0008,
-	0x00D8, 0x031D, 0x000B,
-	0x00CB, 0x0326, 0x000F,
-	0x00BE, 0x032F, 0x0013,
-	0x00B2, 0x0337, 0x0017,
-	0x00A6, 0x033E, 0x001C,
-	0x009A, 0x0345, 0x0021,
-	0x008F, 0x034A, 0x0027,
-	0x0084, 0x034F, 0x002D,
-	0x0079, 0x0353, 0x0034,
-	0x006F, 0x0356, 0x003B,
-	0x0065, 0x0358, 0x0043,
-	0x005C, 0x0359, 0x004B,
-	0x0053, 0x035A, 0x0053,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	3t_64p_LanczosEd_p_0.9_p_10qb_
-// <num_taps>		3
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.900000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_3tap_64p_ratio_0_90[99] = {
-	0x0200, 0x0200, 0x0000,
-	0x01EE, 0x0214, 0x0FFE,
-	0x01DC, 0x0228, 0x0FFC,
-	0x01CA, 0x023C, 0x0FFA,
-	0x01B9, 0x024F, 0x0FF8,
-	0x01A7, 0x0262, 0x0FF7,
-	0x0195, 0x0276, 0x0FF5,
-	0x0183, 0x028A, 0x0FF3,
-	0x0172, 0x029C, 0x0FF2,
-	0x0160, 0x02AF, 0x0FF1,
-	0x014F, 0x02C2, 0x0FEF,
-	0x013E, 0x02D4, 0x0FEE,
-	0x012D, 0x02E5, 0x0FEE,
-	0x011C, 0x02F7, 0x0FED,
-	0x010C, 0x0307, 0x0FED,
-	0x00FB, 0x0318, 0x0FED,
-	0x00EC, 0x0327, 0x0FED,
-	0x00DC, 0x0336, 0x0FEE,
-	0x00CD, 0x0344, 0x0FEF,
-	0x00BE, 0x0352, 0x0FF0,
-	0x00B0, 0x035E, 0x0FF2,
-	0x00A2, 0x036A, 0x0FF4,
-	0x0095, 0x0375, 0x0FF6,
-	0x0088, 0x037F, 0x0FF9,
-	0x007B, 0x0388, 0x0FFD,
-	0x006F, 0x0391, 0x0000,
-	0x0064, 0x0397, 0x0005,
-	0x0059, 0x039D, 0x000A,
-	0x004E, 0x03A3, 0x000F,
-	0x0045, 0x03A6, 0x0015,
-	0x003B, 0x03A9, 0x001C,
-	0x0033, 0x03AA, 0x0023,
-	0x002A, 0x03AC, 0x002A,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	3t_64p_LanczosEd_p_1_p_10qb_
-// <num_taps>		3
-// <num_phases>		64
-// <scale_ratio>	 input/output = 1.000000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_3tap_64p_ratio_1_00[99] = {
-	0x0200, 0x0200, 0x0000,
-	0x01EB, 0x0217, 0x0FFE,
-	0x01D5, 0x022F, 0x0FFC,
-	0x01C0, 0x0247, 0x0FF9,
-	0x01AB, 0x025E, 0x0FF7,
-	0x0196, 0x0276, 0x0FF4,
-	0x0181, 0x028D, 0x0FF2,
-	0x016C, 0x02A5, 0x0FEF,
-	0x0158, 0x02BB, 0x0FED,
-	0x0144, 0x02D1, 0x0FEB,
-	0x0130, 0x02E8, 0x0FE8,
-	0x011C, 0x02FE, 0x0FE6,
-	0x0109, 0x0313, 0x0FE4,
-	0x00F6, 0x0328, 0x0FE2,
-	0x00E4, 0x033C, 0x0FE0,
-	0x00D2, 0x034F, 0x0FDF,
-	0x00C0, 0x0363, 0x0FDD,
-	0x00B0, 0x0374, 0x0FDC,
-	0x009F, 0x0385, 0x0FDC,
-	0x0090, 0x0395, 0x0FDB,
-	0x0081, 0x03A4, 0x0FDB,
-	0x0072, 0x03B3, 0x0FDB,
-	0x0064, 0x03C0, 0x0FDC,
-	0x0057, 0x03CC, 0x0FDD,
-	0x004B, 0x03D6, 0x0FDF,
-	0x003F, 0x03E0, 0x0FE1,
-	0x0034, 0x03E8, 0x0FE4,
-	0x002A, 0x03EF, 0x0FE7,
-	0x0020, 0x03F5, 0x0FEB,
-	0x0017, 0x03FA, 0x0FEF,
-	0x000F, 0x03FD, 0x0FF4,
-	0x0007, 0x03FF, 0x0FFA,
-	0x0000, 0x0400, 0x0000,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	4t_64p_LanczosEd_p_0.3_p_10qb_
-// <num_taps>		4
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.300000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_4tap_64p_ratio_0_30[132] = {
-	0x0104, 0x01F8, 0x0104, 0x0000,
-	0x00FE, 0x01F7, 0x010A, 0x0001,
-	0x00F8, 0x01F6, 0x010F, 0x0003,
-	0x00F2, 0x01F5, 0x0114, 0x0005,
-	0x00EB, 0x01F4, 0x011B, 0x0006,
-	0x00E5, 0x01F3, 0x0120, 0x0008,
-	0x00DF, 0x01F2, 0x0125, 0x000A,
-	0x00DA, 0x01F0, 0x012A, 0x000C,
-	0x00D4, 0x01EE, 0x0130, 0x000E,
-	0x00CE, 0x01ED, 0x0135, 0x0010,
-	0x00C8, 0x01EB, 0x013A, 0x0013,
-	0x00C2, 0x01E9, 0x0140, 0x0015,
-	0x00BD, 0x01E7, 0x0145, 0x0017,
-	0x00B7, 0x01E5, 0x014A, 0x001A,
-	0x00B1, 0x01E2, 0x0151, 0x001C,
-	0x00AC, 0x01E0, 0x0155, 0x001F,
-	0x00A7, 0x01DD, 0x015A, 0x0022,
-	0x00A1, 0x01DB, 0x015F, 0x0025,
-	0x009C, 0x01D8, 0x0165, 0x0027,
-	0x0097, 0x01D5, 0x016A, 0x002A,
-	0x0092, 0x01D2, 0x016E, 0x002E,
-	0x008C, 0x01CF, 0x0174, 0x0031,
-	0x0087, 0x01CC, 0x0179, 0x0034,
-	0x0083, 0x01C9, 0x017D, 0x0037,
-	0x007E, 0x01C5, 0x0182, 0x003B,
-	0x0079, 0x01C2, 0x0187, 0x003E,
-	0x0074, 0x01BE, 0x018C, 0x0042,
-	0x0070, 0x01BA, 0x0190, 0x0046,
-	0x006B, 0x01B7, 0x0195, 0x0049,
-	0x0066, 0x01B3, 0x019A, 0x004D,
-	0x0062, 0x01AF, 0x019E, 0x0051,
-	0x005E, 0x01AB, 0x01A2, 0x0055,
-	0x005A, 0x01A6, 0x01A6, 0x005A,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	4t_64p_LanczosEd_p_0.4_p_10qb_
-// <num_taps>		4
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.400000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_4tap_64p_ratio_0_40[132] = {
-	0x00FB, 0x0209, 0x00FC, 0x0000,
-	0x00F5, 0x0209, 0x0101, 0x0001,
-	0x00EE, 0x0208, 0x0108, 0x0002,
-	0x00E8, 0x0207, 0x010E, 0x0003,
-	0x00E2, 0x0206, 0x0114, 0x0004,
-	0x00DB, 0x0205, 0x011A, 0x0006,
-	0x00D5, 0x0204, 0x0120, 0x0007,
-	0x00CF, 0x0203, 0x0125, 0x0009,
-	0x00C9, 0x0201, 0x012C, 0x000A,
-	0x00C3, 0x01FF, 0x0132, 0x000C,
-	0x00BD, 0x01FD, 0x0138, 0x000E,
-	0x00B7, 0x01FB, 0x013E, 0x0010,
-	0x00B1, 0x01F9, 0x0144, 0x0012,
-	0x00AC, 0x01F7, 0x0149, 0x0014,
-	0x00A6, 0x01F4, 0x0150, 0x0016,
-	0x00A0, 0x01F2, 0x0156, 0x0018,
-	0x009B, 0x01EF, 0x015C, 0x001A,
-	0x0095, 0x01EC, 0x0162, 0x001D,
-	0x0090, 0x01E9, 0x0168, 0x001F,
-	0x008B, 0x01E6, 0x016D, 0x0022,
-	0x0085, 0x01E3, 0x0173, 0x0025,
-	0x0080, 0x01DF, 0x0179, 0x0028,
-	0x007B, 0x01DC, 0x017E, 0x002B,
-	0x0076, 0x01D8, 0x0184, 0x002E,
-	0x0071, 0x01D4, 0x018A, 0x0031,
-	0x006D, 0x01D1, 0x018E, 0x0034,
-	0x0068, 0x01CD, 0x0193, 0x0038,
-	0x0063, 0x01C8, 0x019A, 0x003B,
-	0x005F, 0x01C4, 0x019E, 0x003F,
-	0x005B, 0x01C0, 0x01A3, 0x0042,
-	0x0056, 0x01BB, 0x01A9, 0x0046,
-	0x0052, 0x01B7, 0x01AD, 0x004A,
-	0x004E, 0x01B2, 0x01B2, 0x004E,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	4t_64p_LanczosEd_p_0.5_p_10qb_
-// <num_taps>		4
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.500000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_4tap_64p_ratio_0_50[132] = {
-	0x00E5, 0x0236, 0x00E5, 0x0000,
-	0x00DE, 0x0235, 0x00ED, 0x0000,
-	0x00D7, 0x0235, 0x00F4, 0x0000,
-	0x00D0, 0x0235, 0x00FB, 0x0000,
-	0x00C9, 0x0234, 0x0102, 0x0001,
-	0x00C2, 0x0233, 0x010A, 0x0001,
-	0x00BC, 0x0232, 0x0111, 0x0001,
-	0x00B5, 0x0230, 0x0119, 0x0002,
-	0x00AE, 0x022F, 0x0121, 0x0002,
-	0x00A8, 0x022D, 0x0128, 0x0003,
-	0x00A2, 0x022B, 0x012F, 0x0004,
-	0x009B, 0x0229, 0x0137, 0x0005,
-	0x0095, 0x0226, 0x013F, 0x0006,
-	0x008F, 0x0224, 0x0146, 0x0007,
-	0x0089, 0x0221, 0x014E, 0x0008,
-	0x0083, 0x021E, 0x0155, 0x000A,
-	0x007E, 0x021B, 0x015C, 0x000B,
-	0x0078, 0x0217, 0x0164, 0x000D,
-	0x0072, 0x0213, 0x016D, 0x000E,
-	0x006D, 0x0210, 0x0173, 0x0010,
-	0x0068, 0x020C, 0x017A, 0x0012,
-	0x0063, 0x0207, 0x0182, 0x0014,
-	0x005E, 0x0203, 0x0189, 0x0016,
-	0x0059, 0x01FE, 0x0191, 0x0018,
-	0x0054, 0x01F9, 0x0198, 0x001B,
-	0x0050, 0x01F4, 0x019F, 0x001D,
-	0x004B, 0x01EF, 0x01A6, 0x0020,
-	0x0047, 0x01EA, 0x01AC, 0x0023,
-	0x0043, 0x01E4, 0x01B3, 0x0026,
-	0x003F, 0x01DF, 0x01B9, 0x0029,
-	0x003B, 0x01D9, 0x01C0, 0x002C,
-	0x0037, 0x01D3, 0x01C6, 0x0030,
-	0x0033, 0x01CD, 0x01CD, 0x0033,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	4t_64p_LanczosEd_p_0.6_p_10qb_
-// <num_taps>		4
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.600000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_4tap_64p_ratio_0_60[132] = {
-	0x00C8, 0x026F, 0x00C9, 0x0000,
-	0x00C0, 0x0270, 0x00D1, 0x0FFF,
-	0x00B8, 0x0270, 0x00D9, 0x0FFF,
-	0x00B1, 0x0270, 0x00E1, 0x0FFE,
-	0x00A9, 0x026F, 0x00EB, 0x0FFD,
-	0x00A2, 0x026E, 0x00F3, 0x0FFD,
-	0x009A, 0x026D, 0x00FD, 0x0FFC,
-	0x0093, 0x026C, 0x0105, 0x0FFC,
-	0x008C, 0x026A, 0x010F, 0x0FFB,
-	0x0085, 0x0268, 0x0118, 0x0FFB,
-	0x007E, 0x0265, 0x0122, 0x0FFB,
-	0x0078, 0x0263, 0x012A, 0x0FFB,
-	0x0071, 0x0260, 0x0134, 0x0FFB,
-	0x006B, 0x025C, 0x013E, 0x0FFB,
-	0x0065, 0x0259, 0x0147, 0x0FFB,
-	0x005F, 0x0255, 0x0151, 0x0FFB,
-	0x0059, 0x0251, 0x015A, 0x0FFC,
-	0x0054, 0x024D, 0x0163, 0x0FFC,
-	0x004E, 0x0248, 0x016D, 0x0FFD,
-	0x0049, 0x0243, 0x0176, 0x0FFE,
-	0x0044, 0x023E, 0x017F, 0x0FFF,
-	0x003F, 0x0238, 0x0189, 0x0000,
-	0x003A, 0x0232, 0x0193, 0x0001,
-	0x0036, 0x022C, 0x019C, 0x0002,
-	0x0031, 0x0226, 0x01A5, 0x0004,
-	0x002D, 0x021F, 0x01AF, 0x0005,
-	0x0029, 0x0218, 0x01B8, 0x0007,
-	0x0025, 0x0211, 0x01C1, 0x0009,
-	0x0022, 0x020A, 0x01C9, 0x000B,
-	0x001E, 0x0203, 0x01D2, 0x000D,
-	0x001B, 0x01FB, 0x01DA, 0x0010,
-	0x0018, 0x01F3, 0x01E3, 0x0012,
-	0x0015, 0x01EB, 0x01EB, 0x0015,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	4t_64p_LanczosEd_p_0.7_p_10qb_
-// <num_taps>		4
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.700000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_4tap_64p_ratio_0_70[132] = {
-	0x00A3, 0x02B9, 0x00A4, 0x0000,
-	0x009A, 0x02BA, 0x00AD, 0x0FFF,
-	0x0092, 0x02BA, 0x00B6, 0x0FFE,
-	0x0089, 0x02BA, 0x00C1, 0x0FFC,
-	0x0081, 0x02B9, 0x00CB, 0x0FFB,
-	0x0079, 0x02B8, 0x00D5, 0x0FFA,
-	0x0071, 0x02B7, 0x00DF, 0x0FF9,
-	0x0069, 0x02B5, 0x00EA, 0x0FF8,
-	0x0062, 0x02B3, 0x00F4, 0x0FF7,
-	0x005B, 0x02B0, 0x00FF, 0x0FF6,
-	0x0054, 0x02AD, 0x010B, 0x0FF4,
-	0x004D, 0x02A9, 0x0117, 0x0FF3,
-	0x0046, 0x02A5, 0x0123, 0x0FF2,
-	0x0040, 0x02A1, 0x012D, 0x0FF2,
-	0x003A, 0x029C, 0x0139, 0x0FF1,
-	0x0034, 0x0297, 0x0145, 0x0FF0,
-	0x002F, 0x0292, 0x0150, 0x0FEF,
-	0x0029, 0x028C, 0x015C, 0x0FEF,
-	0x0024, 0x0285, 0x0169, 0x0FEE,
-	0x001F, 0x027F, 0x0174, 0x0FEE,
-	0x001B, 0x0278, 0x017F, 0x0FEE,
-	0x0016, 0x0270, 0x018D, 0x0FED,
-	0x0012, 0x0268, 0x0199, 0x0FED,
-	0x000E, 0x0260, 0x01A4, 0x0FEE,
-	0x000B, 0x0258, 0x01AF, 0x0FEE,
-	0x0007, 0x024F, 0x01BC, 0x0FEE,
-	0x0004, 0x0246, 0x01C7, 0x0FEF,
-	0x0001, 0x023D, 0x01D3, 0x0FEF,
-	0x0FFE, 0x0233, 0x01DF, 0x0FF0,
-	0x0FFC, 0x0229, 0x01EA, 0x0FF1,
-	0x0FFA, 0x021F, 0x01F4, 0x0FF3,
-	0x0FF8, 0x0215, 0x01FF, 0x0FF4,
-	0x0FF6, 0x020A, 0x020A, 0x0FF6,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	4t_64p_LanczosEd_p_0.8_p_10qb_
-// <num_taps>		4
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.800000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_4tap_64p_ratio_0_80[132] = {
-	0x0075, 0x0315, 0x0076, 0x0000,
-	0x006C, 0x0316, 0x007F, 0x0FFF,
-	0x0062, 0x0316, 0x008A, 0x0FFE,
-	0x0059, 0x0315, 0x0096, 0x0FFC,
-	0x0050, 0x0314, 0x00A1, 0x0FFB,
-	0x0048, 0x0312, 0x00AD, 0x0FF9,
-	0x0040, 0x0310, 0x00B8, 0x0FF8,
-	0x0038, 0x030D, 0x00C5, 0x0FF6,
-	0x0030, 0x030A, 0x00D1, 0x0FF5,
-	0x0029, 0x0306, 0x00DE, 0x0FF3,
-	0x0022, 0x0301, 0x00EB, 0x0FF2,
-	0x001C, 0x02FC, 0x00F8, 0x0FF0,
-	0x0015, 0x02F7, 0x0106, 0x0FEE,
-	0x0010, 0x02F1, 0x0112, 0x0FED,
-	0x000A, 0x02EA, 0x0121, 0x0FEB,
-	0x0005, 0x02E3, 0x012F, 0x0FE9,
-	0x0000, 0x02DB, 0x013D, 0x0FE8,
-	0x0FFB, 0x02D3, 0x014C, 0x0FE6,
-	0x0FF7, 0x02CA, 0x015A, 0x0FE5,
-	0x0FF3, 0x02C1, 0x0169, 0x0FE3,
-	0x0FF0, 0x02B7, 0x0177, 0x0FE2,
-	0x0FEC, 0x02AD, 0x0186, 0x0FE1,
-	0x0FE9, 0x02A2, 0x0196, 0x0FDF,
-	0x0FE7, 0x0297, 0x01A4, 0x0FDE,
-	0x0FE4, 0x028C, 0x01B3, 0x0FDD,
-	0x0FE2, 0x0280, 0x01C2, 0x0FDC,
-	0x0FE0, 0x0274, 0x01D0, 0x0FDC,
-	0x0FDF, 0x0268, 0x01DE, 0x0FDB,
-	0x0FDD, 0x025B, 0x01EE, 0x0FDA,
-	0x0FDC, 0x024E, 0x01FC, 0x0FDA,
-	0x0FDB, 0x0241, 0x020A, 0x0FDA,
-	0x0FDB, 0x0233, 0x0218, 0x0FDA,
-	0x0FDA, 0x0226, 0x0226, 0x0FDA,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	4t_64p_LanczosEd_p_0.9_p_10qb_
-// <num_taps>		4
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.900000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_4tap_64p_ratio_0_90[132] = {
-	0x003F, 0x0383, 0x003E, 0x0000,
-	0x0034, 0x0383, 0x004A, 0x0FFF,
-	0x002B, 0x0383, 0x0054, 0x0FFE,
-	0x0021, 0x0381, 0x0061, 0x0FFD,
-	0x0019, 0x037F, 0x006C, 0x0FFC,
-	0x0010, 0x037C, 0x0079, 0x0FFB,
-	0x0008, 0x0378, 0x0086, 0x0FFA,
-	0x0001, 0x0374, 0x0093, 0x0FF8,
-	0x0FFA, 0x036E, 0x00A1, 0x0FF7,
-	0x0FF3, 0x0368, 0x00B0, 0x0FF5,
-	0x0FED, 0x0361, 0x00BF, 0x0FF3,
-	0x0FE8, 0x035A, 0x00CD, 0x0FF1,
-	0x0FE2, 0x0352, 0x00DC, 0x0FF0,
-	0x0FDE, 0x0349, 0x00EB, 0x0FEE,
-	0x0FD9, 0x033F, 0x00FC, 0x0FEC,
-	0x0FD5, 0x0335, 0x010D, 0x0FE9,
-	0x0FD2, 0x032A, 0x011D, 0x0FE7,
-	0x0FCF, 0x031E, 0x012E, 0x0FE5,
-	0x0FCC, 0x0312, 0x013F, 0x0FE3,
-	0x0FCA, 0x0305, 0x0150, 0x0FE1,
-	0x0FC8, 0x02F8, 0x0162, 0x0FDE,
-	0x0FC6, 0x02EA, 0x0174, 0x0FDC,
-	0x0FC5, 0x02DC, 0x0185, 0x0FDA,
-	0x0FC4, 0x02CD, 0x0197, 0x0FD8,
-	0x0FC3, 0x02BE, 0x01AA, 0x0FD5,
-	0x0FC3, 0x02AF, 0x01BB, 0x0FD3,
-	0x0FC3, 0x029F, 0x01CD, 0x0FD1,
-	0x0FC3, 0x028E, 0x01E0, 0x0FCF,
-	0x0FC3, 0x027E, 0x01F2, 0x0FCD,
-	0x0FC4, 0x026D, 0x0203, 0x0FCC,
-	0x0FC5, 0x025C, 0x0215, 0x0FCA,
-	0x0FC6, 0x024B, 0x0227, 0x0FC8,
-	0x0FC7, 0x0239, 0x0239, 0x0FC7,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			03-Apr-2024
-// <coeffDescrip>	4t_64p_LanczosEd_p_1_p_10qb_
-// <num_taps>		4
-// <num_phases>		64
-// <scale_ratio>	 input/output = 1.000000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_4tap_64p_ratio_1_00[132] = {
-	0x0000, 0x0400, 0x0000, 0x0000,
-	0x0FF6, 0x03FF, 0x000B, 0x0000,
-	0x0FED, 0x03FE, 0x0015, 0x0000,
-	0x0FE4, 0x03FB, 0x0022, 0x0FFF,
-	0x0FDC, 0x03F7, 0x002E, 0x0FFF,
-	0x0FD5, 0x03F2, 0x003B, 0x0FFE,
-	0x0FCE, 0x03EC, 0x0048, 0x0FFE,
-	0x0FC8, 0x03E5, 0x0056, 0x0FFD,
-	0x0FC3, 0x03DC, 0x0065, 0x0FFC,
-	0x0FBE, 0x03D3, 0x0075, 0x0FFA,
-	0x0FB9, 0x03C9, 0x0085, 0x0FF9,
-	0x0FB6, 0x03BE, 0x0094, 0x0FF8,
-	0x0FB2, 0x03B2, 0x00A6, 0x0FF6,
-	0x0FB0, 0x03A5, 0x00B7, 0x0FF4,
-	0x0FAD, 0x0397, 0x00CA, 0x0FF2,
-	0x0FAB, 0x0389, 0x00DC, 0x0FF0,
-	0x0FAA, 0x0379, 0x00EF, 0x0FEE,
-	0x0FA9, 0x0369, 0x0102, 0x0FEC,
-	0x0FA9, 0x0359, 0x0115, 0x0FE9,
-	0x0FA9, 0x0348, 0x0129, 0x0FE6,
-	0x0FA9, 0x0336, 0x013D, 0x0FE4,
-	0x0FA9, 0x0323, 0x0153, 0x0FE1,
-	0x0FAA, 0x0310, 0x0168, 0x0FDE,
-	0x0FAC, 0x02FD, 0x017C, 0x0FDB,
-	0x0FAD, 0x02E9, 0x0192, 0x0FD8,
-	0x0FAF, 0x02D5, 0x01A7, 0x0FD5,
-	0x0FB1, 0x02C0, 0x01BD, 0x0FD2,
-	0x0FB3, 0x02AC, 0x01D2, 0x0FCF,
-	0x0FB5, 0x0296, 0x01E9, 0x0FCC,
-	0x0FB8, 0x0281, 0x01FE, 0x0FC9,
-	0x0FBA, 0x026C, 0x0214, 0x0FC6,
-	0x0FBD, 0x0256, 0x022A, 0x0FC3,
-	0x0FC0, 0x0240, 0x0240, 0x0FC0,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			02-Apr-2024
-// <coeffDescrip>	6t_64p_LanczosEd_p_0.3_p_10qb_
-// <num_taps>		6
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.300000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_6tap_64p_ratio_0_30[198] = {
-	0x004B, 0x0100, 0x0169, 0x0101, 0x004B, 0x0000,
-	0x0049, 0x00FD, 0x0169, 0x0103, 0x004E, 0x0000,
-	0x0047, 0x00FA, 0x0169, 0x0106, 0x0050, 0x0000,
-	0x0045, 0x00F7, 0x0168, 0x0109, 0x0052, 0x0001,
-	0x0043, 0x00F5, 0x0168, 0x010B, 0x0054, 0x0001,
-	0x0040, 0x00F2, 0x0168, 0x010E, 0x0057, 0x0001,
-	0x003E, 0x00EF, 0x0168, 0x0110, 0x0059, 0x0002,
-	0x003C, 0x00EC, 0x0167, 0x0113, 0x005C, 0x0002,
-	0x003A, 0x00E9, 0x0167, 0x0116, 0x005E, 0x0002,
-	0x0038, 0x00E6, 0x0166, 0x0118, 0x0061, 0x0003,
-	0x0036, 0x00E3, 0x0165, 0x011C, 0x0063, 0x0003,
-	0x0034, 0x00E0, 0x0165, 0x011D, 0x0066, 0x0004,
-	0x0033, 0x00DD, 0x0164, 0x0120, 0x0068, 0x0004,
-	0x0031, 0x00DA, 0x0163, 0x0122, 0x006B, 0x0005,
-	0x002F, 0x00D7, 0x0163, 0x0125, 0x006D, 0x0005,
-	0x002D, 0x00D3, 0x0162, 0x0128, 0x0070, 0x0006,
-	0x002B, 0x00D0, 0x0161, 0x012A, 0x0073, 0x0007,
-	0x002A, 0x00CD, 0x0160, 0x012D, 0x0075, 0x0007,
-	0x0028, 0x00CA, 0x015F, 0x012F, 0x0078, 0x0008,
-	0x0026, 0x00C7, 0x015E, 0x0131, 0x007B, 0x0009,
-	0x0025, 0x00C4, 0x015D, 0x0133, 0x007E, 0x0009,
-	0x0023, 0x00C1, 0x015C, 0x0136, 0x0080, 0x000A,
-	0x0022, 0x00BE, 0x015A, 0x0138, 0x0083, 0x000B,
-	0x0020, 0x00BB, 0x0159, 0x013A, 0x0086, 0x000C,
-	0x001F, 0x00B8, 0x0158, 0x013B, 0x0089, 0x000D,
-	0x001E, 0x00B5, 0x0156, 0x013E, 0x008C, 0x000D,
-	0x001C, 0x00B2, 0x0155, 0x0140, 0x008F, 0x000E,
-	0x001B, 0x00AF, 0x0153, 0x0143, 0x0091, 0x000F,
-	0x0019, 0x00AC, 0x0152, 0x0145, 0x0094, 0x0010,
-	0x0018, 0x00A9, 0x0150, 0x0147, 0x0097, 0x0011,
-	0x0017, 0x00A6, 0x014F, 0x0148, 0x009A, 0x0012,
-	0x0016, 0x00A3, 0x014D, 0x0149, 0x009D, 0x0014,
-	0x0015, 0x00A0, 0x014B, 0x014B, 0x00A0, 0x0015,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			02-Apr-2024
-// <coeffDescrip>	6t_64p_LanczosEd_p_0.4_p_10qb_
-// <num_taps>		6
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.400000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_6tap_64p_ratio_0_40[198] = {
-	0x0028, 0x0106, 0x01A3, 0x0107, 0x0028, 0x0000,
-	0x0026, 0x0102, 0x01A3, 0x010A, 0x002B, 0x0000,
-	0x0024, 0x00FE, 0x01A3, 0x010F, 0x002D, 0x0FFF,
-	0x0022, 0x00FA, 0x01A3, 0x0113, 0x002F, 0x0FFF,
-	0x0021, 0x00F6, 0x01A3, 0x0116, 0x0031, 0x0FFF,
-	0x001F, 0x00F2, 0x01A2, 0x011B, 0x0034, 0x0FFE,
-	0x001D, 0x00EE, 0x01A2, 0x011F, 0x0036, 0x0FFE,
-	0x001B, 0x00EA, 0x01A1, 0x0123, 0x0039, 0x0FFE,
-	0x0019, 0x00E6, 0x01A1, 0x0127, 0x003B, 0x0FFE,
-	0x0018, 0x00E2, 0x01A0, 0x012A, 0x003E, 0x0FFE,
-	0x0016, 0x00DE, 0x01A0, 0x012E, 0x0041, 0x0FFD,
-	0x0015, 0x00DA, 0x019F, 0x0132, 0x0043, 0x0FFD,
-	0x0013, 0x00D6, 0x019E, 0x0136, 0x0046, 0x0FFD,
-	0x0012, 0x00D2, 0x019D, 0x0139, 0x0049, 0x0FFD,
-	0x0010, 0x00CE, 0x019C, 0x013D, 0x004C, 0x0FFD,
-	0x000F, 0x00CA, 0x019A, 0x0141, 0x004F, 0x0FFD,
-	0x000E, 0x00C6, 0x0199, 0x0144, 0x0052, 0x0FFD,
-	0x000D, 0x00C2, 0x0197, 0x0148, 0x0055, 0x0FFD,
-	0x000B, 0x00BE, 0x0196, 0x014C, 0x0058, 0x0FFD,
-	0x000A, 0x00BA, 0x0195, 0x014F, 0x005B, 0x0FFD,
-	0x0009, 0x00B6, 0x0193, 0x0153, 0x005E, 0x0FFD,
-	0x0008, 0x00B2, 0x0191, 0x0157, 0x0061, 0x0FFD,
-	0x0007, 0x00AE, 0x0190, 0x015A, 0x0064, 0x0FFD,
-	0x0006, 0x00AA, 0x018E, 0x015D, 0x0068, 0x0FFD,
-	0x0005, 0x00A6, 0x018C, 0x0161, 0x006B, 0x0FFD,
-	0x0005, 0x00A2, 0x0189, 0x0164, 0x006F, 0x0FFD,
-	0x0004, 0x009E, 0x0187, 0x0167, 0x0072, 0x0FFE,
-	0x0003, 0x009A, 0x0185, 0x016B, 0x0075, 0x0FFE,
-	0x0002, 0x0096, 0x0183, 0x016E, 0x0079, 0x0FFE,
-	0x0002, 0x0093, 0x0180, 0x016F, 0x007D, 0x0FFF,
-	0x0001, 0x008F, 0x017E, 0x0173, 0x0080, 0x0FFF,
-	0x0001, 0x008B, 0x017B, 0x0175, 0x0084, 0x0000,
-	0x0000, 0x0087, 0x0179, 0x0179, 0x0087, 0x0000,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			02-Apr-2024
-// <coeffDescrip>	6t_64p_LanczosEd_p_0.5_p_10qb_
-// <num_taps>		6
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.500000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_6tap_64p_ratio_0_50[198] = {
-	0x0000, 0x0107, 0x01F3, 0x0106, 0x0000, 0x0000,
-	0x0FFE, 0x0101, 0x01F3, 0x010D, 0x0002, 0x0FFF,
-	0x0FFD, 0x00FB, 0x01F3, 0x0113, 0x0003, 0x0FFF,
-	0x0FFC, 0x00F6, 0x01F3, 0x0118, 0x0005, 0x0FFE,
-	0x0FFA, 0x00F0, 0x01F3, 0x011E, 0x0007, 0x0FFE,
-	0x0FF9, 0x00EB, 0x01F2, 0x0124, 0x0009, 0x0FFD,
-	0x0FF8, 0x00E5, 0x01F2, 0x0129, 0x000B, 0x0FFD,
-	0x0FF7, 0x00E0, 0x01F1, 0x012F, 0x000D, 0x0FFC,
-	0x0FF6, 0x00DA, 0x01F0, 0x0135, 0x0010, 0x0FFB,
-	0x0FF5, 0x00D4, 0x01EF, 0x013B, 0x0012, 0x0FFB,
-	0x0FF4, 0x00CF, 0x01EE, 0x0141, 0x0014, 0x0FFA,
-	0x0FF3, 0x00C9, 0x01ED, 0x0147, 0x0017, 0x0FF9,
-	0x0FF2, 0x00C4, 0x01EB, 0x014C, 0x001A, 0x0FF9,
-	0x0FF1, 0x00BF, 0x01EA, 0x0152, 0x001C, 0x0FF8,
-	0x0FF1, 0x00B9, 0x01E8, 0x0157, 0x001F, 0x0FF8,
-	0x0FF0, 0x00B4, 0x01E6, 0x015D, 0x0022, 0x0FF7,
-	0x0FF0, 0x00AE, 0x01E4, 0x0163, 0x0025, 0x0FF6,
-	0x0FEF, 0x00A9, 0x01E2, 0x0168, 0x0028, 0x0FF6,
-	0x0FEF, 0x00A4, 0x01DF, 0x016E, 0x002B, 0x0FF5,
-	0x0FEF, 0x009F, 0x01DD, 0x0172, 0x002E, 0x0FF5,
-	0x0FEE, 0x009A, 0x01DA, 0x0178, 0x0032, 0x0FF4,
-	0x0FEE, 0x0094, 0x01D8, 0x017E, 0x0035, 0x0FF3,
-	0x0FEE, 0x008F, 0x01D5, 0x0182, 0x0039, 0x0FF3,
-	0x0FEE, 0x008A, 0x01D2, 0x0188, 0x003C, 0x0FF2,
-	0x0FEE, 0x0085, 0x01CF, 0x018C, 0x0040, 0x0FF2,
-	0x0FEE, 0x0081, 0x01CB, 0x0191, 0x0044, 0x0FF1,
-	0x0FEE, 0x007C, 0x01C8, 0x0196, 0x0047, 0x0FF1,
-	0x0FEE, 0x0077, 0x01C4, 0x019C, 0x004B, 0x0FF0,
-	0x0FEE, 0x0072, 0x01C1, 0x01A0, 0x004F, 0x0FF0,
-	0x0FEE, 0x006E, 0x01BD, 0x01A4, 0x0053, 0x0FF0,
-	0x0FEE, 0x0069, 0x01B9, 0x01A9, 0x0058, 0x0FEF,
-	0x0FEE, 0x0065, 0x01B5, 0x01AD, 0x005C, 0x0FEF,
-	0x0FEF, 0x0060, 0x01B1, 0x01B1, 0x0060, 0x0FEF,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			02-Apr-2024
-// <coeffDescrip>	6t_64p_LanczosEd_p_0.6_p_10qb_
-// <num_taps>		6
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.600000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_6tap_64p_ratio_0_60[198] = {
-	0x0FD9, 0x00FB, 0x0258, 0x00FB, 0x0FD9, 0x0000,
-	0x0FD9, 0x00F3, 0x0258, 0x0102, 0x0FDA, 0x0000,
-	0x0FD8, 0x00EB, 0x0258, 0x010B, 0x0FDB, 0x0FFF,
-	0x0FD8, 0x00E3, 0x0258, 0x0112, 0x0FDC, 0x0FFF,
-	0x0FD8, 0x00DC, 0x0257, 0x011B, 0x0FDC, 0x0FFE,
-	0x0FD7, 0x00D4, 0x0256, 0x0123, 0x0FDE, 0x0FFE,
-	0x0FD7, 0x00CD, 0x0255, 0x012B, 0x0FDF, 0x0FFD,
-	0x0FD7, 0x00C5, 0x0254, 0x0133, 0x0FE0, 0x0FFD,
-	0x0FD7, 0x00BE, 0x0252, 0x013C, 0x0FE1, 0x0FFC,
-	0x0FD7, 0x00B6, 0x0251, 0x0143, 0x0FE3, 0x0FFC,
-	0x0FD8, 0x00AF, 0x024F, 0x014B, 0x0FE4, 0x0FFB,
-	0x0FD8, 0x00A8, 0x024C, 0x0154, 0x0FE6, 0x0FFA,
-	0x0FD8, 0x00A1, 0x024A, 0x015B, 0x0FE8, 0x0FFA,
-	0x0FD9, 0x009A, 0x0247, 0x0163, 0x0FEA, 0x0FF9,
-	0x0FD9, 0x0093, 0x0244, 0x016C, 0x0FEC, 0x0FF8,
-	0x0FD9, 0x008C, 0x0241, 0x0174, 0x0FEF, 0x0FF7,
-	0x0FDA, 0x0085, 0x023E, 0x017B, 0x0FF1, 0x0FF7,
-	0x0FDB, 0x007F, 0x023A, 0x0183, 0x0FF3, 0x0FF6,
-	0x0FDB, 0x0078, 0x0237, 0x018B, 0x0FF6, 0x0FF5,
-	0x0FDC, 0x0072, 0x0233, 0x0192, 0x0FF9, 0x0FF4,
-	0x0FDD, 0x006C, 0x022F, 0x0199, 0x0FFC, 0x0FF3,
-	0x0FDD, 0x0065, 0x022A, 0x01A3, 0x0FFF, 0x0FF2,
-	0x0FDE, 0x005F, 0x0226, 0x01AA, 0x0002, 0x0FF1,
-	0x0FDF, 0x005A, 0x0221, 0x01B0, 0x0006, 0x0FF0,
-	0x0FE0, 0x0054, 0x021C, 0x01B7, 0x0009, 0x0FF0,
-	0x0FE1, 0x004E, 0x0217, 0x01BE, 0x000D, 0x0FEF,
-	0x0FE2, 0x0048, 0x0212, 0x01C6, 0x0010, 0x0FEE,
-	0x0FE3, 0x0043, 0x020C, 0x01CD, 0x0014, 0x0FED,
-	0x0FE4, 0x003E, 0x0207, 0x01D3, 0x0018, 0x0FEC,
-	0x0FE5, 0x0039, 0x0200, 0x01DA, 0x001D, 0x0FEB,
-	0x0FE6, 0x0034, 0x01FA, 0x01E1, 0x0021, 0x0FEA,
-	0x0FE7, 0x002F, 0x01F5, 0x01E7, 0x0025, 0x0FE9,
-	0x0FE8, 0x002A, 0x01EE, 0x01EE, 0x002A, 0x0FE8,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			02-Apr-2024
-// <coeffDescrip>	6t_64p_LanczosEd_p_0.7_p_10qb_
-// <num_taps>		6
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.700000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_6tap_64p_ratio_0_70[198] = {
-	0x0FC0, 0x00DA, 0x02CC, 0x00DA, 0x0FC0, 0x0000,
-	0x0FC1, 0x00D0, 0x02CC, 0x00E4, 0x0FBF, 0x0000,
-	0x0FC2, 0x00C6, 0x02CB, 0x00EF, 0x0FBE, 0x0000,
-	0x0FC3, 0x00BC, 0x02CA, 0x00F9, 0x0FBE, 0x0000,
-	0x0FC4, 0x00B2, 0x02C9, 0x0104, 0x0FBD, 0x0000,
-	0x0FC5, 0x00A8, 0x02C7, 0x010F, 0x0FBD, 0x0000,
-	0x0FC7, 0x009F, 0x02C5, 0x0119, 0x0FBC, 0x0000,
-	0x0FC8, 0x0095, 0x02C3, 0x0124, 0x0FBC, 0x0000,
-	0x0FC9, 0x008C, 0x02C0, 0x012F, 0x0FBC, 0x0000,
-	0x0FCB, 0x0083, 0x02BD, 0x0139, 0x0FBC, 0x0000,
-	0x0FCC, 0x007A, 0x02BA, 0x0144, 0x0FBC, 0x0000,
-	0x0FCE, 0x0072, 0x02B6, 0x014D, 0x0FBD, 0x0000,
-	0x0FD0, 0x0069, 0x02B2, 0x0159, 0x0FBD, 0x0FFF,
-	0x0FD1, 0x0061, 0x02AD, 0x0164, 0x0FBE, 0x0FFF,
-	0x0FD3, 0x0059, 0x02A9, 0x016E, 0x0FBF, 0x0FFE,
-	0x0FD4, 0x0051, 0x02A4, 0x017A, 0x0FBF, 0x0FFE,
-	0x0FD6, 0x0049, 0x029E, 0x0184, 0x0FC1, 0x0FFE,
-	0x0FD8, 0x0042, 0x0299, 0x018E, 0x0FC2, 0x0FFD,
-	0x0FD9, 0x003A, 0x0293, 0x019B, 0x0FC3, 0x0FFC,
-	0x0FDB, 0x0033, 0x028D, 0x01A4, 0x0FC5, 0x0FFC,
-	0x0FDC, 0x002D, 0x0286, 0x01AF, 0x0FC7, 0x0FFB,
-	0x0FDE, 0x0026, 0x0280, 0x01BA, 0x0FC8, 0x0FFA,
-	0x0FE0, 0x001F, 0x0279, 0x01C4, 0x0FCB, 0x0FF9,
-	0x0FE1, 0x0019, 0x0272, 0x01CE, 0x0FCD, 0x0FF9,
-	0x0FE3, 0x0013, 0x026A, 0x01D9, 0x0FCF, 0x0FF8,
-	0x0FE4, 0x000D, 0x0263, 0x01E3, 0x0FD2, 0x0FF7,
-	0x0FE6, 0x0008, 0x025B, 0x01EC, 0x0FD5, 0x0FF6,
-	0x0FE7, 0x0002, 0x0253, 0x01F7, 0x0FD8, 0x0FF5,
-	0x0FE9, 0x0FFD, 0x024A, 0x0202, 0x0FDB, 0x0FF3,
-	0x0FEA, 0x0FF8, 0x0242, 0x020B, 0x0FDF, 0x0FF2,
-	0x0FEC, 0x0FF3, 0x0239, 0x0215, 0x0FE2, 0x0FF1,
-	0x0FED, 0x0FEF, 0x0230, 0x021E, 0x0FE6, 0x0FF0,
-	0x0FEF, 0x0FEB, 0x0226, 0x0226, 0x0FEB, 0x0FEF,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			02-Apr-2024
-// <coeffDescrip>	6t_64p_LanczosEd_p_0.8_p_10qb_
-// <num_taps>		6
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.800000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_6tap_64p_ratio_0_80[198] = {
-	0x0FBF, 0x00A1, 0x0340, 0x00A1, 0x0FBF, 0x0000,
-	0x0FC1, 0x0095, 0x0340, 0x00AD, 0x0FBC, 0x0001,
-	0x0FC4, 0x0089, 0x033E, 0x00BA, 0x0FBA, 0x0001,
-	0x0FC6, 0x007D, 0x033D, 0x00C6, 0x0FB8, 0x0002,
-	0x0FC9, 0x0072, 0x033A, 0x00D3, 0x0FB6, 0x0002,
-	0x0FCC, 0x0067, 0x0338, 0x00DF, 0x0FB3, 0x0003,
-	0x0FCE, 0x005C, 0x0334, 0x00EE, 0x0FB1, 0x0003,
-	0x0FD1, 0x0051, 0x0331, 0x00FA, 0x0FAF, 0x0004,
-	0x0FD3, 0x0047, 0x032D, 0x0108, 0x0FAD, 0x0004,
-	0x0FD6, 0x003D, 0x0328, 0x0116, 0x0FAB, 0x0004,
-	0x0FD8, 0x0033, 0x0323, 0x0123, 0x0FAA, 0x0005,
-	0x0FDB, 0x002A, 0x031D, 0x0131, 0x0FA8, 0x0005,
-	0x0FDD, 0x0021, 0x0317, 0x013F, 0x0FA7, 0x0005,
-	0x0FDF, 0x0018, 0x0311, 0x014D, 0x0FA5, 0x0006,
-	0x0FE2, 0x0010, 0x030A, 0x015A, 0x0FA4, 0x0006,
-	0x0FE4, 0x0008, 0x0302, 0x0169, 0x0FA3, 0x0006,
-	0x0FE6, 0x0000, 0x02FB, 0x0177, 0x0FA2, 0x0006,
-	0x0FE8, 0x0FF9, 0x02F3, 0x0185, 0x0FA1, 0x0006,
-	0x0FEB, 0x0FF1, 0x02EA, 0x0193, 0x0FA1, 0x0006,
-	0x0FED, 0x0FEB, 0x02E1, 0x01A1, 0x0FA0, 0x0006,
-	0x0FEE, 0x0FE4, 0x02D8, 0x01B0, 0x0FA0, 0x0006,
-	0x0FF0, 0x0FDE, 0x02CE, 0x01BE, 0x0FA0, 0x0006,
-	0x0FF2, 0x0FD8, 0x02C5, 0x01CB, 0x0FA0, 0x0006,
-	0x0FF4, 0x0FD3, 0x02BA, 0x01D8, 0x0FA1, 0x0006,
-	0x0FF6, 0x0FCD, 0x02B0, 0x01E7, 0x0FA1, 0x0005,
-	0x0FF7, 0x0FC8, 0x02A5, 0x01F5, 0x0FA2, 0x0005,
-	0x0FF9, 0x0FC4, 0x029A, 0x0202, 0x0FA3, 0x0004,
-	0x0FFA, 0x0FC0, 0x028E, 0x0210, 0x0FA4, 0x0004,
-	0x0FFB, 0x0FBC, 0x0283, 0x021D, 0x0FA6, 0x0003,
-	0x0FFD, 0x0FB8, 0x0276, 0x022A, 0x0FA8, 0x0003,
-	0x0FFE, 0x0FB4, 0x026B, 0x0237, 0x0FAA, 0x0002,
-	0x0FFF, 0x0FB1, 0x025E, 0x0245, 0x0FAC, 0x0001,
-	0x0000, 0x0FAE, 0x0252, 0x0252, 0x0FAE, 0x0000,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			02-Apr-2024
-// <coeffDescrip>	6t_64p_LanczosEd_p_0.9_p_10qb_
-// <num_taps>		6
-// <num_phases>		64
-// <scale_ratio>	 input/output = 0.900000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_6tap_64p_ratio_0_90[198] = {
-	0x0FD8, 0x0055, 0x03A7, 0x0054, 0x0FD8, 0x0000,
-	0x0FDB, 0x0047, 0x03A7, 0x0063, 0x0FD4, 0x0000,
-	0x0FDF, 0x003B, 0x03A5, 0x006F, 0x0FD1, 0x0001,
-	0x0FE2, 0x002E, 0x03A3, 0x007E, 0x0FCD, 0x0002,
-	0x0FE5, 0x0022, 0x03A0, 0x008D, 0x0FCA, 0x0002,
-	0x0FE8, 0x0017, 0x039D, 0x009B, 0x0FC6, 0x0003,
-	0x0FEB, 0x000C, 0x0398, 0x00AC, 0x0FC2, 0x0003,
-	0x0FEE, 0x0001, 0x0394, 0x00BA, 0x0FBF, 0x0004,
-	0x0FF1, 0x0FF7, 0x038E, 0x00CA, 0x0FBB, 0x0005,
-	0x0FF4, 0x0FED, 0x0388, 0x00DA, 0x0FB8, 0x0005,
-	0x0FF6, 0x0FE4, 0x0381, 0x00EB, 0x0FB4, 0x0006,
-	0x0FF9, 0x0FDB, 0x037A, 0x00FA, 0x0FB1, 0x0007,
-	0x0FFB, 0x0FD3, 0x0372, 0x010B, 0x0FAD, 0x0008,
-	0x0FFD, 0x0FCB, 0x0369, 0x011D, 0x0FAA, 0x0008,
-	0x0000, 0x0FC3, 0x0360, 0x012E, 0x0FA6, 0x0009,
-	0x0002, 0x0FBC, 0x0356, 0x013F, 0x0FA3, 0x000A,
-	0x0003, 0x0FB6, 0x034C, 0x0150, 0x0FA0, 0x000B,
-	0x0005, 0x0FB0, 0x0341, 0x0162, 0x0F9D, 0x000B,
-	0x0007, 0x0FAA, 0x0336, 0x0173, 0x0F9A, 0x000C,
-	0x0008, 0x0FA5, 0x032A, 0x0185, 0x0F97, 0x000D,
-	0x000A, 0x0FA0, 0x031E, 0x0197, 0x0F94, 0x000D,
-	0x000B, 0x0F9B, 0x0311, 0x01A9, 0x0F92, 0x000E,
-	0x000C, 0x0F97, 0x0303, 0x01BC, 0x0F8F, 0x000F,
-	0x000D, 0x0F94, 0x02F6, 0x01CD, 0x0F8D, 0x000F,
-	0x000E, 0x0F91, 0x02E8, 0x01DE, 0x0F8B, 0x0010,
-	0x000F, 0x0F8E, 0x02D9, 0x01F1, 0x0F89, 0x0010,
-	0x0010, 0x0F8B, 0x02CA, 0x0202, 0x0F88, 0x0011,
-	0x0010, 0x0F89, 0x02BB, 0x0214, 0x0F87, 0x0011,
-	0x0011, 0x0F87, 0x02AB, 0x0226, 0x0F86, 0x0011,
-	0x0011, 0x0F86, 0x029C, 0x0236, 0x0F85, 0x0012,
-	0x0011, 0x0F85, 0x028B, 0x0249, 0x0F84, 0x0012,
-	0x0012, 0x0F84, 0x027B, 0x0259, 0x0F84, 0x0012,
-	0x0012, 0x0F84, 0x026A, 0x026A, 0x0F84, 0x0012,
-};
-
-//========================================================
-// <using>			gen_scaler_coeffs_cnf_file.m
-// <using>			make_test_script.m
-// <date>			02-Apr-2024
-// <coeffDescrip>	6t_64p_LanczosEd_p_1_p_10qb_
-// <num_taps>		6
-// <num_phases>		64
-// <scale_ratio>	 input/output = 1.000000000000
-// <CoefType>		LanczosEd
-// <CoefQuant>		S1.10
-//========================================================
-static const uint16_t easf_filter_6tap_64p_ratio_1_00[198] = {
-	0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000,
-	0x0003, 0x0FF3, 0x0400, 0x000D, 0x0FFD, 0x0000,
-	0x0006, 0x0FE7, 0x03FE, 0x001C, 0x0FF9, 0x0000,
-	0x0009, 0x0FDB, 0x03FC, 0x002B, 0x0FF5, 0x0000,
-	0x000C, 0x0FD0, 0x03F9, 0x003A, 0x0FF1, 0x0000,
-	0x000E, 0x0FC5, 0x03F5, 0x004A, 0x0FED, 0x0001,
-	0x0011, 0x0FBB, 0x03F0, 0x005A, 0x0FE9, 0x0001,
-	0x0013, 0x0FB2, 0x03EB, 0x006A, 0x0FE5, 0x0001,
-	0x0015, 0x0FA9, 0x03E4, 0x007B, 0x0FE1, 0x0002,
-	0x0017, 0x0FA1, 0x03DD, 0x008D, 0x0FDC, 0x0002,
-	0x0018, 0x0F99, 0x03D4, 0x00A0, 0x0FD8, 0x0003,
-	0x001A, 0x0F92, 0x03CB, 0x00B2, 0x0FD3, 0x0004,
-	0x001B, 0x0F8C, 0x03C1, 0x00C6, 0x0FCE, 0x0004,
-	0x001C, 0x0F86, 0x03B7, 0x00D9, 0x0FC9, 0x0005,
-	0x001D, 0x0F80, 0x03AB, 0x00EE, 0x0FC4, 0x0006,
-	0x001E, 0x0F7C, 0x039F, 0x0101, 0x0FBF, 0x0007,
-	0x001F, 0x0F78, 0x0392, 0x0115, 0x0FBA, 0x0008,
-	0x001F, 0x0F74, 0x0385, 0x012B, 0x0FB5, 0x0008,
-	0x0020, 0x0F71, 0x0376, 0x0140, 0x0FB0, 0x0009,
-	0x0020, 0x0F6E, 0x0367, 0x0155, 0x0FAB, 0x000B,
-	0x0020, 0x0F6C, 0x0357, 0x016B, 0x0FA6, 0x000C,
-	0x0020, 0x0F6A, 0x0347, 0x0180, 0x0FA2, 0x000D,
-	0x0020, 0x0F69, 0x0336, 0x0196, 0x0F9D, 0x000E,
-	0x0020, 0x0F69, 0x0325, 0x01AB, 0x0F98, 0x000F,
-	0x001F, 0x0F68, 0x0313, 0x01C3, 0x0F93, 0x0010,
-	0x001F, 0x0F69, 0x0300, 0x01D8, 0x0F8F, 0x0011,
-	0x001E, 0x0F69, 0x02ED, 0x01EF, 0x0F8B, 0x0012,
-	0x001D, 0x0F6A, 0x02D9, 0x0205, 0x0F87, 0x0014,
-	0x001D, 0x0F6C, 0x02C5, 0x021A, 0x0F83, 0x0015,
-	0x001C, 0x0F6E, 0x02B1, 0x0230, 0x0F7F, 0x0016,
-	0x001B, 0x0F70, 0x029C, 0x0247, 0x0F7B, 0x0017,
-	0x001A, 0x0F72, 0x0287, 0x025D, 0x0F78, 0x0018,
-	0x0019, 0x0F75, 0x0272, 0x0272, 0x0F75, 0x0019,
-};
-
-/* Converted scaler coeff tables from S1.10 to S1.12 */
-static uint16_t easf_filter_3tap_64p_ratio_0_30_s1_12[99];
-static uint16_t easf_filter_3tap_64p_ratio_0_40_s1_12[99];
-static uint16_t easf_filter_3tap_64p_ratio_0_50_s1_12[99];
-static uint16_t easf_filter_3tap_64p_ratio_0_60_s1_12[99];
-static uint16_t easf_filter_3tap_64p_ratio_0_70_s1_12[99];
-static uint16_t easf_filter_3tap_64p_ratio_0_80_s1_12[99];
-static uint16_t easf_filter_3tap_64p_ratio_0_90_s1_12[99];
-static uint16_t easf_filter_3tap_64p_ratio_1_00_s1_12[99];
-static uint16_t easf_filter_4tap_64p_ratio_0_30_s1_12[132];
-static uint16_t easf_filter_4tap_64p_ratio_0_40_s1_12[132];
-static uint16_t easf_filter_4tap_64p_ratio_0_50_s1_12[132];
-static uint16_t easf_filter_4tap_64p_ratio_0_60_s1_12[132];
-static uint16_t easf_filter_4tap_64p_ratio_0_70_s1_12[132];
-static uint16_t easf_filter_4tap_64p_ratio_0_80_s1_12[132];
-static uint16_t easf_filter_4tap_64p_ratio_0_90_s1_12[132];
-static uint16_t easf_filter_4tap_64p_ratio_1_00_s1_12[132];
-static uint16_t easf_filter_6tap_64p_ratio_0_30_s1_12[198];
-static uint16_t easf_filter_6tap_64p_ratio_0_40_s1_12[198];
-static uint16_t easf_filter_6tap_64p_ratio_0_50_s1_12[198];
-static uint16_t easf_filter_6tap_64p_ratio_0_60_s1_12[198];
-static uint16_t easf_filter_6tap_64p_ratio_0_70_s1_12[198];
-static uint16_t easf_filter_6tap_64p_ratio_0_80_s1_12[198];
-static uint16_t easf_filter_6tap_64p_ratio_0_90_s1_12[198];
-static uint16_t easf_filter_6tap_64p_ratio_1_00_s1_12[198];
-
-struct scale_ratio_to_reg_value_lookup easf_v_bf3_mode_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x0000},
-	{5, 10, 0x0000},
-	{6, 10, 0x0000},
-	{7, 10, 0x0000},
-	{8, 10, 0x0000},
-	{9, 10, 0x0000},
-	{1, 1, 0x0000},
-	{-1, -1, 0x0002},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_h_bf3_mode_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x0000},
-	{5, 10, 0x0000},
-	{6, 10, 0x0000},
-	{7, 10, 0x0000},
-	{8, 10, 0x0000},
-	{9, 10, 0x0000},
-	{1, 1, 0x0000},
-	{-1, -1, 0x0002},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_reducer_gain6_6tap_lookup[] = {
-	{3, 10, 0x4100},
-	{4, 10, 0x4100},
-	{5, 10, 0x4100},
-	{6, 10, 0x4100},
-	{7, 10, 0x4100},
-	{8, 10, 0x4100},
-	{9, 10, 0x4100},
-	{1, 1, 0x4100},
-	{-1, -1, 0x4100},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_reducer_gain4_6tap_lookup[] = {
-	{3, 10, 0x4000},
-	{4, 10, 0x4000},
-	{5, 10, 0x4000},
-	{6, 10, 0x4000},
-	{7, 10, 0x4000},
-	{8, 10, 0x4000},
-	{9, 10, 0x4000},
-	{1, 1, 0x4000},
-	{-1, -1, 0x4000},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_gain_ring6_6tap_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x251F},
-	{5, 10, 0x291F},
-	{6, 10, 0xA51F},
-	{7, 10, 0xA51F},
-	{8, 10, 0xAA66},
-	{9, 10, 0xA51F},
-	{1, 1, 0xA640},
-	{-1, -1, 0xA640},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_gain_ring4_6tap_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x9600},
-	{5, 10, 0xA460},
-	{6, 10, 0xA8E0},
-	{7, 10, 0xAC00},
-	{8, 10, 0xAD20},
-	{9, 10, 0xAFC0},
-	{1, 1, 0xB058},
-	{-1, -1, 0xB058},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_reducer_gain6_4tap_lookup[] = {
-	{3, 10, 0x4100},
-	{4, 10, 0x4100},
-	{5, 10, 0x4100},
-	{6, 10, 0x4100},
-	{7, 10, 0x4100},
-	{8, 10, 0x4100},
-	{9, 10, 0x4100},
-	{1, 1, 0x4100},
-	{-1, -1, 0x4100},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_reducer_gain4_4tap_lookup[] = {
-	{3, 10, 0x4000},
-	{4, 10, 0x4000},
-	{5, 10, 0x4000},
-	{6, 10, 0x4000},
-	{7, 10, 0x4000},
-	{8, 10, 0x4000},
-	{9, 10, 0x4000},
-	{1, 1, 0x4000},
-	{-1, -1, 0x4000},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_gain_ring6_4tap_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x0000},
-	{5, 10, 0x0000},
-	{6, 10, 0x0000},
-	{7, 10, 0x0000},
-	{8, 10, 0x0000},
-	{9, 10, 0x0000},
-	{1, 1, 0x0000},
-	{-1, -1, 0x0000},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_gain_ring4_4tap_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x0000},
-	{5, 10, 0x0000},
-	{6, 10, 0x9900},
-	{7, 10, 0xA100},
-	{8, 10, 0xA8C0},
-	{9, 10, 0xAB20},
-	{1, 1, 0xAC00},
-	{-1, -1, 0xAC00},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_3tap_dntilt_uptilt_offset_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x0000},
-	{5, 10, 0x0000},
-	{6, 10, 0x0000},
-	{7, 10, 0x0000},
-	{8, 10, 0x4100},
-	{9, 10, 0x9F00},
-	{1, 1, 0xA4C0},
-	{-1, -1, 0xA8D8},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_3tap_uptilt_maxval_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x0000},
-	{5, 10, 0x0000},
-	{6, 10, 0x0000},
-	{7, 10, 0x0000},
-	{8, 10, 0x4000},
-	{9, 10, 0x24FE},
-	{1, 1, 0x2D64},
-	{-1, -1, 0x3ADB},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_3tap_dntilt_slope_lookup[] = {
-	{3, 10, 0x3800},
-	{4, 10, 0x3800},
-	{5, 10, 0x3800},
-	{6, 10, 0x3800},
-	{7, 10, 0x3800},
-	{8, 10, 0x3886},
-	{9, 10, 0x3940},
-	{1, 1, 0x3A4E},
-	{-1, -1, 0x3B66},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_3tap_uptilt1_slope_lookup[] = {
-	{3, 10, 0x3800},
-	{4, 10, 0x3800},
-	{5, 10, 0x3800},
-	{6, 10, 0x3800},
-	{7, 10, 0x3800},
-	{8, 10, 0x36F4},
-	{9, 10, 0x359C},
-	{1, 1, 0x3360},
-	{-1, -1, 0x2F20},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_3tap_uptilt2_slope_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x0000},
-	{5, 10, 0x0000},
-	{6, 10, 0x0000},
-	{7, 10, 0x0000},
-	{8, 10, 0x0000},
-	{9, 10, 0x359C},
-	{1, 1, 0x31F0},
-	{-1, -1, 0x1F00},
-};
-
-struct scale_ratio_to_reg_value_lookup easf_3tap_uptilt2_offset_lookup[] = {
-	{3, 10, 0x0000},
-	{4, 10, 0x0000},
-	{5, 10, 0x0000},
-	{6, 10, 0x0000},
-	{7, 10, 0x0000},
-	{8, 10, 0x0000},
-	{9, 10, 0x9F00},
-	{1, 1, 0xA400},
-	{-1, -1, 0x9E00},
-};
-
-void spl_init_easf_filter_coeffs(void)
-{
-	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_30,
-		easf_filter_3tap_64p_ratio_0_30_s1_12, 3);
-	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_40,
-		easf_filter_3tap_64p_ratio_0_40_s1_12, 3);
-	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_50,
-		easf_filter_3tap_64p_ratio_0_50_s1_12, 3);
-	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_60,
-		easf_filter_3tap_64p_ratio_0_60_s1_12, 3);
-	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_70,
-		easf_filter_3tap_64p_ratio_0_70_s1_12, 3);
-	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_80,
-		easf_filter_3tap_64p_ratio_0_80_s1_12, 3);
-	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_90,
-		easf_filter_3tap_64p_ratio_0_90_s1_12, 3);
-	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_1_00,
-		easf_filter_3tap_64p_ratio_1_00_s1_12, 3);
-
-	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_30,
-		easf_filter_4tap_64p_ratio_0_30_s1_12, 4);
-	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_40,
-		easf_filter_4tap_64p_ratio_0_40_s1_12, 4);
-	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_50,
-		easf_filter_4tap_64p_ratio_0_50_s1_12, 4);
-	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_60,
-		easf_filter_4tap_64p_ratio_0_60_s1_12, 4);
-	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_70,
-		easf_filter_4tap_64p_ratio_0_70_s1_12, 4);
-	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_80,
-		easf_filter_4tap_64p_ratio_0_80_s1_12, 4);
-	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_90,
-		easf_filter_4tap_64p_ratio_0_90_s1_12, 4);
-	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_1_00,
-		easf_filter_4tap_64p_ratio_1_00_s1_12, 4);
-
-	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_30,
-		easf_filter_6tap_64p_ratio_0_30_s1_12, 6);
-	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_40,
-		easf_filter_6tap_64p_ratio_0_40_s1_12, 6);
-	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_50,
-		easf_filter_6tap_64p_ratio_0_50_s1_12, 6);
-	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_60,
-		easf_filter_6tap_64p_ratio_0_60_s1_12, 6);
-	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_70,
-		easf_filter_6tap_64p_ratio_0_70_s1_12, 6);
-	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_80,
-		easf_filter_6tap_64p_ratio_0_80_s1_12, 6);
-	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_90,
-		easf_filter_6tap_64p_ratio_0_90_s1_12, 6);
-	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_1_00,
-		easf_filter_6tap_64p_ratio_1_00_s1_12, 6);
-}
-
-uint16_t *spl_get_easf_filter_3tap_64p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_from_fraction(3, 10).value)
-		return easf_filter_3tap_64p_ratio_0_30_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 10).value)
-		return easf_filter_3tap_64p_ratio_0_40_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 10).value)
-		return easf_filter_3tap_64p_ratio_0_50_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(6, 10).value)
-		return easf_filter_3tap_64p_ratio_0_60_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(7, 10).value)
-		return easf_filter_3tap_64p_ratio_0_70_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(8, 10).value)
-		return easf_filter_3tap_64p_ratio_0_80_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(9, 10).value)
-		return easf_filter_3tap_64p_ratio_0_90_s1_12;
-	else
-		return easf_filter_3tap_64p_ratio_1_00_s1_12;
-}
-
-uint16_t *spl_get_easf_filter_4tap_64p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_from_fraction(3, 10).value)
-		return easf_filter_4tap_64p_ratio_0_30_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 10).value)
-		return easf_filter_4tap_64p_ratio_0_40_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 10).value)
-		return easf_filter_4tap_64p_ratio_0_50_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(6, 10).value)
-		return easf_filter_4tap_64p_ratio_0_60_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(7, 10).value)
-		return easf_filter_4tap_64p_ratio_0_70_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(8, 10).value)
-		return easf_filter_4tap_64p_ratio_0_80_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(9, 10).value)
-		return easf_filter_4tap_64p_ratio_0_90_s1_12;
-	else
-		return easf_filter_4tap_64p_ratio_1_00_s1_12;
-}
-
-uint16_t *spl_get_easf_filter_6tap_64p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_from_fraction(3, 10).value)
-		return easf_filter_6tap_64p_ratio_0_30_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 10).value)
-		return easf_filter_6tap_64p_ratio_0_40_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 10).value)
-		return easf_filter_6tap_64p_ratio_0_50_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(6, 10).value)
-		return easf_filter_6tap_64p_ratio_0_60_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(7, 10).value)
-		return easf_filter_6tap_64p_ratio_0_70_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(8, 10).value)
-		return easf_filter_6tap_64p_ratio_0_80_s1_12;
-	else if (ratio.value < spl_fixpt_from_fraction(9, 10).value)
-		return easf_filter_6tap_64p_ratio_0_90_s1_12;
-	else
-		return easf_filter_6tap_64p_ratio_1_00_s1_12;
-}
-
-uint16_t *spl_dscl_get_easf_filter_coeffs_64p(int taps, struct spl_fixed31_32 ratio)
-{
-	if (taps == 6)
-		return spl_get_easf_filter_6tap_64p(ratio);
-	else if (taps == 4)
-		return spl_get_easf_filter_4tap_64p(ratio);
-	else if (taps == 3)
-		return spl_get_easf_filter_3tap_64p(ratio);
-	else {
-		/* should never happen, bug */
-		SPL_BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-}
-
-void spl_set_filters_data(struct dscl_prog_data *dscl_prog_data,
-		const struct spl_scaler_data *data, bool enable_easf_v,
-		bool enable_easf_h)
-{
-	/*
-	 * Old coefficients calculated scaling ratio = input / output
-	 * New coefficients are calculated based on = output / input
-	 */
-	if (enable_easf_h) {
-		dscl_prog_data->filter_h = spl_dscl_get_easf_filter_coeffs_64p(
-			data->taps.h_taps, data->recip_ratios.horz);
-
-		dscl_prog_data->filter_h_c = spl_dscl_get_easf_filter_coeffs_64p(
-			data->taps.h_taps_c, data->recip_ratios.horz_c);
-	} else {
-		dscl_prog_data->filter_h = spl_dscl_get_filter_coeffs_64p(
-			data->taps.h_taps, data->ratios.horz);
-
-		dscl_prog_data->filter_h_c = spl_dscl_get_filter_coeffs_64p(
-			data->taps.h_taps_c, data->ratios.horz_c);
-	}
-	if (enable_easf_v) {
-		dscl_prog_data->filter_v = spl_dscl_get_easf_filter_coeffs_64p(
-			data->taps.v_taps, data->recip_ratios.vert);
-
-		dscl_prog_data->filter_v_c = spl_dscl_get_easf_filter_coeffs_64p(
-			data->taps.v_taps_c, data->recip_ratios.vert_c);
-	} else {
-		dscl_prog_data->filter_v = spl_dscl_get_filter_coeffs_64p(
-			data->taps.v_taps, data->ratios.vert);
-
-		dscl_prog_data->filter_v_c = spl_dscl_get_filter_coeffs_64p(
-			data->taps.v_taps_c, data->ratios.vert_c);
-	}
-}
-
-static uint32_t spl_easf_get_scale_ratio_to_reg_value(struct spl_fixed31_32 ratio,
-	struct scale_ratio_to_reg_value_lookup *lookup_table_base_ptr,
-	unsigned int num_entries)
-{
-	unsigned int count = 0;
-	uint32_t value = 0;
-	struct scale_ratio_to_reg_value_lookup *lookup_table_index_ptr;
-
-	lookup_table_index_ptr = (lookup_table_base_ptr + num_entries - 1);
-	value = lookup_table_index_ptr->reg_value;
-
-	while (count < num_entries) {
-
-		lookup_table_index_ptr = (lookup_table_base_ptr + count);
-		if (lookup_table_index_ptr->numer < 0)
-			break;
-
-		if (ratio.value < spl_fixpt_from_fraction(
-			lookup_table_index_ptr->numer,
-			lookup_table_index_ptr->denom).value) {
-			value = lookup_table_index_ptr->reg_value;
-			break;
-		}
-
-		count++;
-	}
-	return value;
-}
-uint32_t spl_get_v_bf3_mode(struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries = sizeof(easf_v_bf3_mode_lookup) /
-		sizeof(struct scale_ratio_to_reg_value_lookup);
-	value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-		easf_v_bf3_mode_lookup, num_entries);
-	return value;
-}
-uint32_t spl_get_h_bf3_mode(struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries = sizeof(easf_h_bf3_mode_lookup) /
-		sizeof(struct scale_ratio_to_reg_value_lookup);
-	value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-		easf_h_bf3_mode_lookup, num_entries);
-	return value;
-}
-uint32_t spl_get_reducer_gain6(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 4) {
-		num_entries = sizeof(easf_reducer_gain6_4tap_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_reducer_gain6_4tap_lookup, num_entries);
-	} else if (taps == 6) {
-		num_entries = sizeof(easf_reducer_gain6_6tap_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_reducer_gain6_6tap_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
-uint32_t spl_get_reducer_gain4(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 4) {
-		num_entries = sizeof(easf_reducer_gain4_4tap_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_reducer_gain4_4tap_lookup, num_entries);
-	} else if (taps == 6) {
-		num_entries = sizeof(easf_reducer_gain4_6tap_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_reducer_gain4_6tap_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
-uint32_t spl_get_gainRing6(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 4) {
-		num_entries = sizeof(easf_gain_ring6_4tap_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_gain_ring6_4tap_lookup, num_entries);
-	} else if (taps == 6) {
-		num_entries = sizeof(easf_gain_ring6_6tap_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_gain_ring6_6tap_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
-uint32_t spl_get_gainRing4(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 4) {
-		num_entries = sizeof(easf_gain_ring4_4tap_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_gain_ring4_4tap_lookup, num_entries);
-	} else if (taps == 6) {
-		num_entries = sizeof(easf_gain_ring4_6tap_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_gain_ring4_6tap_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
-uint32_t spl_get_3tap_dntilt_uptilt_offset(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 3) {
-		num_entries = sizeof(easf_3tap_dntilt_uptilt_offset_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_3tap_dntilt_uptilt_offset_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
-uint32_t spl_get_3tap_uptilt_maxval(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 3) {
-		num_entries = sizeof(easf_3tap_uptilt_maxval_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_3tap_uptilt_maxval_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
-uint32_t spl_get_3tap_dntilt_slope(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 3) {
-		num_entries = sizeof(easf_3tap_dntilt_slope_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_3tap_dntilt_slope_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
-uint32_t spl_get_3tap_uptilt1_slope(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 3) {
-		num_entries = sizeof(easf_3tap_uptilt1_slope_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_3tap_uptilt1_slope_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
-uint32_t spl_get_3tap_uptilt2_slope(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 3) {
-		num_entries = sizeof(easf_3tap_uptilt2_slope_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_3tap_uptilt2_slope_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
-uint32_t spl_get_3tap_uptilt2_offset(int taps, struct spl_fixed31_32 ratio)
-{
-	uint32_t value;
-	unsigned int num_entries;
-
-	if (taps == 3) {
-		num_entries = sizeof(easf_3tap_uptilt2_offset_lookup) /
-			sizeof(struct scale_ratio_to_reg_value_lookup);
-		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
-			easf_3tap_uptilt2_offset_lookup, num_entries);
-	} else
-		value = 0;
-	return value;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_easf_filters.h b/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_easf_filters.h
deleted file mode 100644
index 8bb2b8108e38..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_easf_filters.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-
-/* Copyright 2024 Advanced Micro Devices, Inc. */
-
-#ifndef __DC_SPL_SCL_EASF_FILTERS_H__
-#define __DC_SPL_SCL_EASF_FILTERS_H__
-
-#include "dc_spl_types.h"
-
-struct scale_ratio_to_reg_value_lookup {
-	int numer;
-	int denom;
-	const uint32_t reg_value;
-};
-
-void spl_init_easf_filter_coeffs(void);
-uint16_t *spl_get_easf_filter_3tap_64p(struct spl_fixed31_32 ratio);
-uint16_t *spl_get_easf_filter_4tap_64p(struct spl_fixed31_32 ratio);
-uint16_t *spl_get_easf_filter_6tap_64p(struct spl_fixed31_32 ratio);
-uint16_t *spl_dscl_get_easf_filter_coeffs_64p(int taps, struct spl_fixed31_32 ratio);
-void spl_set_filters_data(struct dscl_prog_data *dscl_prog_data,
-	const struct spl_scaler_data *data, bool enable_easf_v,
-	bool enable_easf_h);
-
-uint32_t spl_get_v_bf3_mode(struct spl_fixed31_32 ratio);
-uint32_t spl_get_h_bf3_mode(struct spl_fixed31_32 ratio);
-uint32_t spl_get_reducer_gain6(int taps, struct spl_fixed31_32 ratio);
-uint32_t spl_get_reducer_gain4(int taps, struct spl_fixed31_32 ratio);
-uint32_t spl_get_gainRing6(int taps, struct spl_fixed31_32 ratio);
-uint32_t spl_get_gainRing4(int taps, struct spl_fixed31_32 ratio);
-uint32_t spl_get_3tap_dntilt_uptilt_offset(int taps, struct spl_fixed31_32 ratio);
-uint32_t spl_get_3tap_uptilt_maxval(int taps, struct spl_fixed31_32 ratio);
-uint32_t spl_get_3tap_dntilt_slope(int taps, struct spl_fixed31_32 ratio);
-uint32_t spl_get_3tap_uptilt1_slope(int taps, struct spl_fixed31_32 ratio);
-uint32_t spl_get_3tap_uptilt2_slope(int taps, struct spl_fixed31_32 ratio);
-uint32_t spl_get_3tap_uptilt2_offset(int taps, struct spl_fixed31_32 ratio);
-
-#endif /* __DC_SPL_SCL_EASF_FILTERS_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_filters.c b/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_filters.c
deleted file mode 100644
index b02c7b0b262b..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_filters.c
+++ /dev/null
@@ -1,1451 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#include "spl_debug.h"
-#include "dc_spl_scl_filters.h"
-//=========================================
-// <num_taps>    = 2
-// <num_phases>  = 16
-// <scale_ratio> = 0.833333 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = s1.10
-// <CoefOut>     = s1.12
-//=========================================
-static const uint16_t filter_2tap_16p[18] = {
-		0x1000, 0x0000,
-		0x0FF0, 0x0010,
-		0x0FB0, 0x0050,
-		0x0F34, 0x00CC,
-		0x0E68, 0x0198,
-		0x0D44, 0x02BC,
-		0x0BC4, 0x043C,
-		0x09FC, 0x0604,
-		0x0800, 0x0800
-};
-
-//=========================================
-// <num_taps>    = 3
-// <num_phases>  = 16
-// <scale_ratio> = 0.83333 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_3tap_16p_upscale[27] = {
-		0x0804, 0x07FC, 0x0000,
-		0x06AC, 0x0978, 0x3FDC,
-		0x055C, 0x0AF0, 0x3FB4,
-		0x0420, 0x0C50, 0x3F90,
-		0x0300, 0x0D88, 0x3F78,
-		0x0200, 0x0E90, 0x3F70,
-		0x0128, 0x0F5C, 0x3F7C,
-		0x007C, 0x0FD8, 0x3FAC,
-		0x0000, 0x1000, 0x0000
-};
-
-//=========================================
-// <num_taps>    = 3
-// <num_phases>  = 16
-// <scale_ratio> = 1.16666 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_3tap_16p_116[27] = {
-		0x0804, 0x07FC, 0x0000,
-		0x0700, 0x0914, 0x3FEC,
-		0x0604, 0x0A1C, 0x3FE0,
-		0x050C, 0x0B14, 0x3FE0,
-		0x041C, 0x0BF4, 0x3FF0,
-		0x0340, 0x0CB0, 0x0010,
-		0x0274, 0x0D3C, 0x0050,
-		0x01C0, 0x0D94, 0x00AC,
-		0x0128, 0x0DB4, 0x0124
-};
-
-//=========================================
-// <num_taps>    = 3
-// <num_phases>  = 16
-// <scale_ratio> = 1.49999 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_3tap_16p_149[27] = {
-		0x0804, 0x07FC, 0x0000,
-		0x0730, 0x08CC, 0x0004,
-		0x0660, 0x098C, 0x0014,
-		0x0590, 0x0A3C, 0x0034,
-		0x04C4, 0x0AD4, 0x0068,
-		0x0400, 0x0B54, 0x00AC,
-		0x0348, 0x0BB0, 0x0108,
-		0x029C, 0x0BEC, 0x0178,
-		0x0200, 0x0C00, 0x0200
-};
-
-//=========================================
-// <num_taps>    = 3
-// <num_phases>  = 16
-// <scale_ratio> = 1.83332 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_3tap_16p_183[27] = {
-		0x0804, 0x07FC, 0x0000,
-		0x0754, 0x0880, 0x002C,
-		0x06A8, 0x08F0, 0x0068,
-		0x05FC, 0x0954, 0x00B0,
-		0x0550, 0x09AC, 0x0104,
-		0x04A8, 0x09F0, 0x0168,
-		0x0408, 0x0A20, 0x01D8,
-		0x036C, 0x0A40, 0x0254,
-		0x02DC, 0x0A48, 0x02DC
-};
-
-//=========================================
-// <num_taps>    = 4
-// <num_phases>  = 16
-// <scale_ratio> = 0.83333 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_4tap_16p_upscale[36] = {
-		0x0000, 0x1000, 0x0000, 0x0000,
-		0x3F74, 0x0FDC, 0x00B4, 0x3FFC,
-		0x3F0C, 0x0F70, 0x0194, 0x3FF0,
-		0x3ECC, 0x0EC4, 0x0298, 0x3FD8,
-		0x3EAC, 0x0DE4, 0x03B8, 0x3FB8,
-		0x3EA4, 0x0CD8, 0x04F4, 0x3F90,
-		0x3EB8, 0x0BA0, 0x0644, 0x3F64,
-		0x3ED8, 0x0A54, 0x07A0, 0x3F34,
-		0x3F00, 0x08FC, 0x0900, 0x3F04
-};
-
-//=========================================
-// <num_taps>    = 4
-// <num_phases>  = 16
-// <scale_ratio> = 1.16666 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_4tap_16p_116[36] = {
-		0x01A8, 0x0CB4, 0x01A4, 0x0000,
-		0x0110, 0x0CB0, 0x0254, 0x3FEC,
-		0x0090, 0x0C80, 0x031C, 0x3FD4,
-		0x0024, 0x0C2C, 0x03F4, 0x3FBC,
-		0x3FD8, 0x0BAC, 0x04DC, 0x3FA0,
-		0x3F9C, 0x0B14, 0x05CC, 0x3F84,
-		0x3F70, 0x0A60, 0x06C4, 0x3F6C,
-		0x3F5C, 0x098C, 0x07BC, 0x3F5C,
-		0x3F54, 0x08AC, 0x08AC, 0x3F54
-};
-
-//=========================================
-// <num_taps>    = 4
-// <num_phases>  = 16
-// <scale_ratio> = 1.49999 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_4tap_16p_149[36] = {
-		0x02B8, 0x0A90, 0x02B8, 0x0000,
-		0x0230, 0x0A90, 0x0350, 0x3FF0,
-		0x01B8, 0x0A78, 0x03F0, 0x3FE0,
-		0x0148, 0x0A48, 0x049C, 0x3FD4,
-		0x00E8, 0x0A00, 0x054C, 0x3FCC,
-		0x0098, 0x09A0, 0x0600, 0x3FC8,
-		0x0054, 0x0928, 0x06B4, 0x3FD0,
-		0x001C, 0x08A4, 0x0760, 0x3FE0,
-		0x3FFC, 0x0804, 0x0804, 0x3FFC
-};
-
-//=========================================
-// <num_taps>    = 4
-// <num_phases>  = 16
-// <scale_ratio> = 1.83332 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_4tap_16p_183[36] = {
-		0x03B0, 0x08A0, 0x03B0, 0x0000,
-		0x0348, 0x0898, 0x041C, 0x0004,
-		0x02DC, 0x0884, 0x0490, 0x0010,
-		0x0278, 0x0864, 0x0500, 0x0024,
-		0x021C, 0x0838, 0x0570, 0x003C,
-		0x01C8, 0x07FC, 0x05E0, 0x005C,
-		0x0178, 0x07B8, 0x064C, 0x0084,
-		0x0130, 0x076C, 0x06B0, 0x00B4,
-		0x00F0, 0x0714, 0x0710, 0x00EC
-};
-
-//=========================================
-// <num_taps>    = 2
-// <num_phases>  = 64
-// <scale_ratio> = 0.833333 (input/output)
-// <sharpness>   = 0
-// <CoefType> = ModifiedLanczos
-// <CoefQuant> = s1.10
-// <CoefOut> = s1.12
-//=========================================
-static const uint16_t filter_2tap_64p[66] = {
-		0x1000, 0x0000,
-		0x1000, 0x0000,
-		0x0FFC, 0x0004,
-		0x0FF8, 0x0008,
-		0x0FF0, 0x0010,
-		0x0FE4, 0x001C,
-		0x0FD8, 0x0028,
-		0x0FC4, 0x003C,
-		0x0FB0, 0x0050,
-		0x0F98, 0x0068,
-		0x0F7C, 0x0084,
-		0x0F58, 0x00A8,
-		0x0F34, 0x00CC,
-		0x0F08, 0x00F8,
-		0x0ED8, 0x0128,
-		0x0EA4, 0x015C,
-		0x0E68, 0x0198,
-		0x0E28, 0x01D8,
-		0x0DE4, 0x021C,
-		0x0D98, 0x0268,
-		0x0D44, 0x02BC,
-		0x0CEC, 0x0314,
-		0x0C90, 0x0370,
-		0x0C2C, 0x03D4,
-		0x0BC4, 0x043C,
-		0x0B58, 0x04A8,
-		0x0AE8, 0x0518,
-		0x0A74, 0x058C,
-		0x09FC, 0x0604,
-		0x0980, 0x0680,
-		0x0900, 0x0700,
-		0x0880, 0x0780,
-		0x0800, 0x0800
-};
-
-//=========================================
-// <num_taps>    = 3
-// <num_phases>  = 64
-// <scale_ratio> = 0.83333 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_3tap_64p_upscale[99] = {
-		0x0804, 0x07FC, 0x0000,
-		0x07A8, 0x0860, 0x3FF8,
-		0x0754, 0x08BC, 0x3FF0,
-		0x0700, 0x0918, 0x3FE8,
-		0x06AC, 0x0978, 0x3FDC,
-		0x0654, 0x09D8, 0x3FD4,
-		0x0604, 0x0A34, 0x3FC8,
-		0x05B0, 0x0A90, 0x3FC0,
-		0x055C, 0x0AF0, 0x3FB4,
-		0x050C, 0x0B48, 0x3FAC,
-		0x04BC, 0x0BA0, 0x3FA4,
-		0x0470, 0x0BF4, 0x3F9C,
-		0x0420, 0x0C50, 0x3F90,
-		0x03D8, 0x0C9C, 0x3F8C,
-		0x038C, 0x0CF0, 0x3F84,
-		0x0344, 0x0D40, 0x3F7C,
-		0x0300, 0x0D88, 0x3F78,
-		0x02BC, 0x0DD0, 0x3F74,
-		0x027C, 0x0E14, 0x3F70,
-		0x023C, 0x0E54, 0x3F70,
-		0x0200, 0x0E90, 0x3F70,
-		0x01C8, 0x0EC8, 0x3F70,
-		0x0190, 0x0EFC, 0x3F74,
-		0x015C, 0x0F2C, 0x3F78,
-		0x0128, 0x0F5C, 0x3F7C,
-		0x00FC, 0x0F7C, 0x3F88,
-		0x00CC, 0x0FA4, 0x3F90,
-		0x00A4, 0x0FC0, 0x3F9C,
-		0x007C, 0x0FD8, 0x3FAC,
-		0x0058, 0x0FE8, 0x3FC0,
-		0x0038, 0x0FF4, 0x3FD4,
-		0x0018, 0x1000, 0x3FE8,
-		0x0000, 0x1000, 0x0000
-};
-
-//=========================================
-// <num_taps>    = 3
-// <num_phases>  = 64
-// <scale_ratio> = 1.16666 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_3tap_64p_116[99] = {
-		0x0804, 0x07FC, 0x0000,
-		0x07C0, 0x0844, 0x3FFC,
-		0x0780, 0x0888, 0x3FF8,
-		0x0740, 0x08D0, 0x3FF0,
-		0x0700, 0x0914, 0x3FEC,
-		0x06C0, 0x0958, 0x3FE8,
-		0x0684, 0x0998, 0x3FE4,
-		0x0644, 0x09DC, 0x3FE0,
-		0x0604, 0x0A1C, 0x3FE0,
-		0x05C4, 0x0A5C, 0x3FE0,
-		0x0588, 0x0A9C, 0x3FDC,
-		0x0548, 0x0ADC, 0x3FDC,
-		0x050C, 0x0B14, 0x3FE0,
-		0x04CC, 0x0B54, 0x3FE0,
-		0x0490, 0x0B8C, 0x3FE4,
-		0x0458, 0x0BC0, 0x3FE8,
-		0x041C, 0x0BF4, 0x3FF0,
-		0x03E0, 0x0C28, 0x3FF8,
-		0x03A8, 0x0C58, 0x0000,
-		0x0374, 0x0C88, 0x0004,
-		0x0340, 0x0CB0, 0x0010,
-		0x0308, 0x0CD8, 0x0020,
-		0x02D8, 0x0CFC, 0x002C,
-		0x02A0, 0x0D20, 0x0040,
-		0x0274, 0x0D3C, 0x0050,
-		0x0244, 0x0D58, 0x0064,
-		0x0214, 0x0D70, 0x007C,
-		0x01E8, 0x0D84, 0x0094,
-		0x01C0, 0x0D94, 0x00AC,
-		0x0198, 0x0DA0, 0x00C8,
-		0x0170, 0x0DAC, 0x00E4,
-		0x014C, 0x0DB0, 0x0104,
-		0x0128, 0x0DB4, 0x0124
-};
-
-//=========================================
-// <num_taps>    = 3
-// <num_phases>  = 64
-// <scale_ratio> = 1.49999 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_3tap_64p_149[99] = {
-		0x0804, 0x07FC, 0x0000,
-		0x07CC, 0x0834, 0x0000,
-		0x0798, 0x0868, 0x0000,
-		0x0764, 0x089C, 0x0000,
-		0x0730, 0x08CC, 0x0004,
-		0x0700, 0x08FC, 0x0004,
-		0x06CC, 0x092C, 0x0008,
-		0x0698, 0x095C, 0x000C,
-		0x0660, 0x098C, 0x0014,
-		0x062C, 0x09B8, 0x001C,
-		0x05FC, 0x09E4, 0x0020,
-		0x05C4, 0x0A10, 0x002C,
-		0x0590, 0x0A3C, 0x0034,
-		0x055C, 0x0A64, 0x0040,
-		0x0528, 0x0A8C, 0x004C,
-		0x04F8, 0x0AB0, 0x0058,
-		0x04C4, 0x0AD4, 0x0068,
-		0x0490, 0x0AF8, 0x0078,
-		0x0460, 0x0B18, 0x0088,
-		0x0430, 0x0B38, 0x0098,
-		0x0400, 0x0B54, 0x00AC,
-		0x03D0, 0x0B6C, 0x00C4,
-		0x03A0, 0x0B88, 0x00D8,
-		0x0374, 0x0B9C, 0x00F0,
-		0x0348, 0x0BB0, 0x0108,
-		0x0318, 0x0BC4, 0x0124,
-		0x02EC, 0x0BD4, 0x0140,
-		0x02C4, 0x0BE0, 0x015C,
-		0x029C, 0x0BEC, 0x0178,
-		0x0274, 0x0BF4, 0x0198,
-		0x024C, 0x0BFC, 0x01B8,
-		0x0228, 0x0BFC, 0x01DC,
-		0x0200, 0x0C00, 0x0200
-};
-
-//=========================================
-// <num_taps>    = 3
-// <num_phases>  = 64
-// <scale_ratio> = 1.83332 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_3tap_64p_183[99] = {
-		0x0804, 0x07FC, 0x0000,
-		0x07D4, 0x0824, 0x0008,
-		0x07AC, 0x0840, 0x0014,
-		0x0780, 0x0860, 0x0020,
-		0x0754, 0x0880, 0x002C,
-		0x0728, 0x089C, 0x003C,
-		0x0700, 0x08B8, 0x0048,
-		0x06D4, 0x08D4, 0x0058,
-		0x06A8, 0x08F0, 0x0068,
-		0x067C, 0x090C, 0x0078,
-		0x0650, 0x0924, 0x008C,
-		0x0628, 0x093C, 0x009C,
-		0x05FC, 0x0954, 0x00B0,
-		0x05D0, 0x096C, 0x00C4,
-		0x05A8, 0x0980, 0x00D8,
-		0x0578, 0x0998, 0x00F0,
-		0x0550, 0x09AC, 0x0104,
-		0x0528, 0x09BC, 0x011C,
-		0x04FC, 0x09D0, 0x0134,
-		0x04D4, 0x09E0, 0x014C,
-		0x04A8, 0x09F0, 0x0168,
-		0x0480, 0x09FC, 0x0184,
-		0x045C, 0x0A08, 0x019C,
-		0x0434, 0x0A14, 0x01B8,
-		0x0408, 0x0A20, 0x01D8,
-		0x03E0, 0x0A2C, 0x01F4,
-		0x03B8, 0x0A34, 0x0214,
-		0x0394, 0x0A38, 0x0234,
-		0x036C, 0x0A40, 0x0254,
-		0x0348, 0x0A44, 0x0274,
-		0x0324, 0x0A48, 0x0294,
-		0x0300, 0x0A48, 0x02B8,
-		0x02DC, 0x0A48, 0x02DC
-};
-
-//=========================================
-// <num_taps>    = 4
-// <num_phases>  = 64
-// <scale_ratio> = 0.83333 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_4tap_64p_upscale[132] = {
-		0x0000, 0x1000, 0x0000, 0x0000,
-		0x3FDC, 0x0FFC, 0x0028, 0x0000,
-		0x3FB4, 0x0FF8, 0x0054, 0x0000,
-		0x3F94, 0x0FE8, 0x0084, 0x0000,
-		0x3F74, 0x0FDC, 0x00B4, 0x3FFC,
-		0x3F58, 0x0FC4, 0x00E8, 0x3FFC,
-		0x3F3C, 0x0FAC, 0x0120, 0x3FF8,
-		0x3F24, 0x0F90, 0x0158, 0x3FF4,
-		0x3F0C, 0x0F70, 0x0194, 0x3FF0,
-		0x3EF8, 0x0F4C, 0x01D0, 0x3FEC,
-		0x3EE8, 0x0F20, 0x0210, 0x3FE8,
-		0x3ED8, 0x0EF4, 0x0254, 0x3FE0,
-		0x3ECC, 0x0EC4, 0x0298, 0x3FD8,
-		0x3EC0, 0x0E90, 0x02DC, 0x3FD4,
-		0x3EB8, 0x0E58, 0x0324, 0x3FCC,
-		0x3EB0, 0x0E20, 0x036C, 0x3FC4,
-		0x3EAC, 0x0DE4, 0x03B8, 0x3FB8,
-		0x3EA8, 0x0DA4, 0x0404, 0x3FB0,
-		0x3EA4, 0x0D60, 0x0454, 0x3FA8,
-		0x3EA4, 0x0D1C, 0x04A4, 0x3F9C,
-		0x3EA4, 0x0CD8, 0x04F4, 0x3F90,
-		0x3EA8, 0x0C88, 0x0548, 0x3F88,
-		0x3EAC, 0x0C3C, 0x059C, 0x3F7C,
-		0x3EB0, 0x0BF0, 0x05F0, 0x3F70,
-		0x3EB8, 0x0BA0, 0x0644, 0x3F64,
-		0x3EBC, 0x0B54, 0x0698, 0x3F58,
-		0x3EC4, 0x0B00, 0x06F0, 0x3F4C,
-		0x3ECC, 0x0AAC, 0x0748, 0x3F40,
-		0x3ED8, 0x0A54, 0x07A0, 0x3F34,
-		0x3EE0, 0x0A04, 0x07F8, 0x3F24,
-		0x3EEC, 0x09AC, 0x0850, 0x3F18,
-		0x3EF8, 0x0954, 0x08A8, 0x3F0C,
-		0x3F00, 0x08FC, 0x0900, 0x3F04
-};
-
-//=========================================
-// <num_taps>    = 4
-// <num_phases>  = 64
-// <scale_ratio> = 1.16666 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_4tap_64p_116[132] = {
-		0x01A8, 0x0CB4, 0x01A4, 0x0000,
-		0x017C, 0x0CB8, 0x01D0, 0x3FFC,
-		0x0158, 0x0CB8, 0x01F8, 0x3FF8,
-		0x0130, 0x0CB4, 0x0228, 0x3FF4,
-		0x0110, 0x0CB0, 0x0254, 0x3FEC,
-		0x00EC, 0x0CA8, 0x0284, 0x3FE8,
-		0x00CC, 0x0C9C, 0x02B4, 0x3FE4,
-		0x00AC, 0x0C90, 0x02E8, 0x3FDC,
-		0x0090, 0x0C80, 0x031C, 0x3FD4,
-		0x0070, 0x0C70, 0x0350, 0x3FD0,
-		0x0058, 0x0C5C, 0x0384, 0x3FC8,
-		0x003C, 0x0C48, 0x03BC, 0x3FC0,
-		0x0024, 0x0C2C, 0x03F4, 0x3FBC,
-		0x0010, 0x0C10, 0x042C, 0x3FB4,
-		0x3FFC, 0x0BF4, 0x0464, 0x3FAC,
-		0x3FE8, 0x0BD4, 0x04A0, 0x3FA4,
-		0x3FD8, 0x0BAC, 0x04DC, 0x3FA0,
-		0x3FC4, 0x0B8C, 0x0518, 0x3F98,
-		0x3FB4, 0x0B68, 0x0554, 0x3F90,
-		0x3FA8, 0x0B40, 0x0590, 0x3F88,
-		0x3F9C, 0x0B14, 0x05CC, 0x3F84,
-		0x3F90, 0x0AEC, 0x0608, 0x3F7C,
-		0x3F84, 0x0ABC, 0x0648, 0x3F78,
-		0x3F7C, 0x0A90, 0x0684, 0x3F70,
-		0x3F70, 0x0A60, 0x06C4, 0x3F6C,
-		0x3F6C, 0x0A2C, 0x0700, 0x3F68,
-		0x3F64, 0x09F8, 0x0740, 0x3F64,
-		0x3F60, 0x09C4, 0x077C, 0x3F60,
-		0x3F5C, 0x098C, 0x07BC, 0x3F5C,
-		0x3F58, 0x0958, 0x07F8, 0x3F58,
-		0x3F58, 0x091C, 0x0834, 0x3F58,
-		0x3F54, 0x08E4, 0x0870, 0x3F58,
-		0x3F54, 0x08AC, 0x08AC, 0x3F54
-};
-
-//=========================================
-// <num_taps>    = 4
-// <num_phases>  = 64
-// <scale_ratio> = 1.49999 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_4tap_64p_149[132] = {
-		0x02B8, 0x0A90, 0x02B8, 0x0000,
-		0x0294, 0x0A94, 0x02DC, 0x3FFC,
-		0x0274, 0x0A94, 0x0300, 0x3FF8,
-		0x0250, 0x0A94, 0x0328, 0x3FF4,
-		0x0230, 0x0A90, 0x0350, 0x3FF0,
-		0x0214, 0x0A8C, 0x0374, 0x3FEC,
-		0x01F0, 0x0A88, 0x03A0, 0x3FE8,
-		0x01D4, 0x0A80, 0x03C8, 0x3FE4,
-		0x01B8, 0x0A78, 0x03F0, 0x3FE0,
-		0x0198, 0x0A70, 0x041C, 0x3FDC,
-		0x0180, 0x0A64, 0x0444, 0x3FD8,
-		0x0164, 0x0A54, 0x0470, 0x3FD8,
-		0x0148, 0x0A48, 0x049C, 0x3FD4,
-		0x0130, 0x0A38, 0x04C8, 0x3FD0,
-		0x0118, 0x0A24, 0x04F4, 0x3FD0,
-		0x0100, 0x0A14, 0x0520, 0x3FCC,
-		0x00E8, 0x0A00, 0x054C, 0x3FCC,
-		0x00D4, 0x09E8, 0x057C, 0x3FC8,
-		0x00C0, 0x09D0, 0x05A8, 0x3FC8,
-		0x00AC, 0x09B8, 0x05D4, 0x3FC8,
-		0x0098, 0x09A0, 0x0600, 0x3FC8,
-		0x0084, 0x0984, 0x0630, 0x3FC8,
-		0x0074, 0x0964, 0x065C, 0x3FCC,
-		0x0064, 0x0948, 0x0688, 0x3FCC,
-		0x0054, 0x0928, 0x06B4, 0x3FD0,
-		0x0044, 0x0908, 0x06E0, 0x3FD4,
-		0x0038, 0x08E8, 0x070C, 0x3FD4,
-		0x002C, 0x08C4, 0x0738, 0x3FD8,
-		0x001C, 0x08A4, 0x0760, 0x3FE0,
-		0x0014, 0x087C, 0x078C, 0x3FE4,
-		0x0008, 0x0858, 0x07B4, 0x3FEC,
-		0x0000, 0x0830, 0x07DC, 0x3FF4,
-		0x3FFC, 0x0804, 0x0804, 0x3FFC
-};
-
-//=========================================
-// <num_taps>    = 4
-// <num_phases>  = 64
-// <scale_ratio> = 1.83332 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_4tap_64p_183[132] = {
-		0x03B0, 0x08A0, 0x03B0, 0x0000,
-		0x0394, 0x08A0, 0x03CC, 0x0000,
-		0x037C, 0x089C, 0x03E8, 0x0000,
-		0x0360, 0x089C, 0x0400, 0x0004,
-		0x0348, 0x0898, 0x041C, 0x0004,
-		0x032C, 0x0894, 0x0438, 0x0008,
-		0x0310, 0x0890, 0x0454, 0x000C,
-		0x02F8, 0x0888, 0x0474, 0x000C,
-		0x02DC, 0x0884, 0x0490, 0x0010,
-		0x02C4, 0x087C, 0x04AC, 0x0014,
-		0x02AC, 0x0874, 0x04C8, 0x0018,
-		0x0290, 0x086C, 0x04E4, 0x0020,
-		0x0278, 0x0864, 0x0500, 0x0024,
-		0x0264, 0x0858, 0x051C, 0x0028,
-		0x024C, 0x084C, 0x0538, 0x0030,
-		0x0234, 0x0844, 0x0554, 0x0034,
-		0x021C, 0x0838, 0x0570, 0x003C,
-		0x0208, 0x0828, 0x058C, 0x0044,
-		0x01F0, 0x081C, 0x05A8, 0x004C,
-		0x01DC, 0x080C, 0x05C4, 0x0054,
-		0x01C8, 0x07FC, 0x05E0, 0x005C,
-		0x01B4, 0x07EC, 0x05FC, 0x0064,
-		0x019C, 0x07DC, 0x0618, 0x0070,
-		0x018C, 0x07CC, 0x0630, 0x0078,
-		0x0178, 0x07B8, 0x064C, 0x0084,
-		0x0164, 0x07A8, 0x0664, 0x0090,
-		0x0150, 0x0794, 0x0680, 0x009C,
-		0x0140, 0x0780, 0x0698, 0x00A8,
-		0x0130, 0x076C, 0x06B0, 0x00B4,
-		0x0120, 0x0758, 0x06C8, 0x00C0,
-		0x0110, 0x0740, 0x06E0, 0x00D0,
-		0x0100, 0x072C, 0x06F8, 0x00DC,
-		0x00F0, 0x0714, 0x0710, 0x00EC
-};
-
-//=========================================
-// <num_taps>    = 5
-// <num_phases>  = 64
-// <scale_ratio> = 0.83333 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_5tap_64p_upscale[165] = {
-		0x3E40, 0x09C0, 0x09C0, 0x3E40, 0x0000,
-		0x3E50, 0x0964, 0x0A18, 0x3E34, 0x0000,
-		0x3E5C, 0x0908, 0x0A6C, 0x3E2C, 0x0004,
-		0x3E6C, 0x08AC, 0x0AC0, 0x3E20, 0x0008,
-		0x3E78, 0x0850, 0x0B14, 0x3E18, 0x000C,
-		0x3E88, 0x07F4, 0x0B60, 0x3E14, 0x0010,
-		0x3E98, 0x0798, 0x0BB0, 0x3E0C, 0x0014,
-		0x3EA8, 0x073C, 0x0C00, 0x3E08, 0x0014,
-		0x3EB8, 0x06E4, 0x0C48, 0x3E04, 0x0018,
-		0x3ECC, 0x0684, 0x0C90, 0x3E04, 0x001C,
-		0x3EDC, 0x062C, 0x0CD4, 0x3E04, 0x0020,
-		0x3EEC, 0x05D4, 0x0D1C, 0x3E04, 0x0020,
-		0x3EFC, 0x057C, 0x0D5C, 0x3E08, 0x0024,
-		0x3F0C, 0x0524, 0x0D98, 0x3E10, 0x0028,
-		0x3F20, 0x04CC, 0x0DD8, 0x3E14, 0x0028,
-		0x3F30, 0x0478, 0x0E14, 0x3E1C, 0x0028,
-		0x3F40, 0x0424, 0x0E48, 0x3E28, 0x002C,
-		0x3F50, 0x03D4, 0x0E7C, 0x3E34, 0x002C,
-		0x3F60, 0x0384, 0x0EAC, 0x3E44, 0x002C,
-		0x3F6C, 0x0338, 0x0EDC, 0x3E54, 0x002C,
-		0x3F7C, 0x02E8, 0x0F08, 0x3E68, 0x002C,
-		0x3F8C, 0x02A0, 0x0F2C, 0x3E7C, 0x002C,
-		0x3F98, 0x0258, 0x0F50, 0x3E94, 0x002C,
-		0x3FA4, 0x0210, 0x0F74, 0x3EB0, 0x0028,
-		0x3FB0, 0x01CC, 0x0F90, 0x3ECC, 0x0028,
-		0x3FC0, 0x018C, 0x0FA8, 0x3EE8, 0x0024,
-		0x3FC8, 0x014C, 0x0FC0, 0x3F0C, 0x0020,
-		0x3FD4, 0x0110, 0x0FD4, 0x3F2C, 0x001C,
-		0x3FE0, 0x00D4, 0x0FE0, 0x3F54, 0x0018,
-		0x3FE8, 0x009C, 0x0FF0, 0x3F7C, 0x0010,
-		0x3FF0, 0x0064, 0x0FFC, 0x3FA4, 0x000C,
-		0x3FFC, 0x0030, 0x0FFC, 0x3FD4, 0x0004,
-		0x0000, 0x0000, 0x1000, 0x0000, 0x0000
-};
-
-//=========================================
-// <num_taps>    = 5
-// <num_phases>  = 64
-// <scale_ratio> = 1.16666 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_5tap_64p_116[165] = {
-		0x3EDC, 0x0924, 0x0924, 0x3EDC, 0x0000,
-		0x3ED8, 0x08EC, 0x095C, 0x3EE0, 0x0000,
-		0x3ED4, 0x08B0, 0x0994, 0x3EE8, 0x0000,
-		0x3ED0, 0x0878, 0x09C8, 0x3EF0, 0x0000,
-		0x3ED0, 0x083C, 0x09FC, 0x3EF8, 0x0000,
-		0x3ED0, 0x0800, 0x0A2C, 0x3F04, 0x0000,
-		0x3ED0, 0x07C4, 0x0A5C, 0x3F10, 0x0000,
-		0x3ED0, 0x0788, 0x0A8C, 0x3F1C, 0x0000,
-		0x3ED0, 0x074C, 0x0AC0, 0x3F28, 0x3FFC,
-		0x3ED4, 0x0710, 0x0AE8, 0x3F38, 0x3FFC,
-		0x3ED8, 0x06D0, 0x0B18, 0x3F48, 0x3FF8,
-		0x3EDC, 0x0694, 0x0B3C, 0x3F5C, 0x3FF8,
-		0x3EE0, 0x0658, 0x0B68, 0x3F6C, 0x3FF4,
-		0x3EE4, 0x061C, 0x0B90, 0x3F80, 0x3FF0,
-		0x3EEC, 0x05DC, 0x0BB4, 0x3F98, 0x3FEC,
-		0x3EF0, 0x05A0, 0x0BD8, 0x3FB0, 0x3FE8,
-		0x3EF8, 0x0564, 0x0BF8, 0x3FC8, 0x3FE4,
-		0x3EFC, 0x0528, 0x0C1C, 0x3FE0, 0x3FE0,
-		0x3F04, 0x04EC, 0x0C38, 0x3FFC, 0x3FDC,
-		0x3F0C, 0x04B4, 0x0C54, 0x0014, 0x3FD8,
-		0x3F14, 0x047C, 0x0C70, 0x0030, 0x3FD0,
-		0x3F1C, 0x0440, 0x0C88, 0x0050, 0x3FCC,
-		0x3F24, 0x0408, 0x0CA0, 0x0070, 0x3FC4,
-		0x3F2C, 0x03D0, 0x0CB0, 0x0094, 0x3FC0,
-		0x3F34, 0x0398, 0x0CC4, 0x00B8, 0x3FB8,
-		0x3F3C, 0x0364, 0x0CD4, 0x00DC, 0x3FB0,
-		0x3F48, 0x032C, 0x0CE0, 0x0100, 0x3FAC,
-		0x3F50, 0x02F8, 0x0CEC, 0x0128, 0x3FA4,
-		0x3F58, 0x02C4, 0x0CF8, 0x0150, 0x3F9C,
-		0x3F60, 0x0290, 0x0D00, 0x017C, 0x3F94,
-		0x3F68, 0x0260, 0x0D04, 0x01A8, 0x3F8C,
-		0x3F74, 0x0230, 0x0D04, 0x01D4, 0x3F84,
-		0x3F7C, 0x0200, 0x0D08, 0x0200, 0x3F7C
-};
-
-//=========================================
-// <num_taps>    = 5
-// <num_phases>  = 64
-// <scale_ratio> = 1.49999 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_5tap_64p_149[165] = {
-		0x3FF4, 0x080C, 0x080C, 0x3FF4, 0x0000,
-		0x3FE8, 0x07E8, 0x0830, 0x0000, 0x0000,
-		0x3FDC, 0x07C8, 0x0850, 0x0010, 0x3FFC,
-		0x3FD0, 0x07A4, 0x0878, 0x001C, 0x3FF8,
-		0x3FC4, 0x0780, 0x0898, 0x0030, 0x3FF4,
-		0x3FB8, 0x075C, 0x08B8, 0x0040, 0x3FF4,
-		0x3FB0, 0x0738, 0x08D8, 0x0050, 0x3FF0,
-		0x3FA8, 0x0710, 0x08F8, 0x0064, 0x3FEC,
-		0x3FA0, 0x06EC, 0x0914, 0x0078, 0x3FE8,
-		0x3F98, 0x06C4, 0x0934, 0x008C, 0x3FE4,
-		0x3F90, 0x06A0, 0x094C, 0x00A4, 0x3FE0,
-		0x3F8C, 0x0678, 0x0968, 0x00B8, 0x3FDC,
-		0x3F84, 0x0650, 0x0984, 0x00D0, 0x3FD8,
-		0x3F80, 0x0628, 0x099C, 0x00E8, 0x3FD4,
-		0x3F7C, 0x0600, 0x09B8, 0x0100, 0x3FCC,
-		0x3F78, 0x05D8, 0x09D0, 0x0118, 0x3FC8,
-		0x3F74, 0x05B0, 0x09E4, 0x0134, 0x3FC4,
-		0x3F70, 0x0588, 0x09F8, 0x0150, 0x3FC0,
-		0x3F70, 0x0560, 0x0A08, 0x016C, 0x3FBC,
-		0x3F6C, 0x0538, 0x0A20, 0x0188, 0x3FB4,
-		0x3F6C, 0x0510, 0x0A30, 0x01A4, 0x3FB0,
-		0x3F6C, 0x04E8, 0x0A3C, 0x01C4, 0x3FAC,
-		0x3F6C, 0x04C0, 0x0A48, 0x01E4, 0x3FA8,
-		0x3F6C, 0x0498, 0x0A58, 0x0200, 0x3FA4,
-		0x3F6C, 0x0470, 0x0A60, 0x0224, 0x3FA0,
-		0x3F6C, 0x0448, 0x0A70, 0x0244, 0x3F98,
-		0x3F70, 0x0420, 0x0A78, 0x0264, 0x3F94,
-		0x3F70, 0x03F8, 0x0A80, 0x0288, 0x3F90,
-		0x3F74, 0x03D4, 0x0A84, 0x02A8, 0x3F8C,
-		0x3F74, 0x03AC, 0x0A8C, 0x02CC, 0x3F88,
-		0x3F78, 0x0384, 0x0A90, 0x02F0, 0x3F84,
-		0x3F7C, 0x0360, 0x0A90, 0x0314, 0x3F80,
-		0x3F7C, 0x033C, 0x0A90, 0x033C, 0x3F7C
-};
-
-//=========================================
-// <num_taps>    = 5
-// <num_phases>  = 64
-// <scale_ratio> = 1.83332 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_5tap_64p_183[165] = {
-		0x0168, 0x069C, 0x0698, 0x0164, 0x0000,
-		0x0154, 0x068C, 0x06AC, 0x0174, 0x0000,
-		0x0144, 0x0674, 0x06C0, 0x0188, 0x0000,
-		0x0138, 0x0664, 0x06D0, 0x0198, 0x3FFC,
-		0x0128, 0x0654, 0x06E0, 0x01A8, 0x3FFC,
-		0x0118, 0x0640, 0x06F0, 0x01BC, 0x3FFC,
-		0x010C, 0x0630, 0x0700, 0x01CC, 0x3FF8,
-		0x00FC, 0x061C, 0x0710, 0x01E0, 0x3FF8,
-		0x00F0, 0x060C, 0x071C, 0x01F0, 0x3FF8,
-		0x00E4, 0x05F4, 0x072C, 0x0204, 0x3FF8,
-		0x00D8, 0x05E4, 0x0738, 0x0218, 0x3FF4,
-		0x00CC, 0x05D0, 0x0744, 0x022C, 0x3FF4,
-		0x00C0, 0x05B8, 0x0754, 0x0240, 0x3FF4,
-		0x00B4, 0x05A4, 0x0760, 0x0254, 0x3FF4,
-		0x00A8, 0x0590, 0x076C, 0x0268, 0x3FF4,
-		0x009C, 0x057C, 0x0778, 0x027C, 0x3FF4,
-		0x0094, 0x0564, 0x0780, 0x0294, 0x3FF4,
-		0x0088, 0x0550, 0x0788, 0x02A8, 0x3FF8,
-		0x0080, 0x0538, 0x0794, 0x02BC, 0x3FF8,
-		0x0074, 0x0524, 0x079C, 0x02D4, 0x3FF8,
-		0x006C, 0x0510, 0x07A4, 0x02E8, 0x3FF8,
-		0x0064, 0x04F4, 0x07AC, 0x0300, 0x3FFC,
-		0x005C, 0x04E4, 0x07B0, 0x0314, 0x3FFC,
-		0x0054, 0x04C8, 0x07B8, 0x032C, 0x0000,
-		0x004C, 0x04B4, 0x07C0, 0x0340, 0x0000,
-		0x0044, 0x04A0, 0x07C4, 0x0358, 0x0000,
-		0x003C, 0x0488, 0x07C8, 0x0370, 0x0004,
-		0x0038, 0x0470, 0x07CC, 0x0384, 0x0008,
-		0x0030, 0x045C, 0x07D0, 0x039C, 0x0008,
-		0x002C, 0x0444, 0x07D0, 0x03B4, 0x000C,
-		0x0024, 0x042C, 0x07D4, 0x03CC, 0x0010,
-		0x0020, 0x0414, 0x07D4, 0x03E0, 0x0018,
-		0x001C, 0x03FC, 0x07D4, 0x03F8, 0x001C
-};
-
-//=========================================
-// <num_taps>    = 6
-// <num_phases>  = 64
-// <scale_ratio> = 0.83333 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_6tap_64p_upscale[198] = {
-		0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000,
-		0x000C, 0x3FD0, 0x0FFC, 0x0034, 0x3FF4, 0x0000,
-		0x0018, 0x3F9C, 0x0FF8, 0x006C, 0x3FE8, 0x0000,
-		0x0024, 0x3F6C, 0x0FF0, 0x00A8, 0x3FD8, 0x0000,
-		0x002C, 0x3F44, 0x0FE4, 0x00E4, 0x3FC8, 0x0000,
-		0x0038, 0x3F18, 0x0FD4, 0x0124, 0x3FB8, 0x0000,
-		0x0040, 0x3EF0, 0x0FC0, 0x0164, 0x3FA8, 0x0004,
-		0x0048, 0x3EC8, 0x0FAC, 0x01A8, 0x3F98, 0x0004,
-		0x0050, 0x3EA8, 0x0F94, 0x01EC, 0x3F84, 0x0004,
-		0x0058, 0x3E84, 0x0F74, 0x0234, 0x3F74, 0x0008,
-		0x0060, 0x3E68, 0x0F54, 0x027C, 0x3F60, 0x0008,
-		0x0064, 0x3E4C, 0x0F30, 0x02C8, 0x3F4C, 0x000C,
-		0x006C, 0x3E30, 0x0F04, 0x0314, 0x3F3C, 0x0010,
-		0x0070, 0x3E18, 0x0EDC, 0x0360, 0x3F28, 0x0014,
-		0x0074, 0x3E04, 0x0EB0, 0x03B0, 0x3F14, 0x0014,
-		0x0078, 0x3DF0, 0x0E80, 0x0400, 0x3F00, 0x0018,
-		0x0078, 0x3DE0, 0x0E4C, 0x0454, 0x3EEC, 0x001C,
-		0x007C, 0x3DD0, 0x0E14, 0x04A8, 0x3ED8, 0x0020,
-		0x007C, 0x3DC4, 0x0DDC, 0x04FC, 0x3EC4, 0x0024,
-		0x007C, 0x3DBC, 0x0DA0, 0x0550, 0x3EB0, 0x0028,
-		0x0080, 0x3DB4, 0x0D5C, 0x05A8, 0x3E9C, 0x002C,
-		0x0080, 0x3DAC, 0x0D1C, 0x0600, 0x3E88, 0x0030,
-		0x007C, 0x3DA8, 0x0CDC, 0x0658, 0x3E74, 0x0034,
-		0x007C, 0x3DA4, 0x0C94, 0x06B0, 0x3E64, 0x0038,
-		0x007C, 0x3DA4, 0x0C48, 0x0708, 0x3E50, 0x0040,
-		0x0078, 0x3DA4, 0x0C00, 0x0760, 0x3E40, 0x0044,
-		0x0078, 0x3DA8, 0x0BB4, 0x07B8, 0x3E2C, 0x0048,
-		0x0074, 0x3DAC, 0x0B68, 0x0810, 0x3E1C, 0x004C,
-		0x0070, 0x3DB4, 0x0B18, 0x0868, 0x3E0C, 0x0050,
-		0x006C, 0x3DBC, 0x0AC4, 0x08C4, 0x3DFC, 0x0054,
-		0x0068, 0x3DC4, 0x0A74, 0x0918, 0x3DF0, 0x0058,
-		0x0068, 0x3DCC, 0x0A20, 0x0970, 0x3DE0, 0x005C,
-		0x0064, 0x3DD4, 0x09C8, 0x09C8, 0x3DD4, 0x0064
-};
-
-//=========================================
-// <num_taps>    = 6
-// <num_phases>  = 64
-// <scale_ratio> = 1.16666 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_6tap_64p_116[198] = {
-		0x3F0C, 0x0240, 0x0D68, 0x0240, 0x3F0C, 0x0000,
-		0x3F18, 0x0210, 0x0D64, 0x0274, 0x3F00, 0x0000,
-		0x3F24, 0x01E0, 0x0D58, 0x02A8, 0x3EF8, 0x0004,
-		0x3F2C, 0x01B0, 0x0D58, 0x02DC, 0x3EEC, 0x0004,
-		0x3F38, 0x0180, 0x0D50, 0x0310, 0x3EE0, 0x0008,
-		0x3F44, 0x0154, 0x0D40, 0x0348, 0x3ED8, 0x0008,
-		0x3F50, 0x0128, 0x0D34, 0x037C, 0x3ECC, 0x000C,
-		0x3F5C, 0x00FC, 0x0D20, 0x03B4, 0x3EC4, 0x0010,
-		0x3F64, 0x00D4, 0x0D14, 0x03EC, 0x3EB8, 0x0010,
-		0x3F70, 0x00AC, 0x0CFC, 0x0424, 0x3EB0, 0x0014,
-		0x3F78, 0x0084, 0x0CE8, 0x0460, 0x3EA8, 0x0014,
-		0x3F84, 0x0060, 0x0CCC, 0x0498, 0x3EA0, 0x0018,
-		0x3F90, 0x003C, 0x0CB4, 0x04D0, 0x3E98, 0x0018,
-		0x3F98, 0x0018, 0x0C9C, 0x050C, 0x3E90, 0x0018,
-		0x3FA0, 0x3FFC, 0x0C78, 0x0548, 0x3E88, 0x001C,
-		0x3FAC, 0x3FDC, 0x0C54, 0x0584, 0x3E84, 0x001C,
-		0x3FB4, 0x3FBC, 0x0C3C, 0x05BC, 0x3E7C, 0x001C,
-		0x3FBC, 0x3FA0, 0x0C14, 0x05F8, 0x3E78, 0x0020,
-		0x3FC4, 0x3F84, 0x0BF0, 0x0634, 0x3E74, 0x0020,
-		0x3FCC, 0x3F68, 0x0BCC, 0x0670, 0x3E70, 0x0020,
-		0x3FD4, 0x3F50, 0x0BA4, 0x06AC, 0x3E6C, 0x0020,
-		0x3FDC, 0x3F38, 0x0B78, 0x06E8, 0x3E6C, 0x0020,
-		0x3FE0, 0x3F24, 0x0B50, 0x0724, 0x3E68, 0x0020,
-		0x3FE8, 0x3F0C, 0x0B24, 0x0760, 0x3E68, 0x0020,
-		0x3FF0, 0x3EFC, 0x0AF4, 0x0798, 0x3E68, 0x0020,
-		0x3FF4, 0x3EE8, 0x0AC8, 0x07D4, 0x3E68, 0x0020,
-		0x3FFC, 0x3ED8, 0x0A94, 0x0810, 0x3E6C, 0x001C,
-		0x0000, 0x3EC8, 0x0A64, 0x0848, 0x3E70, 0x001C,
-		0x0000, 0x3EB8, 0x0A38, 0x0880, 0x3E74, 0x001C,
-		0x0004, 0x3EAC, 0x0A04, 0x08BC, 0x3E78, 0x0018,
-		0x0008, 0x3EA4, 0x09D0, 0x08F4, 0x3E7C, 0x0014,
-		0x000C, 0x3E98, 0x0998, 0x092C, 0x3E84, 0x0014,
-		0x0010, 0x3E90, 0x0964, 0x0960, 0x3E8C, 0x0010
-};
-
-//=========================================
-// <num_taps>    = 6
-// <num_phases>  = 64
-// <scale_ratio> = 1.49999 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_6tap_64p_149[198] = {
-		0x3F14, 0x0394, 0x0AB0, 0x0394, 0x3F14, 0x0000,
-		0x3F18, 0x036C, 0x0AB0, 0x03B8, 0x3F14, 0x0000,
-		0x3F18, 0x0348, 0x0AAC, 0x03E0, 0x3F14, 0x0000,
-		0x3F1C, 0x0320, 0x0AAC, 0x0408, 0x3F10, 0x0000,
-		0x3F20, 0x02FC, 0x0AA8, 0x042C, 0x3F10, 0x0000,
-		0x3F24, 0x02D8, 0x0AA0, 0x0454, 0x3F10, 0x0000,
-		0x3F28, 0x02B4, 0x0A98, 0x047C, 0x3F10, 0x0000,
-		0x3F28, 0x0290, 0x0A90, 0x04A4, 0x3F14, 0x0000,
-		0x3F30, 0x026C, 0x0A84, 0x04CC, 0x3F14, 0x0000,
-		0x3F34, 0x024C, 0x0A7C, 0x04F4, 0x3F14, 0x3FFC,
-		0x3F38, 0x0228, 0x0A70, 0x051C, 0x3F18, 0x3FFC,
-		0x3F3C, 0x0208, 0x0A64, 0x0544, 0x3F1C, 0x3FF8,
-		0x3F40, 0x01E8, 0x0A54, 0x056C, 0x3F20, 0x3FF8,
-		0x3F44, 0x01C8, 0x0A48, 0x0594, 0x3F24, 0x3FF4,
-		0x3F4C, 0x01A8, 0x0A34, 0x05BC, 0x3F28, 0x3FF4,
-		0x3F50, 0x0188, 0x0A28, 0x05E4, 0x3F2C, 0x3FF0,
-		0x3F54, 0x016C, 0x0A10, 0x060C, 0x3F34, 0x3FF0,
-		0x3F5C, 0x014C, 0x09FC, 0x0634, 0x3F3C, 0x3FEC,
-		0x3F60, 0x0130, 0x09EC, 0x065C, 0x3F40, 0x3FE8,
-		0x3F68, 0x0114, 0x09D0, 0x0684, 0x3F48, 0x3FE8,
-		0x3F6C, 0x00F8, 0x09B8, 0x06AC, 0x3F54, 0x3FE4,
-		0x3F74, 0x00E0, 0x09A0, 0x06D0, 0x3F5C, 0x3FE0,
-		0x3F78, 0x00C4, 0x098C, 0x06F8, 0x3F64, 0x3FDC,
-		0x3F7C, 0x00AC, 0x0970, 0x0720, 0x3F70, 0x3FD8,
-		0x3F84, 0x0094, 0x0954, 0x0744, 0x3F7C, 0x3FD4,
-		0x3F88, 0x007C, 0x093C, 0x0768, 0x3F88, 0x3FD0,
-		0x3F90, 0x0064, 0x091C, 0x0790, 0x3F94, 0x3FCC,
-		0x3F94, 0x0050, 0x08FC, 0x07B4, 0x3FA4, 0x3FC8,
-		0x3F98, 0x003C, 0x08E0, 0x07D8, 0x3FB0, 0x3FC4,
-		0x3FA0, 0x0024, 0x08C0, 0x07FC, 0x3FC0, 0x3FC0,
-		0x3FA4, 0x0014, 0x08A4, 0x081C, 0x3FD0, 0x3FB8,
-		0x3FAC, 0x0000, 0x0880, 0x0840, 0x3FE0, 0x3FB4,
-		0x3FB0, 0x3FF0, 0x0860, 0x0860, 0x3FF0, 0x3FB0
-};
-
-//=========================================
-// <num_taps>    = 6
-// <num_phases>  = 64
-// <scale_ratio> = 1.83332 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_6tap_64p_183[198] = {
-		0x002C, 0x0420, 0x076C, 0x041C, 0x002C, 0x0000,
-		0x0028, 0x040C, 0x0768, 0x0430, 0x0034, 0x0000,
-		0x0020, 0x03F8, 0x0768, 0x0448, 0x003C, 0x3FFC,
-		0x0018, 0x03E4, 0x0768, 0x045C, 0x0044, 0x3FFC,
-		0x0014, 0x03D0, 0x0768, 0x0470, 0x004C, 0x3FF8,
-		0x000C, 0x03BC, 0x0764, 0x0484, 0x0058, 0x3FF8,
-		0x0008, 0x03A4, 0x0764, 0x049C, 0x0060, 0x3FF4,
-		0x0004, 0x0390, 0x0760, 0x04B0, 0x0068, 0x3FF4,
-		0x0000, 0x037C, 0x0760, 0x04C4, 0x0070, 0x3FF0,
-		0x3FFC, 0x0364, 0x075C, 0x04D8, 0x007C, 0x3FF0,
-		0x3FF8, 0x0350, 0x0758, 0x04F0, 0x0084, 0x3FEC,
-		0x3FF4, 0x033C, 0x0750, 0x0504, 0x0090, 0x3FEC,
-		0x3FF0, 0x0328, 0x074C, 0x0518, 0x009C, 0x3FE8,
-		0x3FEC, 0x0314, 0x0744, 0x052C, 0x00A8, 0x3FE8,
-		0x3FE8, 0x0304, 0x0740, 0x0540, 0x00B0, 0x3FE4,
-		0x3FE4, 0x02EC, 0x073C, 0x0554, 0x00BC, 0x3FE4,
-		0x3FE0, 0x02DC, 0x0734, 0x0568, 0x00C8, 0x3FE0,
-		0x3FE0, 0x02C4, 0x072C, 0x057C, 0x00D4, 0x3FE0,
-		0x3FDC, 0x02B4, 0x0724, 0x058C, 0x00E4, 0x3FDC,
-		0x3FDC, 0x02A0, 0x0718, 0x05A0, 0x00F0, 0x3FDC,
-		0x3FD8, 0x028C, 0x0714, 0x05B4, 0x00FC, 0x3FD8,
-		0x3FD8, 0x0278, 0x0704, 0x05C8, 0x010C, 0x3FD8,
-		0x3FD4, 0x0264, 0x0700, 0x05D8, 0x0118, 0x3FD8,
-		0x3FD4, 0x0254, 0x06F0, 0x05EC, 0x0128, 0x3FD4,
-		0x3FD0, 0x0244, 0x06E8, 0x05FC, 0x0134, 0x3FD4,
-		0x3FD0, 0x0230, 0x06DC, 0x060C, 0x0144, 0x3FD4,
-		0x3FD0, 0x021C, 0x06D0, 0x0620, 0x0154, 0x3FD0,
-		0x3FD0, 0x0208, 0x06C4, 0x0630, 0x0164, 0x3FD0,
-		0x3FD0, 0x01F8, 0x06B8, 0x0640, 0x0170, 0x3FD0,
-		0x3FCC, 0x01E8, 0x06AC, 0x0650, 0x0180, 0x3FD0,
-		0x3FCC, 0x01D8, 0x069C, 0x0660, 0x0190, 0x3FD0,
-		0x3FCC, 0x01C4, 0x068C, 0x0670, 0x01A4, 0x3FD0,
-		0x3FCC, 0x01B8, 0x0680, 0x067C, 0x01B4, 0x3FCC
-};
-
-//=========================================
-// <num_taps>    = 7
-// <num_phases>  = 64
-// <scale_ratio> = 0.83333 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_7tap_64p_upscale[231] = {
-		0x00B0, 0x3D98, 0x09BC, 0x09B8, 0x3D94, 0x00B0, 0x0000,
-		0x00AC, 0x3DA0, 0x0968, 0x0A10, 0x3D88, 0x00B4, 0x0000,
-		0x00A8, 0x3DAC, 0x0914, 0x0A60, 0x3D80, 0x00B8, 0x0000,
-		0x00A4, 0x3DB8, 0x08C0, 0x0AB4, 0x3D78, 0x00BC, 0x3FFC,
-		0x00A0, 0x3DC8, 0x0868, 0x0B00, 0x3D74, 0x00C0, 0x3FFC,
-		0x0098, 0x3DD8, 0x0818, 0x0B54, 0x3D6C, 0x00C0, 0x3FF8,
-		0x0094, 0x3DE8, 0x07C0, 0x0B9C, 0x3D6C, 0x00C4, 0x3FF8,
-		0x008C, 0x3DFC, 0x0768, 0x0BEC, 0x3D68, 0x00C4, 0x3FF8,
-		0x0088, 0x3E0C, 0x0714, 0x0C38, 0x3D68, 0x00C4, 0x3FF4,
-		0x0080, 0x3E20, 0x06BC, 0x0C80, 0x3D6C, 0x00C4, 0x3FF4,
-		0x0078, 0x3E34, 0x0668, 0x0CC4, 0x3D70, 0x00C4, 0x3FF4,
-		0x0074, 0x3E48, 0x0610, 0x0D08, 0x3D78, 0x00C4, 0x3FF0,
-		0x006C, 0x3E5C, 0x05BC, 0x0D48, 0x3D80, 0x00C4, 0x3FF0,
-		0x0068, 0x3E74, 0x0568, 0x0D84, 0x3D88, 0x00C0, 0x3FF0,
-		0x0060, 0x3E88, 0x0514, 0x0DC8, 0x3D94, 0x00BC, 0x3FEC,
-		0x0058, 0x3E9C, 0x04C0, 0x0E04, 0x3DA4, 0x00B8, 0x3FEC,
-		0x0054, 0x3EB4, 0x046C, 0x0E38, 0x3DB4, 0x00B4, 0x3FEC,
-		0x004C, 0x3ECC, 0x0418, 0x0E6C, 0x3DC8, 0x00B0, 0x3FEC,
-		0x0044, 0x3EE0, 0x03C8, 0x0EA4, 0x3DDC, 0x00A8, 0x3FEC,
-		0x0040, 0x3EF8, 0x0378, 0x0ED0, 0x3DF4, 0x00A0, 0x3FEC,
-		0x0038, 0x3F0C, 0x032C, 0x0EFC, 0x3E10, 0x0098, 0x3FEC,
-		0x0034, 0x3F24, 0x02DC, 0x0F24, 0x3E2C, 0x0090, 0x3FEC,
-		0x002C, 0x3F38, 0x0294, 0x0F4C, 0x3E48, 0x0088, 0x3FEC,
-		0x0028, 0x3F50, 0x0248, 0x0F68, 0x3E6C, 0x007C, 0x3FF0,
-		0x0020, 0x3F64, 0x0200, 0x0F88, 0x3E90, 0x0074, 0x3FF0,
-		0x001C, 0x3F7C, 0x01B8, 0x0FA4, 0x3EB4, 0x0068, 0x3FF0,
-		0x0018, 0x3F90, 0x0174, 0x0FBC, 0x3EDC, 0x0058, 0x3FF4,
-		0x0014, 0x3FA4, 0x0130, 0x0FD0, 0x3F08, 0x004C, 0x3FF4,
-		0x000C, 0x3FB8, 0x00F0, 0x0FE4, 0x3F34, 0x003C, 0x3FF8,
-		0x0008, 0x3FCC, 0x00B0, 0x0FF0, 0x3F64, 0x0030, 0x3FF8,
-		0x0004, 0x3FDC, 0x0070, 0x0FFC, 0x3F98, 0x0020, 0x3FFC,
-		0x0000, 0x3FF0, 0x0038, 0x0FFC, 0x3FCC, 0x0010, 0x0000,
-		0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000
-};
-
-//=========================================
-// <num_taps>    = 7
-// <num_phases>  = 64
-// <scale_ratio> = 1.16666 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_7tap_64p_116[231] = {
-		0x0020, 0x3E58, 0x0988, 0x0988, 0x3E58, 0x0020, 0x0000,
-		0x0024, 0x3E4C, 0x0954, 0x09C0, 0x3E64, 0x0018, 0x0000,
-		0x002C, 0x3E44, 0x091C, 0x09F4, 0x3E70, 0x0010, 0x0000,
-		0x0030, 0x3E3C, 0x08E8, 0x0A24, 0x3E80, 0x0008, 0x0000,
-		0x0034, 0x3E34, 0x08AC, 0x0A5C, 0x3E90, 0x0000, 0x0000,
-		0x003C, 0x3E30, 0x0870, 0x0A84, 0x3EA0, 0x3FFC, 0x0004,
-		0x0040, 0x3E28, 0x0838, 0x0AB4, 0x3EB4, 0x3FF4, 0x0004,
-		0x0044, 0x3E24, 0x07FC, 0x0AE4, 0x3EC8, 0x3FEC, 0x0004,
-		0x0048, 0x3E24, 0x07C4, 0x0B08, 0x3EDC, 0x3FE4, 0x0008,
-		0x0048, 0x3E20, 0x0788, 0x0B3C, 0x3EF4, 0x3FD8, 0x0008,
-		0x004C, 0x3E20, 0x074C, 0x0B60, 0x3F0C, 0x3FD0, 0x000C,
-		0x0050, 0x3E20, 0x0710, 0x0B8C, 0x3F24, 0x3FC4, 0x000C,
-		0x0050, 0x3E20, 0x06D4, 0x0BB0, 0x3F40, 0x3FBC, 0x0010,
-		0x0054, 0x3E24, 0x0698, 0x0BD4, 0x3F5C, 0x3FB0, 0x0010,
-		0x0054, 0x3E24, 0x065C, 0x0BFC, 0x3F78, 0x3FA4, 0x0014,
-		0x0054, 0x3E28, 0x0624, 0x0C1C, 0x3F98, 0x3F98, 0x0014,
-		0x0058, 0x3E2C, 0x05E4, 0x0C3C, 0x3FB8, 0x3F8C, 0x0018,
-		0x0058, 0x3E34, 0x05A8, 0x0C58, 0x3FD8, 0x3F80, 0x001C,
-		0x0058, 0x3E38, 0x0570, 0x0C78, 0x3FF8, 0x3F74, 0x001C,
-		0x0058, 0x3E40, 0x0534, 0x0C94, 0x0018, 0x3F68, 0x0020,
-		0x0058, 0x3E48, 0x04F4, 0x0CAC, 0x0040, 0x3F5C, 0x0024,
-		0x0058, 0x3E50, 0x04BC, 0x0CC4, 0x0064, 0x3F50, 0x0024,
-		0x0054, 0x3E58, 0x0484, 0x0CD8, 0x008C, 0x3F44, 0x0028,
-		0x0054, 0x3E60, 0x0448, 0x0CEC, 0x00B4, 0x3F38, 0x002C,
-		0x0054, 0x3E68, 0x0410, 0x0CFC, 0x00E0, 0x3F28, 0x0030,
-		0x0054, 0x3E74, 0x03D4, 0x0D0C, 0x010C, 0x3F1C, 0x0030,
-		0x0050, 0x3E7C, 0x03A0, 0x0D18, 0x0138, 0x3F10, 0x0034,
-		0x0050, 0x3E88, 0x0364, 0x0D24, 0x0164, 0x3F04, 0x0038,
-		0x004C, 0x3E94, 0x0330, 0x0D30, 0x0194, 0x3EF4, 0x0038,
-		0x004C, 0x3EA0, 0x02F8, 0x0D34, 0x01C4, 0x3EE8, 0x003C,
-		0x0048, 0x3EAC, 0x02C0, 0x0D3C, 0x01F4, 0x3EDC, 0x0040,
-		0x0048, 0x3EB8, 0x0290, 0x0D3C, 0x0224, 0x3ED0, 0x0040,
-		0x0044, 0x3EC4, 0x0258, 0x0D40, 0x0258, 0x3EC4, 0x0044
-};
-
-//=========================================
-// <num_taps>    = 7
-// <num_phases>  = 64
-// <scale_ratio> = 1.49999 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_7tap_64p_149[231] = {
-		0x3F68, 0x3FEC, 0x08A8, 0x08AC, 0x3FF0, 0x3F68, 0x0000,
-		0x3F70, 0x3FDC, 0x0888, 0x08CC, 0x0000, 0x3F60, 0x0000,
-		0x3F74, 0x3FC8, 0x0868, 0x08F0, 0x0014, 0x3F58, 0x0000,
-		0x3F7C, 0x3FB4, 0x0844, 0x0908, 0x002C, 0x3F54, 0x0004,
-		0x3F84, 0x3FA4, 0x0820, 0x0924, 0x0044, 0x3F4C, 0x0004,
-		0x3F88, 0x3F90, 0x0800, 0x0944, 0x005C, 0x3F44, 0x0004,
-		0x3F90, 0x3F80, 0x07D8, 0x095C, 0x0074, 0x3F40, 0x0008,
-		0x3F98, 0x3F70, 0x07B0, 0x097C, 0x008C, 0x3F38, 0x0008,
-		0x3F9C, 0x3F60, 0x0790, 0x0994, 0x00A8, 0x3F30, 0x0008,
-		0x3FA4, 0x3F54, 0x0764, 0x09B0, 0x00C4, 0x3F28, 0x0008,
-		0x3FA8, 0x3F48, 0x0740, 0x09C4, 0x00DC, 0x3F24, 0x000C,
-		0x3FB0, 0x3F38, 0x0718, 0x09DC, 0x00FC, 0x3F1C, 0x000C,
-		0x3FB4, 0x3F2C, 0x06F0, 0x09F4, 0x0118, 0x3F18, 0x000C,
-		0x3FBC, 0x3F24, 0x06C8, 0x0A08, 0x0134, 0x3F10, 0x000C,
-		0x3FC0, 0x3F18, 0x06A0, 0x0A1C, 0x0154, 0x3F08, 0x0010,
-		0x3FC8, 0x3F10, 0x0678, 0x0A2C, 0x0170, 0x3F04, 0x0010,
-		0x3FCC, 0x3F04, 0x0650, 0x0A40, 0x0190, 0x3F00, 0x0010,
-		0x3FD0, 0x3EFC, 0x0628, 0x0A54, 0x01B0, 0x3EF8, 0x0010,
-		0x3FD4, 0x3EF4, 0x0600, 0x0A64, 0x01D0, 0x3EF4, 0x0010,
-		0x3FDC, 0x3EEC, 0x05D8, 0x0A6C, 0x01F4, 0x3EF0, 0x0010,
-		0x3FE0, 0x3EE8, 0x05B0, 0x0A7C, 0x0214, 0x3EE8, 0x0010,
-		0x3FE4, 0x3EE0, 0x0588, 0x0A88, 0x0238, 0x3EE4, 0x0010,
-		0x3FE8, 0x3EDC, 0x055C, 0x0A98, 0x0258, 0x3EE0, 0x0010,
-		0x3FEC, 0x3ED8, 0x0534, 0x0AA0, 0x027C, 0x3EDC, 0x0010,
-		0x3FF0, 0x3ED4, 0x050C, 0x0AAC, 0x02A0, 0x3ED8, 0x000C,
-		0x3FF4, 0x3ED0, 0x04E4, 0x0AB4, 0x02C4, 0x3ED4, 0x000C,
-		0x3FF4, 0x3ECC, 0x04C0, 0x0ABC, 0x02E8, 0x3ED0, 0x000C,
-		0x3FF8, 0x3ECC, 0x0494, 0x0AC0, 0x030C, 0x3ED0, 0x000C,
-		0x3FFC, 0x3EC8, 0x046C, 0x0AC8, 0x0334, 0x3ECC, 0x0008,
-		0x0000, 0x3EC8, 0x0444, 0x0AC8, 0x0358, 0x3ECC, 0x0008,
-		0x0000, 0x3EC8, 0x041C, 0x0ACC, 0x0380, 0x3EC8, 0x0008,
-		0x0000, 0x3EC8, 0x03F4, 0x0AD0, 0x03A8, 0x3EC8, 0x0004,
-		0x0004, 0x3EC8, 0x03CC, 0x0AD0, 0x03CC, 0x3EC8, 0x0004
-};
-
-//=========================================
-// <num_taps>    = 7
-// <num_phases>  = 64
-// <scale_ratio> = 1.83332 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_7tap_64p_183[231] = {
-		0x3FA4, 0x01E8, 0x0674, 0x0674, 0x01E8, 0x3FA4, 0x0000,
-		0x3FA4, 0x01D4, 0x0668, 0x0684, 0x01F8, 0x3FA4, 0x0000,
-		0x3FA4, 0x01C4, 0x0658, 0x0690, 0x0208, 0x3FA8, 0x0000,
-		0x3FA0, 0x01B4, 0x064C, 0x06A0, 0x021C, 0x3FA8, 0x3FFC,
-		0x3FA0, 0x01A4, 0x063C, 0x06AC, 0x022C, 0x3FAC, 0x3FFC,
-		0x3FA0, 0x0194, 0x0630, 0x06B4, 0x0240, 0x3FAC, 0x3FFC,
-		0x3FA0, 0x0184, 0x0620, 0x06C4, 0x0250, 0x3FB0, 0x3FF8,
-		0x3FA0, 0x0174, 0x0614, 0x06CC, 0x0264, 0x3FB0, 0x3FF8,
-		0x3FA0, 0x0164, 0x0604, 0x06D8, 0x0278, 0x3FB4, 0x3FF4,
-		0x3FA0, 0x0154, 0x05F4, 0x06E4, 0x0288, 0x3FB8, 0x3FF4,
-		0x3FA0, 0x0148, 0x05E4, 0x06EC, 0x029C, 0x3FBC, 0x3FF0,
-		0x3FA0, 0x0138, 0x05D4, 0x06F4, 0x02B0, 0x3FC0, 0x3FF0,
-		0x3FA0, 0x0128, 0x05C4, 0x0704, 0x02C4, 0x3FC0, 0x3FEC,
-		0x3FA0, 0x011C, 0x05B4, 0x0708, 0x02D8, 0x3FC4, 0x3FEC,
-		0x3FA4, 0x010C, 0x05A4, 0x0714, 0x02E8, 0x3FC8, 0x3FE8,
-		0x3FA4, 0x0100, 0x0590, 0x0718, 0x02FC, 0x3FD0, 0x3FE8,
-		0x3FA4, 0x00F0, 0x0580, 0x0724, 0x0310, 0x3FD4, 0x3FE4,
-		0x3FA4, 0x00E4, 0x056C, 0x072C, 0x0324, 0x3FD8, 0x3FE4,
-		0x3FA8, 0x00D8, 0x055C, 0x0730, 0x0338, 0x3FDC, 0x3FE0,
-		0x3FA8, 0x00CC, 0x0548, 0x0738, 0x034C, 0x3FE4, 0x3FDC,
-		0x3FA8, 0x00BC, 0x0538, 0x0740, 0x0360, 0x3FE8, 0x3FDC,
-		0x3FAC, 0x00B0, 0x0528, 0x0744, 0x0374, 0x3FEC, 0x3FD8,
-		0x3FAC, 0x00A4, 0x0514, 0x0748, 0x0388, 0x3FF4, 0x3FD8,
-		0x3FB0, 0x0098, 0x0500, 0x074C, 0x039C, 0x3FFC, 0x3FD4,
-		0x3FB0, 0x0090, 0x04EC, 0x0750, 0x03B0, 0x0000, 0x3FD4,
-		0x3FB0, 0x0084, 0x04DC, 0x0758, 0x03C4, 0x0004, 0x3FD0,
-		0x3FB4, 0x0078, 0x04CC, 0x0758, 0x03D8, 0x000C, 0x3FCC,
-		0x3FB4, 0x006C, 0x04B8, 0x075C, 0x03EC, 0x0014, 0x3FCC,
-		0x3FB8, 0x0064, 0x04A0, 0x0760, 0x0400, 0x001C, 0x3FC8,
-		0x3FB8, 0x0058, 0x0490, 0x0760, 0x0414, 0x0024, 0x3FC8,
-		0x3FBC, 0x0050, 0x047C, 0x0760, 0x0428, 0x002C, 0x3FC4,
-		0x3FBC, 0x0048, 0x0464, 0x0764, 0x043C, 0x0034, 0x3FC4,
-		0x3FC0, 0x003C, 0x0454, 0x0764, 0x0450, 0x003C, 0x3FC0
-};
-
-//=========================================
-// <num_taps>    = 8
-// <num_phases>  = 64
-// <scale_ratio> = 0.83333 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_8tap_64p_upscale[264] = {
-		0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000,
-		0x3FFC, 0x0014, 0x3FC8, 0x1000, 0x0038, 0x3FEC, 0x0004, 0x0000,
-		0x3FF4, 0x0024, 0x3F94, 0x0FFC, 0x0074, 0x3FD8, 0x000C, 0x0000,
-		0x3FF0, 0x0038, 0x3F60, 0x0FEC, 0x00B4, 0x3FC4, 0x0014, 0x0000,
-		0x3FEC, 0x004C, 0x3F2C, 0x0FE4, 0x00F4, 0x3FAC, 0x0018, 0x0000,
-		0x3FE4, 0x005C, 0x3F00, 0x0FD4, 0x0138, 0x3F94, 0x0020, 0x0000,
-		0x3FE0, 0x006C, 0x3ED0, 0x0FC4, 0x017C, 0x3F7C, 0x0028, 0x0000,
-		0x3FDC, 0x007C, 0x3EA8, 0x0FA4, 0x01C4, 0x3F68, 0x0030, 0x0000,
-		0x3FD8, 0x0088, 0x3E80, 0x0F90, 0x020C, 0x3F50, 0x0038, 0x3FFC,
-		0x3FD4, 0x0098, 0x3E58, 0x0F70, 0x0258, 0x3F38, 0x0040, 0x3FFC,
-		0x3FD0, 0x00A4, 0x3E34, 0x0F54, 0x02A0, 0x3F1C, 0x004C, 0x3FFC,
-		0x3FD0, 0x00B0, 0x3E14, 0x0F28, 0x02F0, 0x3F04, 0x0054, 0x3FFC,
-		0x3FCC, 0x00BC, 0x3DF4, 0x0F08, 0x033C, 0x3EEC, 0x005C, 0x3FF8,
-		0x3FC8, 0x00C8, 0x3DD8, 0x0EDC, 0x038C, 0x3ED4, 0x0064, 0x3FF8,
-		0x3FC8, 0x00D0, 0x3DC0, 0x0EAC, 0x03E0, 0x3EBC, 0x006C, 0x3FF4,
-		0x3FC4, 0x00D8, 0x3DA8, 0x0E7C, 0x0430, 0x3EA4, 0x0078, 0x3FF4,
-		0x3FC4, 0x00E0, 0x3D94, 0x0E48, 0x0484, 0x3E8C, 0x0080, 0x3FF0,
-		0x3FC4, 0x00E8, 0x3D80, 0x0E10, 0x04D8, 0x3E74, 0x0088, 0x3FF0,
-		0x3FC4, 0x00F0, 0x3D70, 0x0DD8, 0x052C, 0x3E5C, 0x0090, 0x3FEC,
-		0x3FC0, 0x00F4, 0x3D60, 0x0DA0, 0x0584, 0x3E44, 0x0098, 0x3FEC,
-		0x3FC0, 0x00F8, 0x3D54, 0x0D68, 0x05D8, 0x3E2C, 0x00A0, 0x3FE8,
-		0x3FC0, 0x00FC, 0x3D48, 0x0D20, 0x0630, 0x3E18, 0x00AC, 0x3FE8,
-		0x3FC0, 0x0100, 0x3D40, 0x0CE0, 0x0688, 0x3E00, 0x00B4, 0x3FE4,
-		0x3FC4, 0x0100, 0x3D3C, 0x0C98, 0x06DC, 0x3DEC, 0x00BC, 0x3FE4,
-		0x3FC4, 0x0100, 0x3D38, 0x0C58, 0x0734, 0x3DD8, 0x00C0, 0x3FE0,
-		0x3FC4, 0x0104, 0x3D38, 0x0C0C, 0x078C, 0x3DC4, 0x00C8, 0x3FDC,
-		0x3FC4, 0x0100, 0x3D38, 0x0BC4, 0x07E4, 0x3DB0, 0x00D0, 0x3FDC,
-		0x3FC4, 0x0100, 0x3D38, 0x0B78, 0x083C, 0x3DA0, 0x00D8, 0x3FD8,
-		0x3FC8, 0x0100, 0x3D3C, 0x0B28, 0x0890, 0x3D90, 0x00DC, 0x3FD8,
-		0x3FC8, 0x00FC, 0x3D40, 0x0ADC, 0x08E8, 0x3D80, 0x00E4, 0x3FD4,
-		0x3FCC, 0x00FC, 0x3D48, 0x0A84, 0x093C, 0x3D74, 0x00E8, 0x3FD4,
-		0x3FCC, 0x00F8, 0x3D50, 0x0A38, 0x0990, 0x3D64, 0x00F0, 0x3FD0,
-		0x3FD0, 0x00F4, 0x3D58, 0x09E0, 0x09E4, 0x3D5C, 0x00F4, 0x3FD0
-};
-
-//=========================================
-// <num_taps>    = 8
-// <num_phases>  = 64
-// <scale_ratio> = 1.16666 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_8tap_64p_116[264] = {
-		0x0080, 0x3E90, 0x0268, 0x0D14, 0x0264, 0x3E90, 0x0080, 0x0000,
-		0x007C, 0x3E9C, 0x0238, 0x0D14, 0x0298, 0x3E84, 0x0080, 0x0000,
-		0x0078, 0x3EAC, 0x0200, 0x0D10, 0x02D0, 0x3E78, 0x0084, 0x0000,
-		0x0078, 0x3EB8, 0x01D0, 0x0D0C, 0x0304, 0x3E6C, 0x0084, 0x0000,
-		0x0074, 0x3EC8, 0x01A0, 0x0D00, 0x033C, 0x3E60, 0x0088, 0x0000,
-		0x0070, 0x3ED4, 0x0170, 0x0D00, 0x0374, 0x3E54, 0x0088, 0x3FFC,
-		0x006C, 0x3EE4, 0x0140, 0x0CF8, 0x03AC, 0x3E48, 0x0088, 0x3FFC,
-		0x006C, 0x3EF0, 0x0114, 0x0CE8, 0x03E4, 0x3E3C, 0x008C, 0x3FFC,
-		0x0068, 0x3F00, 0x00E8, 0x0CD8, 0x041C, 0x3E34, 0x008C, 0x3FFC,
-		0x0064, 0x3F10, 0x00BC, 0x0CCC, 0x0454, 0x3E28, 0x008C, 0x3FFC,
-		0x0060, 0x3F1C, 0x0090, 0x0CBC, 0x0490, 0x3E20, 0x008C, 0x3FFC,
-		0x005C, 0x3F2C, 0x0068, 0x0CA4, 0x04CC, 0x3E18, 0x008C, 0x3FFC,
-		0x0058, 0x3F38, 0x0040, 0x0C94, 0x0504, 0x3E10, 0x008C, 0x3FFC,
-		0x0054, 0x3F48, 0x001C, 0x0C7C, 0x0540, 0x3E08, 0x0088, 0x3FFC,
-		0x0050, 0x3F54, 0x3FF8, 0x0C60, 0x057C, 0x3E04, 0x0088, 0x3FFC,
-		0x004C, 0x3F64, 0x3FD4, 0x0C44, 0x05B8, 0x3DFC, 0x0088, 0x3FFC,
-		0x0048, 0x3F70, 0x3FB4, 0x0C28, 0x05F4, 0x3DF8, 0x0084, 0x3FFC,
-		0x0044, 0x3F80, 0x3F90, 0x0C0C, 0x0630, 0x3DF4, 0x0080, 0x3FFC,
-		0x0040, 0x3F8C, 0x3F70, 0x0BE8, 0x066C, 0x3DF4, 0x0080, 0x3FFC,
-		0x003C, 0x3F9C, 0x3F50, 0x0BC8, 0x06A8, 0x3DF0, 0x007C, 0x3FFC,
-		0x0038, 0x3FA8, 0x3F34, 0x0BA0, 0x06E4, 0x3DF0, 0x0078, 0x0000,
-		0x0034, 0x3FB4, 0x3F18, 0x0B80, 0x071C, 0x3DF0, 0x0074, 0x0000,
-		0x0030, 0x3FC0, 0x3EFC, 0x0B5C, 0x0758, 0x3DF0, 0x0070, 0x0000,
-		0x002C, 0x3FCC, 0x3EE4, 0x0B34, 0x0794, 0x3DF4, 0x0068, 0x0000,
-		0x002C, 0x3FDC, 0x3ECC, 0x0B08, 0x07CC, 0x3DF4, 0x0064, 0x0000,
-		0x0028, 0x3FE4, 0x3EB4, 0x0AE0, 0x0808, 0x3DF8, 0x0060, 0x0000,
-		0x0024, 0x3FF0, 0x3EA0, 0x0AB0, 0x0840, 0x3E00, 0x0058, 0x0004,
-		0x0020, 0x3FFC, 0x3E90, 0x0A84, 0x0878, 0x3E04, 0x0050, 0x0004,
-		0x001C, 0x0004, 0x3E7C, 0x0A54, 0x08B0, 0x3E0C, 0x004C, 0x0008,
-		0x0018, 0x000C, 0x3E68, 0x0A28, 0x08E8, 0x3E18, 0x0044, 0x0008,
-		0x0018, 0x0018, 0x3E54, 0x09F4, 0x0920, 0x3E20, 0x003C, 0x000C,
-		0x0014, 0x0020, 0x3E48, 0x09C0, 0x0954, 0x3E2C, 0x0034, 0x0010,
-		0x0010, 0x002C, 0x3E3C, 0x098C, 0x0988, 0x3E38, 0x002C, 0x0010
-};
-
-//=========================================
-// <num_taps>    = 8
-// <num_phases>  = 64
-// <scale_ratio> = 1.49999 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_8tap_64p_149[264] = {
-		0x0008, 0x3E8C, 0x03F8, 0x0AE8, 0x03F8, 0x3E8C, 0x0008, 0x0000,
-		0x000C, 0x3E8C, 0x03D0, 0x0AE8, 0x0420, 0x3E90, 0x0000, 0x0000,
-		0x000C, 0x3E8C, 0x03AC, 0x0AE8, 0x0444, 0x3E90, 0x0000, 0x0000,
-		0x0010, 0x3E90, 0x0384, 0x0AE0, 0x046C, 0x3E94, 0x3FFC, 0x0000,
-		0x0014, 0x3E90, 0x035C, 0x0ADC, 0x0494, 0x3E94, 0x3FF8, 0x0004,
-		0x0018, 0x3E90, 0x0334, 0x0AD8, 0x04BC, 0x3E98, 0x3FF4, 0x0004,
-		0x001C, 0x3E94, 0x0310, 0x0AD0, 0x04E4, 0x3E9C, 0x3FEC, 0x0004,
-		0x0020, 0x3E98, 0x02E8, 0x0AC4, 0x050C, 0x3EA0, 0x3FE8, 0x0008,
-		0x0020, 0x3E98, 0x02C4, 0x0AC0, 0x0534, 0x3EA4, 0x3FE4, 0x0008,
-		0x0024, 0x3E9C, 0x02A0, 0x0AB4, 0x055C, 0x3EAC, 0x3FDC, 0x0008,
-		0x0024, 0x3EA0, 0x027C, 0x0AA8, 0x0584, 0x3EB0, 0x3FD8, 0x000C,
-		0x0028, 0x3EA4, 0x0258, 0x0A9C, 0x05AC, 0x3EB8, 0x3FD0, 0x000C,
-		0x0028, 0x3EA8, 0x0234, 0x0A90, 0x05D4, 0x3EC0, 0x3FC8, 0x0010,
-		0x002C, 0x3EAC, 0x0210, 0x0A80, 0x05FC, 0x3EC8, 0x3FC4, 0x0010,
-		0x002C, 0x3EB4, 0x01F0, 0x0A70, 0x0624, 0x3ED0, 0x3FBC, 0x0010,
-		0x002C, 0x3EB8, 0x01CC, 0x0A60, 0x064C, 0x3EDC, 0x3FB4, 0x0014,
-		0x0030, 0x3EBC, 0x01A8, 0x0A50, 0x0674, 0x3EE4, 0x3FB0, 0x0014,
-		0x0030, 0x3EC4, 0x0188, 0x0A38, 0x069C, 0x3EF0, 0x3FA8, 0x0018,
-		0x0030, 0x3ECC, 0x0168, 0x0A28, 0x06C0, 0x3EFC, 0x3FA0, 0x0018,
-		0x0030, 0x3ED0, 0x0148, 0x0A14, 0x06E8, 0x3F08, 0x3F98, 0x001C,
-		0x0030, 0x3ED8, 0x012C, 0x0A00, 0x070C, 0x3F14, 0x3F90, 0x001C,
-		0x0034, 0x3EE0, 0x0108, 0x09E4, 0x0734, 0x3F24, 0x3F8C, 0x001C,
-		0x0034, 0x3EE4, 0x00EC, 0x09CC, 0x0758, 0x3F34, 0x3F84, 0x0020,
-		0x0034, 0x3EEC, 0x00D0, 0x09B8, 0x077C, 0x3F40, 0x3F7C, 0x0020,
-		0x0034, 0x3EF4, 0x00B4, 0x0998, 0x07A4, 0x3F50, 0x3F74, 0x0024,
-		0x0030, 0x3EFC, 0x0098, 0x0980, 0x07C8, 0x3F64, 0x3F6C, 0x0024,
-		0x0030, 0x3F04, 0x0080, 0x0968, 0x07E8, 0x3F74, 0x3F64, 0x0024,
-		0x0030, 0x3F0C, 0x0060, 0x094C, 0x080C, 0x3F88, 0x3F5C, 0x0028,
-		0x0030, 0x3F14, 0x0048, 0x0930, 0x0830, 0x3F98, 0x3F54, 0x0028,
-		0x0030, 0x3F1C, 0x0030, 0x0914, 0x0850, 0x3FAC, 0x3F4C, 0x0028,
-		0x0030, 0x3F24, 0x0018, 0x08F0, 0x0874, 0x3FC0, 0x3F44, 0x002C,
-		0x002C, 0x3F2C, 0x0000, 0x08D4, 0x0894, 0x3FD8, 0x3F3C, 0x002C,
-		0x002C, 0x3F34, 0x3FEC, 0x08B4, 0x08B4, 0x3FEC, 0x3F34, 0x002C
-};
-
-//=========================================
-// <num_taps>    = 8
-// <num_phases>  = 64
-// <scale_ratio> = 1.83332 (input/output)
-// <sharpness>   = 0
-// <CoefType>    = ModifiedLanczos
-// <CoefQuant>   = 1.10
-// <CoefOut>     = 1.12
-//=========================================
-static const uint16_t filter_8tap_64p_183[264] = {
-		0x3F88, 0x0048, 0x047C, 0x0768, 0x047C, 0x0048, 0x3F88, 0x0000,
-		0x3F88, 0x003C, 0x0468, 0x076C, 0x0490, 0x0054, 0x3F84, 0x0000,
-		0x3F8C, 0x0034, 0x0454, 0x0768, 0x04A4, 0x005C, 0x3F84, 0x0000,
-		0x3F8C, 0x0028, 0x0444, 0x076C, 0x04B4, 0x0068, 0x3F80, 0x0000,
-		0x3F90, 0x0020, 0x042C, 0x0768, 0x04C8, 0x0074, 0x3F80, 0x0000,
-		0x3F90, 0x0018, 0x041C, 0x0764, 0x04DC, 0x0080, 0x3F7C, 0x0000,
-		0x3F94, 0x0010, 0x0408, 0x075C, 0x04F0, 0x008C, 0x3F7C, 0x0000,
-		0x3F94, 0x0004, 0x03F8, 0x0760, 0x0500, 0x0098, 0x3F7C, 0x3FFC,
-		0x3F98, 0x0000, 0x03E0, 0x075C, 0x0514, 0x00A4, 0x3F78, 0x3FFC,
-		0x3F9C, 0x3FF8, 0x03CC, 0x0754, 0x0528, 0x00B0, 0x3F78, 0x3FFC,
-		0x3F9C, 0x3FF0, 0x03B8, 0x0754, 0x0538, 0x00BC, 0x3F78, 0x3FFC,
-		0x3FA0, 0x3FE8, 0x03A4, 0x0750, 0x054C, 0x00CC, 0x3F74, 0x3FF8,
-		0x3FA4, 0x3FE0, 0x0390, 0x074C, 0x055C, 0x00D8, 0x3F74, 0x3FF8,
-		0x3FA4, 0x3FDC, 0x037C, 0x0744, 0x0570, 0x00E4, 0x3F74, 0x3FF8,
-		0x3FA8, 0x3FD4, 0x0368, 0x0740, 0x0580, 0x00F4, 0x3F74, 0x3FF4,
-		0x3FA8, 0x3FCC, 0x0354, 0x073C, 0x0590, 0x0104, 0x3F74, 0x3FF4,
-		0x3FAC, 0x3FC8, 0x0340, 0x0730, 0x05A4, 0x0110, 0x3F74, 0x3FF4,
-		0x3FB0, 0x3FC0, 0x0330, 0x0728, 0x05B4, 0x0120, 0x3F74, 0x3FF0,
-		0x3FB0, 0x3FBC, 0x031C, 0x0724, 0x05C4, 0x0130, 0x3F70, 0x3FF0,
-		0x3FB4, 0x3FB4, 0x0308, 0x0720, 0x05D4, 0x013C, 0x3F70, 0x3FF0,
-		0x3FB8, 0x3FB0, 0x02F4, 0x0714, 0x05E4, 0x014C, 0x3F74, 0x3FEC,
-		0x3FB8, 0x3FAC, 0x02E0, 0x0708, 0x05F8, 0x015C, 0x3F74, 0x3FEC,
-		0x3FBC, 0x3FA8, 0x02CC, 0x0704, 0x0604, 0x016C, 0x3F74, 0x3FE8,
-		0x3FC0, 0x3FA0, 0x02BC, 0x06F8, 0x0614, 0x017C, 0x3F74, 0x3FE8,
-		0x3FC0, 0x3F9C, 0x02A8, 0x06F4, 0x0624, 0x018C, 0x3F74, 0x3FE4,
-		0x3FC4, 0x3F98, 0x0294, 0x06E8, 0x0634, 0x019C, 0x3F74, 0x3FE4,
-		0x3FC8, 0x3F94, 0x0284, 0x06D8, 0x0644, 0x01AC, 0x3F78, 0x3FE0,
-		0x3FC8, 0x3F90, 0x0270, 0x06D4, 0x0650, 0x01BC, 0x3F78, 0x3FE0,
-		0x3FCC, 0x3F8C, 0x025C, 0x06C8, 0x0660, 0x01D0, 0x3F78, 0x3FDC,
-		0x3FCC, 0x3F8C, 0x024C, 0x06B8, 0x066C, 0x01E0, 0x3F7C, 0x3FDC,
-		0x3FD0, 0x3F88, 0x0238, 0x06B0, 0x067C, 0x01F0, 0x3F7C, 0x3FD8,
-		0x3FD4, 0x3F84, 0x0228, 0x069C, 0x0688, 0x0204, 0x3F80, 0x3FD8,
-		0x3FD4, 0x3F84, 0x0214, 0x0694, 0x0694, 0x0214, 0x3F84, 0x3FD4
-};
-
-const uint16_t *spl_get_filter_3tap_16p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_one.value)
-		return filter_3tap_16p_upscale;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
-		return filter_3tap_16p_116;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
-		return filter_3tap_16p_149;
-	else
-		return filter_3tap_16p_183;
-}
-
-const uint16_t *spl_get_filter_3tap_64p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_one.value)
-		return filter_3tap_64p_upscale;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
-		return filter_3tap_64p_116;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
-		return filter_3tap_64p_149;
-	else
-		return filter_3tap_64p_183;
-}
-
-const uint16_t *spl_get_filter_4tap_16p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_one.value)
-		return filter_4tap_16p_upscale;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
-		return filter_4tap_16p_116;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
-		return filter_4tap_16p_149;
-	else
-		return filter_4tap_16p_183;
-}
-
-const uint16_t *spl_get_filter_4tap_64p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_one.value)
-		return filter_4tap_64p_upscale;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
-		return filter_4tap_64p_116;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
-		return filter_4tap_64p_149;
-	else
-		return filter_4tap_64p_183;
-}
-
-const uint16_t *spl_get_filter_5tap_64p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_one.value)
-		return filter_5tap_64p_upscale;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
-		return filter_5tap_64p_116;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
-		return filter_5tap_64p_149;
-	else
-		return filter_5tap_64p_183;
-}
-
-const uint16_t *spl_get_filter_6tap_64p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_one.value)
-		return filter_6tap_64p_upscale;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
-		return filter_6tap_64p_116;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
-		return filter_6tap_64p_149;
-	else
-		return filter_6tap_64p_183;
-}
-
-const uint16_t *spl_get_filter_7tap_64p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_one.value)
-		return filter_7tap_64p_upscale;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
-		return filter_7tap_64p_116;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
-		return filter_7tap_64p_149;
-	else
-		return filter_7tap_64p_183;
-}
-
-const uint16_t *spl_get_filter_8tap_64p(struct spl_fixed31_32 ratio)
-{
-	if (ratio.value < spl_fixpt_one.value)
-		return filter_8tap_64p_upscale;
-	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
-		return filter_8tap_64p_116;
-	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
-		return filter_8tap_64p_149;
-	else
-		return filter_8tap_64p_183;
-}
-
-const uint16_t *spl_get_filter_2tap_16p(void)
-{
-	return filter_2tap_16p;
-}
-
-const uint16_t *spl_get_filter_2tap_64p(void)
-{
-	return filter_2tap_64p;
-}
-
-const uint16_t *spl_dscl_get_filter_coeffs_64p(int taps, struct spl_fixed31_32 ratio)
-{
-	if (taps == 8)
-		return spl_get_filter_8tap_64p(ratio);
-	else if (taps == 7)
-		return spl_get_filter_7tap_64p(ratio);
-	else if (taps == 6)
-		return spl_get_filter_6tap_64p(ratio);
-	else if (taps == 5)
-		return spl_get_filter_5tap_64p(ratio);
-	else if (taps == 4)
-		return spl_get_filter_4tap_64p(ratio);
-	else if (taps == 3)
-		return spl_get_filter_3tap_64p(ratio);
-	else if (taps == 2)
-		return spl_get_filter_2tap_64p();
-	else if (taps == 1)
-		return NULL;
-	else {
-		/* should never happen, bug */
-		SPL_BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-}
-
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_filters.h b/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_filters.h
deleted file mode 100644
index 48202bc4f81e..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_scl_filters.h
+++ /dev/null
@@ -1,22 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#ifndef __DC_SPL_SCL_FILTERS_H__
-#define __DC_SPL_SCL_FILTERS_H__
-
-#include "dc_spl_types.h"
-
-const uint16_t *spl_get_filter_3tap_16p(struct spl_fixed31_32 ratio);
-const uint16_t *spl_get_filter_3tap_64p(struct spl_fixed31_32 ratio);
-const uint16_t *spl_get_filter_4tap_16p(struct spl_fixed31_32 ratio);
-const uint16_t *spl_get_filter_4tap_64p(struct spl_fixed31_32 ratio);
-const uint16_t *spl_get_filter_5tap_64p(struct spl_fixed31_32 ratio);
-const uint16_t *spl_get_filter_6tap_64p(struct spl_fixed31_32 ratio);
-const uint16_t *spl_get_filter_7tap_64p(struct spl_fixed31_32 ratio);
-const uint16_t *spl_get_filter_8tap_64p(struct spl_fixed31_32 ratio);
-const uint16_t *spl_get_filter_2tap_16p(void);
-const uint16_t *spl_get_filter_2tap_64p(void);
-const uint16_t *spl_dscl_get_filter_coeffs_64p(int taps, struct spl_fixed31_32 ratio);
-
-#endif /* __DC_SPL_SCL_FILTERS_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_types.h b/drivers/gpu/drm/amd/display/dc/spl/dc_spl_types.h
deleted file mode 100644
index 467af9dd90de..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/dc_spl_types.h
+++ /dev/null
@@ -1,543 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#ifndef __DC_SPL_TYPES_H__
-#define __DC_SPL_TYPES_H__
-
-#include "spl_debug.h"
-#include "spl_os_types.h"   // swap
-#include "spl_fixpt31_32.h"	// fixed31_32 and related functions
-#include "spl_custom_float.h" // custom float and related functions
-
-struct spl_size {
-	uint32_t width;
-	uint32_t height;
-};
-struct spl_rect	{
-	int x;
-	int y;
-	int width;
-	int height;
-};
-
-struct spl_ratios {
-	struct spl_fixed31_32 horz;
-	struct spl_fixed31_32 vert;
-	struct spl_fixed31_32 horz_c;
-	struct spl_fixed31_32 vert_c;
-};
-struct spl_inits {
-	struct spl_fixed31_32 h;
-	struct spl_fixed31_32 h_c;
-	struct spl_fixed31_32 v;
-	struct spl_fixed31_32 v_c;
-};
-
-struct spl_taps	{
-	uint32_t v_taps;
-	uint32_t h_taps;
-	uint32_t v_taps_c;
-	uint32_t h_taps_c;
-	bool integer_scaling;
-};
-enum spl_view_3d {
-	SPL_VIEW_3D_NONE = 0,
-	SPL_VIEW_3D_FRAME_SEQUENTIAL,
-	SPL_VIEW_3D_SIDE_BY_SIDE,
-	SPL_VIEW_3D_TOP_AND_BOTTOM,
-	SPL_VIEW_3D_COUNT,
-	SPL_VIEW_3D_FIRST = SPL_VIEW_3D_FRAME_SEQUENTIAL
-};
-/* Pixel format */
-enum spl_pixel_format {
-	/*graph*/
-	SPL_PIXEL_FORMAT_UNINITIALIZED,
-	SPL_PIXEL_FORMAT_INDEX8,
-	SPL_PIXEL_FORMAT_RGB565,
-	SPL_PIXEL_FORMAT_ARGB8888,
-	SPL_PIXEL_FORMAT_ARGB2101010,
-	SPL_PIXEL_FORMAT_ARGB2101010_XRBIAS,
-	SPL_PIXEL_FORMAT_FP16,
-	/*video*/
-	SPL_PIXEL_FORMAT_420BPP8,
-	SPL_PIXEL_FORMAT_420BPP10,
-	/*end of pixel format definition*/
-	SPL_PIXEL_FORMAT_GRPH_BEGIN = SPL_PIXEL_FORMAT_INDEX8,
-	SPL_PIXEL_FORMAT_GRPH_END = SPL_PIXEL_FORMAT_FP16,
-	SPL_PIXEL_FORMAT_SUBSAMPLED_BEGIN = SPL_PIXEL_FORMAT_420BPP8,
-	SPL_PIXEL_FORMAT_SUBSAMPLED_END = SPL_PIXEL_FORMAT_420BPP10,
-	SPL_PIXEL_FORMAT_VIDEO_BEGIN = SPL_PIXEL_FORMAT_420BPP8,
-	SPL_PIXEL_FORMAT_VIDEO_END = SPL_PIXEL_FORMAT_420BPP10,
-	SPL_PIXEL_FORMAT_INVALID,
-	SPL_PIXEL_FORMAT_UNKNOWN
-};
-
-enum lb_memory_config {
-	/* Enable all 3 pieces of memory */
-	LB_MEMORY_CONFIG_0 = 0,
-
-	/* Enable only the first piece of memory */
-	LB_MEMORY_CONFIG_1 = 1,
-
-	/* Enable only the second piece of memory */
-	LB_MEMORY_CONFIG_2 = 2,
-
-	/* Only applicable in 4:2:0 mode, enable all 3 pieces of memory and the
-	 * last piece of chroma memory used for the luma storage
-	 */
-	LB_MEMORY_CONFIG_3 = 3
-};
-
-/* Rotation angle */
-enum spl_rotation_angle {
-	SPL_ROTATION_ANGLE_0 = 0,
-	SPL_ROTATION_ANGLE_90,
-	SPL_ROTATION_ANGLE_180,
-	SPL_ROTATION_ANGLE_270,
-	SPL_ROTATION_ANGLE_COUNT
-};
-enum spl_color_space {
-	SPL_COLOR_SPACE_UNKNOWN,
-	SPL_COLOR_SPACE_SRGB,
-	SPL_COLOR_SPACE_XR_RGB,
-	SPL_COLOR_SPACE_SRGB_LIMITED,
-	SPL_COLOR_SPACE_MSREF_SCRGB,
-	SPL_COLOR_SPACE_YCBCR601,
-	SPL_COLOR_SPACE_YCBCR709,
-	SPL_COLOR_SPACE_XV_YCC_709,
-	SPL_COLOR_SPACE_XV_YCC_601,
-	SPL_COLOR_SPACE_YCBCR601_LIMITED,
-	SPL_COLOR_SPACE_YCBCR709_LIMITED,
-	SPL_COLOR_SPACE_2020_RGB_FULLRANGE,
-	SPL_COLOR_SPACE_2020_RGB_LIMITEDRANGE,
-	SPL_COLOR_SPACE_2020_YCBCR,
-	SPL_COLOR_SPACE_ADOBERGB,
-	SPL_COLOR_SPACE_DCIP3,
-	SPL_COLOR_SPACE_DISPLAYNATIVE,
-	SPL_COLOR_SPACE_DOLBYVISION,
-	SPL_COLOR_SPACE_APPCTRL,
-	SPL_COLOR_SPACE_CUSTOMPOINTS,
-	SPL_COLOR_SPACE_YCBCR709_BLACK,
-};
-
-enum chroma_cositing {
-	CHROMA_COSITING_NONE,
-	CHROMA_COSITING_LEFT,
-	CHROMA_COSITING_TOPLEFT,
-	CHROMA_COSITING_COUNT
-};
-
-// Scratch space for calculating scaler params
-struct spl_scaler_data {
-	int h_active;
-	int v_active;
-	struct spl_taps taps;
-	struct spl_rect viewport;
-	struct spl_rect viewport_c;
-	struct spl_rect recout;
-	struct spl_ratios ratios;
-	struct spl_ratios recip_ratios;
-	struct spl_inits inits;
-};
-
-enum spl_transfer_func_type {
-	SPL_TF_TYPE_PREDEFINED,
-	SPL_TF_TYPE_DISTRIBUTED_POINTS,
-	SPL_TF_TYPE_BYPASS,
-	SPL_TF_TYPE_HWPWL
-};
-
-enum spl_transfer_func_predefined {
-	SPL_TRANSFER_FUNCTION_SRGB,
-	SPL_TRANSFER_FUNCTION_BT709,
-	SPL_TRANSFER_FUNCTION_PQ,
-	SPL_TRANSFER_FUNCTION_LINEAR,
-	SPL_TRANSFER_FUNCTION_UNITY,
-	SPL_TRANSFER_FUNCTION_HLG,
-	SPL_TRANSFER_FUNCTION_HLG12,
-	SPL_TRANSFER_FUNCTION_GAMMA22,
-	SPL_TRANSFER_FUNCTION_GAMMA24,
-	SPL_TRANSFER_FUNCTION_GAMMA26
-};
-
-/*==============================================================*/
-/* Below structs are defined to hold hw register data */
-
-// SPL output is used to set below registers
-
-// MPC_SIZE - set based on scl_data h_active and v_active
-struct mpc_size	{
-	uint32_t width;
-	uint32_t height;
-};
-// SCL_MODE - set based on scl_data.ratios and always_scale
-enum scl_mode {
-	SCL_MODE_SCALING_444_BYPASS = 0,
-	SCL_MODE_SCALING_444_RGB_ENABLE = 1,
-	SCL_MODE_SCALING_444_YCBCR_ENABLE = 2,
-	SCL_MODE_SCALING_420_YCBCR_ENABLE = 3,
-	SCL_MODE_SCALING_420_LUMA_BYPASS = 4,
-	SCL_MODE_SCALING_420_CHROMA_BYPASS = 5,
-	SCL_MODE_DSCL_BYPASS = 6
-};
-// SCL_BLACK_COLOR - set based on scl_data.format
-struct scl_black_color	{
-	uint32_t offset_rgb_y;
-	uint32_t offset_rgb_cbcr;
-};
-// RATIO - set based on scl_data.ratios
-struct ratio	{
-	uint32_t h_scale_ratio;
-	uint32_t v_scale_ratio;
-	uint32_t h_scale_ratio_c;
-	uint32_t v_scale_ratio_c;
-};
-
-// INIT - set based on scl_data.init
-struct init	{
-	// SCL_HORZ_FILTER_INIT
-	uint32_t h_filter_init_frac;	//	SCL_H_INIT_FRAC
-	uint32_t h_filter_init_int;	//	SCL_H_INIT_INT
-	// SCL_HORZ_FILTER_INIT_C
-	uint32_t h_filter_init_frac_c;	//	SCL_H_INIT_FRAC_C
-	uint32_t h_filter_init_int_c;	//	SCL_H_INIT_INT_C
-	// SCL_VERT_FILTER_INIT
-	uint32_t v_filter_init_frac;	//	SCL_V_INIT_FRAC
-	uint32_t v_filter_init_int;	//	SCL_V_INIT_INT
-	//	SCL_VERT_FILTER_INIT_C
-	uint32_t v_filter_init_frac_c;	//	SCL_V_INIT_FRAC_C
-	uint32_t v_filter_init_int_c;	//	SCL_V_INIT_INT_C
-	//	SCL_VERT_FILTER_INIT_BOT
-	uint32_t v_filter_init_bot_frac;	//	SCL_V_INIT_FRAC_BOT
-	uint32_t v_filter_init_bot_int;	//	SCL_V_INIT_INT_BOT
-	//	SCL_VERT_FILTER_INIT_BOT_C
-	uint32_t v_filter_init_bot_frac_c;	//	SCL_V_INIT_FRAC_BOT_C
-	uint32_t v_filter_init_bot_int_c;	//	SCL_V_INIT_INT_BOT_C
-};
-
-// FILTER - calculated based on scl_data ratios and taps
-
-// iSHARP
-struct isharp_noise_det {
-	uint32_t enable;	// ISHARP_NOISEDET_EN
-	uint32_t mode;		// ISHARP_NOISEDET_MODE
-	uint32_t uthreshold;	// ISHARP_NOISEDET_UTHRE
-	uint32_t dthreshold;	// ISHARP_NOISEDET_DTHRE
-	uint32_t pwl_start_in;	// ISHARP_NOISEDET_PWL_START_IN
-	uint32_t pwl_end_in;	// ISHARP_NOISEDET_PWL_END_IN
-	uint32_t pwl_slope;	// ISHARP_NOISEDET_PWL_SLOPE
-};
-struct isharp_lba	{
-	uint32_t mode;	// ISHARP_LBA_MODE
-	uint32_t in_seg[6];
-	uint32_t base_seg[6];
-	uint32_t slope_seg[6];
-};
-struct isharp_fmt	{
-	uint32_t mode;	// ISHARP_FMT_MODE
-	uint32_t norm;	// ISHARP_FMT_NORM
-};
-struct isharp_nldelta_sclip	{
-	uint32_t enable_p;	// ISHARP_NLDELTA_SCLIP_EN_P
-	uint32_t pivot_p;	// ISHARP_NLDELTA_SCLIP_PIVOT_P
-	uint32_t slope_p;	// ISHARP_NLDELTA_SCLIP_SLOPE_P
-	uint32_t enable_n;	// ISHARP_NLDELTA_SCLIP_EN_N
-	uint32_t pivot_n;	// ISHARP_NLDELTA_SCLIP_PIVOT_N
-	uint32_t slope_n;	// ISHARP_NLDELTA_SCLIP_SLOPE_N
-};
-enum isharp_en	{
-	ISHARP_DISABLE,
-	ISHARP_ENABLE
-};
-#define ISHARP_LUT_TABLE_SIZE 32
-// Below struct holds values that can be directly used to program
-// hardware registers. No conversion/clamping is required
-struct dscl_prog_data {
-	struct spl_rect recout; // RECOUT - set based on scl_data.recout
-	struct mpc_size mpc_size;
-	uint32_t dscl_mode;
-	struct scl_black_color scl_black_color;
-	struct ratio ratios;
-	struct init init;
-	struct spl_taps taps;	// TAPS - set based on scl_data.taps
-	struct spl_rect viewport;
-	struct spl_rect viewport_c;
-	// raw filter
-	const uint16_t *filter_h;
-	const uint16_t *filter_v;
-	const uint16_t *filter_h_c;
-	const uint16_t *filter_v_c;
-	// EASF registers
-	uint32_t easf_matrix_mode;
-	uint32_t easf_ltonl_en;
-	uint32_t easf_v_en;
-	uint32_t easf_v_sharp_factor;
-	uint32_t easf_v_ring;
-	uint32_t easf_v_bf1_en;
-	uint32_t easf_v_bf2_mode;
-	uint32_t easf_v_bf3_mode;
-	uint32_t easf_v_bf2_flat1_gain;
-	uint32_t easf_v_bf2_flat2_gain;
-	uint32_t easf_v_bf2_roc_gain;
-	uint32_t easf_v_ringest_3tap_dntilt_uptilt;
-	uint32_t easf_v_ringest_3tap_uptilt_max;
-	uint32_t easf_v_ringest_3tap_dntilt_slope;
-	uint32_t easf_v_ringest_3tap_uptilt1_slope;
-	uint32_t easf_v_ringest_3tap_uptilt2_slope;
-	uint32_t easf_v_ringest_3tap_uptilt2_offset;
-	uint32_t easf_v_ringest_eventap_reduceg1;
-	uint32_t easf_v_ringest_eventap_reduceg2;
-	uint32_t easf_v_ringest_eventap_gain1;
-	uint32_t easf_v_ringest_eventap_gain2;
-	uint32_t easf_v_bf_maxa;
-	uint32_t easf_v_bf_maxb;
-	uint32_t easf_v_bf_mina;
-	uint32_t easf_v_bf_minb;
-	uint32_t easf_v_bf1_pwl_in_seg0;
-	uint32_t easf_v_bf1_pwl_base_seg0;
-	uint32_t easf_v_bf1_pwl_slope_seg0;
-	uint32_t easf_v_bf1_pwl_in_seg1;
-	uint32_t easf_v_bf1_pwl_base_seg1;
-	uint32_t easf_v_bf1_pwl_slope_seg1;
-	uint32_t easf_v_bf1_pwl_in_seg2;
-	uint32_t easf_v_bf1_pwl_base_seg2;
-	uint32_t easf_v_bf1_pwl_slope_seg2;
-	uint32_t easf_v_bf1_pwl_in_seg3;
-	uint32_t easf_v_bf1_pwl_base_seg3;
-	uint32_t easf_v_bf1_pwl_slope_seg3;
-	uint32_t easf_v_bf1_pwl_in_seg4;
-	uint32_t easf_v_bf1_pwl_base_seg4;
-	uint32_t easf_v_bf1_pwl_slope_seg4;
-	uint32_t easf_v_bf1_pwl_in_seg5;
-	uint32_t easf_v_bf1_pwl_base_seg5;
-	uint32_t easf_v_bf1_pwl_slope_seg5;
-	uint32_t easf_v_bf1_pwl_in_seg6;
-	uint32_t easf_v_bf1_pwl_base_seg6;
-	uint32_t easf_v_bf1_pwl_slope_seg6;
-	uint32_t easf_v_bf1_pwl_in_seg7;
-	uint32_t easf_v_bf1_pwl_base_seg7;
-	uint32_t easf_v_bf3_pwl_in_set0;
-	uint32_t easf_v_bf3_pwl_base_set0;
-	uint32_t easf_v_bf3_pwl_slope_set0;
-	uint32_t easf_v_bf3_pwl_in_set1;
-	uint32_t easf_v_bf3_pwl_base_set1;
-	uint32_t easf_v_bf3_pwl_slope_set1;
-	uint32_t easf_v_bf3_pwl_in_set2;
-	uint32_t easf_v_bf3_pwl_base_set2;
-	uint32_t easf_v_bf3_pwl_slope_set2;
-	uint32_t easf_v_bf3_pwl_in_set3;
-	uint32_t easf_v_bf3_pwl_base_set3;
-	uint32_t easf_v_bf3_pwl_slope_set3;
-	uint32_t easf_v_bf3_pwl_in_set4;
-	uint32_t easf_v_bf3_pwl_base_set4;
-	uint32_t easf_v_bf3_pwl_slope_set4;
-	uint32_t easf_v_bf3_pwl_in_set5;
-	uint32_t easf_v_bf3_pwl_base_set5;
-	uint32_t easf_h_en;
-	uint32_t easf_h_sharp_factor;
-	uint32_t easf_h_ring;
-	uint32_t easf_h_bf1_en;
-	uint32_t easf_h_bf2_mode;
-	uint32_t easf_h_bf3_mode;
-	uint32_t easf_h_bf2_flat1_gain;
-	uint32_t easf_h_bf2_flat2_gain;
-	uint32_t easf_h_bf2_roc_gain;
-	uint32_t easf_h_ringest_eventap_reduceg1;
-	uint32_t easf_h_ringest_eventap_reduceg2;
-	uint32_t easf_h_ringest_eventap_gain1;
-	uint32_t easf_h_ringest_eventap_gain2;
-	uint32_t easf_h_bf_maxa;
-	uint32_t easf_h_bf_maxb;
-	uint32_t easf_h_bf_mina;
-	uint32_t easf_h_bf_minb;
-	uint32_t easf_h_bf1_pwl_in_seg0;
-	uint32_t easf_h_bf1_pwl_base_seg0;
-	uint32_t easf_h_bf1_pwl_slope_seg0;
-	uint32_t easf_h_bf1_pwl_in_seg1;
-	uint32_t easf_h_bf1_pwl_base_seg1;
-	uint32_t easf_h_bf1_pwl_slope_seg1;
-	uint32_t easf_h_bf1_pwl_in_seg2;
-	uint32_t easf_h_bf1_pwl_base_seg2;
-	uint32_t easf_h_bf1_pwl_slope_seg2;
-	uint32_t easf_h_bf1_pwl_in_seg3;
-	uint32_t easf_h_bf1_pwl_base_seg3;
-	uint32_t easf_h_bf1_pwl_slope_seg3;
-	uint32_t easf_h_bf1_pwl_in_seg4;
-	uint32_t easf_h_bf1_pwl_base_seg4;
-	uint32_t easf_h_bf1_pwl_slope_seg4;
-	uint32_t easf_h_bf1_pwl_in_seg5;
-	uint32_t easf_h_bf1_pwl_base_seg5;
-	uint32_t easf_h_bf1_pwl_slope_seg5;
-	uint32_t easf_h_bf1_pwl_in_seg6;
-	uint32_t easf_h_bf1_pwl_base_seg6;
-	uint32_t easf_h_bf1_pwl_slope_seg6;
-	uint32_t easf_h_bf1_pwl_in_seg7;
-	uint32_t easf_h_bf1_pwl_base_seg7;
-	uint32_t easf_h_bf3_pwl_in_set0;
-	uint32_t easf_h_bf3_pwl_base_set0;
-	uint32_t easf_h_bf3_pwl_slope_set0;
-	uint32_t easf_h_bf3_pwl_in_set1;
-	uint32_t easf_h_bf3_pwl_base_set1;
-	uint32_t easf_h_bf3_pwl_slope_set1;
-	uint32_t easf_h_bf3_pwl_in_set2;
-	uint32_t easf_h_bf3_pwl_base_set2;
-	uint32_t easf_h_bf3_pwl_slope_set2;
-	uint32_t easf_h_bf3_pwl_in_set3;
-	uint32_t easf_h_bf3_pwl_base_set3;
-	uint32_t easf_h_bf3_pwl_slope_set3;
-	uint32_t easf_h_bf3_pwl_in_set4;
-	uint32_t easf_h_bf3_pwl_base_set4;
-	uint32_t easf_h_bf3_pwl_slope_set4;
-	uint32_t easf_h_bf3_pwl_in_set5;
-	uint32_t easf_h_bf3_pwl_base_set5;
-	uint32_t easf_matrix_c0;
-	uint32_t easf_matrix_c1;
-	uint32_t easf_matrix_c2;
-	uint32_t easf_matrix_c3;
-	// iSharp
-	uint32_t isharp_en;     //      ISHARP_EN
-	struct isharp_noise_det isharp_noise_det;       //      ISHARP_NOISEDET
-	uint32_t isharp_nl_en;  //      ISHARP_NL_EN ? TODO:check this
-	struct isharp_lba isharp_lba;   //      ISHARP_LBA
-	struct isharp_fmt isharp_fmt;   //      ISHARP_FMT
-	uint32_t isharp_delta[ISHARP_LUT_TABLE_SIZE];
-	struct isharp_nldelta_sclip isharp_nldelta_sclip;       //      ISHARP_NLDELTA_SCLIP
-	/* blur and scale filter */
-	const uint16_t *filter_blur_scale_v;
-	const uint16_t *filter_blur_scale_h;
-	int sharpness_level; /* Track sharpness level */
-};
-
-/* SPL input and output definitions */
-// SPL scratch struct
-struct spl_scratch {
-	// Pack all SPL outputs in scl_data
-	struct spl_scaler_data scl_data;
-};
-
-/* SPL input and output definitions */
-// SPL outputs struct
-struct spl_out	{
-	// Pack all output need to program hw registers
-	struct dscl_prog_data *dscl_prog_data;
-};
-
-// end of SPL outputs
-
-// SPL inputs
-
-// Basic input information
-struct basic_in	{
-	enum spl_pixel_format format; // Pixel Format
-	enum chroma_cositing cositing; /* Chroma Subsampling Offset */
-	struct spl_rect src_rect; // Source rect
-	struct spl_rect dst_rect; // Destination Rect
-	struct spl_rect clip_rect; // Clip rect
-	enum spl_rotation_angle rotation;  // Rotation
-	bool horizontal_mirror;  // Horizontal mirror
-	struct { // previous mpc_combine_h - split count
-		bool use_recout_width_aligned;
-		union {
-			int mpc_num_h_slices;
-			int mpc_recout_width_align;
-		} num_slices_recout_width;
-	} num_h_slices_recout_width_align;
-	int mpc_h_slice_index; // previous mpc_combine_v - split_idx
-	// Inputs for adaptive scaler - TODO
-	enum spl_transfer_func_type tf_type; /* Transfer function type */
-	enum spl_transfer_func_predefined tf_predefined_type; /* Transfer function predefined type */
-	// enum dc_transfer_func_predefined tf;
-	enum spl_color_space color_space;	//	Color Space
-	unsigned int max_luminance;	//	Max Luminance TODO: Is determined in dc_hw_sequencer.c is_sdr
-	bool film_grain_applied;	//	Film Grain Applied // TODO: To check from where to get this?
-};
-
-// Basic output information
-struct basic_out {
-	struct spl_size output_size; // Output Size
-	struct spl_rect dst_rect;	// Destination Rect
-	struct spl_rect src_rect;	// Source rect
-	int odm_combine_factor;	// deprecated
-	struct spl_rect odm_slice_rect; // OPP input rect in timing active
-	enum spl_view_3d view_format;	// TODO: View format Check if it is chroma subsampling
-	bool always_scale;	// Is always scale enabled? Required for getting SCL_MODE
-	int max_downscale_src_width; // Required to get optimal no of taps
-	bool alpha_en;
-	bool use_two_pixels_per_container;
-};
-enum sharpness_setting	{
-	SHARPNESS_HW_OFF = 0,
-	SHARPNESS_ZERO,
-	SHARPNESS_CUSTOM
-};
-struct spl_sharpness_range {
-	int sdr_rgb_min;
-	int sdr_rgb_max;
-	int sdr_rgb_mid;
-	int sdr_yuv_min;
-	int sdr_yuv_max;
-	int sdr_yuv_mid;
-	int hdr_rgb_min;
-	int hdr_rgb_max;
-	int hdr_rgb_mid;
-};
-struct adaptive_sharpness {
-	bool enable;
-	int sharpness_level;
-	struct spl_sharpness_range sharpness_range;
-};
-enum linear_light_scaling	{	// convert it in translation logic
-	LLS_PREF_DONT_CARE = 0,
-	LLS_PREF_YES,
-	LLS_PREF_NO
-};
-enum sharpen_policy {
-	SHARPEN_ALWAYS = 0,
-	SHARPEN_YUV = 1,
-	SHARPEN_RGB_FULLSCREEN_YUV = 2,
-	SHARPEN_FULLSCREEN_ALL = 3
-};
-enum scale_to_sharpness_policy {
-	NO_SCALE_TO_SHARPNESS_ADJ = 0,
-	SCALE_TO_SHARPNESS_ADJ_YUV = 1,
-	SCALE_TO_SHARPNESS_ADJ_ALL = 2
-};
-struct spl_callbacks {
-	void (*spl_calc_lb_num_partitions)
-		(bool alpha_en,
-		const struct spl_scaler_data *scl_data,
-		enum lb_memory_config lb_config,
-		int *num_part_y,
-		int *num_part_c);
-};
-
-struct spl_debug {
-	int visual_confirm_base_offset;
-	int visual_confirm_dpp_offset;
-	enum scale_to_sharpness_policy scale_to_sharpness_policy;
-};
-
-struct spl_in	{
-	struct basic_out basic_out;
-	struct basic_in basic_in;
-	// Basic slice information
-	int odm_slice_index;	// ODM Slice Index using get_odm_split_index
-	struct spl_taps scaling_quality; // Explicit Scaling Quality
-	struct spl_callbacks callbacks;
-	// Inputs for isharp and EASF
-	struct adaptive_sharpness adaptive_sharpness;	//	Adaptive Sharpness
-	enum linear_light_scaling lls_pref;	//	Linear Light Scaling
-	bool prefer_easf;
-	bool disable_easf;
-	struct spl_debug debug;
-	bool is_fullscreen;
-	bool is_hdr_on;
-	int h_active;
-	int v_active;
-	int sdr_white_level_nits;
-	enum sharpen_policy sharpen_policy;
-};
-// end of SPL inputs
-
-#endif /* __DC_SPL_TYPES_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/spl/spl_custom_float.c b/drivers/gpu/drm/amd/display/dc/spl/spl_custom_float.c
deleted file mode 100644
index be2f34d034c5..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/spl_custom_float.c
+++ /dev/null
@@ -1,151 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#include "spl_debug.h"
-#include "spl_custom_float.h"
-
-static bool spl_build_custom_float(struct spl_fixed31_32 value,
-			       const struct spl_custom_float_format *format,
-			       bool *negative,
-			       uint32_t *mantissa,
-			       uint32_t *exponenta)
-{
-	uint32_t exp_offset = (1 << (format->exponenta_bits - 1)) - 1;
-
-	const struct spl_fixed31_32 mantissa_constant_plus_max_fraction =
-		spl_fixpt_from_fraction((1LL << (format->mantissa_bits + 1)) - 1,
-				       1LL << format->mantissa_bits);
-
-	struct spl_fixed31_32 mantiss;
-
-	if (spl_fixpt_eq(value, spl_fixpt_zero)) {
-		*negative = false;
-		*mantissa = 0;
-		*exponenta = 0;
-		return true;
-	}
-
-	if (spl_fixpt_lt(value, spl_fixpt_zero)) {
-		*negative = format->sign;
-		value = spl_fixpt_neg(value);
-	} else {
-		*negative = false;
-	}
-
-	if (spl_fixpt_lt(value, spl_fixpt_one)) {
-		uint32_t i = 1;
-
-		do {
-			value = spl_fixpt_shl(value, 1);
-			++i;
-		} while (spl_fixpt_lt(value, spl_fixpt_one));
-
-		--i;
-
-		if (exp_offset <= i) {
-			*mantissa = 0;
-			*exponenta = 0;
-			return true;
-		}
-
-		*exponenta = exp_offset - i;
-	} else if (spl_fixpt_le(mantissa_constant_plus_max_fraction, value)) {
-		uint32_t i = 1;
-
-		do {
-			value = spl_fixpt_shr(value, 1);
-			++i;
-		} while (spl_fixpt_lt(mantissa_constant_plus_max_fraction, value));
-
-		*exponenta = exp_offset + i - 1;
-	} else {
-		*exponenta = exp_offset;
-	}
-
-	mantiss = spl_fixpt_sub(value, spl_fixpt_one);
-
-	if (spl_fixpt_lt(mantiss, spl_fixpt_zero) ||
-	    spl_fixpt_lt(spl_fixpt_one, mantiss))
-		mantiss = spl_fixpt_zero;
-	else
-		mantiss = spl_fixpt_shl(mantiss, format->mantissa_bits);
-
-	*mantissa = spl_fixpt_floor(mantiss);
-
-	return true;
-}
-
-static bool spl_setup_custom_float(const struct spl_custom_float_format *format,
-			       bool negative,
-			       uint32_t mantissa,
-			       uint32_t exponenta,
-			       uint32_t *result)
-{
-	uint32_t i = 0;
-	uint32_t j = 0;
-	uint32_t value = 0;
-
-	/* verification code:
-	 * once calculation is ok we can remove it
-	 */
-
-	const uint32_t mantissa_mask =
-		(1 << (format->mantissa_bits + 1)) - 1;
-
-	const uint32_t exponenta_mask =
-		(1 << (format->exponenta_bits + 1)) - 1;
-
-	if (mantissa & ~mantissa_mask) {
-		SPL_BREAK_TO_DEBUGGER();
-		mantissa = mantissa_mask;
-	}
-
-	if (exponenta & ~exponenta_mask) {
-		SPL_BREAK_TO_DEBUGGER();
-		exponenta = exponenta_mask;
-	}
-
-	/* end of verification code */
-
-	while (i < format->mantissa_bits) {
-		uint32_t mask = 1 << i;
-
-		if (mantissa & mask)
-			value |= mask;
-
-		++i;
-	}
-
-	while (j < format->exponenta_bits) {
-		uint32_t mask = 1 << j;
-
-		if (exponenta & mask)
-			value |= mask << i;
-
-		++j;
-	}
-
-	if (negative && format->sign)
-		value |= 1 << (i + j);
-
-	*result = value;
-
-	return true;
-}
-
-bool spl_convert_to_custom_float_format(struct spl_fixed31_32 value,
-				    const struct spl_custom_float_format *format,
-				    uint32_t *result)
-{
-	uint32_t mantissa;
-	uint32_t exponenta;
-	bool negative;
-
-	return spl_build_custom_float(value, format, &negative, &mantissa, &exponenta) &&
-				  spl_setup_custom_float(format,
-						     negative,
-						     mantissa,
-						     exponenta,
-						     result);
-}
diff --git a/drivers/gpu/drm/amd/display/dc/spl/spl_custom_float.h b/drivers/gpu/drm/amd/display/dc/spl/spl_custom_float.h
deleted file mode 100644
index cdc4e107b9de..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/spl_custom_float.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-
-/* Copyright 2024 Advanced Micro Devices, Inc. */
-
-#ifndef SPL_CUSTOM_FLOAT_H_
-#define SPL_CUSTOM_FLOAT_H_
-
-#include "spl_os_types.h"
-#include "spl_fixpt31_32.h"
-
-struct spl_custom_float_format {
-	uint32_t mantissa_bits;
-	uint32_t exponenta_bits;
-	bool sign;
-};
-
-struct spl_custom_float_value {
-	uint32_t mantissa;
-	uint32_t exponenta;
-	uint32_t value;
-	bool negative;
-};
-
-bool spl_convert_to_custom_float_format(
-	struct spl_fixed31_32 value,
-	const struct spl_custom_float_format *format,
-	uint32_t *result);
-
-#endif //SPL_CUSTOM_FLOAT_H_
diff --git a/drivers/gpu/drm/amd/display/dc/spl/spl_debug.h b/drivers/gpu/drm/amd/display/dc/spl/spl_debug.h
deleted file mode 100644
index a6f6132df241..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/spl_debug.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-
-/* Copyright 2024 Advanced Micro Devices, Inc. */
-
-#ifndef SPL_DEBUG_H
-#define SPL_DEBUG_H
-
-#if defined(CONFIG_HAVE_KGDB) || defined(CONFIG_KGDB)
-#define SPL_ASSERT_CRITICAL(expr) do {	\
-	if (WARN_ON(!(expr))) { \
-		kgdb_breakpoint(); \
-	} \
-} while (0)
-#else
-#define SPL_ASSERT_CRITICAL(expr) do {	\
-	if (WARN_ON(!(expr))) { \
-		; \
-	} \
-} while (0)
-#endif /* CONFIG_HAVE_KGDB || CONFIG_KGDB */
-
-#if defined(CONFIG_DEBUG_KERNEL_DC)
-#define SPL_ASSERT(expr) SPL_ASSERT_CRITICAL(expr)
-#else
-#define SPL_ASSERT(expr) WARN_ON(!(expr))
-#endif /* CONFIG_DEBUG_KERNEL_DC */
-
-#define SPL_BREAK_TO_DEBUGGER() SPL_ASSERT(0)
-
-#endif  // SPL_DEBUG_H
diff --git a/drivers/gpu/drm/amd/display/dc/spl/spl_fixpt31_32.c b/drivers/gpu/drm/amd/display/dc/spl/spl_fixpt31_32.c
deleted file mode 100644
index 131f1e3949d3..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/spl_fixpt31_32.c
+++ /dev/null
@@ -1,497 +0,0 @@
-// SPDX-License-Identifier: MIT
-//
-// Copyright 2024 Advanced Micro Devices, Inc.
-
-#include "spl_fixpt31_32.h"
-
-static const struct spl_fixed31_32 spl_fixpt_two_pi = { 26986075409LL };
-static const struct spl_fixed31_32 spl_fixpt_ln2 = { 2977044471LL };
-static const struct spl_fixed31_32 spl_fixpt_ln2_div_2 = { 1488522236LL };
-
-static inline unsigned long long abs_i64(
-	long long arg)
-{
-	if (arg > 0)
-		return (unsigned long long)arg;
-	else
-		return (unsigned long long)(-arg);
-}
-
-/*
- * @brief
- * result = dividend / divisor
- * *remainder = dividend % divisor
- */
-static inline unsigned long long spl_complete_integer_division_u64(
-	unsigned long long dividend,
-	unsigned long long divisor,
-	unsigned long long *remainder)
-{
-	unsigned long long result;
-
-	SPL_ASSERT(divisor);
-
-	result = spl_div64_u64_rem(dividend, divisor, remainder);
-
-	return result;
-}
-
-
-#define FRACTIONAL_PART_MASK \
-	((1ULL << FIXED31_32_BITS_PER_FRACTIONAL_PART) - 1)
-
-#define GET_INTEGER_PART(x) \
-	((x) >> FIXED31_32_BITS_PER_FRACTIONAL_PART)
-
-#define GET_FRACTIONAL_PART(x) \
-	(FRACTIONAL_PART_MASK & (x))
-
-struct spl_fixed31_32 spl_fixpt_from_fraction(long long numerator, long long denominator)
-{
-	struct spl_fixed31_32 res;
-
-	bool arg1_negative = numerator < 0;
-	bool arg2_negative = denominator < 0;
-
-	unsigned long long arg1_value = arg1_negative ? -numerator : numerator;
-	unsigned long long arg2_value = arg2_negative ? -denominator : denominator;
-
-	unsigned long long remainder;
-
-	/* determine integer part */
-
-	unsigned long long res_value = spl_complete_integer_division_u64(
-		arg1_value, arg2_value, &remainder);
-
-	SPL_ASSERT(res_value <= (unsigned long long)LONG_MAX);
-
-	/* determine fractional part */
-	{
-		unsigned int i = FIXED31_32_BITS_PER_FRACTIONAL_PART;
-
-		do {
-			remainder <<= 1;
-
-			res_value <<= 1;
-
-			if (remainder >= arg2_value) {
-				res_value |= 1;
-				remainder -= arg2_value;
-			}
-		} while (--i != 0);
-	}
-
-	/* round up LSB */
-	{
-		unsigned long long summand = (remainder << 1) >= arg2_value;
-
-		SPL_ASSERT(res_value <= (unsigned long long)LLONG_MAX - summand);
-
-		res_value += summand;
-	}
-
-	res.value = (long long)res_value;
-
-	if (arg1_negative ^ arg2_negative)
-		res.value = -res.value;
-
-	return res;
-}
-
-struct spl_fixed31_32 spl_fixpt_mul(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	struct spl_fixed31_32 res;
-
-	bool arg1_negative = arg1.value < 0;
-	bool arg2_negative = arg2.value < 0;
-
-	unsigned long long arg1_value = arg1_negative ? -arg1.value : arg1.value;
-	unsigned long long arg2_value = arg2_negative ? -arg2.value : arg2.value;
-
-	unsigned long long arg1_int = GET_INTEGER_PART(arg1_value);
-	unsigned long long arg2_int = GET_INTEGER_PART(arg2_value);
-
-	unsigned long long arg1_fra = GET_FRACTIONAL_PART(arg1_value);
-	unsigned long long arg2_fra = GET_FRACTIONAL_PART(arg2_value);
-
-	unsigned long long tmp;
-
-	res.value = arg1_int * arg2_int;
-
-	SPL_ASSERT(res.value <= (long long)LONG_MAX);
-
-	res.value <<= FIXED31_32_BITS_PER_FRACTIONAL_PART;
-
-	tmp = arg1_int * arg2_fra;
-
-	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
-
-	res.value += tmp;
-
-	tmp = arg2_int * arg1_fra;
-
-	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
-
-	res.value += tmp;
-
-	tmp = arg1_fra * arg2_fra;
-
-	tmp = (tmp >> FIXED31_32_BITS_PER_FRACTIONAL_PART) +
-		(tmp >= (unsigned long long)spl_fixpt_half.value);
-
-	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
-
-	res.value += tmp;
-
-	if (arg1_negative ^ arg2_negative)
-		res.value = -res.value;
-
-	return res;
-}
-
-struct spl_fixed31_32 spl_fixpt_sqr(struct spl_fixed31_32 arg)
-{
-	struct spl_fixed31_32 res;
-
-	unsigned long long arg_value = abs_i64(arg.value);
-
-	unsigned long long arg_int = GET_INTEGER_PART(arg_value);
-
-	unsigned long long arg_fra = GET_FRACTIONAL_PART(arg_value);
-
-	unsigned long long tmp;
-
-	res.value = arg_int * arg_int;
-
-	SPL_ASSERT(res.value <= (long long)LONG_MAX);
-
-	res.value <<= FIXED31_32_BITS_PER_FRACTIONAL_PART;
-
-	tmp = arg_int * arg_fra;
-
-	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
-
-	res.value += tmp;
-
-	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
-
-	res.value += tmp;
-
-	tmp = arg_fra * arg_fra;
-
-	tmp = (tmp >> FIXED31_32_BITS_PER_FRACTIONAL_PART) +
-		(tmp >= (unsigned long long)spl_fixpt_half.value);
-
-	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
-
-	res.value += tmp;
-
-	return res;
-}
-
-struct spl_fixed31_32 spl_fixpt_recip(struct spl_fixed31_32 arg)
-{
-	/*
-	 * @note
-	 * Good idea to use Newton's method
-	 */
-
-	SPL_ASSERT(arg.value);
-
-	return spl_fixpt_from_fraction(
-		spl_fixpt_one.value,
-		arg.value);
-}
-
-struct spl_fixed31_32 spl_fixpt_sinc(struct spl_fixed31_32 arg)
-{
-	struct spl_fixed31_32 square;
-
-	struct spl_fixed31_32 res = spl_fixpt_one;
-
-	int n = 27;
-
-	struct spl_fixed31_32 arg_norm = arg;
-
-	if (spl_fixpt_le(
-		spl_fixpt_two_pi,
-		spl_fixpt_abs(arg))) {
-		arg_norm = spl_fixpt_sub(
-			arg_norm,
-			spl_fixpt_mul_int(
-				spl_fixpt_two_pi,
-				(int)spl_div64_s64(
-					arg_norm.value,
-					spl_fixpt_two_pi.value)));
-	}
-
-	square = spl_fixpt_sqr(arg_norm);
-
-	do {
-		res = spl_fixpt_sub(
-			spl_fixpt_one,
-			spl_fixpt_div_int(
-				spl_fixpt_mul(
-					square,
-					res),
-				n * (n - 1)));
-
-		n -= 2;
-	} while (n > 2);
-
-	if (arg.value != arg_norm.value)
-		res = spl_fixpt_div(
-			spl_fixpt_mul(res, arg_norm),
-			arg);
-
-	return res;
-}
-
-struct spl_fixed31_32 spl_fixpt_sin(struct spl_fixed31_32 arg)
-{
-	return spl_fixpt_mul(
-		arg,
-		spl_fixpt_sinc(arg));
-}
-
-struct spl_fixed31_32 spl_fixpt_cos(struct spl_fixed31_32 arg)
-{
-	/* TODO implement argument normalization */
-
-	const struct spl_fixed31_32 square = spl_fixpt_sqr(arg);
-
-	struct spl_fixed31_32 res = spl_fixpt_one;
-
-	int n = 26;
-
-	do {
-		res = spl_fixpt_sub(
-			spl_fixpt_one,
-			spl_fixpt_div_int(
-				spl_fixpt_mul(
-					square,
-					res),
-				n * (n - 1)));
-
-		n -= 2;
-	} while (n != 0);
-
-	return res;
-}
-
-/*
- * @brief
- * result = exp(arg),
- * where abs(arg) < 1
- *
- * Calculated as Taylor series.
- */
-static struct spl_fixed31_32 spl_fixed31_32_exp_from_taylor_series(struct spl_fixed31_32 arg)
-{
-	unsigned int n = 9;
-
-	struct spl_fixed31_32 res = spl_fixpt_from_fraction(
-		n + 2,
-		n + 1);
-	/* TODO find correct res */
-
-	SPL_ASSERT(spl_fixpt_lt(arg, spl_fixpt_one));
-
-	do
-		res = spl_fixpt_add(
-			spl_fixpt_one,
-			spl_fixpt_div_int(
-				spl_fixpt_mul(
-					arg,
-					res),
-				n));
-	while (--n != 1);
-
-	return spl_fixpt_add(
-		spl_fixpt_one,
-		spl_fixpt_mul(
-			arg,
-			res));
-}
-
-struct spl_fixed31_32 spl_fixpt_exp(struct spl_fixed31_32 arg)
-{
-	/*
-	 * @brief
-	 * Main equation is:
-	 * exp(x) = exp(r + m * ln(2)) = (1 << m) * exp(r),
-	 * where m = round(x / ln(2)), r = x - m * ln(2)
-	 */
-
-	if (spl_fixpt_le(
-		spl_fixpt_ln2_div_2,
-		spl_fixpt_abs(arg))) {
-		int m = spl_fixpt_round(
-			spl_fixpt_div(
-				arg,
-				spl_fixpt_ln2));
-
-		struct spl_fixed31_32 r = spl_fixpt_sub(
-			arg,
-			spl_fixpt_mul_int(
-				spl_fixpt_ln2,
-				m));
-
-		SPL_ASSERT(m != 0);
-
-		SPL_ASSERT(spl_fixpt_lt(
-			spl_fixpt_abs(r),
-			spl_fixpt_one));
-
-		if (m > 0)
-			return spl_fixpt_shl(
-				spl_fixed31_32_exp_from_taylor_series(r),
-				(unsigned char)m);
-		else
-			return spl_fixpt_div_int(
-				spl_fixed31_32_exp_from_taylor_series(r),
-				1LL << -m);
-	} else if (arg.value != 0)
-		return spl_fixed31_32_exp_from_taylor_series(arg);
-	else
-		return spl_fixpt_one;
-}
-
-struct spl_fixed31_32 spl_fixpt_log(struct spl_fixed31_32 arg)
-{
-	struct spl_fixed31_32 res = spl_fixpt_neg(spl_fixpt_one);
-	/* TODO improve 1st estimation */
-
-	struct spl_fixed31_32 error;
-
-	SPL_ASSERT(arg.value > 0);
-	/* TODO if arg is negative, return NaN */
-	/* TODO if arg is zero, return -INF */
-
-	do {
-		struct spl_fixed31_32 res1 = spl_fixpt_add(
-			spl_fixpt_sub(
-				res,
-				spl_fixpt_one),
-			spl_fixpt_div(
-				arg,
-				spl_fixpt_exp(res)));
-
-		error = spl_fixpt_sub(
-			res,
-			res1);
-
-		res = res1;
-		/* TODO determine max_allowed_error based on quality of exp() */
-	} while (abs_i64(error.value) > 100ULL);
-
-	return res;
-}
-
-
-/* this function is a generic helper to translate fixed point value to
- * specified integer format that will consist of integer_bits integer part and
- * fractional_bits fractional part. For example it is used in
- * spl_fixpt_u2d19 to receive 2 bits integer part and 19 bits fractional
- * part in 32 bits. It is used in hw programming (scaler)
- */
-
-static inline unsigned int spl_ux_dy(
-	long long value,
-	unsigned int integer_bits,
-	unsigned int fractional_bits)
-{
-	/* 1. create mask of integer part */
-	unsigned int result = (1 << integer_bits) - 1;
-	/* 2. mask out fractional part */
-	unsigned int fractional_part = FRACTIONAL_PART_MASK & value;
-	/* 3. shrink fixed point integer part to be of integer_bits width*/
-	result &= GET_INTEGER_PART(value);
-	/* 4. make space for fractional part to be filled in after integer */
-	result <<= fractional_bits;
-	/* 5. shrink fixed point fractional part to of fractional_bits width*/
-	fractional_part >>= FIXED31_32_BITS_PER_FRACTIONAL_PART - fractional_bits;
-	/* 6. merge the result */
-	return result | fractional_part;
-}
-
-static inline unsigned int spl_clamp_ux_dy(
-	long long value,
-	unsigned int integer_bits,
-	unsigned int fractional_bits,
-	unsigned int min_clamp)
-{
-	unsigned int truncated_val = spl_ux_dy(value, integer_bits, fractional_bits);
-
-	if (value >= (1LL << (integer_bits + FIXED31_32_BITS_PER_FRACTIONAL_PART)))
-		return (1 << (integer_bits + fractional_bits)) - 1;
-	else if (truncated_val > min_clamp)
-		return truncated_val;
-	else
-		return min_clamp;
-}
-
-unsigned int spl_fixpt_u4d19(struct spl_fixed31_32 arg)
-{
-	return spl_ux_dy(arg.value, 4, 19);
-}
-
-unsigned int spl_fixpt_u3d19(struct spl_fixed31_32 arg)
-{
-	return spl_ux_dy(arg.value, 3, 19);
-}
-
-unsigned int spl_fixpt_u2d19(struct spl_fixed31_32 arg)
-{
-	return spl_ux_dy(arg.value, 2, 19);
-}
-
-unsigned int spl_fixpt_u0d19(struct spl_fixed31_32 arg)
-{
-	return spl_ux_dy(arg.value, 0, 19);
-}
-
-unsigned int spl_fixpt_clamp_u0d14(struct spl_fixed31_32 arg)
-{
-	return spl_clamp_ux_dy(arg.value, 0, 14, 1);
-}
-
-unsigned int spl_fixpt_clamp_u0d10(struct spl_fixed31_32 arg)
-{
-	return spl_clamp_ux_dy(arg.value, 0, 10, 1);
-}
-
-int spl_fixpt_s4d19(struct spl_fixed31_32 arg)
-{
-	if (arg.value < 0)
-		return -(int)spl_ux_dy(spl_fixpt_abs(arg).value, 4, 19);
-	else
-		return spl_ux_dy(arg.value, 4, 19);
-}
-
-struct spl_fixed31_32 spl_fixpt_from_ux_dy(unsigned int value,
-	unsigned int integer_bits,
-	unsigned int fractional_bits)
-{
-	struct spl_fixed31_32 fixpt_value = spl_fixpt_zero;
-	struct spl_fixed31_32 fixpt_int_value = spl_fixpt_zero;
-	long long frac_mask = ((long long)1 << (long long)integer_bits) - 1;
-
-	fixpt_value.value = (long long)value << (FIXED31_32_BITS_PER_FRACTIONAL_PART - fractional_bits);
-	frac_mask = frac_mask << fractional_bits;
-	fixpt_int_value.value = value & frac_mask;
-	fixpt_int_value.value <<= (FIXED31_32_BITS_PER_FRACTIONAL_PART - fractional_bits);
-	fixpt_value.value |= fixpt_int_value.value;
-	return fixpt_value;
-}
-
-struct spl_fixed31_32 spl_fixpt_from_int_dy(unsigned int int_value,
-	unsigned int frac_value,
-	unsigned int integer_bits,
-	unsigned int fractional_bits)
-{
-	struct spl_fixed31_32 fixpt_value = spl_fixpt_from_int(int_value);
-
-	fixpt_value.value |= (long long)frac_value << (FIXED31_32_BITS_PER_FRACTIONAL_PART - fractional_bits);
-	return fixpt_value;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/spl/spl_fixpt31_32.h b/drivers/gpu/drm/amd/display/dc/spl/spl_fixpt31_32.h
deleted file mode 100644
index ed2647f9a099..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/spl_fixpt31_32.h
+++ /dev/null
@@ -1,522 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-
-/* Copyright 2024 Advanced Micro Devices, Inc. */
-
-#ifndef __SPL_FIXED31_32_H__
-#define __SPL_FIXED31_32_H__
-
-#include "spl_debug.h"
-#include "spl_os_types.h"   // swap
-
-#ifndef LLONG_MAX
-#define LLONG_MAX 9223372036854775807ll
-#endif
-#ifndef LLONG_MIN
-#define LLONG_MIN (-LLONG_MAX - 1ll)
-#endif
-
-#define FIXED31_32_BITS_PER_FRACTIONAL_PART 32
-#ifndef LLONG_MIN
-#define LLONG_MIN (1LL<<63)
-#endif
-#ifndef LLONG_MAX
-#define LLONG_MAX (-1LL>>1)
-#endif
-
-/*
- * @brief
- * Arithmetic operations on real numbers
- * represented as fixed-point numbers.
- * There are: 1 bit for sign,
- * 31 bit for integer part,
- * 32 bits for fractional part.
- *
- * @note
- * Currently, overflows and underflows are asserted;
- * no special result returned.
- */
-
-struct spl_fixed31_32 {
-	long long value;
-};
-
-
-/*
- * @brief
- * Useful constants
- */
-
-static const struct spl_fixed31_32 spl_fixpt_zero = { 0 };
-static const struct spl_fixed31_32 spl_fixpt_epsilon = { 1LL };
-static const struct spl_fixed31_32 spl_fixpt_half = { 0x80000000LL };
-static const struct spl_fixed31_32 spl_fixpt_one = { 0x100000000LL };
-
-/*
- * @brief
- * Initialization routines
- */
-
-/*
- * @brief
- * result = numerator / denominator
- */
-struct spl_fixed31_32 spl_fixpt_from_fraction(long long numerator, long long denominator);
-
-/*
- * @brief
- * result = arg
- */
-static inline struct spl_fixed31_32 spl_fixpt_from_int(int arg)
-{
-	struct spl_fixed31_32 res;
-
-	res.value = (long long) arg << FIXED31_32_BITS_PER_FRACTIONAL_PART;
-
-	return res;
-}
-
-/*
- * @brief
- * Unary operators
- */
-
-/*
- * @brief
- * result = -arg
- */
-static inline struct spl_fixed31_32 spl_fixpt_neg(struct spl_fixed31_32 arg)
-{
-	struct spl_fixed31_32 res;
-
-	res.value = -arg.value;
-
-	return res;
-}
-
-/*
- * @brief
- * result = abs(arg) := (arg >= 0) ? arg : -arg
- */
-static inline struct spl_fixed31_32 spl_fixpt_abs(struct spl_fixed31_32 arg)
-{
-	if (arg.value < 0)
-		return spl_fixpt_neg(arg);
-	else
-		return arg;
-}
-
-/*
- * @brief
- * Binary relational operators
- */
-
-/*
- * @brief
- * result = arg1 < arg2
- */
-static inline bool spl_fixpt_lt(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	return arg1.value < arg2.value;
-}
-
-/*
- * @brief
- * result = arg1 <= arg2
- */
-static inline bool spl_fixpt_le(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	return arg1.value <= arg2.value;
-}
-
-/*
- * @brief
- * result = arg1 == arg2
- */
-static inline bool spl_fixpt_eq(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	return arg1.value == arg2.value;
-}
-
-/*
- * @brief
- * result = min(arg1, arg2) := (arg1 <= arg2) ? arg1 : arg2
- */
-static inline struct spl_fixed31_32 spl_fixpt_min(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	if (arg1.value <= arg2.value)
-		return arg1;
-	else
-		return arg2;
-}
-
-/*
- * @brief
- * result = max(arg1, arg2) := (arg1 <= arg2) ? arg2 : arg1
- */
-static inline struct spl_fixed31_32 spl_fixpt_max(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	if (arg1.value <= arg2.value)
-		return arg2;
-	else
-		return arg1;
-}
-
-/*
- * @brief
- *          | min_value, when arg <= min_value
- * result = | arg, when min_value < arg < max_value
- *          | max_value, when arg >= max_value
- */
-static inline struct spl_fixed31_32 spl_fixpt_clamp(
-	struct spl_fixed31_32 arg,
-	struct spl_fixed31_32 min_value,
-	struct spl_fixed31_32 max_value)
-{
-	if (spl_fixpt_le(arg, min_value))
-		return min_value;
-	else if (spl_fixpt_le(max_value, arg))
-		return max_value;
-	else
-		return arg;
-}
-
-/*
- * @brief
- * Binary shift operators
- */
-
-/*
- * @brief
- * result = arg << shift
- */
-static inline struct spl_fixed31_32 spl_fixpt_shl(struct spl_fixed31_32 arg, unsigned char shift)
-{
-	SPL_ASSERT(((arg.value >= 0) && (arg.value <= LLONG_MAX >> shift)) ||
-		((arg.value < 0) && (arg.value >= ~(LLONG_MAX >> shift))));
-
-	arg.value = arg.value << shift;
-
-	return arg;
-}
-
-/*
- * @brief
- * result = arg >> shift
- */
-static inline struct spl_fixed31_32 spl_fixpt_shr(struct spl_fixed31_32 arg, unsigned char shift)
-{
-	bool negative = arg.value < 0;
-
-	if (negative)
-		arg.value = -arg.value;
-	arg.value = arg.value >> shift;
-	if (negative)
-		arg.value = -arg.value;
-	return arg;
-}
-
-/*
- * @brief
- * Binary additive operators
- */
-
-/*
- * @brief
- * result = arg1 + arg2
- */
-static inline struct spl_fixed31_32 spl_fixpt_add(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	struct spl_fixed31_32 res;
-
-	SPL_ASSERT(((arg1.value >= 0) && (LLONG_MAX - arg1.value >= arg2.value)) ||
-		((arg1.value < 0) && (LLONG_MIN - arg1.value <= arg2.value)));
-
-	res.value = arg1.value + arg2.value;
-
-	return res;
-}
-
-/*
- * @brief
- * result = arg1 + arg2
- */
-static inline struct spl_fixed31_32 spl_fixpt_add_int(struct spl_fixed31_32 arg1, int arg2)
-{
-	return spl_fixpt_add(arg1, spl_fixpt_from_int(arg2));
-}
-
-/*
- * @brief
- * result = arg1 - arg2
- */
-static inline struct spl_fixed31_32 spl_fixpt_sub(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	struct spl_fixed31_32 res;
-
-	SPL_ASSERT(((arg2.value >= 0) && (LLONG_MIN + arg2.value <= arg1.value)) ||
-		((arg2.value < 0) && (LLONG_MAX + arg2.value >= arg1.value)));
-
-	res.value = arg1.value - arg2.value;
-
-	return res;
-}
-
-/*
- * @brief
- * result = arg1 - arg2
- */
-static inline struct spl_fixed31_32 spl_fixpt_sub_int(struct spl_fixed31_32 arg1, int arg2)
-{
-	return spl_fixpt_sub(arg1, spl_fixpt_from_int(arg2));
-}
-
-
-/*
- * @brief
- * Binary multiplicative operators
- */
-
-/*
- * @brief
- * result = arg1 * arg2
- */
-struct spl_fixed31_32 spl_fixpt_mul(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2);
-
-
-/*
- * @brief
- * result = arg1 * arg2
- */
-static inline struct spl_fixed31_32 spl_fixpt_mul_int(struct spl_fixed31_32 arg1, int arg2)
-{
-	return spl_fixpt_mul(arg1, spl_fixpt_from_int(arg2));
-}
-
-/*
- * @brief
- * result = square(arg) := arg * arg
- */
-struct spl_fixed31_32 spl_fixpt_sqr(struct spl_fixed31_32 arg);
-
-/*
- * @brief
- * result = arg1 / arg2
- */
-static inline struct spl_fixed31_32 spl_fixpt_div_int(struct spl_fixed31_32 arg1, long long arg2)
-{
-	return spl_fixpt_from_fraction(arg1.value, spl_fixpt_from_int((int)arg2).value);
-}
-
-/*
- * @brief
- * result = arg1 / arg2
- */
-static inline struct spl_fixed31_32 spl_fixpt_div(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	return spl_fixpt_from_fraction(arg1.value, arg2.value);
-}
-
-/*
- * @brief
- * Reciprocal function
- */
-
-/*
- * @brief
- * result = reciprocal(arg) := 1 / arg
- *
- * @note
- * No special actions taken in case argument is zero.
- */
-struct spl_fixed31_32 spl_fixpt_recip(struct spl_fixed31_32 arg);
-
-/*
- * @brief
- * Trigonometric functions
- */
-
-/*
- * @brief
- * result = sinc(arg) := sin(arg) / arg
- *
- * @note
- * Argument specified in radians,
- * internally it's normalized to [-2pi...2pi] range.
- */
-struct spl_fixed31_32 spl_fixpt_sinc(struct spl_fixed31_32 arg);
-
-/*
- * @brief
- * result = sin(arg)
- *
- * @note
- * Argument specified in radians,
- * internally it's normalized to [-2pi...2pi] range.
- */
-struct spl_fixed31_32 spl_fixpt_sin(struct spl_fixed31_32 arg);
-
-/*
- * @brief
- * result = cos(arg)
- *
- * @note
- * Argument specified in radians
- * and should be in [-2pi...2pi] range -
- * passing arguments outside that range
- * will cause incorrect result!
- */
-struct spl_fixed31_32 spl_fixpt_cos(struct spl_fixed31_32 arg);
-
-/*
- * @brief
- * Transcendent functions
- */
-
-/*
- * @brief
- * result = exp(arg)
- *
- * @note
- * Currently, function is verified for abs(arg) <= 1.
- */
-struct spl_fixed31_32 spl_fixpt_exp(struct spl_fixed31_32 arg);
-
-/*
- * @brief
- * result = log(arg)
- *
- * @note
- * Currently, abs(arg) should be less than 1.
- * No normalization is done.
- * Currently, no special actions taken
- * in case of invalid argument(s). Take care!
- */
-struct spl_fixed31_32 spl_fixpt_log(struct spl_fixed31_32 arg);
-
-/*
- * @brief
- * Power function
- */
-
-/*
- * @brief
- * result = pow(arg1, arg2)
- *
- * @note
- * Currently, abs(arg1) should be less than 1. Take care!
- */
-static inline struct spl_fixed31_32 spl_fixpt_pow(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
-{
-	if (arg1.value == 0)
-		return arg2.value == 0 ? spl_fixpt_one : spl_fixpt_zero;
-
-	return spl_fixpt_exp(
-		spl_fixpt_mul(
-			spl_fixpt_log(arg1),
-			arg2));
-}
-
-/*
- * @brief
- * Rounding functions
- */
-
-/*
- * @brief
- * result = floor(arg) := greatest integer lower than or equal to arg
- */
-static inline int spl_fixpt_floor(struct spl_fixed31_32 arg)
-{
-	unsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;
-
-	if (arg.value >= 0)
-		return (int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
-	else
-		return -(int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
-}
-
-/*
- * @brief
- * result = round(arg) := integer nearest to arg
- */
-static inline int spl_fixpt_round(struct spl_fixed31_32 arg)
-{
-	unsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;
-
-	const long long summand = spl_fixpt_half.value;
-
-	SPL_ASSERT(LLONG_MAX - (long long)arg_value >= summand);
-
-	arg_value += summand;
-
-	if (arg.value >= 0)
-		return (int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
-	else
-		return -(int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
-}
-
-/*
- * @brief
- * result = ceil(arg) := lowest integer greater than or equal to arg
- */
-static inline int spl_fixpt_ceil(struct spl_fixed31_32 arg)
-{
-	unsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;
-
-	const long long summand = spl_fixpt_one.value -
-		spl_fixpt_epsilon.value;
-
-	SPL_ASSERT(LLONG_MAX - (long long)arg_value >= summand);
-
-	arg_value += summand;
-
-	if (arg.value >= 0)
-		return (int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
-	else
-		return -(int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
-}
-
-/* the following two function are used in scaler hw programming to convert fixed
- * point value to format 2 bits from integer part and 19 bits from fractional
- * part. The same applies for u0d19, 0 bits from integer part and 19 bits from
- * fractional
- */
-
-unsigned int spl_fixpt_u4d19(struct spl_fixed31_32 arg);
-
-unsigned int spl_fixpt_u3d19(struct spl_fixed31_32 arg);
-
-unsigned int spl_fixpt_u2d19(struct spl_fixed31_32 arg);
-
-unsigned int spl_fixpt_u0d19(struct spl_fixed31_32 arg);
-
-unsigned int spl_fixpt_clamp_u0d14(struct spl_fixed31_32 arg);
-
-unsigned int spl_fixpt_clamp_u0d10(struct spl_fixed31_32 arg);
-
-int spl_fixpt_s4d19(struct spl_fixed31_32 arg);
-
-static inline struct spl_fixed31_32 spl_fixpt_truncate(struct spl_fixed31_32 arg, unsigned int frac_bits)
-{
-	bool negative = arg.value < 0;
-
-	if (frac_bits >= FIXED31_32_BITS_PER_FRACTIONAL_PART) {
-		SPL_ASSERT(frac_bits == FIXED31_32_BITS_PER_FRACTIONAL_PART);
-		return arg;
-	}
-
-	if (negative)
-		arg.value = -arg.value;
-	arg.value &= (~0ULL) << (FIXED31_32_BITS_PER_FRACTIONAL_PART - frac_bits);
-	if (negative)
-		arg.value = -arg.value;
-	return arg;
-}
-
-struct spl_fixed31_32 spl_fixpt_from_ux_dy(unsigned int value, unsigned int integer_bits, unsigned int fractional_bits);
-struct spl_fixed31_32 spl_fixpt_from_int_dy(unsigned int int_value,
-		unsigned int frac_value,
-		unsigned int integer_bits,
-		unsigned int fractional_bits);
-
-#endif
diff --git a/drivers/gpu/drm/amd/display/dc/spl/spl_os_types.h b/drivers/gpu/drm/amd/display/dc/spl/spl_os_types.h
deleted file mode 100644
index 2e6ba71960ac..000000000000
--- a/drivers/gpu/drm/amd/display/dc/spl/spl_os_types.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-
-/* Copyright 2024 Advanced Micro Devices, Inc. */
-/* Copyright 2019 Raptor Engineering, LLC */
-
-#ifndef _SPL_OS_TYPES_H_
-#define _SPL_OS_TYPES_H_
-
-#include "spl_debug.h"
-
-#include <linux/slab.h>
-#include <linux/kgdb.h>
-#include <linux/kref.h>
-#include <linux/types.h>
-#include <linux/delay.h>
-#include <linux/mm.h>
-
-/*
- *
- * general debug capabilities
- *
- */
-
-static inline uint64_t spl_div_u64_rem(uint64_t dividend, uint32_t divisor, uint32_t *remainder)
-{
-	return div_u64_rem(dividend, divisor, remainder);
-}
-
-static inline uint64_t spl_div_u64(uint64_t dividend, uint32_t divisor)
-{
-	return div_u64(dividend, divisor);
-}
-
-static inline uint64_t spl_div64_u64(uint64_t dividend, uint64_t divisor)
-{
-	return div64_u64(dividend, divisor);
-}
-
-static inline uint64_t spl_div64_u64_rem(uint64_t dividend, uint64_t divisor, uint64_t *remainder)
-{
-	return div64_u64_rem(dividend, divisor, remainder);
-}
-
-static inline int64_t spl_div64_s64(int64_t dividend, int64_t divisor)
-{
-	return div64_s64(dividend, divisor);
-}
-
-#define spl_swap(a, b) \
-	do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)
-
-#ifndef spl_min
-#define spl_min(a, b)    (((a) < (b)) ? (a):(b))
-#endif
-
-#endif /* _SPL_OS_TYPES_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/Makefile b/drivers/gpu/drm/amd/display/dc/sspl/Makefile
new file mode 100644
index 000000000000..5e3e4aa13820
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/Makefile
@@ -0,0 +1,33 @@
+#
+# Copyright 2017 Advanced Micro Devices, Inc.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files (the "Software"),
+# to deal in the Software without restriction, including without limitation
+# the rights to use, copy, modify, merge, publish, distribute, sublicense,
+# and/or sell copies of the Software, and to permit persons to whom the
+# Software is furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+# THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+# OTHER DEALINGS IN THE SOFTWARE.
+#
+#
+# Makefile for the 'spl' sub-component of DAL.
+# It provides the scaling library interface.
+
+SPL = dc_spl.o dc_spl_scl_filters.o dc_spl_scl_easf_filters.o dc_spl_isharp_filters.o dc_spl_filters.o spl_fixpt31_32.o spl_custom_float.o
+
+AMD_DAL_SPL = $(addprefix $(AMDDALPATH)/dc/sspl/,$(SPL))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_SPL)
+
+
+
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl.c b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl.c
new file mode 100644
index 000000000000..38a9a0d68058
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl.c
@@ -0,0 +1,1874 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#include "dc_spl.h"
+#include "dc_spl_scl_filters.h"
+#include "dc_spl_scl_easf_filters.h"
+#include "dc_spl_isharp_filters.h"
+#include "spl_debug.h"
+
+#define IDENTITY_RATIO(ratio) (spl_fixpt_u2d19(ratio) == (1 << 19))
+#define MIN_VIEWPORT_SIZE 12
+
+static bool spl_is_yuv420(enum spl_pixel_format format)
+{
+	if ((format >= SPL_PIXEL_FORMAT_420BPP8) &&
+		(format <= SPL_PIXEL_FORMAT_420BPP10))
+		return true;
+
+	return false;
+}
+
+static bool spl_is_rgb8(enum spl_pixel_format format)
+{
+	if (format == SPL_PIXEL_FORMAT_ARGB8888)
+		return true;
+
+	return false;
+}
+
+static bool spl_is_video_format(enum spl_pixel_format format)
+{
+	if (format >= SPL_PIXEL_FORMAT_VIDEO_BEGIN
+		&& format <= SPL_PIXEL_FORMAT_VIDEO_END)
+		return true;
+	else
+		return false;
+}
+
+static bool spl_is_subsampled_format(enum spl_pixel_format format)
+{
+	if (format >= SPL_PIXEL_FORMAT_SUBSAMPLED_BEGIN
+		&& format <= SPL_PIXEL_FORMAT_SUBSAMPLED_END)
+		return true;
+	else
+		return false;
+}
+
+static struct spl_rect intersect_rec(const struct spl_rect *r0, const struct spl_rect *r1)
+{
+	struct spl_rect rec;
+	int r0_x_end = r0->x + r0->width;
+	int r1_x_end = r1->x + r1->width;
+	int r0_y_end = r0->y + r0->height;
+	int r1_y_end = r1->y + r1->height;
+
+	rec.x = r0->x > r1->x ? r0->x : r1->x;
+	rec.width = r0_x_end > r1_x_end ? r1_x_end - rec.x : r0_x_end - rec.x;
+	rec.y = r0->y > r1->y ? r0->y : r1->y;
+	rec.height = r0_y_end > r1_y_end ? r1_y_end - rec.y : r0_y_end - rec.y;
+
+	/* in case that there is no intersection */
+	if (rec.width < 0 || rec.height < 0)
+		memset(&rec, 0, sizeof(rec));
+
+	return rec;
+}
+
+static struct spl_rect shift_rec(const struct spl_rect *rec_in, int x, int y)
+{
+	struct spl_rect rec_out = *rec_in;
+
+	rec_out.x += x;
+	rec_out.y += y;
+
+	return rec_out;
+}
+
+static struct spl_rect calculate_plane_rec_in_timing_active(
+		struct spl_in *spl_in,
+		const struct spl_rect *rec_in)
+{
+	/*
+	 * The following diagram shows an example where we map a 1920x1200
+	 * desktop to a 2560x1440 timing with a plane rect in the middle
+	 * of the screen. To map a plane rect from Stream Source to Timing
+	 * Active space, we first multiply stream scaling ratios (i.e 2304/1920
+	 * horizontal and 1440/1200 vertical) to the plane's x and y, then
+	 * we add stream destination offsets (i.e 128 horizontal, 0 vertical).
+	 * This will give us a plane rect's position in Timing Active. However
+	 * we have to remove the fractional. The rule is that we find left/right
+	 * and top/bottom positions and round the value to the adjacent integer.
+	 *
+	 * Stream Source Space
+	 * ------------
+	 *        __________________________________________________
+	 *       |Stream Source (1920 x 1200) ^                     |
+	 *       |                            y                     |
+	 *       |         <------- w --------|>                    |
+	 *       |          __________________V                     |
+	 *       |<-- x -->|Plane//////////////| ^                  |
+	 *       |         |(pre scale)////////| |                  |
+	 *       |         |///////////////////| |                  |
+	 *       |         |///////////////////| h                  |
+	 *       |         |///////////////////| |                  |
+	 *       |         |///////////////////| |                  |
+	 *       |         |///////////////////| V                  |
+	 *       |                                                  |
+	 *       |                                                  |
+	 *       |__________________________________________________|
+	 *
+	 *
+	 * Timing Active Space
+	 * ---------------------------------
+	 *
+	 *       Timing Active (2560 x 1440)
+	 *        __________________________________________________
+	 *       |*****|  Stteam Destination (2304 x 1440)    |*****|
+	 *       |*****|                                      |*****|
+	 *       |<128>|                                      |*****|
+	 *       |*****|     __________________               |*****|
+	 *       |*****|    |Plane/////////////|              |*****|
+	 *       |*****|    |(post scale)//////|              |*****|
+	 *       |*****|    |//////////////////|              |*****|
+	 *       |*****|    |//////////////////|              |*****|
+	 *       |*****|    |//////////////////|              |*****|
+	 *       |*****|    |//////////////////|              |*****|
+	 *       |*****|                                      |*****|
+	 *       |*****|                                      |*****|
+	 *       |*****|                                      |*****|
+	 *       |*****|______________________________________|*****|
+	 *
+	 * So the resulting formulas are shown below:
+	 *
+	 * recout_x = 128 + round(plane_x * 2304 / 1920)
+	 * recout_w = 128 + round((plane_x + plane_w) * 2304 / 1920) - recout_x
+	 * recout_y = 0 + round(plane_y * 1440 / 1200)
+	 * recout_h = 0 + round((plane_y + plane_h) * 1440 / 1200) - recout_y
+	 *
+	 * NOTE: fixed point division is not error free. To reduce errors
+	 * introduced by fixed point division, we divide only after
+	 * multiplication is complete.
+	 */
+	const struct spl_rect *stream_src = &spl_in->basic_out.src_rect;
+	const struct spl_rect *stream_dst = &spl_in->basic_out.dst_rect;
+	struct spl_rect rec_out = {0};
+	struct spl_fixed31_32 temp;
+
+
+	temp = spl_fixpt_from_fraction(rec_in->x * (long long)stream_dst->width,
+			stream_src->width);
+	rec_out.x = stream_dst->x + spl_fixpt_round(temp);
+
+	temp = spl_fixpt_from_fraction(
+			(rec_in->x + rec_in->width) * (long long)stream_dst->width,
+			stream_src->width);
+	rec_out.width = stream_dst->x + spl_fixpt_round(temp) - rec_out.x;
+
+	temp = spl_fixpt_from_fraction(rec_in->y * (long long)stream_dst->height,
+			stream_src->height);
+	rec_out.y = stream_dst->y + spl_fixpt_round(temp);
+
+	temp = spl_fixpt_from_fraction(
+			(rec_in->y + rec_in->height) * (long long)stream_dst->height,
+			stream_src->height);
+	rec_out.height = stream_dst->y + spl_fixpt_round(temp) - rec_out.y;
+
+	return rec_out;
+}
+
+static struct spl_rect calculate_mpc_slice_in_timing_active(
+		struct spl_in *spl_in,
+		struct spl_rect *plane_clip_rec)
+{
+	bool use_recout_width_aligned =
+		spl_in->basic_in.num_h_slices_recout_width_align.use_recout_width_aligned;
+	int mpc_slice_count =
+		spl_in->basic_in.num_h_slices_recout_width_align.num_slices_recout_width.mpc_num_h_slices;
+	int recout_width_align =
+		spl_in->basic_in.num_h_slices_recout_width_align.num_slices_recout_width.mpc_recout_width_align;
+	int mpc_slice_idx = spl_in->basic_in.mpc_h_slice_index;
+	int epimo = mpc_slice_count - plane_clip_rec->width % mpc_slice_count - 1;
+	struct spl_rect mpc_rec;
+
+	if (use_recout_width_aligned) {
+		mpc_rec.width = recout_width_align;
+		if ((mpc_rec.width * (mpc_slice_idx + 1)) > plane_clip_rec->width) {
+			mpc_rec.width = plane_clip_rec->width % recout_width_align;
+			mpc_rec.x = plane_clip_rec->x + recout_width_align * mpc_slice_idx;
+		} else
+			mpc_rec.x = plane_clip_rec->x + mpc_rec.width * mpc_slice_idx;
+		mpc_rec.height = plane_clip_rec->height;
+		mpc_rec.y = plane_clip_rec->y;
+
+	} else {
+		mpc_rec.width = plane_clip_rec->width / mpc_slice_count;
+		mpc_rec.x = plane_clip_rec->x + mpc_rec.width * mpc_slice_idx;
+		mpc_rec.height = plane_clip_rec->height;
+		mpc_rec.y = plane_clip_rec->y;
+	}
+	SPL_ASSERT(mpc_slice_count == 1 ||
+			spl_in->basic_out.view_format != SPL_VIEW_3D_SIDE_BY_SIDE ||
+			mpc_rec.width % 2 == 0);
+
+	/* extra pixels in the division remainder need to go to pipes after
+	 * the extra pixel index minus one(epimo) defined here as:
+	 */
+	if (mpc_slice_idx > epimo) {
+		mpc_rec.x += mpc_slice_idx - epimo - 1;
+		mpc_rec.width += 1;
+	}
+
+	if (spl_in->basic_out.view_format == SPL_VIEW_3D_TOP_AND_BOTTOM) {
+		SPL_ASSERT(mpc_rec.height % 2 == 0);
+		mpc_rec.height /= 2;
+	}
+	return mpc_rec;
+}
+
+static struct spl_rect calculate_odm_slice_in_timing_active(struct spl_in *spl_in)
+{
+	int odm_slice_count = spl_in->basic_out.odm_combine_factor;
+	int odm_slice_idx = spl_in->odm_slice_index;
+	bool is_last_odm_slice = (odm_slice_idx + 1) == odm_slice_count;
+	int h_active = spl_in->basic_out.output_size.width;
+	int v_active = spl_in->basic_out.output_size.height;
+	int odm_slice_width;
+	struct spl_rect odm_rec;
+
+	if (spl_in->basic_out.odm_combine_factor > 0) {
+		odm_slice_width = h_active / odm_slice_count;
+		/*
+		 * deprecated, caller must pass in odm slice rect i.e OPP input
+		 * rect in timing active for the new interface.
+		 */
+		if (spl_in->basic_out.use_two_pixels_per_container && (odm_slice_width % 2))
+			odm_slice_width++;
+
+		odm_rec.x = odm_slice_width * odm_slice_idx;
+		odm_rec.width = is_last_odm_slice ?
+				/* last slice width is the reminder of h_active */
+				h_active - odm_slice_width * (odm_slice_count - 1) :
+				/* odm slice width is the floor of h_active / count */
+				odm_slice_width;
+		odm_rec.y = 0;
+		odm_rec.height = v_active;
+
+		return odm_rec;
+	}
+
+	return spl_in->basic_out.odm_slice_rect;
+}
+
+static void spl_calculate_recout(struct spl_in *spl_in, struct spl_scratch *spl_scratch, struct spl_out *spl_out)
+{
+	/*
+	 * A plane clip represents the desired plane size and position in Stream
+	 * Source Space. Stream Source is the destination where all planes are
+	 * blended (i.e. positioned, scaled and overlaid). It is a canvas where
+	 * all planes associated with the current stream are drawn together.
+	 * After Stream Source is completed, we will further scale and
+	 * reposition the entire canvas of the stream source to Stream
+	 * Destination in Timing Active Space. This could be due to display
+	 * overscan adjustment where we will need to rescale and reposition all
+	 * the planes so they can fit into a TV with overscan or downscale
+	 * upscale features such as GPU scaling or VSR.
+	 *
+	 * This two step blending is a virtual procedure in software. In
+	 * hardware there is no such thing as Stream Source. all planes are
+	 * blended once in Timing Active Space. Software virtualizes a Stream
+	 * Source space to decouple the math complicity so scaling param
+	 * calculation focuses on one step at a time.
+	 *
+	 * In the following two diagrams, user applied 10% overscan adjustment
+	 * so the Stream Source needs to be scaled down a little before mapping
+	 * to Timing Active Space. As a result the Plane Clip is also scaled
+	 * down by the same ratio, Plane Clip position (i.e. x and y) with
+	 * respect to Stream Source is also scaled down. To map it in Timing
+	 * Active Space additional x and y offsets from Stream Destination are
+	 * added to Plane Clip as well.
+	 *
+	 * Stream Source Space
+	 * ------------
+	 *        __________________________________________________
+	 *       |Stream Source (3840 x 2160) ^                     |
+	 *       |                            y                     |
+	 *       |                            |                     |
+	 *       |          __________________V                     |
+	 *       |<-- x -->|Plane Clip/////////|                    |
+	 *       |         |(pre scale)////////|                    |
+	 *       |         |///////////////////|                    |
+	 *       |         |///////////////////|                    |
+	 *       |         |///////////////////|                    |
+	 *       |         |///////////////////|                    |
+	 *       |         |///////////////////|                    |
+	 *       |                                                  |
+	 *       |                                                  |
+	 *       |__________________________________________________|
+	 *
+	 *
+	 * Timing Active Space (3840 x 2160)
+	 * ---------------------------------
+	 *
+	 *       Timing Active
+	 *        __________________________________________________
+	 *       | y_____________________________________________   |
+	 *       |x |Stream Destination (3456 x 1944)            |  |
+	 *       |  |                                            |  |
+	 *       |  |        __________________                  |  |
+	 *       |  |       |Plane Clip////////|                 |  |
+	 *       |  |       |(post scale)//////|                 |  |
+	 *       |  |       |//////////////////|                 |  |
+	 *       |  |       |//////////////////|                 |  |
+	 *       |  |       |//////////////////|                 |  |
+	 *       |  |       |//////////////////|                 |  |
+	 *       |  |                                            |  |
+	 *       |  |                                            |  |
+	 *       |  |____________________________________________|  |
+	 *       |__________________________________________________|
+	 *
+	 *
+	 * In Timing Active Space a plane clip could be further sliced into
+	 * pieces called MPC slices. Each Pipe Context is responsible for
+	 * processing only one MPC slice so the plane processing workload can be
+	 * distributed to multiple DPP Pipes. MPC slices could be blended
+	 * together to a single ODM slice. Each ODM slice is responsible for
+	 * processing a portion of Timing Active divided horizontally so the
+	 * output pixel processing workload can be distributed to multiple OPP
+	 * pipes. All ODM slices are mapped together in ODM block so all MPC
+	 * slices belong to different ODM slices could be pieced together to
+	 * form a single image in Timing Active. MPC slices must belong to
+	 * single ODM slice. If an MPC slice goes across ODM slice boundary, it
+	 * needs to be divided into two MPC slices one for each ODM slice.
+	 *
+	 * In the following diagram the output pixel processing workload is
+	 * divided horizontally into two ODM slices one for each OPP blend tree.
+	 * OPP0 blend tree is responsible for processing left half of Timing
+	 * Active, while OPP2 blend tree is responsible for processing right
+	 * half.
+	 *
+	 * The plane has two MPC slices. However since the right MPC slice goes
+	 * across ODM boundary, two DPP pipes are needed one for each OPP blend
+	 * tree. (i.e. DPP1 for OPP0 blend tree and DPP2 for OPP2 blend tree).
+	 *
+	 * Assuming that we have a Pipe Context associated with OPP0 and DPP1
+	 * working on processing the plane in the diagram. We want to know the
+	 * width and height of the shaded rectangle and its relative position
+	 * with respect to the ODM slice0. This is called the recout of the pipe
+	 * context.
+	 *
+	 * Planes can be at arbitrary size and position and there could be an
+	 * arbitrary number of MPC and ODM slices. The algorithm needs to take
+	 * all scenarios into account.
+	 *
+	 * Timing Active Space (3840 x 2160)
+	 * ---------------------------------
+	 *
+	 *       Timing Active
+	 *        __________________________________________________
+	 *       |OPP0(ODM slice0)^        |OPP2(ODM slice1)        |
+	 *       |                y        |                        |
+	 *       |                |  <- w ->                        |
+	 *       |           _____V________|____                    |
+	 *       |          |DPP0 ^  |DPP1 |DPP2|                   |
+	 *       |<------ x |-----|->|/////|    |                   |
+	 *       |          |     |  |/////|    |                   |
+	 *       |          |     h  |/////|    |                   |
+	 *       |          |     |  |/////|    |                   |
+	 *       |          |_____V__|/////|____|                   |
+	 *       |                         |                        |
+	 *       |                         |                        |
+	 *       |                         |                        |
+	 *       |_________________________|________________________|
+	 *
+	 *
+	 */
+	struct spl_rect plane_clip;
+	struct spl_rect mpc_slice_of_plane_clip;
+	struct spl_rect odm_slice;
+	struct spl_rect overlapping_area;
+
+	plane_clip = calculate_plane_rec_in_timing_active(spl_in,
+			&spl_in->basic_in.clip_rect);
+	/* guard plane clip from drawing beyond stream dst here */
+	plane_clip = intersect_rec(&plane_clip,
+				&spl_in->basic_out.dst_rect);
+	mpc_slice_of_plane_clip = calculate_mpc_slice_in_timing_active(
+			spl_in, &plane_clip);
+	odm_slice = calculate_odm_slice_in_timing_active(spl_in);
+	overlapping_area = intersect_rec(&mpc_slice_of_plane_clip, &odm_slice);
+
+	if (overlapping_area.height > 0 &&
+			overlapping_area.width > 0) {
+		/* shift the overlapping area so it is with respect to current
+		 * ODM slice's position
+		 */
+		spl_scratch->scl_data.recout = shift_rec(
+				&overlapping_area,
+				-odm_slice.x, -odm_slice.y);
+		spl_scratch->scl_data.recout.height -=
+			spl_in->debug.visual_confirm_base_offset;
+		spl_scratch->scl_data.recout.height -=
+			spl_in->debug.visual_confirm_dpp_offset;
+	} else
+		/* if there is no overlap, zero recout */
+		memset(&spl_scratch->scl_data.recout, 0,
+				sizeof(struct spl_rect));
+}
+
+/* Calculate scaling ratios */
+static void spl_calculate_scaling_ratios(struct spl_in *spl_in,
+		struct spl_scratch *spl_scratch,
+		struct spl_out *spl_out)
+{
+	const int in_w = spl_in->basic_out.src_rect.width;
+	const int in_h = spl_in->basic_out.src_rect.height;
+	const int out_w = spl_in->basic_out.dst_rect.width;
+	const int out_h = spl_in->basic_out.dst_rect.height;
+	struct spl_rect surf_src = spl_in->basic_in.src_rect;
+
+	/*Swap surf_src height and width since scaling ratios are in recout rotation*/
+	if (spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_90 ||
+		spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_270)
+		spl_swap(surf_src.height, surf_src.width);
+
+	spl_scratch->scl_data.ratios.horz = spl_fixpt_from_fraction(
+					surf_src.width,
+					spl_in->basic_in.dst_rect.width);
+	spl_scratch->scl_data.ratios.vert = spl_fixpt_from_fraction(
+					surf_src.height,
+					spl_in->basic_in.dst_rect.height);
+
+	if (spl_in->basic_out.view_format == SPL_VIEW_3D_SIDE_BY_SIDE)
+		spl_scratch->scl_data.ratios.horz.value *= 2;
+	else if (spl_in->basic_out.view_format == SPL_VIEW_3D_TOP_AND_BOTTOM)
+		spl_scratch->scl_data.ratios.vert.value *= 2;
+
+	spl_scratch->scl_data.ratios.vert.value = spl_div64_s64(
+		spl_scratch->scl_data.ratios.vert.value * in_h, out_h);
+	spl_scratch->scl_data.ratios.horz.value = spl_div64_s64(
+		spl_scratch->scl_data.ratios.horz.value * in_w, out_w);
+
+	spl_scratch->scl_data.ratios.horz_c = spl_scratch->scl_data.ratios.horz;
+	spl_scratch->scl_data.ratios.vert_c = spl_scratch->scl_data.ratios.vert;
+
+	if (spl_is_yuv420(spl_in->basic_in.format)) {
+		spl_scratch->scl_data.ratios.horz_c.value /= 2;
+		spl_scratch->scl_data.ratios.vert_c.value /= 2;
+	}
+	spl_scratch->scl_data.ratios.horz = spl_fixpt_truncate(
+			spl_scratch->scl_data.ratios.horz, 19);
+	spl_scratch->scl_data.ratios.vert = spl_fixpt_truncate(
+			spl_scratch->scl_data.ratios.vert, 19);
+	spl_scratch->scl_data.ratios.horz_c = spl_fixpt_truncate(
+			spl_scratch->scl_data.ratios.horz_c, 19);
+	spl_scratch->scl_data.ratios.vert_c = spl_fixpt_truncate(
+			spl_scratch->scl_data.ratios.vert_c, 19);
+
+	/*
+	 * Coefficient table and some registers are different based on ratio
+	 * that is output/input.  Currently we calculate input/output
+	 * Store 1/ratio in recip_ratio for those lookups
+	 */
+	spl_scratch->scl_data.recip_ratios.horz = spl_fixpt_recip(
+			spl_scratch->scl_data.ratios.horz);
+	spl_scratch->scl_data.recip_ratios.vert = spl_fixpt_recip(
+			spl_scratch->scl_data.ratios.vert);
+	spl_scratch->scl_data.recip_ratios.horz_c = spl_fixpt_recip(
+			spl_scratch->scl_data.ratios.horz_c);
+	spl_scratch->scl_data.recip_ratios.vert_c = spl_fixpt_recip(
+			spl_scratch->scl_data.ratios.vert_c);
+}
+
+/* Calculate Viewport size */
+static void spl_calculate_viewport_size(struct spl_in *spl_in, struct spl_scratch *spl_scratch)
+{
+	spl_scratch->scl_data.viewport.width = spl_fixpt_ceil(spl_fixpt_mul_int(spl_scratch->scl_data.ratios.horz,
+							spl_scratch->scl_data.recout.width));
+	spl_scratch->scl_data.viewport.height = spl_fixpt_ceil(spl_fixpt_mul_int(spl_scratch->scl_data.ratios.vert,
+							spl_scratch->scl_data.recout.height));
+	spl_scratch->scl_data.viewport_c.width = spl_fixpt_ceil(spl_fixpt_mul_int(spl_scratch->scl_data.ratios.horz_c,
+						spl_scratch->scl_data.recout.width));
+	spl_scratch->scl_data.viewport_c.height = spl_fixpt_ceil(spl_fixpt_mul_int(spl_scratch->scl_data.ratios.vert_c,
+						spl_scratch->scl_data.recout.height));
+	if (spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_90 ||
+			spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_270) {
+		spl_swap(spl_scratch->scl_data.viewport.width, spl_scratch->scl_data.viewport.height);
+		spl_swap(spl_scratch->scl_data.viewport_c.width, spl_scratch->scl_data.viewport_c.height);
+	}
+}
+
+static void spl_get_vp_scan_direction(enum spl_rotation_angle rotation,
+			   bool horizontal_mirror,
+			   bool *orthogonal_rotation,
+			   bool *flip_vert_scan_dir,
+			   bool *flip_horz_scan_dir)
+{
+	*orthogonal_rotation = false;
+	*flip_vert_scan_dir = false;
+	*flip_horz_scan_dir = false;
+	if (rotation == SPL_ROTATION_ANGLE_180) {
+		*flip_vert_scan_dir = true;
+		*flip_horz_scan_dir = true;
+	} else if (rotation == SPL_ROTATION_ANGLE_90) {
+		*orthogonal_rotation = true;
+		*flip_horz_scan_dir = true;
+	} else if (rotation == SPL_ROTATION_ANGLE_270) {
+		*orthogonal_rotation = true;
+		*flip_vert_scan_dir = true;
+	}
+
+	if (horizontal_mirror)
+		*flip_horz_scan_dir = !*flip_horz_scan_dir;
+}
+
+/*
+ * We completely calculate vp offset, size and inits here based entirely on scaling
+ * ratios and recout for pixel perfect pipe combine.
+ */
+static void spl_calculate_init_and_vp(bool flip_scan_dir,
+				int recout_offset_within_recout_full,
+				int recout_size,
+				int src_size,
+				int taps,
+				struct spl_fixed31_32 ratio,
+				struct spl_fixed31_32 init_adj,
+				struct spl_fixed31_32 *init,
+				int *vp_offset,
+				int *vp_size)
+{
+	struct spl_fixed31_32 temp;
+	int int_part;
+
+	/*
+	 * First of the taps starts sampling pixel number <init_int_part> corresponding to recout
+	 * pixel 1. Next recout pixel samples int part of <init + scaling ratio> and so on.
+	 * All following calculations are based on this logic.
+	 *
+	 * Init calculated according to formula:
+	 * init = (scaling_ratio + number_of_taps + 1) / 2
+	 * init_bot = init + scaling_ratio
+	 * to get pixel perfect combine add the fraction from calculating vp offset
+	 */
+	temp = spl_fixpt_mul_int(ratio, recout_offset_within_recout_full);
+	*vp_offset = spl_fixpt_floor(temp);
+	temp.value &= 0xffffffff;
+	*init = spl_fixpt_add(spl_fixpt_div_int(spl_fixpt_add_int(ratio, taps + 1), 2), temp);
+	*init = spl_fixpt_add(*init, init_adj);
+	*init = spl_fixpt_truncate(*init, 19);
+
+	/*
+	 * If viewport has non 0 offset and there are more taps than covered by init then
+	 * we should decrease the offset and increase init so we are never sampling
+	 * outside of viewport.
+	 */
+	int_part = spl_fixpt_floor(*init);
+	if (int_part < taps) {
+		int_part = taps - int_part;
+		if (int_part > *vp_offset)
+			int_part = *vp_offset;
+		*vp_offset -= int_part;
+		*init = spl_fixpt_add_int(*init, int_part);
+	}
+	/*
+	 * If taps are sampling outside of viewport at end of recout and there are more pixels
+	 * available in the surface we should increase the viewport size, regardless set vp to
+	 * only what is used.
+	 */
+	temp = spl_fixpt_add(*init, spl_fixpt_mul_int(ratio, recout_size - 1));
+	*vp_size = spl_fixpt_floor(temp);
+	if (*vp_size + *vp_offset > src_size)
+		*vp_size = src_size - *vp_offset;
+
+	/* We did all the math assuming we are scanning same direction as display does,
+	 * however mirror/rotation changes how vp scans vs how it is offset. If scan direction
+	 * is flipped we simply need to calculate offset from the other side of plane.
+	 * Note that outside of viewport all scaling hardware works in recout space.
+	 */
+	if (flip_scan_dir)
+		*vp_offset = src_size - *vp_offset - *vp_size;
+}
+
+/*Calculate inits and viewport */
+static void spl_calculate_inits_and_viewports(struct spl_in *spl_in,
+		struct spl_scratch *spl_scratch)
+{
+	struct spl_rect src = spl_in->basic_in.src_rect;
+	struct spl_rect recout_dst_in_active_timing;
+	struct spl_rect recout_clip_in_active_timing;
+	struct spl_rect recout_clip_in_recout_dst;
+	struct spl_rect overlap_in_active_timing;
+	struct spl_rect odm_slice = calculate_odm_slice_in_timing_active(spl_in);
+	int vpc_div = spl_is_subsampled_format(spl_in->basic_in.format) ? 2 : 1;
+	bool orthogonal_rotation, flip_vert_scan_dir, flip_horz_scan_dir;
+	struct spl_fixed31_32 init_adj_h = spl_fixpt_zero;
+	struct spl_fixed31_32 init_adj_v = spl_fixpt_zero;
+
+	recout_clip_in_active_timing = shift_rec(
+			&spl_scratch->scl_data.recout, odm_slice.x, odm_slice.y);
+	recout_dst_in_active_timing = calculate_plane_rec_in_timing_active(
+			spl_in, &spl_in->basic_in.dst_rect);
+	overlap_in_active_timing = intersect_rec(&recout_clip_in_active_timing,
+			&recout_dst_in_active_timing);
+	if (overlap_in_active_timing.width > 0 &&
+			overlap_in_active_timing.height > 0)
+		recout_clip_in_recout_dst = shift_rec(&overlap_in_active_timing,
+				-recout_dst_in_active_timing.x,
+				-recout_dst_in_active_timing.y);
+	else
+		memset(&recout_clip_in_recout_dst, 0, sizeof(struct spl_rect));
+	/*
+	 * Work in recout rotation since that requires less transformations
+	 */
+	spl_get_vp_scan_direction(
+			spl_in->basic_in.rotation,
+			spl_in->basic_in.horizontal_mirror,
+			&orthogonal_rotation,
+			&flip_vert_scan_dir,
+			&flip_horz_scan_dir);
+
+	if (spl_is_subsampled_format(spl_in->basic_in.format)) {
+		/* this gives the direction of the cositing (negative will move
+		 * left, right otherwise)
+		 */
+		int sign = 1;
+
+		switch (spl_in->basic_in.cositing) {
+
+		case CHROMA_COSITING_TOPLEFT:
+			init_adj_h = spl_fixpt_from_fraction(sign, 4);
+			init_adj_v = spl_fixpt_from_fraction(sign, 4);
+			break;
+		case CHROMA_COSITING_LEFT:
+			init_adj_h = spl_fixpt_from_fraction(sign, 4);
+			init_adj_v = spl_fixpt_zero;
+			break;
+		case CHROMA_COSITING_NONE:
+		default:
+			init_adj_h = spl_fixpt_zero;
+			init_adj_v = spl_fixpt_zero;
+			break;
+		}
+	}
+
+	if (orthogonal_rotation) {
+		spl_swap(src.width, src.height);
+		spl_swap(flip_vert_scan_dir, flip_horz_scan_dir);
+		spl_swap(init_adj_h, init_adj_v);
+	}
+
+	spl_calculate_init_and_vp(
+			flip_horz_scan_dir,
+			recout_clip_in_recout_dst.x,
+			spl_scratch->scl_data.recout.width,
+			src.width,
+			spl_scratch->scl_data.taps.h_taps,
+			spl_scratch->scl_data.ratios.horz,
+			spl_fixpt_zero,
+			&spl_scratch->scl_data.inits.h,
+			&spl_scratch->scl_data.viewport.x,
+			&spl_scratch->scl_data.viewport.width);
+	spl_calculate_init_and_vp(
+			flip_horz_scan_dir,
+			recout_clip_in_recout_dst.x,
+			spl_scratch->scl_data.recout.width,
+			src.width / vpc_div,
+			spl_scratch->scl_data.taps.h_taps_c,
+			spl_scratch->scl_data.ratios.horz_c,
+			init_adj_h,
+			&spl_scratch->scl_data.inits.h_c,
+			&spl_scratch->scl_data.viewport_c.x,
+			&spl_scratch->scl_data.viewport_c.width);
+	spl_calculate_init_and_vp(
+			flip_vert_scan_dir,
+			recout_clip_in_recout_dst.y,
+			spl_scratch->scl_data.recout.height,
+			src.height,
+			spl_scratch->scl_data.taps.v_taps,
+			spl_scratch->scl_data.ratios.vert,
+			spl_fixpt_zero,
+			&spl_scratch->scl_data.inits.v,
+			&spl_scratch->scl_data.viewport.y,
+			&spl_scratch->scl_data.viewport.height);
+	spl_calculate_init_and_vp(
+			flip_vert_scan_dir,
+			recout_clip_in_recout_dst.y,
+			spl_scratch->scl_data.recout.height,
+			src.height / vpc_div,
+			spl_scratch->scl_data.taps.v_taps_c,
+			spl_scratch->scl_data.ratios.vert_c,
+			init_adj_v,
+			&spl_scratch->scl_data.inits.v_c,
+			&spl_scratch->scl_data.viewport_c.y,
+			&spl_scratch->scl_data.viewport_c.height);
+	if (orthogonal_rotation) {
+		spl_swap(spl_scratch->scl_data.viewport.x, spl_scratch->scl_data.viewport.y);
+		spl_swap(spl_scratch->scl_data.viewport.width, spl_scratch->scl_data.viewport.height);
+		spl_swap(spl_scratch->scl_data.viewport_c.x, spl_scratch->scl_data.viewport_c.y);
+		spl_swap(spl_scratch->scl_data.viewport_c.width, spl_scratch->scl_data.viewport_c.height);
+	}
+	spl_scratch->scl_data.viewport.x += src.x;
+	spl_scratch->scl_data.viewport.y += src.y;
+	SPL_ASSERT(src.x % vpc_div == 0 && src.y % vpc_div == 0);
+	spl_scratch->scl_data.viewport_c.x += src.x / vpc_div;
+	spl_scratch->scl_data.viewport_c.y += src.y / vpc_div;
+}
+
+static void spl_handle_3d_recout(struct spl_in *spl_in, struct spl_rect *recout)
+{
+	/*
+	 * Handle side by side and top bottom 3d recout offsets after vp calculation
+	 * since 3d is special and needs to calculate vp as if there is no recout offset
+	 * This may break with rotation, good thing we aren't mixing hw rotation and 3d
+	 */
+	if (spl_in->basic_in.mpc_h_slice_index) {
+		SPL_ASSERT(spl_in->basic_in.rotation == SPL_ROTATION_ANGLE_0 ||
+			(spl_in->basic_out.view_format != SPL_VIEW_3D_TOP_AND_BOTTOM &&
+					spl_in->basic_out.view_format != SPL_VIEW_3D_SIDE_BY_SIDE));
+		if (spl_in->basic_out.view_format == SPL_VIEW_3D_TOP_AND_BOTTOM)
+			recout->y += recout->height;
+		else if (spl_in->basic_out.view_format == SPL_VIEW_3D_SIDE_BY_SIDE)
+			recout->x += recout->width;
+	}
+}
+
+static void spl_clamp_viewport(struct spl_rect *viewport)
+{
+	/* Clamp minimum viewport size */
+	if (viewport->height < MIN_VIEWPORT_SIZE)
+		viewport->height = MIN_VIEWPORT_SIZE;
+	if (viewport->width < MIN_VIEWPORT_SIZE)
+		viewport->width = MIN_VIEWPORT_SIZE;
+}
+
+static enum scl_mode spl_get_dscl_mode(const struct spl_in *spl_in,
+				const struct spl_scaler_data *data,
+				bool enable_isharp, bool enable_easf)
+{
+	const long long one = spl_fixpt_one.value;
+	enum spl_pixel_format pixel_format = spl_in->basic_in.format;
+
+	/* Bypass if ratio is 1:1 with no ISHARP or force scale on */
+	if (data->ratios.horz.value == one
+			&& data->ratios.vert.value == one
+			&& data->ratios.horz_c.value == one
+			&& data->ratios.vert_c.value == one
+			&& !spl_in->basic_out.always_scale
+			&& !enable_isharp)
+		return SCL_MODE_SCALING_444_BYPASS;
+
+	if (!spl_is_subsampled_format(pixel_format)) {
+		if (spl_is_video_format(pixel_format))
+			return SCL_MODE_SCALING_444_YCBCR_ENABLE;
+		else
+			return SCL_MODE_SCALING_444_RGB_ENABLE;
+	}
+
+	/*
+	 * Bypass YUV if Y is 1:1 with no ISHARP
+	 * Do not bypass UV at 1:1 for cositing to be applied
+	 */
+	if (!enable_isharp) {
+		if (data->ratios.horz.value == one && data->ratios.vert.value == one)
+			return SCL_MODE_SCALING_420_LUMA_BYPASS;
+	}
+
+	return SCL_MODE_SCALING_420_YCBCR_ENABLE;
+}
+
+static bool spl_choose_lls_policy(enum spl_pixel_format format,
+	enum spl_transfer_func_type tf_type,
+	enum spl_transfer_func_predefined tf_predefined_type,
+	enum linear_light_scaling *lls_pref)
+{
+	if (spl_is_video_format(format)) {
+		*lls_pref = LLS_PREF_NO;
+		if ((tf_type == SPL_TF_TYPE_PREDEFINED) ||
+			(tf_type == SPL_TF_TYPE_DISTRIBUTED_POINTS))
+			return true;
+	} else { /* RGB or YUV444 */
+		if ((tf_type == SPL_TF_TYPE_PREDEFINED) ||
+			(tf_type == SPL_TF_TYPE_BYPASS)) {
+			*lls_pref = LLS_PREF_YES;
+			return true;
+		}
+	}
+	*lls_pref = LLS_PREF_NO;
+	return false;
+}
+
+/* Enable EASF ?*/
+static bool enable_easf(struct spl_in *spl_in, struct spl_scratch *spl_scratch)
+{
+	int vratio = 0;
+	int hratio = 0;
+	bool skip_easf = false;
+	bool lls_enable_easf = true;
+
+	if (spl_in->disable_easf)
+		skip_easf = true;
+
+	vratio = spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert);
+	hratio = spl_fixpt_ceil(spl_scratch->scl_data.ratios.horz);
+
+	/*
+	 * No EASF support for downscaling > 2:1
+	 * EASF support for upscaling or downscaling up to 2:1
+	 */
+	if ((vratio > 2) || (hratio > 2))
+		skip_easf = true;
+
+	/*
+	 * If lls_pref is LLS_PREF_DONT_CARE, then use pixel format and transfer
+	 *  function to determine whether to use LINEAR or NONLINEAR scaling
+	 */
+	if (spl_in->lls_pref == LLS_PREF_DONT_CARE)
+		lls_enable_easf = spl_choose_lls_policy(spl_in->basic_in.format,
+			spl_in->basic_in.tf_type, spl_in->basic_in.tf_predefined_type,
+			&spl_in->lls_pref);
+
+	if (!lls_enable_easf)
+		skip_easf = true;
+
+	/* Check for linear scaling or EASF preferred */
+	if (spl_in->lls_pref != LLS_PREF_YES && !spl_in->prefer_easf)
+		skip_easf = true;
+
+	return skip_easf;
+}
+
+/* Check if video is in fullscreen mode */
+static bool spl_is_video_fullscreen(struct spl_in *spl_in)
+{
+	if (spl_is_video_format(spl_in->basic_in.format) && spl_in->is_fullscreen)
+		return true;
+	return false;
+}
+
+static bool spl_get_isharp_en(struct spl_in *spl_in,
+	struct spl_scratch *spl_scratch)
+{
+	bool enable_isharp = false;
+	int vratio = 0;
+	int hratio = 0;
+	struct spl_taps taps = spl_scratch->scl_data.taps;
+	bool fullscreen = spl_is_video_fullscreen(spl_in);
+
+	/* Return if adaptive sharpness is disabled */
+	if (spl_in->adaptive_sharpness.enable == false)
+		return enable_isharp;
+
+	vratio = spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert);
+	hratio = spl_fixpt_ceil(spl_scratch->scl_data.ratios.horz);
+
+	/* No iSHARP support for downscaling */
+	if (vratio > 1 || hratio > 1)
+		return enable_isharp;
+
+	// Scaling is up to 1:1 (no scaling) or upscaling
+
+	/*
+	 * Apply sharpness to RGB and YUV (NV12/P010)
+	 *  surfaces based on policy setting
+	 */
+	if (!spl_is_video_format(spl_in->basic_in.format) &&
+		(spl_in->sharpen_policy == SHARPEN_YUV))
+		return enable_isharp;
+	else if ((spl_is_video_format(spl_in->basic_in.format) && !fullscreen) &&
+		(spl_in->sharpen_policy == SHARPEN_RGB_FULLSCREEN_YUV))
+		return enable_isharp;
+	else if (!spl_in->is_fullscreen &&
+			spl_in->sharpen_policy == SHARPEN_FULLSCREEN_ALL)
+		return enable_isharp;
+
+	/*
+	 * Apply sharpness if supports horizontal taps 4,6 AND
+	 *  vertical taps 3, 4, 6
+	 */
+	if ((taps.h_taps == 4 || taps.h_taps == 6) &&
+		(taps.v_taps == 3 || taps.v_taps == 4 || taps.v_taps == 6))
+		enable_isharp = true;
+
+	return enable_isharp;
+}
+
+/* Calculate number of tap with adaptive scaling off */
+static void spl_get_taps_non_adaptive_scaler(
+	  struct spl_scratch *spl_scratch, const struct spl_taps *in_taps)
+{
+	if (in_taps->h_taps == 0) {
+		if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.horz) > 1)
+			spl_scratch->scl_data.taps.h_taps = spl_min(2 * spl_fixpt_ceil(
+				spl_scratch->scl_data.ratios.horz), 8);
+		else
+			spl_scratch->scl_data.taps.h_taps = 4;
+	} else
+		spl_scratch->scl_data.taps.h_taps = in_taps->h_taps;
+
+	if (in_taps->v_taps == 0) {
+		if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert) > 1)
+			spl_scratch->scl_data.taps.v_taps = spl_min(2 * spl_fixpt_ceil(
+				spl_scratch->scl_data.ratios.vert), 8);
+		else
+			spl_scratch->scl_data.taps.v_taps = 4;
+	} else
+		spl_scratch->scl_data.taps.v_taps = in_taps->v_taps;
+
+	if (in_taps->v_taps_c == 0) {
+		if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert_c) > 1)
+			spl_scratch->scl_data.taps.v_taps_c = spl_min(2 * spl_fixpt_ceil(
+				spl_scratch->scl_data.ratios.vert_c), 8);
+		else
+			spl_scratch->scl_data.taps.v_taps_c = 4;
+	} else
+		spl_scratch->scl_data.taps.v_taps_c = in_taps->v_taps_c;
+
+	if (in_taps->h_taps_c == 0) {
+		if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.horz_c) > 1)
+			spl_scratch->scl_data.taps.h_taps_c = spl_min(2 * spl_fixpt_ceil(
+				spl_scratch->scl_data.ratios.horz_c), 8);
+		else
+			spl_scratch->scl_data.taps.h_taps_c = 4;
+	} else if ((in_taps->h_taps_c % 2) != 0 && in_taps->h_taps_c != 1)
+		/* Only 1 and even h_taps_c are supported by hw */
+		spl_scratch->scl_data.taps.h_taps_c = in_taps->h_taps_c - 1;
+	else
+		spl_scratch->scl_data.taps.h_taps_c = in_taps->h_taps_c;
+
+	if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz))
+		spl_scratch->scl_data.taps.h_taps = 1;
+	if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert))
+		spl_scratch->scl_data.taps.v_taps = 1;
+	if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz_c))
+		spl_scratch->scl_data.taps.h_taps_c = 1;
+	if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert_c))
+		spl_scratch->scl_data.taps.v_taps_c = 1;
+
+}
+
+/* Calculate optimal number of taps */
+static bool spl_get_optimal_number_of_taps(
+	  int max_downscale_src_width, struct spl_in *spl_in, struct spl_scratch *spl_scratch,
+	  const struct spl_taps *in_taps, bool *enable_easf_v, bool *enable_easf_h,
+	  bool *enable_isharp)
+{
+	int num_part_y, num_part_c;
+	int max_taps_y, max_taps_c;
+	int min_taps_y, min_taps_c;
+	enum lb_memory_config lb_config;
+	bool skip_easf = false;
+	bool is_subsampled = spl_is_subsampled_format(spl_in->basic_in.format);
+
+	if (spl_scratch->scl_data.viewport.width > spl_scratch->scl_data.h_active &&
+		max_downscale_src_width != 0 &&
+		spl_scratch->scl_data.viewport.width > max_downscale_src_width) {
+		spl_get_taps_non_adaptive_scaler(spl_scratch, in_taps);
+		*enable_easf_v = false;
+		*enable_easf_h = false;
+		*enable_isharp = false;
+		return false;
+	}
+
+	/* Disable adaptive scaler and sharpener when integer scaling is enabled */
+	if (spl_in->scaling_quality.integer_scaling) {
+		spl_get_taps_non_adaptive_scaler(spl_scratch, in_taps);
+		*enable_easf_v = false;
+		*enable_easf_h = false;
+		*enable_isharp = false;
+		return true;
+	}
+
+	/* Check if we are using EASF or not */
+	skip_easf = enable_easf(spl_in, spl_scratch);
+
+	/*
+	 * Set default taps if none are provided
+	 * From programming guide: taps = min{ ceil(2*H_RATIO,1), 8} for downscaling
+	 * taps = 4 for upscaling
+	 */
+	if (skip_easf)
+		spl_get_taps_non_adaptive_scaler(spl_scratch, in_taps);
+	else {
+		if (spl_is_video_format(spl_in->basic_in.format)) {
+			spl_scratch->scl_data.taps.h_taps = 6;
+			spl_scratch->scl_data.taps.v_taps = 6;
+			spl_scratch->scl_data.taps.h_taps_c = 4;
+			spl_scratch->scl_data.taps.v_taps_c = 4;
+		} else { /* RGB */
+			spl_scratch->scl_data.taps.h_taps = 6;
+			spl_scratch->scl_data.taps.v_taps = 6;
+			spl_scratch->scl_data.taps.h_taps_c = 6;
+			spl_scratch->scl_data.taps.v_taps_c = 6;
+		}
+	}
+
+	/*Ensure we can support the requested number of vtaps*/
+	min_taps_y = spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert);
+	min_taps_c = spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert_c);
+
+	/* Use LB_MEMORY_CONFIG_3 for 4:2:0 */
+	if (spl_is_yuv420(spl_in->basic_in.format))
+		lb_config = LB_MEMORY_CONFIG_3;
+	else
+		lb_config = LB_MEMORY_CONFIG_0;
+	// Determine max vtap support by calculating how much line buffer can fit
+	spl_in->callbacks.spl_calc_lb_num_partitions(spl_in->basic_out.alpha_en, &spl_scratch->scl_data,
+			lb_config, &num_part_y, &num_part_c);
+	/* MAX_V_TAPS = MIN (NUM_LINES - MAX(CEILING(V_RATIO,1)-2, 0), 8) */
+	if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert) > 2)
+		max_taps_y = num_part_y - (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert) - 2);
+	else
+		max_taps_y = num_part_y;
+
+	if (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert_c) > 2)
+		max_taps_c = num_part_c - (spl_fixpt_ceil(spl_scratch->scl_data.ratios.vert_c) - 2);
+	else
+		max_taps_c = num_part_c;
+
+	if (max_taps_y < min_taps_y)
+		return false;
+	else if (max_taps_c < min_taps_c)
+		return false;
+
+	if (spl_scratch->scl_data.taps.v_taps > max_taps_y)
+		spl_scratch->scl_data.taps.v_taps = max_taps_y;
+
+	if (spl_scratch->scl_data.taps.v_taps_c > max_taps_c)
+		spl_scratch->scl_data.taps.v_taps_c = max_taps_c;
+
+	if (!skip_easf) {
+		/*
+		 * RGB ( L + NL ) and Linear HDR support 6x6, 6x4, 6x3, 4x4, 4x3
+		 * NL YUV420 only supports 6x6, 6x4 for Y and 4x4 for UV
+		 *
+		 * If LB does not support 3, 4, or 6 taps, then disable EASF_V
+		 *  and only enable EASF_H.  So for RGB, support 6x2, 4x2
+		 *  and for NL YUV420, support 6x2 for Y and 4x2 for UV
+		 *
+		 * All other cases, have to disable EASF_V and EASF_H
+		 *
+		 * If optimal no of taps is 5, then set it to 4
+		 * If optimal no of taps is 7 or 8, then fine since max tap is 6
+		 *
+		 */
+		if (spl_scratch->scl_data.taps.v_taps == 5)
+			spl_scratch->scl_data.taps.v_taps = 4;
+
+		if (spl_scratch->scl_data.taps.v_taps_c == 5)
+			spl_scratch->scl_data.taps.v_taps_c = 4;
+
+		if (spl_scratch->scl_data.taps.h_taps == 5)
+			spl_scratch->scl_data.taps.h_taps = 4;
+
+		if (spl_scratch->scl_data.taps.h_taps_c == 5)
+			spl_scratch->scl_data.taps.h_taps_c = 4;
+
+		if (spl_is_video_format(spl_in->basic_in.format)) {
+			if (spl_scratch->scl_data.taps.h_taps <= 4) {
+				*enable_easf_v = false;
+				*enable_easf_h = false;
+			} else if (spl_scratch->scl_data.taps.v_taps <= 3) {
+				*enable_easf_v = false;
+				*enable_easf_h = true;
+			} else {
+				*enable_easf_v = true;
+				*enable_easf_h = true;
+			}
+			SPL_ASSERT((spl_scratch->scl_data.taps.v_taps > 1) &&
+				(spl_scratch->scl_data.taps.v_taps_c > 1));
+		} else { /* RGB */
+			if (spl_scratch->scl_data.taps.h_taps <= 3) {
+				*enable_easf_v = false;
+				*enable_easf_h = false;
+			} else if (spl_scratch->scl_data.taps.v_taps < 3) {
+				*enable_easf_v = false;
+				*enable_easf_h = true;
+			} else {
+				*enable_easf_v = true;
+				*enable_easf_h = true;
+			}
+			SPL_ASSERT(spl_scratch->scl_data.taps.v_taps > 1);
+		}
+	} else {
+		*enable_easf_v = false;
+		*enable_easf_h = false;
+	} // end of if prefer_easf
+
+	/* Sharpener requires scaler to be enabled, including for 1:1
+	 * Check if ISHARP can be enabled
+	 * If ISHARP is not enabled, set taps to 1 if ratio is 1:1
+	 *  except for chroma taps.  Keep previous taps so it can
+	 *  handle cositing
+	 */
+
+	*enable_isharp = spl_get_isharp_en(spl_in, spl_scratch);
+	if (!*enable_isharp && !spl_in->basic_out.always_scale)	{
+		if ((IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz)) &&
+			(IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert))) {
+			spl_scratch->scl_data.taps.h_taps = 1;
+			spl_scratch->scl_data.taps.v_taps = 1;
+
+			if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz_c) && !is_subsampled)
+				spl_scratch->scl_data.taps.h_taps_c = 1;
+
+			if (IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert_c) && !is_subsampled)
+				spl_scratch->scl_data.taps.v_taps_c = 1;
+
+			*enable_easf_v = false;
+			*enable_easf_h = false;
+		} else {
+			if ((!*enable_easf_h) &&
+				(IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz)))
+				spl_scratch->scl_data.taps.h_taps = 1;
+
+			if ((!*enable_easf_v) &&
+				(IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert)))
+				spl_scratch->scl_data.taps.v_taps = 1;
+
+			if ((!*enable_easf_h) && !is_subsampled &&
+				(IDENTITY_RATIO(spl_scratch->scl_data.ratios.horz_c)))
+				spl_scratch->scl_data.taps.h_taps_c = 1;
+
+			if ((!*enable_easf_v) && !is_subsampled &&
+				(IDENTITY_RATIO(spl_scratch->scl_data.ratios.vert_c)))
+				spl_scratch->scl_data.taps.v_taps_c = 1;
+		}
+	}
+	return true;
+}
+
+static void spl_set_black_color_data(enum spl_pixel_format format,
+			struct scl_black_color *scl_black_color)
+{
+	bool ycbcr = spl_is_video_format(format);
+	if (ycbcr)	{
+		scl_black_color->offset_rgb_y = BLACK_OFFSET_RGB_Y;
+		scl_black_color->offset_rgb_cbcr = BLACK_OFFSET_CBCR;
+	}	else {
+		scl_black_color->offset_rgb_y = 0x0;
+		scl_black_color->offset_rgb_cbcr = 0x0;
+	}
+}
+
+static void spl_set_manual_ratio_init_data(struct dscl_prog_data *dscl_prog_data,
+		const struct spl_scaler_data *scl_data)
+{
+	struct spl_fixed31_32 bot;
+
+	dscl_prog_data->ratios.h_scale_ratio = spl_fixpt_u3d19(scl_data->ratios.horz) << 5;
+	dscl_prog_data->ratios.v_scale_ratio = spl_fixpt_u3d19(scl_data->ratios.vert) << 5;
+	dscl_prog_data->ratios.h_scale_ratio_c = spl_fixpt_u3d19(scl_data->ratios.horz_c) << 5;
+	dscl_prog_data->ratios.v_scale_ratio_c = spl_fixpt_u3d19(scl_data->ratios.vert_c) << 5;
+	/*
+	 * 0.24 format for fraction, first five bits zeroed
+	 */
+	dscl_prog_data->init.h_filter_init_frac =
+			spl_fixpt_u0d19(scl_data->inits.h) << 5;
+	dscl_prog_data->init.h_filter_init_int =
+			spl_fixpt_floor(scl_data->inits.h);
+	dscl_prog_data->init.h_filter_init_frac_c =
+			spl_fixpt_u0d19(scl_data->inits.h_c) << 5;
+	dscl_prog_data->init.h_filter_init_int_c =
+			spl_fixpt_floor(scl_data->inits.h_c);
+	dscl_prog_data->init.v_filter_init_frac =
+			spl_fixpt_u0d19(scl_data->inits.v) << 5;
+	dscl_prog_data->init.v_filter_init_int =
+			spl_fixpt_floor(scl_data->inits.v);
+	dscl_prog_data->init.v_filter_init_frac_c =
+			spl_fixpt_u0d19(scl_data->inits.v_c) << 5;
+	dscl_prog_data->init.v_filter_init_int_c =
+			spl_fixpt_floor(scl_data->inits.v_c);
+
+	bot = spl_fixpt_add(scl_data->inits.v, scl_data->ratios.vert);
+	dscl_prog_data->init.v_filter_init_bot_frac = spl_fixpt_u0d19(bot) << 5;
+	dscl_prog_data->init.v_filter_init_bot_int = spl_fixpt_floor(bot);
+	bot = spl_fixpt_add(scl_data->inits.v_c, scl_data->ratios.vert_c);
+	dscl_prog_data->init.v_filter_init_bot_frac_c = spl_fixpt_u0d19(bot) << 5;
+	dscl_prog_data->init.v_filter_init_bot_int_c = spl_fixpt_floor(bot);
+}
+
+static void spl_set_taps_data(struct dscl_prog_data *dscl_prog_data,
+		const struct spl_scaler_data *scl_data)
+{
+	dscl_prog_data->taps.v_taps = scl_data->taps.v_taps - 1;
+	dscl_prog_data->taps.h_taps = scl_data->taps.h_taps - 1;
+	dscl_prog_data->taps.v_taps_c = scl_data->taps.v_taps_c - 1;
+	dscl_prog_data->taps.h_taps_c = scl_data->taps.h_taps_c - 1;
+}
+
+/* Populate dscl prog data structure from scaler data calculated by SPL */
+static void spl_set_dscl_prog_data(struct spl_in *spl_in, struct spl_scratch *spl_scratch,
+	struct spl_out *spl_out, bool enable_easf_v, bool enable_easf_h, bool enable_isharp)
+{
+	struct dscl_prog_data *dscl_prog_data = spl_out->dscl_prog_data;
+
+	const struct spl_scaler_data *data = &spl_scratch->scl_data;
+
+	struct scl_black_color *scl_black_color = &dscl_prog_data->scl_black_color;
+
+	bool enable_easf = enable_easf_v || enable_easf_h;
+
+	// Set values for recout
+	dscl_prog_data->recout = spl_scratch->scl_data.recout;
+	// Set values for MPC Size
+	dscl_prog_data->mpc_size.width = spl_scratch->scl_data.h_active;
+	dscl_prog_data->mpc_size.height = spl_scratch->scl_data.v_active;
+
+	// SCL_MODE - Set SCL_MODE data
+	dscl_prog_data->dscl_mode = spl_get_dscl_mode(spl_in, data, enable_isharp,
+		enable_easf);
+
+	// SCL_BLACK_COLOR
+	spl_set_black_color_data(spl_in->basic_in.format, scl_black_color);
+
+	/* Manually calculate scale ratio and init values */
+	spl_set_manual_ratio_init_data(dscl_prog_data, data);
+
+	// Set HTaps/VTaps
+	spl_set_taps_data(dscl_prog_data, data);
+	// Set viewport
+	dscl_prog_data->viewport = spl_scratch->scl_data.viewport;
+	// Set viewport_c
+	dscl_prog_data->viewport_c = spl_scratch->scl_data.viewport_c;
+	// Set filters data
+	spl_set_filters_data(dscl_prog_data, data, enable_easf_v, enable_easf_h);
+}
+
+/* Calculate C0-C3 coefficients based on HDR_mult */
+static void spl_calculate_c0_c3_hdr(struct dscl_prog_data *dscl_prog_data, uint32_t sdr_white_level_nits)
+{
+	struct spl_fixed31_32 hdr_mult, c0_mult, c1_mult, c2_mult;
+	struct spl_fixed31_32 c0_calc, c1_calc, c2_calc;
+	struct spl_custom_float_format fmt;
+	uint32_t hdr_multx100_int;
+
+	if ((sdr_white_level_nits >= 80) && (sdr_white_level_nits <= 480))
+		hdr_multx100_int = sdr_white_level_nits * 100 / 80;
+	else
+		hdr_multx100_int = 100; /* default for 80 nits otherwise */
+
+	hdr_mult = spl_fixpt_from_fraction((long long)hdr_multx100_int, 100LL);
+	c0_mult = spl_fixpt_from_fraction(2126LL, 10000LL);
+	c1_mult = spl_fixpt_from_fraction(7152LL, 10000LL);
+	c2_mult = spl_fixpt_from_fraction(722LL, 10000LL);
+
+	c0_calc = spl_fixpt_mul(hdr_mult, spl_fixpt_mul(c0_mult, spl_fixpt_from_fraction(
+		16384LL, 125LL)));
+	c1_calc = spl_fixpt_mul(hdr_mult, spl_fixpt_mul(c1_mult, spl_fixpt_from_fraction(
+		16384LL, 125LL)));
+	c2_calc = spl_fixpt_mul(hdr_mult, spl_fixpt_mul(c2_mult, spl_fixpt_from_fraction(
+		16384LL, 125LL)));
+
+	fmt.exponenta_bits = 5;
+	fmt.mantissa_bits = 10;
+	fmt.sign = true;
+
+	// fp1.5.10, C0 coefficient (LN_rec709:  HDR_MULT * 0.212600 * 2^14/125)
+	spl_convert_to_custom_float_format(c0_calc, &fmt, &dscl_prog_data->easf_matrix_c0);
+	// fp1.5.10, C1 coefficient (LN_rec709:  HDR_MULT * 0.715200 * 2^14/125)
+	spl_convert_to_custom_float_format(c1_calc, &fmt, &dscl_prog_data->easf_matrix_c1);
+	// fp1.5.10, C2 coefficient (LN_rec709:  HDR_MULT * 0.072200 * 2^14/125)
+	spl_convert_to_custom_float_format(c2_calc, &fmt, &dscl_prog_data->easf_matrix_c2);
+	dscl_prog_data->easf_matrix_c3 = 0x0; // fp1.5.10, C3 coefficient
+}
+
+/* Set EASF data */
+static void spl_set_easf_data(struct spl_scratch *spl_scratch, struct spl_out *spl_out, bool enable_easf_v,
+	bool enable_easf_h, enum linear_light_scaling lls_pref,
+	enum spl_pixel_format format, enum system_setup setup,
+	uint32_t sdr_white_level_nits)
+{
+	struct dscl_prog_data *dscl_prog_data = spl_out->dscl_prog_data;
+	if (enable_easf_v) {
+		dscl_prog_data->easf_v_en = true;
+		dscl_prog_data->easf_v_ring = 0;
+		dscl_prog_data->easf_v_sharp_factor = 0;
+		dscl_prog_data->easf_v_bf1_en = 1;	// 1-bit, BF1 calculation enable, 0=disable, 1=enable
+		dscl_prog_data->easf_v_bf2_mode = 0xF;	// 4-bit, BF2 calculation mode
+		/* 2-bit, BF3 chroma mode correction calculation mode */
+		dscl_prog_data->easf_v_bf3_mode = spl_get_v_bf3_mode(
+			spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10 [ minCoef ]*/
+		dscl_prog_data->easf_v_ringest_3tap_dntilt_uptilt =
+			spl_get_3tap_dntilt_uptilt_offset(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10 [ upTiltMaxVal ]*/
+		dscl_prog_data->easf_v_ringest_3tap_uptilt_max =
+			spl_get_3tap_uptilt_maxval(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10 [ dnTiltSlope ]*/
+		dscl_prog_data->easf_v_ringest_3tap_dntilt_slope =
+			spl_get_3tap_dntilt_slope(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10 [ upTilt1Slope ]*/
+		dscl_prog_data->easf_v_ringest_3tap_uptilt1_slope =
+			spl_get_3tap_uptilt1_slope(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10 [ upTilt2Slope ]*/
+		dscl_prog_data->easf_v_ringest_3tap_uptilt2_slope =
+			spl_get_3tap_uptilt2_slope(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10 [ upTilt2Offset ]*/
+		dscl_prog_data->easf_v_ringest_3tap_uptilt2_offset =
+			spl_get_3tap_uptilt2_offset(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10; (2.0) Ring reducer gain for 4 or 6-tap mode [H_REDUCER_GAIN4] */
+		dscl_prog_data->easf_v_ringest_eventap_reduceg1 =
+			spl_get_reducer_gain4(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10; (2.5) Ring reducer gain for 6-tap mode [V_REDUCER_GAIN6] */
+		dscl_prog_data->easf_v_ringest_eventap_reduceg2 =
+			spl_get_reducer_gain6(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10; (-0.135742) Ring gain for 6-tap set to -139/1024 */
+		dscl_prog_data->easf_v_ringest_eventap_gain1 =
+			spl_get_gainRing4(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		/* FP1.5.10; (-0.024414) Ring gain for 6-tap set to -25/1024 */
+		dscl_prog_data->easf_v_ringest_eventap_gain2 =
+			spl_get_gainRing6(spl_scratch->scl_data.taps.v_taps,
+				spl_scratch->scl_data.recip_ratios.vert);
+		dscl_prog_data->easf_v_bf_maxa = 63; //Vertical Max BF value A in U0.6 format.Selected if V_FCNTL == 0
+		dscl_prog_data->easf_v_bf_maxb = 63; //Vertical Max BF value A in U0.6 format.Selected if V_FCNTL == 1
+		dscl_prog_data->easf_v_bf_mina = 0;	//Vertical Min BF value A in U0.6 format.Selected if V_FCNTL == 0
+		dscl_prog_data->easf_v_bf_minb = 0;	//Vertical Min BF value A in U0.6 format.Selected if V_FCNTL == 1
+		if (lls_pref == LLS_PREF_YES)	{
+			dscl_prog_data->easf_v_bf2_flat1_gain = 4;	// U1.3, BF2 Flat1 Gain control
+			dscl_prog_data->easf_v_bf2_flat2_gain = 8;	// U4.0, BF2 Flat2 Gain control
+			dscl_prog_data->easf_v_bf2_roc_gain = 4;	// U2.2, Rate Of Change control
+
+			dscl_prog_data->easf_v_bf1_pwl_in_seg0 = 0x600;	// S0.10, BF1 PWL Segment 0 = -512
+			dscl_prog_data->easf_v_bf1_pwl_base_seg0 = 0;	// U0.6, BF1 Base PWL Segment 0
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg0 = 3;	// S7.3, BF1 Slope PWL Segment 0
+			dscl_prog_data->easf_v_bf1_pwl_in_seg1 = 0x7EC;	// S0.10, BF1 PWL Segment 1 = -20
+			dscl_prog_data->easf_v_bf1_pwl_base_seg1 = 12;	// U0.6, BF1 Base PWL Segment 1
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg1 = 326;	// S7.3, BF1 Slope PWL Segment 1
+			dscl_prog_data->easf_v_bf1_pwl_in_seg2 = 0;	// S0.10, BF1 PWL Segment 2
+			dscl_prog_data->easf_v_bf1_pwl_base_seg2 = 63;	// U0.6, BF1 Base PWL Segment 2
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg2 = 0;	// S7.3, BF1 Slope PWL Segment 2
+			dscl_prog_data->easf_v_bf1_pwl_in_seg3 = 16;	// S0.10, BF1 PWL Segment 3
+			dscl_prog_data->easf_v_bf1_pwl_base_seg3 = 63;	// U0.6, BF1 Base PWL Segment 3
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg3 = 0x7C8;	// S7.3, BF1 Slope PWL Segment 3 = -56
+			dscl_prog_data->easf_v_bf1_pwl_in_seg4 = 32;	// S0.10, BF1 PWL Segment 4
+			dscl_prog_data->easf_v_bf1_pwl_base_seg4 = 56;	// U0.6, BF1 Base PWL Segment 4
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg4 = 0x7D0;	// S7.3, BF1 Slope PWL Segment 4 = -48
+			dscl_prog_data->easf_v_bf1_pwl_in_seg5 = 48;	// S0.10, BF1 PWL Segment 5
+			dscl_prog_data->easf_v_bf1_pwl_base_seg5 = 50;	// U0.6, BF1 Base PWL Segment 5
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg5 = 0x710;	// S7.3, BF1 Slope PWL Segment 5 = -240
+			dscl_prog_data->easf_v_bf1_pwl_in_seg6 = 64;	// S0.10, BF1 PWL Segment 6
+			dscl_prog_data->easf_v_bf1_pwl_base_seg6 = 20;	// U0.6, BF1 Base PWL Segment 6
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg6 = 0x760;	// S7.3, BF1 Slope PWL Segment 6 = -160
+			dscl_prog_data->easf_v_bf1_pwl_in_seg7 = 80;	// S0.10, BF1 PWL Segment 7
+			dscl_prog_data->easf_v_bf1_pwl_base_seg7 = 0;	// U0.6, BF1 Base PWL Segment 7
+
+			dscl_prog_data->easf_v_bf3_pwl_in_set0 = 0x000;	// FP0.6.6, BF3 Input value PWL Segment 0
+			dscl_prog_data->easf_v_bf3_pwl_base_set0 = 63;	// S0.6, BF3 Base PWL Segment 0
+			dscl_prog_data->easf_v_bf3_pwl_slope_set0 = 0x12C5;	// FP1.6.6, BF3 Slope PWL Segment 0
+			dscl_prog_data->easf_v_bf3_pwl_in_set1 =
+				0x0B37; // FP0.6.6, BF3 Input value PWL Segment 1 (0.0078125 * 125^3)
+			dscl_prog_data->easf_v_bf3_pwl_base_set1 = 62;	// S0.6, BF3 Base PWL Segment 1
+			dscl_prog_data->easf_v_bf3_pwl_slope_set1 =
+				0x13B8;	// FP1.6.6, BF3 Slope PWL Segment 1
+			dscl_prog_data->easf_v_bf3_pwl_in_set2 =
+				0x0BB7;	// FP0.6.6, BF3 Input value PWL Segment 2 (0.03125 * 125^3)
+			dscl_prog_data->easf_v_bf3_pwl_base_set2 = 20;	// S0.6, BF3 Base PWL Segment 2
+			dscl_prog_data->easf_v_bf3_pwl_slope_set2 =
+				0x1356;	// FP1.6.6, BF3 Slope PWL Segment 2
+			dscl_prog_data->easf_v_bf3_pwl_in_set3 =
+				0x0BF7;	// FP0.6.6, BF3 Input value PWL Segment 3 (0.0625 * 125^3)
+			dscl_prog_data->easf_v_bf3_pwl_base_set3 = 0;	// S0.6, BF3 Base PWL Segment 3
+			dscl_prog_data->easf_v_bf3_pwl_slope_set3 =
+				0x136B;	// FP1.6.6, BF3 Slope PWL Segment 3
+			dscl_prog_data->easf_v_bf3_pwl_in_set4 =
+				0x0C37;	// FP0.6.6, BF3 Input value PWL Segment 4 (0.125 * 125^3)
+			dscl_prog_data->easf_v_bf3_pwl_base_set4 = 0x4E;	// S0.6, BF3 Base PWL Segment 4 = -50
+			dscl_prog_data->easf_v_bf3_pwl_slope_set4 =
+				0x1200;	// FP1.6.6, BF3 Slope PWL Segment 4
+			dscl_prog_data->easf_v_bf3_pwl_in_set5 =
+				0x0CF7;	// FP0.6.6, BF3 Input value PWL Segment 5 (1.0 * 125^3)
+			dscl_prog_data->easf_v_bf3_pwl_base_set5 = 0x41;	// S0.6, BF3 Base PWL Segment 5 = -63
+		}	else	{
+			dscl_prog_data->easf_v_bf2_flat1_gain = 13;	// U1.3, BF2 Flat1 Gain control
+			dscl_prog_data->easf_v_bf2_flat2_gain = 15;	// U4.0, BF2 Flat2 Gain control
+			dscl_prog_data->easf_v_bf2_roc_gain = 14;	// U2.2, Rate Of Change control
+
+			dscl_prog_data->easf_v_bf1_pwl_in_seg0 = 0x440;	// S0.10, BF1 PWL Segment 0 = -960
+			dscl_prog_data->easf_v_bf1_pwl_base_seg0 = 0;	// U0.6, BF1 Base PWL Segment 0
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg0 = 2;	// S7.3, BF1 Slope PWL Segment 0
+			dscl_prog_data->easf_v_bf1_pwl_in_seg1 = 0x7C4;	// S0.10, BF1 PWL Segment 1 = -60
+			dscl_prog_data->easf_v_bf1_pwl_base_seg1 = 12;	// U0.6, BF1 Base PWL Segment 1
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg1 = 109;	// S7.3, BF1 Slope PWL Segment 1
+			dscl_prog_data->easf_v_bf1_pwl_in_seg2 = 0;	// S0.10, BF1 PWL Segment 2
+			dscl_prog_data->easf_v_bf1_pwl_base_seg2 = 63;	// U0.6, BF1 Base PWL Segment 2
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg2 = 0;	// S7.3, BF1 Slope PWL Segment 2
+			dscl_prog_data->easf_v_bf1_pwl_in_seg3 = 48;	// S0.10, BF1 PWL Segment 3
+			dscl_prog_data->easf_v_bf1_pwl_base_seg3 = 63;	// U0.6, BF1 Base PWL Segment 3
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg3 = 0x7ED;	// S7.3, BF1 Slope PWL Segment 3 = -19
+			dscl_prog_data->easf_v_bf1_pwl_in_seg4 = 96;	// S0.10, BF1 PWL Segment 4
+			dscl_prog_data->easf_v_bf1_pwl_base_seg4 = 56;	// U0.6, BF1 Base PWL Segment 4
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg4 = 0x7F0;	// S7.3, BF1 Slope PWL Segment 4 = -16
+			dscl_prog_data->easf_v_bf1_pwl_in_seg5 = 144;	// S0.10, BF1 PWL Segment 5
+			dscl_prog_data->easf_v_bf1_pwl_base_seg5 = 50;	// U0.6, BF1 Base PWL Segment 5
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg5 = 0x7B0;	// S7.3, BF1 Slope PWL Segment 5 = -80
+			dscl_prog_data->easf_v_bf1_pwl_in_seg6 = 192;	// S0.10, BF1 PWL Segment 6
+			dscl_prog_data->easf_v_bf1_pwl_base_seg6 = 20;	// U0.6, BF1 Base PWL Segment 6
+			dscl_prog_data->easf_v_bf1_pwl_slope_seg6 = 0x7CB;	// S7.3, BF1 Slope PWL Segment 6 = -53
+			dscl_prog_data->easf_v_bf1_pwl_in_seg7 = 240;	// S0.10, BF1 PWL Segment 7
+			dscl_prog_data->easf_v_bf1_pwl_base_seg7 = 0;	// U0.6, BF1 Base PWL Segment 7
+
+			dscl_prog_data->easf_v_bf3_pwl_in_set0 = 0x000;	// FP0.6.6, BF3 Input value PWL Segment 0
+			dscl_prog_data->easf_v_bf3_pwl_base_set0 = 63;	// S0.6, BF3 Base PWL Segment 0
+			dscl_prog_data->easf_v_bf3_pwl_slope_set0 = 0x0000;	// FP1.6.6, BF3 Slope PWL Segment 0
+			dscl_prog_data->easf_v_bf3_pwl_in_set1 =
+				0x06C0; // FP0.6.6, BF3 Input value PWL Segment 1 (0.0625)
+			dscl_prog_data->easf_v_bf3_pwl_base_set1 = 63;	// S0.6, BF3 Base PWL Segment 1
+			dscl_prog_data->easf_v_bf3_pwl_slope_set1 = 0x1896;	// FP1.6.6, BF3 Slope PWL Segment 1
+			dscl_prog_data->easf_v_bf3_pwl_in_set2 =
+				0x0700;	// FP0.6.6, BF3 Input value PWL Segment 2 (0.125)
+			dscl_prog_data->easf_v_bf3_pwl_base_set2 = 20;	// S0.6, BF3 Base PWL Segment 2
+			dscl_prog_data->easf_v_bf3_pwl_slope_set2 = 0x1810;	// FP1.6.6, BF3 Slope PWL Segment 2
+			dscl_prog_data->easf_v_bf3_pwl_in_set3 =
+				0x0740;	// FP0.6.6, BF3 Input value PWL Segment 3 (0.25)
+			dscl_prog_data->easf_v_bf3_pwl_base_set3 = 0;	// S0.6, BF3 Base PWL Segment 3
+			dscl_prog_data->easf_v_bf3_pwl_slope_set3 =
+				0x1878;	// FP1.6.6, BF3 Slope PWL Segment 3
+			dscl_prog_data->easf_v_bf3_pwl_in_set4 =
+				0x0761;	// FP0.6.6, BF3 Input value PWL Segment 4 (0.375)
+			dscl_prog_data->easf_v_bf3_pwl_base_set4 = 0x44;	// S0.6, BF3 Base PWL Segment 4 = -60
+			dscl_prog_data->easf_v_bf3_pwl_slope_set4 = 0x1760;	// FP1.6.6, BF3 Slope PWL Segment 4
+			dscl_prog_data->easf_v_bf3_pwl_in_set5 =
+				0x0780;	// FP0.6.6, BF3 Input value PWL Segment 5 (0.5)
+			dscl_prog_data->easf_v_bf3_pwl_base_set5 = 0x41;	// S0.6, BF3 Base PWL Segment 5 = -63
+		}
+	} else
+		dscl_prog_data->easf_v_en = false;
+
+	if (enable_easf_h) {
+		dscl_prog_data->easf_h_en = true;
+		dscl_prog_data->easf_h_ring = 0;
+		dscl_prog_data->easf_h_sharp_factor = 0;
+		dscl_prog_data->easf_h_bf1_en =
+			1;	// 1-bit, BF1 calculation enable, 0=disable, 1=enable
+		dscl_prog_data->easf_h_bf2_mode =
+			0xF;	// 4-bit, BF2 calculation mode
+		/* 2-bit, BF3 chroma mode correction calculation mode */
+		dscl_prog_data->easf_h_bf3_mode = spl_get_h_bf3_mode(
+			spl_scratch->scl_data.recip_ratios.horz);
+		/* FP1.5.10; (2.0) Ring reducer gain for 4 or 6-tap mode [H_REDUCER_GAIN4] */
+		dscl_prog_data->easf_h_ringest_eventap_reduceg1 =
+			spl_get_reducer_gain4(spl_scratch->scl_data.taps.h_taps,
+				spl_scratch->scl_data.recip_ratios.horz);
+		/* FP1.5.10; (2.5) Ring reducer gain for 6-tap mode [V_REDUCER_GAIN6] */
+		dscl_prog_data->easf_h_ringest_eventap_reduceg2 =
+			spl_get_reducer_gain6(spl_scratch->scl_data.taps.h_taps,
+				spl_scratch->scl_data.recip_ratios.horz);
+		/* FP1.5.10; (-0.135742) Ring gain for 6-tap set to -139/1024 */
+		dscl_prog_data->easf_h_ringest_eventap_gain1 =
+			spl_get_gainRing4(spl_scratch->scl_data.taps.h_taps,
+				spl_scratch->scl_data.recip_ratios.horz);
+		/* FP1.5.10; (-0.024414) Ring gain for 6-tap set to -25/1024 */
+		dscl_prog_data->easf_h_ringest_eventap_gain2 =
+			spl_get_gainRing6(spl_scratch->scl_data.taps.h_taps,
+				spl_scratch->scl_data.recip_ratios.horz);
+		dscl_prog_data->easf_h_bf_maxa = 63; //Horz Max BF value A in U0.6 format.Selected if H_FCNTL==0
+		dscl_prog_data->easf_h_bf_maxb = 63; //Horz Max BF value B in U0.6 format.Selected if H_FCNTL==1
+		dscl_prog_data->easf_h_bf_mina = 0;	//Horz Min BF value B in U0.6 format.Selected if H_FCNTL==0
+		dscl_prog_data->easf_h_bf_minb = 0;	//Horz Min BF value B in U0.6 format.Selected if H_FCNTL==1
+		if (lls_pref == LLS_PREF_YES)	{
+			dscl_prog_data->easf_h_bf2_flat1_gain = 4;	// U1.3, BF2 Flat1 Gain control
+			dscl_prog_data->easf_h_bf2_flat2_gain = 8;	// U4.0, BF2 Flat2 Gain control
+			dscl_prog_data->easf_h_bf2_roc_gain = 4;	// U2.2, Rate Of Change control
+
+			dscl_prog_data->easf_h_bf1_pwl_in_seg0 = 0x600;	// S0.10, BF1 PWL Segment 0 = -512
+			dscl_prog_data->easf_h_bf1_pwl_base_seg0 = 0;	// U0.6, BF1 Base PWL Segment 0
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg0 = 3;	// S7.3, BF1 Slope PWL Segment 0
+			dscl_prog_data->easf_h_bf1_pwl_in_seg1 = 0x7EC;	// S0.10, BF1 PWL Segment 1 = -20
+			dscl_prog_data->easf_h_bf1_pwl_base_seg1 = 12;	// U0.6, BF1 Base PWL Segment 1
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg1 = 326;	// S7.3, BF1 Slope PWL Segment 1
+			dscl_prog_data->easf_h_bf1_pwl_in_seg2 = 0;	// S0.10, BF1 PWL Segment 2
+			dscl_prog_data->easf_h_bf1_pwl_base_seg2 = 63;	// U0.6, BF1 Base PWL Segment 2
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg2 = 0;	// S7.3, BF1 Slope PWL Segment 2
+			dscl_prog_data->easf_h_bf1_pwl_in_seg3 = 16;	// S0.10, BF1 PWL Segment 3
+			dscl_prog_data->easf_h_bf1_pwl_base_seg3 = 63;	// U0.6, BF1 Base PWL Segment 3
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg3 = 0x7C8;	// S7.3, BF1 Slope PWL Segment 3 = -56
+			dscl_prog_data->easf_h_bf1_pwl_in_seg4 = 32;	// S0.10, BF1 PWL Segment 4
+			dscl_prog_data->easf_h_bf1_pwl_base_seg4 = 56;	// U0.6, BF1 Base PWL Segment 4
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg4 = 0x7D0;	// S7.3, BF1 Slope PWL Segment 4 = -48
+			dscl_prog_data->easf_h_bf1_pwl_in_seg5 = 48;	// S0.10, BF1 PWL Segment 5
+			dscl_prog_data->easf_h_bf1_pwl_base_seg5 = 50;	// U0.6, BF1 Base PWL Segment 5
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg5 = 0x710;	// S7.3, BF1 Slope PWL Segment 5 = -240
+			dscl_prog_data->easf_h_bf1_pwl_in_seg6 = 64;	// S0.10, BF1 PWL Segment 6
+			dscl_prog_data->easf_h_bf1_pwl_base_seg6 = 20;	// U0.6, BF1 Base PWL Segment 6
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg6 = 0x760;	// S7.3, BF1 Slope PWL Segment 6 = -160
+			dscl_prog_data->easf_h_bf1_pwl_in_seg7 = 80;	// S0.10, BF1 PWL Segment 7
+			dscl_prog_data->easf_h_bf1_pwl_base_seg7 = 0;	// U0.6, BF1 Base PWL Segment 7
+
+			dscl_prog_data->easf_h_bf3_pwl_in_set0 = 0x000;	// FP0.6.6, BF3 Input value PWL Segment 0
+			dscl_prog_data->easf_h_bf3_pwl_base_set0 = 63;	// S0.6, BF3 Base PWL Segment 0
+			dscl_prog_data->easf_h_bf3_pwl_slope_set0 = 0x12C5;	// FP1.6.6, BF3 Slope PWL Segment 0
+			dscl_prog_data->easf_h_bf3_pwl_in_set1 =
+				0x0B37;	// FP0.6.6, BF3 Input value PWL Segment 1 (0.0078125 * 125^3)
+			dscl_prog_data->easf_h_bf3_pwl_base_set1 = 62;	// S0.6, BF3 Base PWL Segment 1
+			dscl_prog_data->easf_h_bf3_pwl_slope_set1 =	0x13B8;	// FP1.6.6, BF3 Slope PWL Segment 1
+			dscl_prog_data->easf_h_bf3_pwl_in_set2 =
+				0x0BB7;	// FP0.6.6, BF3 Input value PWL Segment 2 (0.03125 * 125^3)
+			dscl_prog_data->easf_h_bf3_pwl_base_set2 = 20;	// S0.6, BF3 Base PWL Segment 2
+			dscl_prog_data->easf_h_bf3_pwl_slope_set2 =	0x1356;	// FP1.6.6, BF3 Slope PWL Segment 2
+			dscl_prog_data->easf_h_bf3_pwl_in_set3 =
+				0x0BF7;	// FP0.6.6, BF3 Input value PWL Segment 3 (0.0625 * 125^3)
+			dscl_prog_data->easf_h_bf3_pwl_base_set3 = 0;	// S0.6, BF3 Base PWL Segment 3
+			dscl_prog_data->easf_h_bf3_pwl_slope_set3 =	0x136B;	// FP1.6.6, BF3 Slope PWL Segment 3
+			dscl_prog_data->easf_h_bf3_pwl_in_set4 =
+				0x0C37;	// FP0.6.6, BF3 Input value PWL Segment 4 (0.125 * 125^3)
+			dscl_prog_data->easf_h_bf3_pwl_base_set4 = 0x4E;	// S0.6, BF3 Base PWL Segment 4 = -50
+			dscl_prog_data->easf_h_bf3_pwl_slope_set4 = 0x1200;	// FP1.6.6, BF3 Slope PWL Segment 4
+			dscl_prog_data->easf_h_bf3_pwl_in_set5 =
+				0x0CF7;	// FP0.6.6, BF3 Input value PWL Segment 5 (1.0 * 125^3)
+			dscl_prog_data->easf_h_bf3_pwl_base_set5 = 0x41;	// S0.6, BF3 Base PWL Segment 5 = -63
+		} else {
+			dscl_prog_data->easf_h_bf2_flat1_gain = 13;	// U1.3, BF2 Flat1 Gain control
+			dscl_prog_data->easf_h_bf2_flat2_gain = 15;	// U4.0, BF2 Flat2 Gain control
+			dscl_prog_data->easf_h_bf2_roc_gain = 14;	// U2.2, Rate Of Change control
+
+			dscl_prog_data->easf_h_bf1_pwl_in_seg0 = 0x440;	// S0.10, BF1 PWL Segment 0 = -960
+			dscl_prog_data->easf_h_bf1_pwl_base_seg0 = 0;	// U0.6, BF1 Base PWL Segment 0
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg0 = 2;	// S7.3, BF1 Slope PWL Segment 0
+			dscl_prog_data->easf_h_bf1_pwl_in_seg1 = 0x7C4;	// S0.10, BF1 PWL Segment 1 = -60
+			dscl_prog_data->easf_h_bf1_pwl_base_seg1 = 12;	// U0.6, BF1 Base PWL Segment 1
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg1 = 109;	// S7.3, BF1 Slope PWL Segment 1
+			dscl_prog_data->easf_h_bf1_pwl_in_seg2 = 0;	// S0.10, BF1 PWL Segment 2
+			dscl_prog_data->easf_h_bf1_pwl_base_seg2 = 63;	// U0.6, BF1 Base PWL Segment 2
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg2 = 0;	// S7.3, BF1 Slope PWL Segment 2
+			dscl_prog_data->easf_h_bf1_pwl_in_seg3 = 48;	// S0.10, BF1 PWL Segment 3
+			dscl_prog_data->easf_h_bf1_pwl_base_seg3 = 63;	// U0.6, BF1 Base PWL Segment 3
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg3 = 0x7ED;	// S7.3, BF1 Slope PWL Segment 3 = -19
+			dscl_prog_data->easf_h_bf1_pwl_in_seg4 = 96;	// S0.10, BF1 PWL Segment 4
+			dscl_prog_data->easf_h_bf1_pwl_base_seg4 = 56;	// U0.6, BF1 Base PWL Segment 4
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg4 = 0x7F0;	// S7.3, BF1 Slope PWL Segment 4 = -16
+			dscl_prog_data->easf_h_bf1_pwl_in_seg5 = 144;	// S0.10, BF1 PWL Segment 5
+			dscl_prog_data->easf_h_bf1_pwl_base_seg5 = 50;	// U0.6, BF1 Base PWL Segment 5
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg5 = 0x7B0;	// S7.3, BF1 Slope PWL Segment 5 = -80
+			dscl_prog_data->easf_h_bf1_pwl_in_seg6 = 192;	// S0.10, BF1 PWL Segment 6
+			dscl_prog_data->easf_h_bf1_pwl_base_seg6 = 20;	// U0.6, BF1 Base PWL Segment 6
+			dscl_prog_data->easf_h_bf1_pwl_slope_seg6 = 0x7CB;	// S7.3, BF1 Slope PWL Segment 6 = -53
+			dscl_prog_data->easf_h_bf1_pwl_in_seg7 = 240;	// S0.10, BF1 PWL Segment 7
+			dscl_prog_data->easf_h_bf1_pwl_base_seg7 = 0;	// U0.6, BF1 Base PWL Segment 7
+
+			dscl_prog_data->easf_h_bf3_pwl_in_set0 = 0x000;	// FP0.6.6, BF3 Input value PWL Segment 0
+			dscl_prog_data->easf_h_bf3_pwl_base_set0 = 63;	// S0.6, BF3 Base PWL Segment 0
+			dscl_prog_data->easf_h_bf3_pwl_slope_set0 = 0x0000;	// FP1.6.6, BF3 Slope PWL Segment 0
+			dscl_prog_data->easf_h_bf3_pwl_in_set1 =
+				0x06C0;	// FP0.6.6, BF3 Input value PWL Segment 1 (0.0625)
+			dscl_prog_data->easf_h_bf3_pwl_base_set1 = 63;	// S0.6, BF3 Base PWL Segment 1
+			dscl_prog_data->easf_h_bf3_pwl_slope_set1 = 0x1896;	// FP1.6.6, BF3 Slope PWL Segment 1
+			dscl_prog_data->easf_h_bf3_pwl_in_set2 =
+				0x0700;	// FP0.6.6, BF3 Input value PWL Segment 2 (0.125)
+			dscl_prog_data->easf_h_bf3_pwl_base_set2 = 20;	// S0.6, BF3 Base PWL Segment 2
+			dscl_prog_data->easf_h_bf3_pwl_slope_set2 = 0x1810;	// FP1.6.6, BF3 Slope PWL Segment 2
+			dscl_prog_data->easf_h_bf3_pwl_in_set3 =
+				0x0740;	// FP0.6.6, BF3 Input value PWL Segment 3 (0.25)
+			dscl_prog_data->easf_h_bf3_pwl_base_set3 = 0;	// S0.6, BF3 Base PWL Segment 3
+			dscl_prog_data->easf_h_bf3_pwl_slope_set3 = 0x1878;	// FP1.6.6, BF3 Slope PWL Segment 3
+			dscl_prog_data->easf_h_bf3_pwl_in_set4 =
+				0x0761;	// FP0.6.6, BF3 Input value PWL Segment 4 (0.375)
+			dscl_prog_data->easf_h_bf3_pwl_base_set4 = 0x44;	// S0.6, BF3 Base PWL Segment 4 = -60
+			dscl_prog_data->easf_h_bf3_pwl_slope_set4 = 0x1760;	// FP1.6.6, BF3 Slope PWL Segment 4
+			dscl_prog_data->easf_h_bf3_pwl_in_set5 =
+				0x0780;	// FP0.6.6, BF3 Input value PWL Segment 5 (0.5)
+			dscl_prog_data->easf_h_bf3_pwl_base_set5 = 0x41;	// S0.6, BF3 Base PWL Segment 5 = -63
+		} // if (lls_pref == LLS_PREF_YES)
+	} else
+		dscl_prog_data->easf_h_en = false;
+
+	if (lls_pref == LLS_PREF_YES)	{
+		dscl_prog_data->easf_ltonl_en = 1;	// Linear input
+		if ((setup == HDR_L) && (spl_is_rgb8(format))) {
+			/* Calculate C0-C3 coefficients based on HDR multiplier */
+			spl_calculate_c0_c3_hdr(dscl_prog_data, sdr_white_level_nits);
+		} else { // HDR_L ( DWM ) and SDR_L
+			dscl_prog_data->easf_matrix_c0 =
+				0x4EF7;	// fp1.5.10, C0 coefficient (LN_rec709:  0.2126 * (2^14)/125 = 27.86590720)
+			dscl_prog_data->easf_matrix_c1 =
+				0x55DC;	// fp1.5.10, C1 coefficient (LN_rec709:  0.7152 * (2^14)/125 = 93.74269440)
+			dscl_prog_data->easf_matrix_c2 =
+				0x48BB;	// fp1.5.10, C2 coefficient (LN_rec709:  0.0722 * (2^14)/125 = 9.46339840)
+			dscl_prog_data->easf_matrix_c3 =
+				0x0;	// fp1.5.10, C3 coefficient
+		}
+	}	else	{
+		dscl_prog_data->easf_ltonl_en = 0;	// Non-Linear input
+		dscl_prog_data->easf_matrix_c0 =
+			0x3434;	// fp1.5.10, C0 coefficient (LN_BT2020:  0.262695312500000)
+		dscl_prog_data->easf_matrix_c1 =
+			0x396D;	// fp1.5.10, C1 coefficient (LN_BT2020:  0.678222656250000)
+		dscl_prog_data->easf_matrix_c2 =
+			0x2B97;	// fp1.5.10, C2 coefficient (LN_BT2020:  0.059295654296875)
+		dscl_prog_data->easf_matrix_c3 =
+			0x0;	// fp1.5.10, C3 coefficient
+	}
+
+	if (spl_is_subsampled_format(format)) { /* TODO: 0 = RGB, 1 = YUV */
+		dscl_prog_data->easf_matrix_mode = 1;
+		/*
+		 * 2-bit, BF3 chroma mode correction calculation mode
+		 * Needs to be disabled for YUV420 mode
+		 * Override lookup value
+		 */
+		dscl_prog_data->easf_v_bf3_mode = 0;
+		dscl_prog_data->easf_h_bf3_mode = 0;
+	} else
+		dscl_prog_data->easf_matrix_mode = 0;
+
+}
+
+/*Set isharp noise detection */
+static void spl_set_isharp_noise_det_mode(struct dscl_prog_data *dscl_prog_data,
+	const struct spl_scaler_data *data)
+{
+	// ISHARP_NOISEDET_MODE
+	// 0: 3x5 as VxH
+	// 1: 4x5 as VxH
+	// 2:
+	// 3: 5x5 as VxH
+	if (data->taps.v_taps == 6)
+		dscl_prog_data->isharp_noise_det.mode = 3;
+	else if (data->taps.v_taps == 4)
+		dscl_prog_data->isharp_noise_det.mode = 1;
+	else if (data->taps.v_taps == 3)
+		dscl_prog_data->isharp_noise_det.mode = 0;
+};
+/* Set Sharpener data */
+static void spl_set_isharp_data(struct dscl_prog_data *dscl_prog_data,
+		struct adaptive_sharpness adp_sharpness, bool enable_isharp,
+		enum linear_light_scaling lls_pref, enum spl_pixel_format format,
+		const struct spl_scaler_data *data, struct spl_fixed31_32 ratio,
+		enum system_setup setup, enum scale_to_sharpness_policy scale_to_sharpness_policy)
+{
+	/* Turn off sharpener if not required */
+	if (!enable_isharp) {
+		dscl_prog_data->isharp_en = 0;
+		return;
+	}
+
+	spl_build_isharp_1dlut_from_reference_curve(ratio, setup, adp_sharpness,
+		scale_to_sharpness_policy);
+	memcpy(dscl_prog_data->isharp_delta, spl_get_pregen_filter_isharp_1D_lut(setup),
+		sizeof(uint32_t) * ISHARP_LUT_TABLE_SIZE);
+	dscl_prog_data->sharpness_level = adp_sharpness.sharpness_level;
+
+	dscl_prog_data->isharp_en = 1;	// ISHARP_EN
+	// Set ISHARP_NOISEDET_MODE if htaps = 6-tap
+	if (data->taps.h_taps == 6) {
+		dscl_prog_data->isharp_noise_det.enable = 1;	/* ISHARP_NOISEDET_EN */
+		spl_set_isharp_noise_det_mode(dscl_prog_data, data);	/* ISHARP_NOISEDET_MODE */
+	} else
+		dscl_prog_data->isharp_noise_det.enable = 0;	// ISHARP_NOISEDET_EN
+	// Program noise detection threshold
+	dscl_prog_data->isharp_noise_det.uthreshold = 24;	// ISHARP_NOISEDET_UTHRE
+	dscl_prog_data->isharp_noise_det.dthreshold = 4;	// ISHARP_NOISEDET_DTHRE
+	// Program noise detection gain
+	dscl_prog_data->isharp_noise_det.pwl_start_in = 3;	// ISHARP_NOISEDET_PWL_START_IN
+	dscl_prog_data->isharp_noise_det.pwl_end_in = 13;	// ISHARP_NOISEDET_PWL_END_IN
+	dscl_prog_data->isharp_noise_det.pwl_slope = 1623;	// ISHARP_NOISEDET_PWL_SLOPE
+
+	if (lls_pref == LLS_PREF_NO) /* ISHARP_FMT_MODE */
+		dscl_prog_data->isharp_fmt.mode = 1;
+	else
+		dscl_prog_data->isharp_fmt.mode = 0;
+
+	dscl_prog_data->isharp_fmt.norm = 0x3C00;	// ISHARP_FMT_NORM
+	dscl_prog_data->isharp_lba.mode = 0;	// ISHARP_LBA_MODE
+
+	if (setup == SDR_L) {
+		// ISHARP_LBA_PWL_SEG0: ISHARP Local Brightness Adjustment PWL Segment 0
+		dscl_prog_data->isharp_lba.in_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[0] = 62;	// ISHARP LBA for Seg 0. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG1: ISHARP LBA PWL Segment 1
+		dscl_prog_data->isharp_lba.in_seg[1] = 130;	// ISHARP LBA PWL for Seg 1. INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[1] = 63; // ISHARP LBA PWL for Seg 1. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[1] = 0; // ISHARP LBA for Seg 1. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG2: ISHARP LBA PWL Segment 2
+		dscl_prog_data->isharp_lba.in_seg[2] = 450; // ISHARP LBA PWL for Seg 2. INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[2] = 63; // ISHARP LBA PWL for Seg 2. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[2] = 0x18D; // ISHARP LBA for Seg 2. SLOPE value in S5.3 format = -115
+		// ISHARP_LBA_PWL_SEG3: ISHARP LBA PWL Segment 3
+		dscl_prog_data->isharp_lba.in_seg[3] = 520; // ISHARP LBA PWL for Seg 3.INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[3] = 0; // ISHARP LBA PWL for Seg 3. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[3] = 0; // ISHARP LBA for Seg 3. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG4: ISHARP LBA PWL Segment 4
+		dscl_prog_data->isharp_lba.in_seg[4] = 520; // ISHARP LBA PWL for Seg 4.INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[4] = 0; // ISHARP LBA PWL for Seg 4. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[4] = 0; // ISHARP LBA for Seg 4. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG5: ISHARP LBA PWL Segment 5
+		dscl_prog_data->isharp_lba.in_seg[5] = 520; // ISHARP LBA PWL for Seg 5.INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[5] = 0;	// ISHARP LBA PWL for Seg 5. BASE value in U0.6 format
+	} else if (setup == HDR_L) {
+		// ISHARP_LBA_PWL_SEG0: ISHARP Local Brightness Adjustment PWL Segment 0
+		dscl_prog_data->isharp_lba.in_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[0] = 32;	// ISHARP LBA for Seg 0. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG1: ISHARP LBA PWL Segment 1
+		dscl_prog_data->isharp_lba.in_seg[1] = 254;	// ISHARP LBA PWL for Seg 1. INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[1] = 63; // ISHARP LBA PWL for Seg 1. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[1] = 0; // ISHARP LBA for Seg 1. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG2: ISHARP LBA PWL Segment 2
+		dscl_prog_data->isharp_lba.in_seg[2] = 559; // ISHARP LBA PWL for Seg 2. INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[2] = 63; // ISHARP LBA PWL for Seg 2. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[2] = 0x10C; // ISHARP LBA for Seg 2. SLOPE value in S5.3 format = -244
+		// ISHARP_LBA_PWL_SEG3: ISHARP LBA PWL Segment 3
+		dscl_prog_data->isharp_lba.in_seg[3] = 592; // ISHARP LBA PWL for Seg 3.INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[3] = 0; // ISHARP LBA PWL for Seg 3. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[3] = 0; // ISHARP LBA for Seg 3. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG4: ISHARP LBA PWL Segment 4
+		dscl_prog_data->isharp_lba.in_seg[4] = 1023; // ISHARP LBA PWL for Seg 4.INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[4] = 0; // ISHARP LBA PWL for Seg 4. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[4] = 0; // ISHARP LBA for Seg 4. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG5: ISHARP LBA PWL Segment 5
+		dscl_prog_data->isharp_lba.in_seg[5] = 1023; // ISHARP LBA PWL for Seg 5.INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[5] = 0;	// ISHARP LBA PWL for Seg 5. BASE value in U0.6 format
+	} else {
+		// ISHARP_LBA_PWL_SEG0: ISHARP Local Brightness Adjustment PWL Segment 0
+		dscl_prog_data->isharp_lba.in_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[0] = 0;	// ISHARP LBA PWL for Seg 0. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[0] = 40;	// ISHARP LBA for Seg 0. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG1: ISHARP LBA PWL Segment 1
+		dscl_prog_data->isharp_lba.in_seg[1] = 204;	// ISHARP LBA PWL for Seg 1. INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[1] = 63; // ISHARP LBA PWL for Seg 1. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[1] = 0; // ISHARP LBA for Seg 1. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG2: ISHARP LBA PWL Segment 2
+		dscl_prog_data->isharp_lba.in_seg[2] = 818; // ISHARP LBA PWL for Seg 2. INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[2] = 63; // ISHARP LBA PWL for Seg 2. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[2] = 0x1D9; // ISHARP LBA for Seg 2. SLOPE value in S5.3 format = -39
+		// ISHARP_LBA_PWL_SEG3: ISHARP LBA PWL Segment 3
+		dscl_prog_data->isharp_lba.in_seg[3] = 1023; // ISHARP LBA PWL for Seg 3.INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[3] = 0; // ISHARP LBA PWL for Seg 3. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[3] = 0; // ISHARP LBA for Seg 3. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG4: ISHARP LBA PWL Segment 4
+		dscl_prog_data->isharp_lba.in_seg[4] = 1023; // ISHARP LBA PWL for Seg 4.INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[4] = 0; // ISHARP LBA PWL for Seg 4. BASE value in U0.6 format
+		dscl_prog_data->isharp_lba.slope_seg[4] = 0; // ISHARP LBA for Seg 4. SLOPE value in S5.3 format
+		// ISHARP_LBA_PWL_SEG5: ISHARP LBA PWL Segment 5
+		dscl_prog_data->isharp_lba.in_seg[5] = 1023; // ISHARP LBA PWL for Seg 5.INPUT value in U0.10 format
+		dscl_prog_data->isharp_lba.base_seg[5] = 0;	// ISHARP LBA PWL for Seg 5. BASE value in U0.6 format
+	}
+
+	// Program the nldelta soft clip values
+	if (lls_pref == LLS_PREF_YES) {
+		dscl_prog_data->isharp_nldelta_sclip.enable_p = 0;	/* ISHARP_NLDELTA_SCLIP_EN_P */
+		dscl_prog_data->isharp_nldelta_sclip.pivot_p = 0;	/* ISHARP_NLDELTA_SCLIP_PIVOT_P */
+		dscl_prog_data->isharp_nldelta_sclip.slope_p = 0;	/* ISHARP_NLDELTA_SCLIP_SLOPE_P */
+		dscl_prog_data->isharp_nldelta_sclip.enable_n = 1;	/* ISHARP_NLDELTA_SCLIP_EN_N */
+		dscl_prog_data->isharp_nldelta_sclip.pivot_n = 71;	/* ISHARP_NLDELTA_SCLIP_PIVOT_N */
+		dscl_prog_data->isharp_nldelta_sclip.slope_n = 16;	/* ISHARP_NLDELTA_SCLIP_SLOPE_N */
+	} else {
+		dscl_prog_data->isharp_nldelta_sclip.enable_p = 1;	/* ISHARP_NLDELTA_SCLIP_EN_P */
+		dscl_prog_data->isharp_nldelta_sclip.pivot_p = 70;	/* ISHARP_NLDELTA_SCLIP_PIVOT_P */
+		dscl_prog_data->isharp_nldelta_sclip.slope_p = 24;	/* ISHARP_NLDELTA_SCLIP_SLOPE_P */
+		dscl_prog_data->isharp_nldelta_sclip.enable_n = 1;	/* ISHARP_NLDELTA_SCLIP_EN_N */
+		dscl_prog_data->isharp_nldelta_sclip.pivot_n = 70;	/* ISHARP_NLDELTA_SCLIP_PIVOT_N */
+		dscl_prog_data->isharp_nldelta_sclip.slope_n = 24;	/* ISHARP_NLDELTA_SCLIP_SLOPE_N */
+	}
+
+	// Set the values as per lookup table
+	spl_set_blur_scale_data(dscl_prog_data, data);
+}
+
+/* Calculate recout, scaling ratio, and viewport, then get optimal number of taps */
+static bool spl_calculate_number_of_taps(struct spl_in *spl_in, struct spl_scratch *spl_scratch, struct spl_out *spl_out,
+	bool *enable_easf_v, bool *enable_easf_h, bool *enable_isharp)
+{
+	bool res = false;
+
+	memset(spl_scratch, 0, sizeof(struct spl_scratch));
+	spl_scratch->scl_data.h_active = spl_in->h_active;
+	spl_scratch->scl_data.v_active = spl_in->v_active;
+
+	// All SPL calls
+	/* recout calculation */
+	/* depends on h_active */
+	spl_calculate_recout(spl_in, spl_scratch, spl_out);
+	/* depends on pixel format */
+	spl_calculate_scaling_ratios(spl_in, spl_scratch, spl_out);
+	/* depends on scaling ratios and recout, does not calculate offset yet */
+	spl_calculate_viewport_size(spl_in, spl_scratch);
+
+	res = spl_get_optimal_number_of_taps(
+			  spl_in->basic_out.max_downscale_src_width, spl_in,
+			  spl_scratch, &spl_in->scaling_quality, enable_easf_v,
+			  enable_easf_h, enable_isharp);
+	return res;
+}
+
+/* Calculate scaler parameters */
+bool spl_calculate_scaler_params(struct spl_in *spl_in, struct spl_out *spl_out)
+{
+	bool res = false;
+	bool enable_easf_v = false;
+	bool enable_easf_h = false;
+	int vratio = 0;
+	int hratio = 0;
+	struct spl_scratch spl_scratch;
+	struct spl_fixed31_32 isharp_scale_ratio;
+	enum system_setup setup;
+	bool enable_isharp = false;
+	const struct spl_scaler_data *data = &spl_scratch.scl_data;
+
+	res = spl_calculate_number_of_taps(spl_in, &spl_scratch, spl_out,
+		&enable_easf_v, &enable_easf_h, &enable_isharp);
+
+	/*
+	 * Depends on recout, scaling ratios, h_active and taps
+	 * May need to re-check lb size after this in some obscure scenario
+	 */
+	if (res)
+		spl_calculate_inits_and_viewports(spl_in, &spl_scratch);
+	// Handle 3d recout
+	spl_handle_3d_recout(spl_in, &spl_scratch.scl_data.recout);
+	// Clamp
+	spl_clamp_viewport(&spl_scratch.scl_data.viewport);
+
+	// Save all calculated parameters in dscl_prog_data structure to program hw registers
+	spl_set_dscl_prog_data(spl_in, &spl_scratch, spl_out, enable_easf_v, enable_easf_h, enable_isharp);
+
+	if (!res)
+		return res;
+
+	if (spl_in->lls_pref == LLS_PREF_YES) {
+		if (spl_in->is_hdr_on)
+			setup = HDR_L;
+		else
+			setup = SDR_L;
+	} else {
+		if (spl_in->is_hdr_on)
+			setup = HDR_NL;
+		else
+			setup = SDR_NL;
+	}
+
+	// Set EASF
+	spl_set_easf_data(&spl_scratch, spl_out, enable_easf_v, enable_easf_h, spl_in->lls_pref,
+		spl_in->basic_in.format, setup, spl_in->sdr_white_level_nits);
+
+	// Set iSHARP
+	vratio = spl_fixpt_ceil(spl_scratch.scl_data.ratios.vert);
+	hratio = spl_fixpt_ceil(spl_scratch.scl_data.ratios.horz);
+	if (vratio <= hratio)
+		isharp_scale_ratio = spl_scratch.scl_data.recip_ratios.vert;
+	else
+		isharp_scale_ratio = spl_scratch.scl_data.recip_ratios.horz;
+
+	spl_set_isharp_data(spl_out->dscl_prog_data, spl_in->adaptive_sharpness, enable_isharp,
+		spl_in->lls_pref, spl_in->basic_in.format, data, isharp_scale_ratio, setup,
+		spl_in->debug.scale_to_sharpness_policy);
+
+	return res;
+}
+
+/* External interface to get number of taps only */
+bool spl_get_number_of_taps(struct spl_in *spl_in, struct spl_out *spl_out)
+{
+	bool res = false;
+	bool enable_easf_v = false;
+	bool enable_easf_h = false;
+	bool enable_isharp = false;
+	struct spl_scratch spl_scratch;
+	struct dscl_prog_data *dscl_prog_data = spl_out->dscl_prog_data;
+	const struct spl_scaler_data *data = &spl_scratch.scl_data;
+
+	res = spl_calculate_number_of_taps(spl_in, &spl_scratch, spl_out,
+		&enable_easf_v, &enable_easf_h, &enable_isharp);
+	spl_set_taps_data(dscl_prog_data, data);
+	return res;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl.h b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl.h
new file mode 100644
index 000000000000..02a2d6725ed5
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl.h
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#ifndef __DC_SPL_H__
+#define __DC_SPL_H__
+
+#include "dc_spl_types.h"
+#define BLACK_OFFSET_RGB_Y 0x0
+#define BLACK_OFFSET_CBCR  0x8000
+
+/* SPL interfaces */
+
+bool spl_calculate_scaler_params(struct spl_in *spl_in, struct spl_out *spl_out);
+
+bool spl_get_number_of_taps(struct spl_in *spl_in, struct spl_out *spl_out);
+
+#endif /* __DC_SPL_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_filters.c b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_filters.c
new file mode 100644
index 000000000000..99238644e0a1
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_filters.c
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#include "dc_spl_filters.h"
+
+void convert_filter_s1_10_to_s1_12(const uint16_t *s1_10_filter,
+	uint16_t *s1_12_filter, int num_taps)
+{
+	int num_entries = NUM_PHASES_COEFF * num_taps;
+	int i;
+
+	for (i = 0; i < num_entries; i++)
+		*(s1_12_filter + i) = *(s1_10_filter + i) * 4;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_filters.h b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_filters.h
new file mode 100644
index 000000000000..20439cdbdb10
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_filters.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: MIT */
+
+/* Copyright 2024 Advanced Micro Devices, Inc. */
+
+#ifndef __DC_SPL_FILTERS_H__
+#define __DC_SPL_FILTERS_H__
+
+#include "dc_spl_types.h"
+
+#define NUM_PHASES_COEFF 33
+
+void convert_filter_s1_10_to_s1_12(const uint16_t *s1_10_filter,
+	uint16_t *s1_12_filter, int num_taps);
+
+#endif /* __DC_SPL_FILTERS_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.c b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.c
new file mode 100644
index 000000000000..e0572252c640
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.c
@@ -0,0 +1,757 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#include "spl_debug.h"
+#include "dc_spl_filters.h"
+#include "dc_spl_isharp_filters.h"
+
+//========================================
+// Delta Gain 1DLUT
+// LUT content is packed as 4-bytes into one DWORD/entry
+// A_start = 0.000000
+// A_end   = 10.000000
+// A_gain  = 2.000000
+// B_start = 11.000000
+// B_end   = 86.000000
+// C_start = 40.000000
+// C_end   = 64.000000
+//========================================
+static const uint32_t filter_isharp_1D_lut_0[ISHARP_LUT_TABLE_SIZE] = {
+0x02010000,
+0x0A070503,
+0x1614100D,
+0x1C1B1918,
+0x22211F1E,
+0x27262423,
+0x2A2A2928,
+0x2D2D2C2B,
+0x302F2F2E,
+0x31313030,
+0x31313131,
+0x31313131,
+0x30303031,
+0x292D2F2F,
+0x191D2125,
+0x050A0F14,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+0x00000000,
+};
+//========================================
+// Delta Gain 1DLUT
+// LUT content is packed as 4-bytes into one DWORD/entry
+// A_start = 0.000000
+// A_end   = 10.000000
+// A_gain  = 0.500000
+// B_start = 11.000000
+// B_end   = 127.000000
+// C_start = 96.000000
+// C_end   = 127.000000
+//========================================
+
+static const uint32_t filter_isharp_1D_lut_0p5x[ISHARP_LUT_TABLE_SIZE] = {
+0x00000000,
+0x02020101,
+0x06050403,
+0x07070606,
+0x09080808,
+0x0A0A0A09,
+0x0C0B0B0B,
+0x0D0D0C0C,
+0x0E0E0D0D,
+0x0F0F0E0E,
+0x100F0F0F,
+0x10101010,
+0x11111010,
+0x11111111,
+0x11111111,
+0x11111111,
+0x11111111,
+0x11111111,
+0x11111111,
+0x10101111,
+0x10101010,
+0x0F0F0F10,
+0x0E0E0F0F,
+0x0D0D0E0E,
+0x0C0C0D0D,
+0x0B0B0B0C,
+0x090A0A0A,
+0x08080809,
+0x06060707,
+0x04050506,
+0x02030304,
+0x00010102,
+};
+//========================================
+// Delta Gain 1DLUT
+// LUT content is packed as 4-bytes into one DWORD/entry
+// A_start = 0.000000
+// A_end   = 10.000000
+// A_gain  = 1.000000
+// B_start = 11.000000
+// B_end   = 127.000000
+// C_start = 96.000000
+// C_end   = 127.000000
+//========================================
+static const uint32_t filter_isharp_1D_lut_1p0x[ISHARP_LUT_TABLE_SIZE] = {
+0x01000000,
+0x05040302,
+0x0B0A0806,
+0x0E0E0D0C,
+0x1211100F,
+0x15141312,
+0x17171615,
+0x1A191918,
+0x1C1B1B1A,
+0x1E1D1D1C,
+0x1F1F1E1E,
+0x2020201F,
+0x21212121,
+0x22222222,
+0x23232222,
+0x23232323,
+0x23232323,
+0x22222323,
+0x22222222,
+0x21212121,
+0x1F202020,
+0x1E1E1F1F,
+0x1C1D1D1E,
+0x1A1B1B1C,
+0x1819191A,
+0x15161717,
+0x12131415,
+0x0F101112,
+0x0C0D0E0E,
+0x08090A0B,
+0x04050607,
+0x00010203,
+};
+//========================================
+// Delta Gain 1DLUT
+// LUT content is packed as 4-bytes into one DWORD/entry
+// A_start = 0.000000
+// A_end   = 10.000000
+// A_gain  = 1.500000
+// B_start = 11.000000
+// B_end   = 127.000000
+// C_start = 96.000000
+// C_end   = 127.000000
+//========================================
+static const uint32_t filter_isharp_1D_lut_1p5x[ISHARP_LUT_TABLE_SIZE] = {
+0x01010000,
+0x07050402,
+0x110F0C0A,
+0x16141312,
+0x1B191817,
+0x1F1E1D1C,
+0x23222120,
+0x26262524,
+0x2A292827,
+0x2C2C2B2A,
+0x2F2E2E2D,
+0x3130302F,
+0x32323131,
+0x33333332,
+0x34343433,
+0x34343434,
+0x34343434,
+0x33343434,
+0x32333333,
+0x31313232,
+0x2F303031,
+0x2D2E2E2F,
+0x2A2B2C2C,
+0x2728292A,
+0x24252626,
+0x20212223,
+0x1C1D1E1F,
+0x1718191B,
+0x12131416,
+0x0C0E0F10,
+0x0608090B,
+0x00020305
+};
+//========================================
+// Delta Gain 1DLUT
+// LUT content is packed as 4-bytes into one DWORD/entry
+// A_start = 0.000000
+// A_end   = 10.000000
+// A_gain  = 2.000000
+// B_start = 11.000000
+// B_end   = 127.000000
+// C_start = 40.000000
+// C_end   = 127.000000
+//========================================
+static const uint32_t filter_isharp_1D_lut_2p0x[ISHARP_LUT_TABLE_SIZE] = {
+0x02010000,
+0x0A070503,
+0x1614100D,
+0x1D1B1A18,
+0x2322201F,
+0x29282625,
+0x2F2D2C2B,
+0x33323130,
+0x38373534,
+0x3B3A3938,
+0x3E3E3D3C,
+0x4140403F,
+0x43424241,
+0x44444443,
+0x45454545,
+0x46454545,
+0x45454546,
+0x45454545,
+0x43444444,
+0x41424243,
+0x3F404041,
+0x3C3D3E3E,
+0x38393A3B,
+0x34353738,
+0x30313233,
+0x2B2C2D2F,
+0x25262829,
+0x1F202223,
+0x181A1B1D,
+0x10121416,
+0x080B0D0E,
+0x00020406,
+};
+//========================================
+// Delta Gain 1DLUT
+// LUT content is packed as 4-bytes into one DWORD/entry
+// A_start = 0.000000
+// A_end   = 10.000000
+// A_gain  = 3.000000
+// B_start = 11.000000
+// B_end   = 127.000000
+// C_start = 40.000000
+// C_end   = 127.000000
+//========================================
+static const uint32_t filter_isharp_1D_lut_3p0x[ISHARP_LUT_TABLE_SIZE] = {
+0x03010000,
+0x0F0B0805,
+0x211E1813,
+0x2B292624,
+0x3533302E,
+0x3E3C3A37,
+0x46444240,
+0x4D4B4A48,
+0x5352504F,
+0x59575655,
+0x5D5C5B5A,
+0x61605F5E,
+0x64646362,
+0x66666565,
+0x68686767,
+0x68686868,
+0x68686868,
+0x67676868,
+0x65656666,
+0x62636464,
+0x5E5F6061,
+0x5A5B5C5D,
+0x55565759,
+0x4F505253,
+0x484A4B4D,
+0x40424446,
+0x373A3C3E,
+0x2E303335,
+0x2426292B,
+0x191B1E21,
+0x0D101316,
+0x0003060A,
+};
+
+//========================================
+// Wide scaler coefficients
+//========================================================
+// <using>			gen_scaler_coeffs.m
+// <date>			15-Dec-2021
+// <coeffDescrip>	6t_64p_LanczosEd_p_1_p_10qb_
+// <num_taps>		6
+// <num_phases>		64
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t filter_isharp_wide_6tap_64p[198] = {
+0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000,
+0x0003, 0x0FF3, 0x0400, 0x000D, 0x0FFD, 0x0000,
+0x0006, 0x0FE7, 0x03FE, 0x001C, 0x0FF9, 0x0000,
+0x0009, 0x0FDB, 0x03FC, 0x002B, 0x0FF5, 0x0000,
+0x000C, 0x0FD0, 0x03F9, 0x003A, 0x0FF1, 0x0000,
+0x000E, 0x0FC5, 0x03F5, 0x004A, 0x0FED, 0x0001,
+0x0011, 0x0FBB, 0x03F0, 0x005A, 0x0FE9, 0x0001,
+0x0013, 0x0FB2, 0x03EB, 0x006A, 0x0FE5, 0x0001,
+0x0015, 0x0FA9, 0x03E4, 0x007B, 0x0FE1, 0x0002,
+0x0017, 0x0FA1, 0x03DD, 0x008D, 0x0FDC, 0x0002,
+0x0018, 0x0F99, 0x03D4, 0x00A0, 0x0FD8, 0x0003,
+0x001A, 0x0F92, 0x03CB, 0x00B2, 0x0FD3, 0x0004,
+0x001B, 0x0F8C, 0x03C1, 0x00C6, 0x0FCE, 0x0004,
+0x001C, 0x0F86, 0x03B7, 0x00D9, 0x0FC9, 0x0005,
+0x001D, 0x0F80, 0x03AB, 0x00EE, 0x0FC4, 0x0006,
+0x001E, 0x0F7C, 0x039F, 0x0101, 0x0FBF, 0x0007,
+0x001F, 0x0F78, 0x0392, 0x0115, 0x0FBA, 0x0008,
+0x001F, 0x0F74, 0x0385, 0x012B, 0x0FB5, 0x0008,
+0x0020, 0x0F71, 0x0376, 0x0140, 0x0FB0, 0x0009,
+0x0020, 0x0F6E, 0x0367, 0x0155, 0x0FAB, 0x000B,
+0x0020, 0x0F6C, 0x0357, 0x016B, 0x0FA6, 0x000C,
+0x0020, 0x0F6A, 0x0347, 0x0180, 0x0FA2, 0x000D,
+0x0020, 0x0F69, 0x0336, 0x0196, 0x0F9D, 0x000E,
+0x0020, 0x0F69, 0x0325, 0x01AB, 0x0F98, 0x000F,
+0x001F, 0x0F68, 0x0313, 0x01C3, 0x0F93, 0x0010,
+0x001F, 0x0F69, 0x0300, 0x01D8, 0x0F8F, 0x0011,
+0x001E, 0x0F69, 0x02ED, 0x01EF, 0x0F8B, 0x0012,
+0x001D, 0x0F6A, 0x02D9, 0x0205, 0x0F87, 0x0014,
+0x001D, 0x0F6C, 0x02C5, 0x021A, 0x0F83, 0x0015,
+0x001C, 0x0F6E, 0x02B1, 0x0230, 0x0F7F, 0x0016,
+0x001B, 0x0F70, 0x029C, 0x0247, 0x0F7B, 0x0017,
+0x001A, 0x0F72, 0x0287, 0x025D, 0x0F78, 0x0018,
+0x0019, 0x0F75, 0x0272, 0x0272, 0x0F75, 0x0019
+};
+// Blur and scale coefficients
+//========================================================
+// <using>			gen_BlurScale_coeffs.m
+// <date>			25-Apr-2022
+// <num_taps>		4
+// <num_phases>		64
+// <CoefType>		Blur & Scale LPF
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t filter_isharp_bs_4tap_in_6_64p[198] = {
+0x0000, 0x00E5, 0x0237, 0x00E4, 0x0000, 0x0000,
+0x0000, 0x00DE, 0x0237, 0x00EB, 0x0000, 0x0000,
+0x0000, 0x00D7, 0x0236, 0x00F2, 0x0001, 0x0000,
+0x0000, 0x00D0, 0x0235, 0x00FA, 0x0001, 0x0000,
+0x0000, 0x00C9, 0x0234, 0x0101, 0x0002, 0x0000,
+0x0000, 0x00C2, 0x0233, 0x0108, 0x0003, 0x0000,
+0x0000, 0x00BB, 0x0232, 0x0110, 0x0003, 0x0000,
+0x0000, 0x00B5, 0x0230, 0x0117, 0x0004, 0x0000,
+0x0000, 0x00AE, 0x022E, 0x011F, 0x0005, 0x0000,
+0x0000, 0x00A8, 0x022C, 0x0126, 0x0006, 0x0000,
+0x0000, 0x00A2, 0x022A, 0x012D, 0x0007, 0x0000,
+0x0000, 0x009C, 0x0228, 0x0134, 0x0008, 0x0000,
+0x0000, 0x0096, 0x0225, 0x013C, 0x0009, 0x0000,
+0x0000, 0x0090, 0x0222, 0x0143, 0x000B, 0x0000,
+0x0000, 0x008A, 0x021F, 0x014B, 0x000C, 0x0000,
+0x0000, 0x0085, 0x021C, 0x0151, 0x000E, 0x0000,
+0x0000, 0x007F, 0x0218, 0x015A, 0x000F, 0x0000,
+0x0000, 0x007A, 0x0215, 0x0160, 0x0011, 0x0000,
+0x0000, 0x0074, 0x0211, 0x0168, 0x0013, 0x0000,
+0x0000, 0x006F, 0x020D, 0x016F, 0x0015, 0x0000,
+0x0000, 0x006A, 0x0209, 0x0176, 0x0017, 0x0000,
+0x0000, 0x0065, 0x0204, 0x017E, 0x0019, 0x0000,
+0x0000, 0x0060, 0x0200, 0x0185, 0x001B, 0x0000,
+0x0000, 0x005C, 0x01FB, 0x018C, 0x001D, 0x0000,
+0x0000, 0x0057, 0x01F6, 0x0193, 0x0020, 0x0000,
+0x0000, 0x0053, 0x01F1, 0x019A, 0x0022, 0x0000,
+0x0000, 0x004E, 0x01EC, 0x01A1, 0x0025, 0x0000,
+0x0000, 0x004A, 0x01E6, 0x01A8, 0x0028, 0x0000,
+0x0000, 0x0046, 0x01E1, 0x01AF, 0x002A, 0x0000,
+0x0000, 0x0042, 0x01DB, 0x01B6, 0x002D, 0x0000,
+0x0000, 0x003F, 0x01D5, 0x01BB, 0x0031, 0x0000,
+0x0000, 0x003B, 0x01CF, 0x01C2, 0x0034, 0x0000,
+0x0000, 0x0037, 0x01C9, 0x01C9, 0x0037, 0x0000
+};
+//========================================================
+// <using>			gen_BlurScale_coeffs.m
+// <date>			25-Apr-2022
+// <num_taps>		4
+// <num_phases>		64
+// <CoefType>		Blur & Scale LPF
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t filter_isharp_bs_4tap_64p[132] = {
+0x00E5, 0x0237, 0x00E4, 0x0000,
+0x00DE, 0x0237, 0x00EB, 0x0000,
+0x00D7, 0x0236, 0x00F2, 0x0001,
+0x00D0, 0x0235, 0x00FA, 0x0001,
+0x00C9, 0x0234, 0x0101, 0x0002,
+0x00C2, 0x0233, 0x0108, 0x0003,
+0x00BB, 0x0232, 0x0110, 0x0003,
+0x00B5, 0x0230, 0x0117, 0x0004,
+0x00AE, 0x022E, 0x011F, 0x0005,
+0x00A8, 0x022C, 0x0126, 0x0006,
+0x00A2, 0x022A, 0x012D, 0x0007,
+0x009C, 0x0228, 0x0134, 0x0008,
+0x0096, 0x0225, 0x013C, 0x0009,
+0x0090, 0x0222, 0x0143, 0x000B,
+0x008A, 0x021F, 0x014B, 0x000C,
+0x0085, 0x021C, 0x0151, 0x000E,
+0x007F, 0x0218, 0x015A, 0x000F,
+0x007A, 0x0215, 0x0160, 0x0011,
+0x0074, 0x0211, 0x0168, 0x0013,
+0x006F, 0x020D, 0x016F, 0x0015,
+0x006A, 0x0209, 0x0176, 0x0017,
+0x0065, 0x0204, 0x017E, 0x0019,
+0x0060, 0x0200, 0x0185, 0x001B,
+0x005C, 0x01FB, 0x018C, 0x001D,
+0x0057, 0x01F6, 0x0193, 0x0020,
+0x0053, 0x01F1, 0x019A, 0x0022,
+0x004E, 0x01EC, 0x01A1, 0x0025,
+0x004A, 0x01E6, 0x01A8, 0x0028,
+0x0046, 0x01E1, 0x01AF, 0x002A,
+0x0042, 0x01DB, 0x01B6, 0x002D,
+0x003F, 0x01D5, 0x01BB, 0x0031,
+0x003B, 0x01CF, 0x01C2, 0x0034,
+0x0037, 0x01C9, 0x01C9, 0x0037,
+};
+//========================================================
+// <using>			gen_BlurScale_coeffs.m
+// <date>			09-Jun-2022
+// <num_taps>		3
+// <num_phases>		64
+// <CoefType>		Blur & Scale LPF
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t filter_isharp_bs_3tap_64p[99] = {
+0x0200, 0x0200, 0x0000,
+0x01F6, 0x0206, 0x0004,
+0x01EC, 0x020B, 0x0009,
+0x01E2, 0x0211, 0x000D,
+0x01D8, 0x0216, 0x0012,
+0x01CE, 0x021C, 0x0016,
+0x01C4, 0x0221, 0x001B,
+0x01BA, 0x0226, 0x0020,
+0x01B0, 0x022A, 0x0026,
+0x01A6, 0x022F, 0x002B,
+0x019C, 0x0233, 0x0031,
+0x0192, 0x0238, 0x0036,
+0x0188, 0x023C, 0x003C,
+0x017E, 0x0240, 0x0042,
+0x0174, 0x0244, 0x0048,
+0x016A, 0x0248, 0x004E,
+0x0161, 0x024A, 0x0055,
+0x0157, 0x024E, 0x005B,
+0x014D, 0x0251, 0x0062,
+0x0144, 0x0253, 0x0069,
+0x013A, 0x0256, 0x0070,
+0x0131, 0x0258, 0x0077,
+0x0127, 0x025B, 0x007E,
+0x011E, 0x025C, 0x0086,
+0x0115, 0x025E, 0x008D,
+0x010B, 0x0260, 0x0095,
+0x0102, 0x0262, 0x009C,
+0x00F9, 0x0263, 0x00A4,
+0x00F0, 0x0264, 0x00AC,
+0x00E7, 0x0265, 0x00B4,
+0x00DF, 0x0264, 0x00BD,
+0x00D6, 0x0265, 0x00C5,
+0x00CD, 0x0266, 0x00CD,
+};
+
+/* Converted Blur & Scale coeff tables from S1.10 to S1.12 */
+static uint16_t filter_isharp_bs_4tap_in_6_64p_s1_12[198];
+static uint16_t filter_isharp_bs_4tap_64p_s1_12[132];
+static uint16_t filter_isharp_bs_3tap_64p_s1_12[99];
+
+/* Pre-generated 1DLUT for given setup and sharpness level */
+struct isharp_1D_lut_pregen filter_isharp_1D_lut_pregen[NUM_SHARPNESS_SETUPS] = {
+	{
+		0, 0,
+		{
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+		}
+	},
+	{
+		0, 0,
+		{
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+		}
+	},
+	{
+		0, 0,
+		{
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+		}
+	},
+	{
+		0, 0,
+		{
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0,
+		}
+	},
+};
+
+struct scale_ratio_to_sharpness_level_adj sharpness_level_adj[NUM_SHARPNESS_ADJ_LEVELS] = {
+	{1125, 1000, 0},
+	{11, 10, 1},
+	{1075, 1000, 2},
+	{105, 100, 3},
+	{1025, 1000, 4},
+	{1, 1, 5},
+};
+
+const uint32_t *spl_get_filter_isharp_1D_lut_0(void)
+{
+	return filter_isharp_1D_lut_0;
+}
+const uint32_t *spl_get_filter_isharp_1D_lut_0p5x(void)
+{
+	return filter_isharp_1D_lut_0p5x;
+}
+const uint32_t *spl_get_filter_isharp_1D_lut_1p0x(void)
+{
+	return filter_isharp_1D_lut_1p0x;
+}
+const uint32_t *spl_get_filter_isharp_1D_lut_1p5x(void)
+{
+	return filter_isharp_1D_lut_1p5x;
+}
+const uint32_t *spl_get_filter_isharp_1D_lut_2p0x(void)
+{
+	return filter_isharp_1D_lut_2p0x;
+}
+const uint32_t *spl_get_filter_isharp_1D_lut_3p0x(void)
+{
+	return filter_isharp_1D_lut_3p0x;
+}
+const uint16_t *spl_get_filter_isharp_wide_6tap_64p(void)
+{
+	return filter_isharp_wide_6tap_64p;
+}
+uint16_t *spl_get_filter_isharp_bs_4tap_in_6_64p(void)
+{
+	return filter_isharp_bs_4tap_in_6_64p_s1_12;
+}
+uint16_t *spl_get_filter_isharp_bs_4tap_64p(void)
+{
+	return filter_isharp_bs_4tap_64p_s1_12;
+}
+uint16_t *spl_get_filter_isharp_bs_3tap_64p(void)
+{
+	return filter_isharp_bs_3tap_64p_s1_12;
+}
+
+static unsigned int spl_calculate_sharpness_level_adj(struct spl_fixed31_32 ratio)
+{
+	int j;
+	struct spl_fixed31_32 ratio_level;
+	struct scale_ratio_to_sharpness_level_adj *lookup_ptr;
+	unsigned int sharpness_level_down_adj;
+
+	/*
+	 * Adjust sharpness level based on current scaling ratio
+	 *
+	 * We have 5 discrete scaling ratios which we will use to adjust the
+	 *  sharpness level down by 1 as we pass each ratio.  The ratios
+	 *  are
+	 *
+	 * 1.125 upscale and higher - no adj
+	 * 1.100 - under 1.125 - adj level down 1
+	 * 1.075 - under 1.100 - adj level down 2
+	 * 1.050 - under 1.075 - adj level down 3
+	 * 1.025 - under 1.050 - adj level down 4
+	 * 1.000 - under 1.025 - adj level down 5
+	 *
+	 */
+	j = 0;
+	sharpness_level_down_adj = 0;
+	lookup_ptr = sharpness_level_adj;
+	while (j < NUM_SHARPNESS_ADJ_LEVELS) {
+		ratio_level = spl_fixpt_from_fraction(lookup_ptr->ratio_numer,
+			lookup_ptr->ratio_denom);
+		if (ratio.value >= ratio_level.value) {
+			sharpness_level_down_adj = lookup_ptr->level_down_adj;
+			break;
+		}
+		lookup_ptr++;
+		j++;
+	}
+	return sharpness_level_down_adj;
+}
+
+static unsigned int spl_calculate_sharpness_level(struct spl_fixed31_32 ratio,
+		int discrete_sharpness_level, enum system_setup setup,
+		struct spl_sharpness_range sharpness_range,
+		enum scale_to_sharpness_policy scale_to_sharpness_policy)
+{
+	unsigned int sharpness_level = 0;
+	unsigned int sharpness_level_down_adj = 0;
+
+	int min_sharpness, max_sharpness, mid_sharpness;
+
+	/*
+	 * Adjust sharpness level if policy requires we adjust it based on
+	 *  scale ratio.  Based on scale ratio, we may adjust the sharpness
+	 *  level down by a certain number of steps.  We will not select
+	 *  a sharpness value of 0 so the lowest sharpness level will be
+	 *  0 or 1 depending on what the min_sharpness is
+	 *
+	 * If the policy is no required, this code maybe removed at a later
+	 *  date
+	 */
+	switch (setup) {
+
+	case HDR_L:
+		min_sharpness = sharpness_range.hdr_rgb_min;
+		max_sharpness = sharpness_range.hdr_rgb_max;
+		mid_sharpness = sharpness_range.hdr_rgb_mid;
+		if (scale_to_sharpness_policy == SCALE_TO_SHARPNESS_ADJ_ALL)
+			sharpness_level_down_adj = spl_calculate_sharpness_level_adj(ratio);
+		break;
+	case HDR_NL:
+		/* currently no use case, use Non-linear SDR values for now */
+	case SDR_NL:
+		min_sharpness = sharpness_range.sdr_yuv_min;
+		max_sharpness = sharpness_range.sdr_yuv_max;
+		mid_sharpness = sharpness_range.sdr_yuv_mid;
+		if (scale_to_sharpness_policy >= SCALE_TO_SHARPNESS_ADJ_YUV)
+			sharpness_level_down_adj = spl_calculate_sharpness_level_adj(ratio);
+		break;
+	case SDR_L:
+	default:
+		min_sharpness = sharpness_range.sdr_rgb_min;
+		max_sharpness = sharpness_range.sdr_rgb_max;
+		mid_sharpness = sharpness_range.sdr_rgb_mid;
+		if (scale_to_sharpness_policy == SCALE_TO_SHARPNESS_ADJ_ALL)
+			sharpness_level_down_adj = spl_calculate_sharpness_level_adj(ratio);
+		break;
+	}
+
+	if ((min_sharpness == 0) && (sharpness_level_down_adj >= discrete_sharpness_level))
+		discrete_sharpness_level = 1;
+	else if (sharpness_level_down_adj >= discrete_sharpness_level)
+		discrete_sharpness_level = 0;
+	else
+		discrete_sharpness_level -= sharpness_level_down_adj;
+
+	int lower_half_step_size = (mid_sharpness - min_sharpness) / 5;
+	int upper_half_step_size = (max_sharpness - mid_sharpness) / 5;
+
+	// lower half linear approximation
+	if (discrete_sharpness_level < 5)
+		sharpness_level = min_sharpness + (lower_half_step_size * discrete_sharpness_level);
+	// upper half linear approximation
+	else
+		sharpness_level = mid_sharpness + (upper_half_step_size * (discrete_sharpness_level - 5));
+
+	return sharpness_level;
+}
+
+void spl_build_isharp_1dlut_from_reference_curve(struct spl_fixed31_32 ratio, enum system_setup setup,
+	struct adaptive_sharpness sharpness, enum scale_to_sharpness_policy scale_to_sharpness_policy)
+{
+	uint8_t *byte_ptr_1dlut_src, *byte_ptr_1dlut_dst;
+	struct spl_fixed31_32 sharp_base, sharp_calc, sharp_level;
+	int j;
+	int size_1dlut;
+	int sharp_calc_int;
+	uint32_t filter_pregen_store[ISHARP_LUT_TABLE_SIZE];
+
+	/* Custom sharpnessX1000 value */
+	unsigned int sharpnessX1000 = spl_calculate_sharpness_level(ratio,
+			sharpness.sharpness_level, setup,
+			sharpness.sharpness_range, scale_to_sharpness_policy);
+	sharp_level = spl_fixpt_from_fraction(sharpnessX1000, 1000);
+
+	/*
+	 * Check if pregen 1dlut table is already precalculated
+	 * If numer/denom is different, then recalculate
+	 */
+	if ((filter_isharp_1D_lut_pregen[setup].sharpness_numer == sharpnessX1000) &&
+		(filter_isharp_1D_lut_pregen[setup].sharpness_denom == 1000))
+		return;
+
+	/*
+	 * Calculate LUT_128_gained with this equation:
+	 *
+	 * LUT_128_gained[i] = (uint8)(0.5 + min(255,(double)(LUT_128[i])*sharpLevel/iGain))
+	 *  where LUT_128[i] is contents of 3p0x isharp 1dlut
+	 *  where sharpLevel is desired sharpness level
+	 *  where iGain is base sharpness level 3.0
+	 *  where LUT_128_gained[i] is adjusted 1dlut value based on desired sharpness level
+	 */
+	byte_ptr_1dlut_src = (uint8_t *)filter_isharp_1D_lut_3p0x;
+	byte_ptr_1dlut_dst = (uint8_t *)filter_pregen_store;
+	size_1dlut = sizeof(filter_isharp_1D_lut_3p0x);
+	memset(byte_ptr_1dlut_dst, 0, size_1dlut);
+	for (j = 0; j < size_1dlut; j++) {
+		sharp_base = spl_fixpt_from_int((int)*byte_ptr_1dlut_src);
+		sharp_calc = spl_fixpt_mul(sharp_base, sharp_level);
+		sharp_calc = spl_fixpt_div(sharp_calc, spl_fixpt_from_int(3));
+		sharp_calc = spl_fixpt_min(spl_fixpt_from_int(255), sharp_calc);
+		sharp_calc = spl_fixpt_add(sharp_calc, spl_fixpt_from_fraction(1, 2));
+		sharp_calc_int = spl_fixpt_floor(sharp_calc);
+		/* Clamp it at 0x7F so it doesn't wrap */
+		if (sharp_calc_int > 127)
+			sharp_calc_int = 127;
+		*byte_ptr_1dlut_dst = (uint8_t)sharp_calc_int;
+
+		byte_ptr_1dlut_src++;
+		byte_ptr_1dlut_dst++;
+	}
+
+	/* Update 1dlut table and sharpness level */
+	memcpy((void *)filter_isharp_1D_lut_pregen[setup].value, (void *)filter_pregen_store, size_1dlut);
+	filter_isharp_1D_lut_pregen[setup].sharpness_numer = sharpnessX1000;
+	filter_isharp_1D_lut_pregen[setup].sharpness_denom = 1000;
+}
+
+uint32_t *spl_get_pregen_filter_isharp_1D_lut(enum system_setup setup)
+{
+	return filter_isharp_1D_lut_pregen[setup].value;
+}
+
+void spl_init_blur_scale_coeffs(void)
+{
+	convert_filter_s1_10_to_s1_12(filter_isharp_bs_3tap_64p,
+		filter_isharp_bs_3tap_64p_s1_12, 3);
+	convert_filter_s1_10_to_s1_12(filter_isharp_bs_4tap_64p,
+		filter_isharp_bs_4tap_64p_s1_12, 4);
+	convert_filter_s1_10_to_s1_12(filter_isharp_bs_4tap_in_6_64p,
+		filter_isharp_bs_4tap_in_6_64p_s1_12, 6);
+}
+
+uint16_t *spl_dscl_get_blur_scale_coeffs_64p(int taps)
+{
+	if (taps == 3)
+		return spl_get_filter_isharp_bs_3tap_64p();
+	else if (taps == 4)
+		return spl_get_filter_isharp_bs_4tap_64p();
+	else if (taps == 6)
+		return spl_get_filter_isharp_bs_4tap_in_6_64p();
+	else {
+		/* should never happen, bug */
+		SPL_BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+}
+
+void spl_set_blur_scale_data(struct dscl_prog_data *dscl_prog_data,
+		const struct spl_scaler_data *data)
+{
+	dscl_prog_data->filter_blur_scale_h =
+		spl_dscl_get_blur_scale_coeffs_64p(data->taps.h_taps);
+
+	dscl_prog_data->filter_blur_scale_v =
+		spl_dscl_get_blur_scale_coeffs_64p(data->taps.v_taps);
+}
+
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.h b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.h
new file mode 100644
index 000000000000..89af91e19b6c
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.h
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#ifndef __DC_SPL_ISHARP_FILTERS_H__
+#define __DC_SPL_ISHARP_FILTERS_H__
+
+#include "dc_spl_types.h"
+
+const uint32_t *spl_get_filter_isharp_1D_lut_0(void);
+const uint32_t *spl_get_filter_isharp_1D_lut_0p5x(void);
+const uint32_t *spl_get_filter_isharp_1D_lut_1p0x(void);
+const uint32_t *spl_get_filter_isharp_1D_lut_1p5x(void);
+const uint32_t *spl_get_filter_isharp_1D_lut_2p0x(void);
+const uint32_t *spl_get_filter_isharp_1D_lut_3p0x(void);
+uint16_t *spl_get_filter_isharp_bs_4tap_in_6_64p(void);
+uint16_t *spl_get_filter_isharp_bs_4tap_64p(void);
+uint16_t *spl_get_filter_isharp_bs_3tap_64p(void);
+const uint16_t *spl_get_filter_isharp_wide_6tap_64p(void);
+uint16_t *spl_dscl_get_blur_scale_coeffs_64p(int taps);
+
+#define NUM_SHARPNESS_ADJ_LEVELS 6
+struct scale_ratio_to_sharpness_level_adj {
+	unsigned int ratio_numer;
+	unsigned int ratio_denom;
+	unsigned int level_down_adj; /* adjust sharpness level down */
+};
+
+struct isharp_1D_lut_pregen {
+	unsigned int sharpness_numer;
+	unsigned int sharpness_denom;
+	uint32_t value[ISHARP_LUT_TABLE_SIZE];
+};
+
+enum system_setup {
+	SDR_NL = 0,
+	SDR_L,
+	HDR_NL,
+	HDR_L,
+	NUM_SHARPNESS_SETUPS
+};
+
+void spl_init_blur_scale_coeffs(void);
+void spl_set_blur_scale_data(struct dscl_prog_data *dscl_prog_data,
+	const struct spl_scaler_data *data);
+
+void spl_build_isharp_1dlut_from_reference_curve(struct spl_fixed31_32 ratio, enum system_setup setup,
+	struct adaptive_sharpness sharpness, enum scale_to_sharpness_policy scale_to_sharpness_policy);
+uint32_t *spl_get_pregen_filter_isharp_1D_lut(enum system_setup setup);
+#endif /* __DC_SPL_ISHARP_FILTERS_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_easf_filters.c b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_easf_filters.c
new file mode 100644
index 000000000000..09bf82f7d468
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_easf_filters.c
@@ -0,0 +1,1726 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#include "spl_debug.h"
+#include "dc_spl_filters.h"
+#include "dc_spl_scl_filters.h"
+#include "dc_spl_scl_easf_filters.h"
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	3t_64p_LanczosEd_p_0.3_p_10qb_
+// <num_taps>		3
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.300000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_3tap_64p_ratio_0_30[99] = {
+	0x0200, 0x0200, 0x0000,
+	0x01F6, 0x0206, 0x0004,
+	0x01EC, 0x020B, 0x0009,
+	0x01E2, 0x0211, 0x000D,
+	0x01D8, 0x0216, 0x0012,
+	0x01CE, 0x021C, 0x0016,
+	0x01C4, 0x0221, 0x001B,
+	0x01BA, 0x0226, 0x0020,
+	0x01B0, 0x022A, 0x0026,
+	0x01A6, 0x022F, 0x002B,
+	0x019C, 0x0233, 0x0031,
+	0x0192, 0x0238, 0x0036,
+	0x0188, 0x023C, 0x003C,
+	0x017E, 0x0240, 0x0042,
+	0x0174, 0x0244, 0x0048,
+	0x016A, 0x0248, 0x004E,
+	0x0161, 0x024A, 0x0055,
+	0x0157, 0x024E, 0x005B,
+	0x014D, 0x0251, 0x0062,
+	0x0144, 0x0253, 0x0069,
+	0x013A, 0x0256, 0x0070,
+	0x0131, 0x0258, 0x0077,
+	0x0127, 0x025B, 0x007E,
+	0x011E, 0x025C, 0x0086,
+	0x0115, 0x025E, 0x008D,
+	0x010B, 0x0260, 0x0095,
+	0x0102, 0x0262, 0x009C,
+	0x00F9, 0x0263, 0x00A4,
+	0x00F0, 0x0264, 0x00AC,
+	0x00E7, 0x0265, 0x00B4,
+	0x00DF, 0x0264, 0x00BD,
+	0x00D6, 0x0265, 0x00C5,
+	0x00CD, 0x0266, 0x00CD,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	3t_64p_LanczosEd_p_0.4_p_10qb_
+// <num_taps>		3
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.400000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_3tap_64p_ratio_0_40[99] = {
+	0x0200, 0x0200, 0x0000,
+	0x01F6, 0x0206, 0x0004,
+	0x01EB, 0x020E, 0x0007,
+	0x01E1, 0x0214, 0x000B,
+	0x01D7, 0x021A, 0x000F,
+	0x01CD, 0x0220, 0x0013,
+	0x01C2, 0x0226, 0x0018,
+	0x01B8, 0x022C, 0x001C,
+	0x01AE, 0x0231, 0x0021,
+	0x01A3, 0x0237, 0x0026,
+	0x0199, 0x023C, 0x002B,
+	0x018F, 0x0240, 0x0031,
+	0x0185, 0x0245, 0x0036,
+	0x017A, 0x024A, 0x003C,
+	0x0170, 0x024F, 0x0041,
+	0x0166, 0x0253, 0x0047,
+	0x015C, 0x0257, 0x004D,
+	0x0152, 0x025A, 0x0054,
+	0x0148, 0x025E, 0x005A,
+	0x013E, 0x0261, 0x0061,
+	0x0134, 0x0264, 0x0068,
+	0x012B, 0x0266, 0x006F,
+	0x0121, 0x0269, 0x0076,
+	0x0117, 0x026C, 0x007D,
+	0x010E, 0x026E, 0x0084,
+	0x0104, 0x0270, 0x008C,
+	0x00FB, 0x0271, 0x0094,
+	0x00F2, 0x0272, 0x009C,
+	0x00E9, 0x0273, 0x00A4,
+	0x00E0, 0x0274, 0x00AC,
+	0x00D7, 0x0275, 0x00B4,
+	0x00CE, 0x0275, 0x00BD,
+	0x00C5, 0x0276, 0x00C5,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	3t_64p_LanczosEd_p_0.5_p_10qb_
+// <num_taps>		3
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.500000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_3tap_64p_ratio_0_50[99] = {
+	0x0200, 0x0200, 0x0000,
+	0x01F5, 0x0209, 0x0002,
+	0x01EA, 0x0211, 0x0005,
+	0x01DF, 0x021A, 0x0007,
+	0x01D4, 0x0222, 0x000A,
+	0x01C9, 0x022A, 0x000D,
+	0x01BE, 0x0232, 0x0010,
+	0x01B3, 0x0239, 0x0014,
+	0x01A8, 0x0241, 0x0017,
+	0x019D, 0x0248, 0x001B,
+	0x0192, 0x024F, 0x001F,
+	0x0187, 0x0255, 0x0024,
+	0x017C, 0x025C, 0x0028,
+	0x0171, 0x0262, 0x002D,
+	0x0166, 0x0268, 0x0032,
+	0x015B, 0x026E, 0x0037,
+	0x0150, 0x0273, 0x003D,
+	0x0146, 0x0278, 0x0042,
+	0x013B, 0x027D, 0x0048,
+	0x0130, 0x0282, 0x004E,
+	0x0126, 0x0286, 0x0054,
+	0x011B, 0x028A, 0x005B,
+	0x0111, 0x028D, 0x0062,
+	0x0107, 0x0290, 0x0069,
+	0x00FD, 0x0293, 0x0070,
+	0x00F3, 0x0296, 0x0077,
+	0x00E9, 0x0298, 0x007F,
+	0x00DF, 0x029A, 0x0087,
+	0x00D5, 0x029C, 0x008F,
+	0x00CC, 0x029D, 0x0097,
+	0x00C3, 0x029E, 0x009F,
+	0x00BA, 0x029E, 0x00A8,
+	0x00B1, 0x029E, 0x00B1,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	3t_64p_LanczosEd_p_0.6_p_10qb_
+// <num_taps>		3
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.600000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_3tap_64p_ratio_0_60[99] = {
+	0x0200, 0x0200, 0x0000,
+	0x01F4, 0x020B, 0x0001,
+	0x01E8, 0x0216, 0x0002,
+	0x01DC, 0x0221, 0x0003,
+	0x01D0, 0x022B, 0x0005,
+	0x01C4, 0x0235, 0x0007,
+	0x01B8, 0x0240, 0x0008,
+	0x01AC, 0x0249, 0x000B,
+	0x01A0, 0x0253, 0x000D,
+	0x0194, 0x025C, 0x0010,
+	0x0188, 0x0265, 0x0013,
+	0x017C, 0x026E, 0x0016,
+	0x0170, 0x0277, 0x0019,
+	0x0164, 0x027F, 0x001D,
+	0x0158, 0x0287, 0x0021,
+	0x014C, 0x028F, 0x0025,
+	0x0140, 0x0297, 0x0029,
+	0x0135, 0x029D, 0x002E,
+	0x0129, 0x02A4, 0x0033,
+	0x011D, 0x02AB, 0x0038,
+	0x0112, 0x02B0, 0x003E,
+	0x0107, 0x02B5, 0x0044,
+	0x00FC, 0x02BA, 0x004A,
+	0x00F1, 0x02BF, 0x0050,
+	0x00E6, 0x02C3, 0x0057,
+	0x00DB, 0x02C7, 0x005E,
+	0x00D1, 0x02CA, 0x0065,
+	0x00C7, 0x02CC, 0x006D,
+	0x00BD, 0x02CE, 0x0075,
+	0x00B3, 0x02D0, 0x007D,
+	0x00A9, 0x02D2, 0x0085,
+	0x00A0, 0x02D2, 0x008E,
+	0x0097, 0x02D2, 0x0097,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	3t_64p_LanczosEd_p_0.7_p_10qb_
+// <num_taps>		3
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.700000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_3tap_64p_ratio_0_70[99] = {
+	0x0200, 0x0200, 0x0000,
+	0x01F3, 0x020D, 0x0000,
+	0x01E5, 0x021B, 0x0000,
+	0x01D8, 0x0228, 0x0000,
+	0x01CB, 0x0235, 0x0000,
+	0x01BD, 0x0243, 0x0000,
+	0x01B0, 0x024F, 0x0001,
+	0x01A2, 0x025C, 0x0002,
+	0x0195, 0x0268, 0x0003,
+	0x0187, 0x0275, 0x0004,
+	0x017A, 0x0280, 0x0006,
+	0x016D, 0x028C, 0x0007,
+	0x015F, 0x0298, 0x0009,
+	0x0152, 0x02A2, 0x000C,
+	0x0145, 0x02AD, 0x000E,
+	0x0138, 0x02B7, 0x0011,
+	0x012B, 0x02C0, 0x0015,
+	0x011E, 0x02CA, 0x0018,
+	0x0111, 0x02D3, 0x001C,
+	0x0105, 0x02DB, 0x0020,
+	0x00F8, 0x02E3, 0x0025,
+	0x00EC, 0x02EA, 0x002A,
+	0x00E0, 0x02F1, 0x002F,
+	0x00D5, 0x02F6, 0x0035,
+	0x00C9, 0x02FC, 0x003B,
+	0x00BE, 0x0301, 0x0041,
+	0x00B3, 0x0305, 0x0048,
+	0x00A8, 0x0309, 0x004F,
+	0x009E, 0x030C, 0x0056,
+	0x0094, 0x030E, 0x005E,
+	0x008A, 0x0310, 0x0066,
+	0x0081, 0x0310, 0x006F,
+	0x0077, 0x0312, 0x0077,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	3t_64p_LanczosEd_p_0.8_p_10qb_
+// <num_taps>		3
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.800000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_3tap_64p_ratio_0_80[99] = {
+	0x0200, 0x0200, 0x0000,
+	0x01F1, 0x0210, 0x0FFF,
+	0x01E2, 0x0220, 0x0FFE,
+	0x01D2, 0x0232, 0x0FFC,
+	0x01C3, 0x0241, 0x0FFC,
+	0x01B4, 0x0251, 0x0FFB,
+	0x01A4, 0x0262, 0x0FFA,
+	0x0195, 0x0271, 0x0FFA,
+	0x0186, 0x0281, 0x0FF9,
+	0x0176, 0x0291, 0x0FF9,
+	0x0167, 0x02A0, 0x0FF9,
+	0x0158, 0x02AE, 0x0FFA,
+	0x0149, 0x02BD, 0x0FFA,
+	0x013A, 0x02CB, 0x0FFB,
+	0x012C, 0x02D7, 0x0FFD,
+	0x011D, 0x02E5, 0x0FFE,
+	0x010F, 0x02F1, 0x0000,
+	0x0101, 0x02FD, 0x0002,
+	0x00F3, 0x0308, 0x0005,
+	0x00E5, 0x0313, 0x0008,
+	0x00D8, 0x031D, 0x000B,
+	0x00CB, 0x0326, 0x000F,
+	0x00BE, 0x032F, 0x0013,
+	0x00B2, 0x0337, 0x0017,
+	0x00A6, 0x033E, 0x001C,
+	0x009A, 0x0345, 0x0021,
+	0x008F, 0x034A, 0x0027,
+	0x0084, 0x034F, 0x002D,
+	0x0079, 0x0353, 0x0034,
+	0x006F, 0x0356, 0x003B,
+	0x0065, 0x0358, 0x0043,
+	0x005C, 0x0359, 0x004B,
+	0x0053, 0x035A, 0x0053,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	3t_64p_LanczosEd_p_0.9_p_10qb_
+// <num_taps>		3
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.900000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_3tap_64p_ratio_0_90[99] = {
+	0x0200, 0x0200, 0x0000,
+	0x01EE, 0x0214, 0x0FFE,
+	0x01DC, 0x0228, 0x0FFC,
+	0x01CA, 0x023C, 0x0FFA,
+	0x01B9, 0x024F, 0x0FF8,
+	0x01A7, 0x0262, 0x0FF7,
+	0x0195, 0x0276, 0x0FF5,
+	0x0183, 0x028A, 0x0FF3,
+	0x0172, 0x029C, 0x0FF2,
+	0x0160, 0x02AF, 0x0FF1,
+	0x014F, 0x02C2, 0x0FEF,
+	0x013E, 0x02D4, 0x0FEE,
+	0x012D, 0x02E5, 0x0FEE,
+	0x011C, 0x02F7, 0x0FED,
+	0x010C, 0x0307, 0x0FED,
+	0x00FB, 0x0318, 0x0FED,
+	0x00EC, 0x0327, 0x0FED,
+	0x00DC, 0x0336, 0x0FEE,
+	0x00CD, 0x0344, 0x0FEF,
+	0x00BE, 0x0352, 0x0FF0,
+	0x00B0, 0x035E, 0x0FF2,
+	0x00A2, 0x036A, 0x0FF4,
+	0x0095, 0x0375, 0x0FF6,
+	0x0088, 0x037F, 0x0FF9,
+	0x007B, 0x0388, 0x0FFD,
+	0x006F, 0x0391, 0x0000,
+	0x0064, 0x0397, 0x0005,
+	0x0059, 0x039D, 0x000A,
+	0x004E, 0x03A3, 0x000F,
+	0x0045, 0x03A6, 0x0015,
+	0x003B, 0x03A9, 0x001C,
+	0x0033, 0x03AA, 0x0023,
+	0x002A, 0x03AC, 0x002A,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	3t_64p_LanczosEd_p_1_p_10qb_
+// <num_taps>		3
+// <num_phases>		64
+// <scale_ratio>	 input/output = 1.000000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_3tap_64p_ratio_1_00[99] = {
+	0x0200, 0x0200, 0x0000,
+	0x01EB, 0x0217, 0x0FFE,
+	0x01D5, 0x022F, 0x0FFC,
+	0x01C0, 0x0247, 0x0FF9,
+	0x01AB, 0x025E, 0x0FF7,
+	0x0196, 0x0276, 0x0FF4,
+	0x0181, 0x028D, 0x0FF2,
+	0x016C, 0x02A5, 0x0FEF,
+	0x0158, 0x02BB, 0x0FED,
+	0x0144, 0x02D1, 0x0FEB,
+	0x0130, 0x02E8, 0x0FE8,
+	0x011C, 0x02FE, 0x0FE6,
+	0x0109, 0x0313, 0x0FE4,
+	0x00F6, 0x0328, 0x0FE2,
+	0x00E4, 0x033C, 0x0FE0,
+	0x00D2, 0x034F, 0x0FDF,
+	0x00C0, 0x0363, 0x0FDD,
+	0x00B0, 0x0374, 0x0FDC,
+	0x009F, 0x0385, 0x0FDC,
+	0x0090, 0x0395, 0x0FDB,
+	0x0081, 0x03A4, 0x0FDB,
+	0x0072, 0x03B3, 0x0FDB,
+	0x0064, 0x03C0, 0x0FDC,
+	0x0057, 0x03CC, 0x0FDD,
+	0x004B, 0x03D6, 0x0FDF,
+	0x003F, 0x03E0, 0x0FE1,
+	0x0034, 0x03E8, 0x0FE4,
+	0x002A, 0x03EF, 0x0FE7,
+	0x0020, 0x03F5, 0x0FEB,
+	0x0017, 0x03FA, 0x0FEF,
+	0x000F, 0x03FD, 0x0FF4,
+	0x0007, 0x03FF, 0x0FFA,
+	0x0000, 0x0400, 0x0000,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	4t_64p_LanczosEd_p_0.3_p_10qb_
+// <num_taps>		4
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.300000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_4tap_64p_ratio_0_30[132] = {
+	0x0104, 0x01F8, 0x0104, 0x0000,
+	0x00FE, 0x01F7, 0x010A, 0x0001,
+	0x00F8, 0x01F6, 0x010F, 0x0003,
+	0x00F2, 0x01F5, 0x0114, 0x0005,
+	0x00EB, 0x01F4, 0x011B, 0x0006,
+	0x00E5, 0x01F3, 0x0120, 0x0008,
+	0x00DF, 0x01F2, 0x0125, 0x000A,
+	0x00DA, 0x01F0, 0x012A, 0x000C,
+	0x00D4, 0x01EE, 0x0130, 0x000E,
+	0x00CE, 0x01ED, 0x0135, 0x0010,
+	0x00C8, 0x01EB, 0x013A, 0x0013,
+	0x00C2, 0x01E9, 0x0140, 0x0015,
+	0x00BD, 0x01E7, 0x0145, 0x0017,
+	0x00B7, 0x01E5, 0x014A, 0x001A,
+	0x00B1, 0x01E2, 0x0151, 0x001C,
+	0x00AC, 0x01E0, 0x0155, 0x001F,
+	0x00A7, 0x01DD, 0x015A, 0x0022,
+	0x00A1, 0x01DB, 0x015F, 0x0025,
+	0x009C, 0x01D8, 0x0165, 0x0027,
+	0x0097, 0x01D5, 0x016A, 0x002A,
+	0x0092, 0x01D2, 0x016E, 0x002E,
+	0x008C, 0x01CF, 0x0174, 0x0031,
+	0x0087, 0x01CC, 0x0179, 0x0034,
+	0x0083, 0x01C9, 0x017D, 0x0037,
+	0x007E, 0x01C5, 0x0182, 0x003B,
+	0x0079, 0x01C2, 0x0187, 0x003E,
+	0x0074, 0x01BE, 0x018C, 0x0042,
+	0x0070, 0x01BA, 0x0190, 0x0046,
+	0x006B, 0x01B7, 0x0195, 0x0049,
+	0x0066, 0x01B3, 0x019A, 0x004D,
+	0x0062, 0x01AF, 0x019E, 0x0051,
+	0x005E, 0x01AB, 0x01A2, 0x0055,
+	0x005A, 0x01A6, 0x01A6, 0x005A,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	4t_64p_LanczosEd_p_0.4_p_10qb_
+// <num_taps>		4
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.400000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_4tap_64p_ratio_0_40[132] = {
+	0x00FB, 0x0209, 0x00FC, 0x0000,
+	0x00F5, 0x0209, 0x0101, 0x0001,
+	0x00EE, 0x0208, 0x0108, 0x0002,
+	0x00E8, 0x0207, 0x010E, 0x0003,
+	0x00E2, 0x0206, 0x0114, 0x0004,
+	0x00DB, 0x0205, 0x011A, 0x0006,
+	0x00D5, 0x0204, 0x0120, 0x0007,
+	0x00CF, 0x0203, 0x0125, 0x0009,
+	0x00C9, 0x0201, 0x012C, 0x000A,
+	0x00C3, 0x01FF, 0x0132, 0x000C,
+	0x00BD, 0x01FD, 0x0138, 0x000E,
+	0x00B7, 0x01FB, 0x013E, 0x0010,
+	0x00B1, 0x01F9, 0x0144, 0x0012,
+	0x00AC, 0x01F7, 0x0149, 0x0014,
+	0x00A6, 0x01F4, 0x0150, 0x0016,
+	0x00A0, 0x01F2, 0x0156, 0x0018,
+	0x009B, 0x01EF, 0x015C, 0x001A,
+	0x0095, 0x01EC, 0x0162, 0x001D,
+	0x0090, 0x01E9, 0x0168, 0x001F,
+	0x008B, 0x01E6, 0x016D, 0x0022,
+	0x0085, 0x01E3, 0x0173, 0x0025,
+	0x0080, 0x01DF, 0x0179, 0x0028,
+	0x007B, 0x01DC, 0x017E, 0x002B,
+	0x0076, 0x01D8, 0x0184, 0x002E,
+	0x0071, 0x01D4, 0x018A, 0x0031,
+	0x006D, 0x01D1, 0x018E, 0x0034,
+	0x0068, 0x01CD, 0x0193, 0x0038,
+	0x0063, 0x01C8, 0x019A, 0x003B,
+	0x005F, 0x01C4, 0x019E, 0x003F,
+	0x005B, 0x01C0, 0x01A3, 0x0042,
+	0x0056, 0x01BB, 0x01A9, 0x0046,
+	0x0052, 0x01B7, 0x01AD, 0x004A,
+	0x004E, 0x01B2, 0x01B2, 0x004E,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	4t_64p_LanczosEd_p_0.5_p_10qb_
+// <num_taps>		4
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.500000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_4tap_64p_ratio_0_50[132] = {
+	0x00E5, 0x0236, 0x00E5, 0x0000,
+	0x00DE, 0x0235, 0x00ED, 0x0000,
+	0x00D7, 0x0235, 0x00F4, 0x0000,
+	0x00D0, 0x0235, 0x00FB, 0x0000,
+	0x00C9, 0x0234, 0x0102, 0x0001,
+	0x00C2, 0x0233, 0x010A, 0x0001,
+	0x00BC, 0x0232, 0x0111, 0x0001,
+	0x00B5, 0x0230, 0x0119, 0x0002,
+	0x00AE, 0x022F, 0x0121, 0x0002,
+	0x00A8, 0x022D, 0x0128, 0x0003,
+	0x00A2, 0x022B, 0x012F, 0x0004,
+	0x009B, 0x0229, 0x0137, 0x0005,
+	0x0095, 0x0226, 0x013F, 0x0006,
+	0x008F, 0x0224, 0x0146, 0x0007,
+	0x0089, 0x0221, 0x014E, 0x0008,
+	0x0083, 0x021E, 0x0155, 0x000A,
+	0x007E, 0x021B, 0x015C, 0x000B,
+	0x0078, 0x0217, 0x0164, 0x000D,
+	0x0072, 0x0213, 0x016D, 0x000E,
+	0x006D, 0x0210, 0x0173, 0x0010,
+	0x0068, 0x020C, 0x017A, 0x0012,
+	0x0063, 0x0207, 0x0182, 0x0014,
+	0x005E, 0x0203, 0x0189, 0x0016,
+	0x0059, 0x01FE, 0x0191, 0x0018,
+	0x0054, 0x01F9, 0x0198, 0x001B,
+	0x0050, 0x01F4, 0x019F, 0x001D,
+	0x004B, 0x01EF, 0x01A6, 0x0020,
+	0x0047, 0x01EA, 0x01AC, 0x0023,
+	0x0043, 0x01E4, 0x01B3, 0x0026,
+	0x003F, 0x01DF, 0x01B9, 0x0029,
+	0x003B, 0x01D9, 0x01C0, 0x002C,
+	0x0037, 0x01D3, 0x01C6, 0x0030,
+	0x0033, 0x01CD, 0x01CD, 0x0033,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	4t_64p_LanczosEd_p_0.6_p_10qb_
+// <num_taps>		4
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.600000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_4tap_64p_ratio_0_60[132] = {
+	0x00C8, 0x026F, 0x00C9, 0x0000,
+	0x00C0, 0x0270, 0x00D1, 0x0FFF,
+	0x00B8, 0x0270, 0x00D9, 0x0FFF,
+	0x00B1, 0x0270, 0x00E1, 0x0FFE,
+	0x00A9, 0x026F, 0x00EB, 0x0FFD,
+	0x00A2, 0x026E, 0x00F3, 0x0FFD,
+	0x009A, 0x026D, 0x00FD, 0x0FFC,
+	0x0093, 0x026C, 0x0105, 0x0FFC,
+	0x008C, 0x026A, 0x010F, 0x0FFB,
+	0x0085, 0x0268, 0x0118, 0x0FFB,
+	0x007E, 0x0265, 0x0122, 0x0FFB,
+	0x0078, 0x0263, 0x012A, 0x0FFB,
+	0x0071, 0x0260, 0x0134, 0x0FFB,
+	0x006B, 0x025C, 0x013E, 0x0FFB,
+	0x0065, 0x0259, 0x0147, 0x0FFB,
+	0x005F, 0x0255, 0x0151, 0x0FFB,
+	0x0059, 0x0251, 0x015A, 0x0FFC,
+	0x0054, 0x024D, 0x0163, 0x0FFC,
+	0x004E, 0x0248, 0x016D, 0x0FFD,
+	0x0049, 0x0243, 0x0176, 0x0FFE,
+	0x0044, 0x023E, 0x017F, 0x0FFF,
+	0x003F, 0x0238, 0x0189, 0x0000,
+	0x003A, 0x0232, 0x0193, 0x0001,
+	0x0036, 0x022C, 0x019C, 0x0002,
+	0x0031, 0x0226, 0x01A5, 0x0004,
+	0x002D, 0x021F, 0x01AF, 0x0005,
+	0x0029, 0x0218, 0x01B8, 0x0007,
+	0x0025, 0x0211, 0x01C1, 0x0009,
+	0x0022, 0x020A, 0x01C9, 0x000B,
+	0x001E, 0x0203, 0x01D2, 0x000D,
+	0x001B, 0x01FB, 0x01DA, 0x0010,
+	0x0018, 0x01F3, 0x01E3, 0x0012,
+	0x0015, 0x01EB, 0x01EB, 0x0015,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	4t_64p_LanczosEd_p_0.7_p_10qb_
+// <num_taps>		4
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.700000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_4tap_64p_ratio_0_70[132] = {
+	0x00A3, 0x02B9, 0x00A4, 0x0000,
+	0x009A, 0x02BA, 0x00AD, 0x0FFF,
+	0x0092, 0x02BA, 0x00B6, 0x0FFE,
+	0x0089, 0x02BA, 0x00C1, 0x0FFC,
+	0x0081, 0x02B9, 0x00CB, 0x0FFB,
+	0x0079, 0x02B8, 0x00D5, 0x0FFA,
+	0x0071, 0x02B7, 0x00DF, 0x0FF9,
+	0x0069, 0x02B5, 0x00EA, 0x0FF8,
+	0x0062, 0x02B3, 0x00F4, 0x0FF7,
+	0x005B, 0x02B0, 0x00FF, 0x0FF6,
+	0x0054, 0x02AD, 0x010B, 0x0FF4,
+	0x004D, 0x02A9, 0x0117, 0x0FF3,
+	0x0046, 0x02A5, 0x0123, 0x0FF2,
+	0x0040, 0x02A1, 0x012D, 0x0FF2,
+	0x003A, 0x029C, 0x0139, 0x0FF1,
+	0x0034, 0x0297, 0x0145, 0x0FF0,
+	0x002F, 0x0292, 0x0150, 0x0FEF,
+	0x0029, 0x028C, 0x015C, 0x0FEF,
+	0x0024, 0x0285, 0x0169, 0x0FEE,
+	0x001F, 0x027F, 0x0174, 0x0FEE,
+	0x001B, 0x0278, 0x017F, 0x0FEE,
+	0x0016, 0x0270, 0x018D, 0x0FED,
+	0x0012, 0x0268, 0x0199, 0x0FED,
+	0x000E, 0x0260, 0x01A4, 0x0FEE,
+	0x000B, 0x0258, 0x01AF, 0x0FEE,
+	0x0007, 0x024F, 0x01BC, 0x0FEE,
+	0x0004, 0x0246, 0x01C7, 0x0FEF,
+	0x0001, 0x023D, 0x01D3, 0x0FEF,
+	0x0FFE, 0x0233, 0x01DF, 0x0FF0,
+	0x0FFC, 0x0229, 0x01EA, 0x0FF1,
+	0x0FFA, 0x021F, 0x01F4, 0x0FF3,
+	0x0FF8, 0x0215, 0x01FF, 0x0FF4,
+	0x0FF6, 0x020A, 0x020A, 0x0FF6,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	4t_64p_LanczosEd_p_0.8_p_10qb_
+// <num_taps>		4
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.800000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_4tap_64p_ratio_0_80[132] = {
+	0x0075, 0x0315, 0x0076, 0x0000,
+	0x006C, 0x0316, 0x007F, 0x0FFF,
+	0x0062, 0x0316, 0x008A, 0x0FFE,
+	0x0059, 0x0315, 0x0096, 0x0FFC,
+	0x0050, 0x0314, 0x00A1, 0x0FFB,
+	0x0048, 0x0312, 0x00AD, 0x0FF9,
+	0x0040, 0x0310, 0x00B8, 0x0FF8,
+	0x0038, 0x030D, 0x00C5, 0x0FF6,
+	0x0030, 0x030A, 0x00D1, 0x0FF5,
+	0x0029, 0x0306, 0x00DE, 0x0FF3,
+	0x0022, 0x0301, 0x00EB, 0x0FF2,
+	0x001C, 0x02FC, 0x00F8, 0x0FF0,
+	0x0015, 0x02F7, 0x0106, 0x0FEE,
+	0x0010, 0x02F1, 0x0112, 0x0FED,
+	0x000A, 0x02EA, 0x0121, 0x0FEB,
+	0x0005, 0x02E3, 0x012F, 0x0FE9,
+	0x0000, 0x02DB, 0x013D, 0x0FE8,
+	0x0FFB, 0x02D3, 0x014C, 0x0FE6,
+	0x0FF7, 0x02CA, 0x015A, 0x0FE5,
+	0x0FF3, 0x02C1, 0x0169, 0x0FE3,
+	0x0FF0, 0x02B7, 0x0177, 0x0FE2,
+	0x0FEC, 0x02AD, 0x0186, 0x0FE1,
+	0x0FE9, 0x02A2, 0x0196, 0x0FDF,
+	0x0FE7, 0x0297, 0x01A4, 0x0FDE,
+	0x0FE4, 0x028C, 0x01B3, 0x0FDD,
+	0x0FE2, 0x0280, 0x01C2, 0x0FDC,
+	0x0FE0, 0x0274, 0x01D0, 0x0FDC,
+	0x0FDF, 0x0268, 0x01DE, 0x0FDB,
+	0x0FDD, 0x025B, 0x01EE, 0x0FDA,
+	0x0FDC, 0x024E, 0x01FC, 0x0FDA,
+	0x0FDB, 0x0241, 0x020A, 0x0FDA,
+	0x0FDB, 0x0233, 0x0218, 0x0FDA,
+	0x0FDA, 0x0226, 0x0226, 0x0FDA,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	4t_64p_LanczosEd_p_0.9_p_10qb_
+// <num_taps>		4
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.900000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_4tap_64p_ratio_0_90[132] = {
+	0x003F, 0x0383, 0x003E, 0x0000,
+	0x0034, 0x0383, 0x004A, 0x0FFF,
+	0x002B, 0x0383, 0x0054, 0x0FFE,
+	0x0021, 0x0381, 0x0061, 0x0FFD,
+	0x0019, 0x037F, 0x006C, 0x0FFC,
+	0x0010, 0x037C, 0x0079, 0x0FFB,
+	0x0008, 0x0378, 0x0086, 0x0FFA,
+	0x0001, 0x0374, 0x0093, 0x0FF8,
+	0x0FFA, 0x036E, 0x00A1, 0x0FF7,
+	0x0FF3, 0x0368, 0x00B0, 0x0FF5,
+	0x0FED, 0x0361, 0x00BF, 0x0FF3,
+	0x0FE8, 0x035A, 0x00CD, 0x0FF1,
+	0x0FE2, 0x0352, 0x00DC, 0x0FF0,
+	0x0FDE, 0x0349, 0x00EB, 0x0FEE,
+	0x0FD9, 0x033F, 0x00FC, 0x0FEC,
+	0x0FD5, 0x0335, 0x010D, 0x0FE9,
+	0x0FD2, 0x032A, 0x011D, 0x0FE7,
+	0x0FCF, 0x031E, 0x012E, 0x0FE5,
+	0x0FCC, 0x0312, 0x013F, 0x0FE3,
+	0x0FCA, 0x0305, 0x0150, 0x0FE1,
+	0x0FC8, 0x02F8, 0x0162, 0x0FDE,
+	0x0FC6, 0x02EA, 0x0174, 0x0FDC,
+	0x0FC5, 0x02DC, 0x0185, 0x0FDA,
+	0x0FC4, 0x02CD, 0x0197, 0x0FD8,
+	0x0FC3, 0x02BE, 0x01AA, 0x0FD5,
+	0x0FC3, 0x02AF, 0x01BB, 0x0FD3,
+	0x0FC3, 0x029F, 0x01CD, 0x0FD1,
+	0x0FC3, 0x028E, 0x01E0, 0x0FCF,
+	0x0FC3, 0x027E, 0x01F2, 0x0FCD,
+	0x0FC4, 0x026D, 0x0203, 0x0FCC,
+	0x0FC5, 0x025C, 0x0215, 0x0FCA,
+	0x0FC6, 0x024B, 0x0227, 0x0FC8,
+	0x0FC7, 0x0239, 0x0239, 0x0FC7,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			03-Apr-2024
+// <coeffDescrip>	4t_64p_LanczosEd_p_1_p_10qb_
+// <num_taps>		4
+// <num_phases>		64
+// <scale_ratio>	 input/output = 1.000000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_4tap_64p_ratio_1_00[132] = {
+	0x0000, 0x0400, 0x0000, 0x0000,
+	0x0FF6, 0x03FF, 0x000B, 0x0000,
+	0x0FED, 0x03FE, 0x0015, 0x0000,
+	0x0FE4, 0x03FB, 0x0022, 0x0FFF,
+	0x0FDC, 0x03F7, 0x002E, 0x0FFF,
+	0x0FD5, 0x03F2, 0x003B, 0x0FFE,
+	0x0FCE, 0x03EC, 0x0048, 0x0FFE,
+	0x0FC8, 0x03E5, 0x0056, 0x0FFD,
+	0x0FC3, 0x03DC, 0x0065, 0x0FFC,
+	0x0FBE, 0x03D3, 0x0075, 0x0FFA,
+	0x0FB9, 0x03C9, 0x0085, 0x0FF9,
+	0x0FB6, 0x03BE, 0x0094, 0x0FF8,
+	0x0FB2, 0x03B2, 0x00A6, 0x0FF6,
+	0x0FB0, 0x03A5, 0x00B7, 0x0FF4,
+	0x0FAD, 0x0397, 0x00CA, 0x0FF2,
+	0x0FAB, 0x0389, 0x00DC, 0x0FF0,
+	0x0FAA, 0x0379, 0x00EF, 0x0FEE,
+	0x0FA9, 0x0369, 0x0102, 0x0FEC,
+	0x0FA9, 0x0359, 0x0115, 0x0FE9,
+	0x0FA9, 0x0348, 0x0129, 0x0FE6,
+	0x0FA9, 0x0336, 0x013D, 0x0FE4,
+	0x0FA9, 0x0323, 0x0153, 0x0FE1,
+	0x0FAA, 0x0310, 0x0168, 0x0FDE,
+	0x0FAC, 0x02FD, 0x017C, 0x0FDB,
+	0x0FAD, 0x02E9, 0x0192, 0x0FD8,
+	0x0FAF, 0x02D5, 0x01A7, 0x0FD5,
+	0x0FB1, 0x02C0, 0x01BD, 0x0FD2,
+	0x0FB3, 0x02AC, 0x01D2, 0x0FCF,
+	0x0FB5, 0x0296, 0x01E9, 0x0FCC,
+	0x0FB8, 0x0281, 0x01FE, 0x0FC9,
+	0x0FBA, 0x026C, 0x0214, 0x0FC6,
+	0x0FBD, 0x0256, 0x022A, 0x0FC3,
+	0x0FC0, 0x0240, 0x0240, 0x0FC0,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			02-Apr-2024
+// <coeffDescrip>	6t_64p_LanczosEd_p_0.3_p_10qb_
+// <num_taps>		6
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.300000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_6tap_64p_ratio_0_30[198] = {
+	0x004B, 0x0100, 0x0169, 0x0101, 0x004B, 0x0000,
+	0x0049, 0x00FD, 0x0169, 0x0103, 0x004E, 0x0000,
+	0x0047, 0x00FA, 0x0169, 0x0106, 0x0050, 0x0000,
+	0x0045, 0x00F7, 0x0168, 0x0109, 0x0052, 0x0001,
+	0x0043, 0x00F5, 0x0168, 0x010B, 0x0054, 0x0001,
+	0x0040, 0x00F2, 0x0168, 0x010E, 0x0057, 0x0001,
+	0x003E, 0x00EF, 0x0168, 0x0110, 0x0059, 0x0002,
+	0x003C, 0x00EC, 0x0167, 0x0113, 0x005C, 0x0002,
+	0x003A, 0x00E9, 0x0167, 0x0116, 0x005E, 0x0002,
+	0x0038, 0x00E6, 0x0166, 0x0118, 0x0061, 0x0003,
+	0x0036, 0x00E3, 0x0165, 0x011C, 0x0063, 0x0003,
+	0x0034, 0x00E0, 0x0165, 0x011D, 0x0066, 0x0004,
+	0x0033, 0x00DD, 0x0164, 0x0120, 0x0068, 0x0004,
+	0x0031, 0x00DA, 0x0163, 0x0122, 0x006B, 0x0005,
+	0x002F, 0x00D7, 0x0163, 0x0125, 0x006D, 0x0005,
+	0x002D, 0x00D3, 0x0162, 0x0128, 0x0070, 0x0006,
+	0x002B, 0x00D0, 0x0161, 0x012A, 0x0073, 0x0007,
+	0x002A, 0x00CD, 0x0160, 0x012D, 0x0075, 0x0007,
+	0x0028, 0x00CA, 0x015F, 0x012F, 0x0078, 0x0008,
+	0x0026, 0x00C7, 0x015E, 0x0131, 0x007B, 0x0009,
+	0x0025, 0x00C4, 0x015D, 0x0133, 0x007E, 0x0009,
+	0x0023, 0x00C1, 0x015C, 0x0136, 0x0080, 0x000A,
+	0x0022, 0x00BE, 0x015A, 0x0138, 0x0083, 0x000B,
+	0x0020, 0x00BB, 0x0159, 0x013A, 0x0086, 0x000C,
+	0x001F, 0x00B8, 0x0158, 0x013B, 0x0089, 0x000D,
+	0x001E, 0x00B5, 0x0156, 0x013E, 0x008C, 0x000D,
+	0x001C, 0x00B2, 0x0155, 0x0140, 0x008F, 0x000E,
+	0x001B, 0x00AF, 0x0153, 0x0143, 0x0091, 0x000F,
+	0x0019, 0x00AC, 0x0152, 0x0145, 0x0094, 0x0010,
+	0x0018, 0x00A9, 0x0150, 0x0147, 0x0097, 0x0011,
+	0x0017, 0x00A6, 0x014F, 0x0148, 0x009A, 0x0012,
+	0x0016, 0x00A3, 0x014D, 0x0149, 0x009D, 0x0014,
+	0x0015, 0x00A0, 0x014B, 0x014B, 0x00A0, 0x0015,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			02-Apr-2024
+// <coeffDescrip>	6t_64p_LanczosEd_p_0.4_p_10qb_
+// <num_taps>		6
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.400000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_6tap_64p_ratio_0_40[198] = {
+	0x0028, 0x0106, 0x01A3, 0x0107, 0x0028, 0x0000,
+	0x0026, 0x0102, 0x01A3, 0x010A, 0x002B, 0x0000,
+	0x0024, 0x00FE, 0x01A3, 0x010F, 0x002D, 0x0FFF,
+	0x0022, 0x00FA, 0x01A3, 0x0113, 0x002F, 0x0FFF,
+	0x0021, 0x00F6, 0x01A3, 0x0116, 0x0031, 0x0FFF,
+	0x001F, 0x00F2, 0x01A2, 0x011B, 0x0034, 0x0FFE,
+	0x001D, 0x00EE, 0x01A2, 0x011F, 0x0036, 0x0FFE,
+	0x001B, 0x00EA, 0x01A1, 0x0123, 0x0039, 0x0FFE,
+	0x0019, 0x00E6, 0x01A1, 0x0127, 0x003B, 0x0FFE,
+	0x0018, 0x00E2, 0x01A0, 0x012A, 0x003E, 0x0FFE,
+	0x0016, 0x00DE, 0x01A0, 0x012E, 0x0041, 0x0FFD,
+	0x0015, 0x00DA, 0x019F, 0x0132, 0x0043, 0x0FFD,
+	0x0013, 0x00D6, 0x019E, 0x0136, 0x0046, 0x0FFD,
+	0x0012, 0x00D2, 0x019D, 0x0139, 0x0049, 0x0FFD,
+	0x0010, 0x00CE, 0x019C, 0x013D, 0x004C, 0x0FFD,
+	0x000F, 0x00CA, 0x019A, 0x0141, 0x004F, 0x0FFD,
+	0x000E, 0x00C6, 0x0199, 0x0144, 0x0052, 0x0FFD,
+	0x000D, 0x00C2, 0x0197, 0x0148, 0x0055, 0x0FFD,
+	0x000B, 0x00BE, 0x0196, 0x014C, 0x0058, 0x0FFD,
+	0x000A, 0x00BA, 0x0195, 0x014F, 0x005B, 0x0FFD,
+	0x0009, 0x00B6, 0x0193, 0x0153, 0x005E, 0x0FFD,
+	0x0008, 0x00B2, 0x0191, 0x0157, 0x0061, 0x0FFD,
+	0x0007, 0x00AE, 0x0190, 0x015A, 0x0064, 0x0FFD,
+	0x0006, 0x00AA, 0x018E, 0x015D, 0x0068, 0x0FFD,
+	0x0005, 0x00A6, 0x018C, 0x0161, 0x006B, 0x0FFD,
+	0x0005, 0x00A2, 0x0189, 0x0164, 0x006F, 0x0FFD,
+	0x0004, 0x009E, 0x0187, 0x0167, 0x0072, 0x0FFE,
+	0x0003, 0x009A, 0x0185, 0x016B, 0x0075, 0x0FFE,
+	0x0002, 0x0096, 0x0183, 0x016E, 0x0079, 0x0FFE,
+	0x0002, 0x0093, 0x0180, 0x016F, 0x007D, 0x0FFF,
+	0x0001, 0x008F, 0x017E, 0x0173, 0x0080, 0x0FFF,
+	0x0001, 0x008B, 0x017B, 0x0175, 0x0084, 0x0000,
+	0x0000, 0x0087, 0x0179, 0x0179, 0x0087, 0x0000,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			02-Apr-2024
+// <coeffDescrip>	6t_64p_LanczosEd_p_0.5_p_10qb_
+// <num_taps>		6
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.500000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_6tap_64p_ratio_0_50[198] = {
+	0x0000, 0x0107, 0x01F3, 0x0106, 0x0000, 0x0000,
+	0x0FFE, 0x0101, 0x01F3, 0x010D, 0x0002, 0x0FFF,
+	0x0FFD, 0x00FB, 0x01F3, 0x0113, 0x0003, 0x0FFF,
+	0x0FFC, 0x00F6, 0x01F3, 0x0118, 0x0005, 0x0FFE,
+	0x0FFA, 0x00F0, 0x01F3, 0x011E, 0x0007, 0x0FFE,
+	0x0FF9, 0x00EB, 0x01F2, 0x0124, 0x0009, 0x0FFD,
+	0x0FF8, 0x00E5, 0x01F2, 0x0129, 0x000B, 0x0FFD,
+	0x0FF7, 0x00E0, 0x01F1, 0x012F, 0x000D, 0x0FFC,
+	0x0FF6, 0x00DA, 0x01F0, 0x0135, 0x0010, 0x0FFB,
+	0x0FF5, 0x00D4, 0x01EF, 0x013B, 0x0012, 0x0FFB,
+	0x0FF4, 0x00CF, 0x01EE, 0x0141, 0x0014, 0x0FFA,
+	0x0FF3, 0x00C9, 0x01ED, 0x0147, 0x0017, 0x0FF9,
+	0x0FF2, 0x00C4, 0x01EB, 0x014C, 0x001A, 0x0FF9,
+	0x0FF1, 0x00BF, 0x01EA, 0x0152, 0x001C, 0x0FF8,
+	0x0FF1, 0x00B9, 0x01E8, 0x0157, 0x001F, 0x0FF8,
+	0x0FF0, 0x00B4, 0x01E6, 0x015D, 0x0022, 0x0FF7,
+	0x0FF0, 0x00AE, 0x01E4, 0x0163, 0x0025, 0x0FF6,
+	0x0FEF, 0x00A9, 0x01E2, 0x0168, 0x0028, 0x0FF6,
+	0x0FEF, 0x00A4, 0x01DF, 0x016E, 0x002B, 0x0FF5,
+	0x0FEF, 0x009F, 0x01DD, 0x0172, 0x002E, 0x0FF5,
+	0x0FEE, 0x009A, 0x01DA, 0x0178, 0x0032, 0x0FF4,
+	0x0FEE, 0x0094, 0x01D8, 0x017E, 0x0035, 0x0FF3,
+	0x0FEE, 0x008F, 0x01D5, 0x0182, 0x0039, 0x0FF3,
+	0x0FEE, 0x008A, 0x01D2, 0x0188, 0x003C, 0x0FF2,
+	0x0FEE, 0x0085, 0x01CF, 0x018C, 0x0040, 0x0FF2,
+	0x0FEE, 0x0081, 0x01CB, 0x0191, 0x0044, 0x0FF1,
+	0x0FEE, 0x007C, 0x01C8, 0x0196, 0x0047, 0x0FF1,
+	0x0FEE, 0x0077, 0x01C4, 0x019C, 0x004B, 0x0FF0,
+	0x0FEE, 0x0072, 0x01C1, 0x01A0, 0x004F, 0x0FF0,
+	0x0FEE, 0x006E, 0x01BD, 0x01A4, 0x0053, 0x0FF0,
+	0x0FEE, 0x0069, 0x01B9, 0x01A9, 0x0058, 0x0FEF,
+	0x0FEE, 0x0065, 0x01B5, 0x01AD, 0x005C, 0x0FEF,
+	0x0FEF, 0x0060, 0x01B1, 0x01B1, 0x0060, 0x0FEF,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			02-Apr-2024
+// <coeffDescrip>	6t_64p_LanczosEd_p_0.6_p_10qb_
+// <num_taps>		6
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.600000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_6tap_64p_ratio_0_60[198] = {
+	0x0FD9, 0x00FB, 0x0258, 0x00FB, 0x0FD9, 0x0000,
+	0x0FD9, 0x00F3, 0x0258, 0x0102, 0x0FDA, 0x0000,
+	0x0FD8, 0x00EB, 0x0258, 0x010B, 0x0FDB, 0x0FFF,
+	0x0FD8, 0x00E3, 0x0258, 0x0112, 0x0FDC, 0x0FFF,
+	0x0FD8, 0x00DC, 0x0257, 0x011B, 0x0FDC, 0x0FFE,
+	0x0FD7, 0x00D4, 0x0256, 0x0123, 0x0FDE, 0x0FFE,
+	0x0FD7, 0x00CD, 0x0255, 0x012B, 0x0FDF, 0x0FFD,
+	0x0FD7, 0x00C5, 0x0254, 0x0133, 0x0FE0, 0x0FFD,
+	0x0FD7, 0x00BE, 0x0252, 0x013C, 0x0FE1, 0x0FFC,
+	0x0FD7, 0x00B6, 0x0251, 0x0143, 0x0FE3, 0x0FFC,
+	0x0FD8, 0x00AF, 0x024F, 0x014B, 0x0FE4, 0x0FFB,
+	0x0FD8, 0x00A8, 0x024C, 0x0154, 0x0FE6, 0x0FFA,
+	0x0FD8, 0x00A1, 0x024A, 0x015B, 0x0FE8, 0x0FFA,
+	0x0FD9, 0x009A, 0x0247, 0x0163, 0x0FEA, 0x0FF9,
+	0x0FD9, 0x0093, 0x0244, 0x016C, 0x0FEC, 0x0FF8,
+	0x0FD9, 0x008C, 0x0241, 0x0174, 0x0FEF, 0x0FF7,
+	0x0FDA, 0x0085, 0x023E, 0x017B, 0x0FF1, 0x0FF7,
+	0x0FDB, 0x007F, 0x023A, 0x0183, 0x0FF3, 0x0FF6,
+	0x0FDB, 0x0078, 0x0237, 0x018B, 0x0FF6, 0x0FF5,
+	0x0FDC, 0x0072, 0x0233, 0x0192, 0x0FF9, 0x0FF4,
+	0x0FDD, 0x006C, 0x022F, 0x0199, 0x0FFC, 0x0FF3,
+	0x0FDD, 0x0065, 0x022A, 0x01A3, 0x0FFF, 0x0FF2,
+	0x0FDE, 0x005F, 0x0226, 0x01AA, 0x0002, 0x0FF1,
+	0x0FDF, 0x005A, 0x0221, 0x01B0, 0x0006, 0x0FF0,
+	0x0FE0, 0x0054, 0x021C, 0x01B7, 0x0009, 0x0FF0,
+	0x0FE1, 0x004E, 0x0217, 0x01BE, 0x000D, 0x0FEF,
+	0x0FE2, 0x0048, 0x0212, 0x01C6, 0x0010, 0x0FEE,
+	0x0FE3, 0x0043, 0x020C, 0x01CD, 0x0014, 0x0FED,
+	0x0FE4, 0x003E, 0x0207, 0x01D3, 0x0018, 0x0FEC,
+	0x0FE5, 0x0039, 0x0200, 0x01DA, 0x001D, 0x0FEB,
+	0x0FE6, 0x0034, 0x01FA, 0x01E1, 0x0021, 0x0FEA,
+	0x0FE7, 0x002F, 0x01F5, 0x01E7, 0x0025, 0x0FE9,
+	0x0FE8, 0x002A, 0x01EE, 0x01EE, 0x002A, 0x0FE8,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			02-Apr-2024
+// <coeffDescrip>	6t_64p_LanczosEd_p_0.7_p_10qb_
+// <num_taps>		6
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.700000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_6tap_64p_ratio_0_70[198] = {
+	0x0FC0, 0x00DA, 0x02CC, 0x00DA, 0x0FC0, 0x0000,
+	0x0FC1, 0x00D0, 0x02CC, 0x00E4, 0x0FBF, 0x0000,
+	0x0FC2, 0x00C6, 0x02CB, 0x00EF, 0x0FBE, 0x0000,
+	0x0FC3, 0x00BC, 0x02CA, 0x00F9, 0x0FBE, 0x0000,
+	0x0FC4, 0x00B2, 0x02C9, 0x0104, 0x0FBD, 0x0000,
+	0x0FC5, 0x00A8, 0x02C7, 0x010F, 0x0FBD, 0x0000,
+	0x0FC7, 0x009F, 0x02C5, 0x0119, 0x0FBC, 0x0000,
+	0x0FC8, 0x0095, 0x02C3, 0x0124, 0x0FBC, 0x0000,
+	0x0FC9, 0x008C, 0x02C0, 0x012F, 0x0FBC, 0x0000,
+	0x0FCB, 0x0083, 0x02BD, 0x0139, 0x0FBC, 0x0000,
+	0x0FCC, 0x007A, 0x02BA, 0x0144, 0x0FBC, 0x0000,
+	0x0FCE, 0x0072, 0x02B6, 0x014D, 0x0FBD, 0x0000,
+	0x0FD0, 0x0069, 0x02B2, 0x0159, 0x0FBD, 0x0FFF,
+	0x0FD1, 0x0061, 0x02AD, 0x0164, 0x0FBE, 0x0FFF,
+	0x0FD3, 0x0059, 0x02A9, 0x016E, 0x0FBF, 0x0FFE,
+	0x0FD4, 0x0051, 0x02A4, 0x017A, 0x0FBF, 0x0FFE,
+	0x0FD6, 0x0049, 0x029E, 0x0184, 0x0FC1, 0x0FFE,
+	0x0FD8, 0x0042, 0x0299, 0x018E, 0x0FC2, 0x0FFD,
+	0x0FD9, 0x003A, 0x0293, 0x019B, 0x0FC3, 0x0FFC,
+	0x0FDB, 0x0033, 0x028D, 0x01A4, 0x0FC5, 0x0FFC,
+	0x0FDC, 0x002D, 0x0286, 0x01AF, 0x0FC7, 0x0FFB,
+	0x0FDE, 0x0026, 0x0280, 0x01BA, 0x0FC8, 0x0FFA,
+	0x0FE0, 0x001F, 0x0279, 0x01C4, 0x0FCB, 0x0FF9,
+	0x0FE1, 0x0019, 0x0272, 0x01CE, 0x0FCD, 0x0FF9,
+	0x0FE3, 0x0013, 0x026A, 0x01D9, 0x0FCF, 0x0FF8,
+	0x0FE4, 0x000D, 0x0263, 0x01E3, 0x0FD2, 0x0FF7,
+	0x0FE6, 0x0008, 0x025B, 0x01EC, 0x0FD5, 0x0FF6,
+	0x0FE7, 0x0002, 0x0253, 0x01F7, 0x0FD8, 0x0FF5,
+	0x0FE9, 0x0FFD, 0x024A, 0x0202, 0x0FDB, 0x0FF3,
+	0x0FEA, 0x0FF8, 0x0242, 0x020B, 0x0FDF, 0x0FF2,
+	0x0FEC, 0x0FF3, 0x0239, 0x0215, 0x0FE2, 0x0FF1,
+	0x0FED, 0x0FEF, 0x0230, 0x021E, 0x0FE6, 0x0FF0,
+	0x0FEF, 0x0FEB, 0x0226, 0x0226, 0x0FEB, 0x0FEF,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			02-Apr-2024
+// <coeffDescrip>	6t_64p_LanczosEd_p_0.8_p_10qb_
+// <num_taps>		6
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.800000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_6tap_64p_ratio_0_80[198] = {
+	0x0FBF, 0x00A1, 0x0340, 0x00A1, 0x0FBF, 0x0000,
+	0x0FC1, 0x0095, 0x0340, 0x00AD, 0x0FBC, 0x0001,
+	0x0FC4, 0x0089, 0x033E, 0x00BA, 0x0FBA, 0x0001,
+	0x0FC6, 0x007D, 0x033D, 0x00C6, 0x0FB8, 0x0002,
+	0x0FC9, 0x0072, 0x033A, 0x00D3, 0x0FB6, 0x0002,
+	0x0FCC, 0x0067, 0x0338, 0x00DF, 0x0FB3, 0x0003,
+	0x0FCE, 0x005C, 0x0334, 0x00EE, 0x0FB1, 0x0003,
+	0x0FD1, 0x0051, 0x0331, 0x00FA, 0x0FAF, 0x0004,
+	0x0FD3, 0x0047, 0x032D, 0x0108, 0x0FAD, 0x0004,
+	0x0FD6, 0x003D, 0x0328, 0x0116, 0x0FAB, 0x0004,
+	0x0FD8, 0x0033, 0x0323, 0x0123, 0x0FAA, 0x0005,
+	0x0FDB, 0x002A, 0x031D, 0x0131, 0x0FA8, 0x0005,
+	0x0FDD, 0x0021, 0x0317, 0x013F, 0x0FA7, 0x0005,
+	0x0FDF, 0x0018, 0x0311, 0x014D, 0x0FA5, 0x0006,
+	0x0FE2, 0x0010, 0x030A, 0x015A, 0x0FA4, 0x0006,
+	0x0FE4, 0x0008, 0x0302, 0x0169, 0x0FA3, 0x0006,
+	0x0FE6, 0x0000, 0x02FB, 0x0177, 0x0FA2, 0x0006,
+	0x0FE8, 0x0FF9, 0x02F3, 0x0185, 0x0FA1, 0x0006,
+	0x0FEB, 0x0FF1, 0x02EA, 0x0193, 0x0FA1, 0x0006,
+	0x0FED, 0x0FEB, 0x02E1, 0x01A1, 0x0FA0, 0x0006,
+	0x0FEE, 0x0FE4, 0x02D8, 0x01B0, 0x0FA0, 0x0006,
+	0x0FF0, 0x0FDE, 0x02CE, 0x01BE, 0x0FA0, 0x0006,
+	0x0FF2, 0x0FD8, 0x02C5, 0x01CB, 0x0FA0, 0x0006,
+	0x0FF4, 0x0FD3, 0x02BA, 0x01D8, 0x0FA1, 0x0006,
+	0x0FF6, 0x0FCD, 0x02B0, 0x01E7, 0x0FA1, 0x0005,
+	0x0FF7, 0x0FC8, 0x02A5, 0x01F5, 0x0FA2, 0x0005,
+	0x0FF9, 0x0FC4, 0x029A, 0x0202, 0x0FA3, 0x0004,
+	0x0FFA, 0x0FC0, 0x028E, 0x0210, 0x0FA4, 0x0004,
+	0x0FFB, 0x0FBC, 0x0283, 0x021D, 0x0FA6, 0x0003,
+	0x0FFD, 0x0FB8, 0x0276, 0x022A, 0x0FA8, 0x0003,
+	0x0FFE, 0x0FB4, 0x026B, 0x0237, 0x0FAA, 0x0002,
+	0x0FFF, 0x0FB1, 0x025E, 0x0245, 0x0FAC, 0x0001,
+	0x0000, 0x0FAE, 0x0252, 0x0252, 0x0FAE, 0x0000,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			02-Apr-2024
+// <coeffDescrip>	6t_64p_LanczosEd_p_0.9_p_10qb_
+// <num_taps>		6
+// <num_phases>		64
+// <scale_ratio>	 input/output = 0.900000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_6tap_64p_ratio_0_90[198] = {
+	0x0FD8, 0x0055, 0x03A7, 0x0054, 0x0FD8, 0x0000,
+	0x0FDB, 0x0047, 0x03A7, 0x0063, 0x0FD4, 0x0000,
+	0x0FDF, 0x003B, 0x03A5, 0x006F, 0x0FD1, 0x0001,
+	0x0FE2, 0x002E, 0x03A3, 0x007E, 0x0FCD, 0x0002,
+	0x0FE5, 0x0022, 0x03A0, 0x008D, 0x0FCA, 0x0002,
+	0x0FE8, 0x0017, 0x039D, 0x009B, 0x0FC6, 0x0003,
+	0x0FEB, 0x000C, 0x0398, 0x00AC, 0x0FC2, 0x0003,
+	0x0FEE, 0x0001, 0x0394, 0x00BA, 0x0FBF, 0x0004,
+	0x0FF1, 0x0FF7, 0x038E, 0x00CA, 0x0FBB, 0x0005,
+	0x0FF4, 0x0FED, 0x0388, 0x00DA, 0x0FB8, 0x0005,
+	0x0FF6, 0x0FE4, 0x0381, 0x00EB, 0x0FB4, 0x0006,
+	0x0FF9, 0x0FDB, 0x037A, 0x00FA, 0x0FB1, 0x0007,
+	0x0FFB, 0x0FD3, 0x0372, 0x010B, 0x0FAD, 0x0008,
+	0x0FFD, 0x0FCB, 0x0369, 0x011D, 0x0FAA, 0x0008,
+	0x0000, 0x0FC3, 0x0360, 0x012E, 0x0FA6, 0x0009,
+	0x0002, 0x0FBC, 0x0356, 0x013F, 0x0FA3, 0x000A,
+	0x0003, 0x0FB6, 0x034C, 0x0150, 0x0FA0, 0x000B,
+	0x0005, 0x0FB0, 0x0341, 0x0162, 0x0F9D, 0x000B,
+	0x0007, 0x0FAA, 0x0336, 0x0173, 0x0F9A, 0x000C,
+	0x0008, 0x0FA5, 0x032A, 0x0185, 0x0F97, 0x000D,
+	0x000A, 0x0FA0, 0x031E, 0x0197, 0x0F94, 0x000D,
+	0x000B, 0x0F9B, 0x0311, 0x01A9, 0x0F92, 0x000E,
+	0x000C, 0x0F97, 0x0303, 0x01BC, 0x0F8F, 0x000F,
+	0x000D, 0x0F94, 0x02F6, 0x01CD, 0x0F8D, 0x000F,
+	0x000E, 0x0F91, 0x02E8, 0x01DE, 0x0F8B, 0x0010,
+	0x000F, 0x0F8E, 0x02D9, 0x01F1, 0x0F89, 0x0010,
+	0x0010, 0x0F8B, 0x02CA, 0x0202, 0x0F88, 0x0011,
+	0x0010, 0x0F89, 0x02BB, 0x0214, 0x0F87, 0x0011,
+	0x0011, 0x0F87, 0x02AB, 0x0226, 0x0F86, 0x0011,
+	0x0011, 0x0F86, 0x029C, 0x0236, 0x0F85, 0x0012,
+	0x0011, 0x0F85, 0x028B, 0x0249, 0x0F84, 0x0012,
+	0x0012, 0x0F84, 0x027B, 0x0259, 0x0F84, 0x0012,
+	0x0012, 0x0F84, 0x026A, 0x026A, 0x0F84, 0x0012,
+};
+
+//========================================================
+// <using>			gen_scaler_coeffs_cnf_file.m
+// <using>			make_test_script.m
+// <date>			02-Apr-2024
+// <coeffDescrip>	6t_64p_LanczosEd_p_1_p_10qb_
+// <num_taps>		6
+// <num_phases>		64
+// <scale_ratio>	 input/output = 1.000000000000
+// <CoefType>		LanczosEd
+// <CoefQuant>		S1.10
+//========================================================
+static const uint16_t easf_filter_6tap_64p_ratio_1_00[198] = {
+	0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000,
+	0x0003, 0x0FF3, 0x0400, 0x000D, 0x0FFD, 0x0000,
+	0x0006, 0x0FE7, 0x03FE, 0x001C, 0x0FF9, 0x0000,
+	0x0009, 0x0FDB, 0x03FC, 0x002B, 0x0FF5, 0x0000,
+	0x000C, 0x0FD0, 0x03F9, 0x003A, 0x0FF1, 0x0000,
+	0x000E, 0x0FC5, 0x03F5, 0x004A, 0x0FED, 0x0001,
+	0x0011, 0x0FBB, 0x03F0, 0x005A, 0x0FE9, 0x0001,
+	0x0013, 0x0FB2, 0x03EB, 0x006A, 0x0FE5, 0x0001,
+	0x0015, 0x0FA9, 0x03E4, 0x007B, 0x0FE1, 0x0002,
+	0x0017, 0x0FA1, 0x03DD, 0x008D, 0x0FDC, 0x0002,
+	0x0018, 0x0F99, 0x03D4, 0x00A0, 0x0FD8, 0x0003,
+	0x001A, 0x0F92, 0x03CB, 0x00B2, 0x0FD3, 0x0004,
+	0x001B, 0x0F8C, 0x03C1, 0x00C6, 0x0FCE, 0x0004,
+	0x001C, 0x0F86, 0x03B7, 0x00D9, 0x0FC9, 0x0005,
+	0x001D, 0x0F80, 0x03AB, 0x00EE, 0x0FC4, 0x0006,
+	0x001E, 0x0F7C, 0x039F, 0x0101, 0x0FBF, 0x0007,
+	0x001F, 0x0F78, 0x0392, 0x0115, 0x0FBA, 0x0008,
+	0x001F, 0x0F74, 0x0385, 0x012B, 0x0FB5, 0x0008,
+	0x0020, 0x0F71, 0x0376, 0x0140, 0x0FB0, 0x0009,
+	0x0020, 0x0F6E, 0x0367, 0x0155, 0x0FAB, 0x000B,
+	0x0020, 0x0F6C, 0x0357, 0x016B, 0x0FA6, 0x000C,
+	0x0020, 0x0F6A, 0x0347, 0x0180, 0x0FA2, 0x000D,
+	0x0020, 0x0F69, 0x0336, 0x0196, 0x0F9D, 0x000E,
+	0x0020, 0x0F69, 0x0325, 0x01AB, 0x0F98, 0x000F,
+	0x001F, 0x0F68, 0x0313, 0x01C3, 0x0F93, 0x0010,
+	0x001F, 0x0F69, 0x0300, 0x01D8, 0x0F8F, 0x0011,
+	0x001E, 0x0F69, 0x02ED, 0x01EF, 0x0F8B, 0x0012,
+	0x001D, 0x0F6A, 0x02D9, 0x0205, 0x0F87, 0x0014,
+	0x001D, 0x0F6C, 0x02C5, 0x021A, 0x0F83, 0x0015,
+	0x001C, 0x0F6E, 0x02B1, 0x0230, 0x0F7F, 0x0016,
+	0x001B, 0x0F70, 0x029C, 0x0247, 0x0F7B, 0x0017,
+	0x001A, 0x0F72, 0x0287, 0x025D, 0x0F78, 0x0018,
+	0x0019, 0x0F75, 0x0272, 0x0272, 0x0F75, 0x0019,
+};
+
+/* Converted scaler coeff tables from S1.10 to S1.12 */
+static uint16_t easf_filter_3tap_64p_ratio_0_30_s1_12[99];
+static uint16_t easf_filter_3tap_64p_ratio_0_40_s1_12[99];
+static uint16_t easf_filter_3tap_64p_ratio_0_50_s1_12[99];
+static uint16_t easf_filter_3tap_64p_ratio_0_60_s1_12[99];
+static uint16_t easf_filter_3tap_64p_ratio_0_70_s1_12[99];
+static uint16_t easf_filter_3tap_64p_ratio_0_80_s1_12[99];
+static uint16_t easf_filter_3tap_64p_ratio_0_90_s1_12[99];
+static uint16_t easf_filter_3tap_64p_ratio_1_00_s1_12[99];
+static uint16_t easf_filter_4tap_64p_ratio_0_30_s1_12[132];
+static uint16_t easf_filter_4tap_64p_ratio_0_40_s1_12[132];
+static uint16_t easf_filter_4tap_64p_ratio_0_50_s1_12[132];
+static uint16_t easf_filter_4tap_64p_ratio_0_60_s1_12[132];
+static uint16_t easf_filter_4tap_64p_ratio_0_70_s1_12[132];
+static uint16_t easf_filter_4tap_64p_ratio_0_80_s1_12[132];
+static uint16_t easf_filter_4tap_64p_ratio_0_90_s1_12[132];
+static uint16_t easf_filter_4tap_64p_ratio_1_00_s1_12[132];
+static uint16_t easf_filter_6tap_64p_ratio_0_30_s1_12[198];
+static uint16_t easf_filter_6tap_64p_ratio_0_40_s1_12[198];
+static uint16_t easf_filter_6tap_64p_ratio_0_50_s1_12[198];
+static uint16_t easf_filter_6tap_64p_ratio_0_60_s1_12[198];
+static uint16_t easf_filter_6tap_64p_ratio_0_70_s1_12[198];
+static uint16_t easf_filter_6tap_64p_ratio_0_80_s1_12[198];
+static uint16_t easf_filter_6tap_64p_ratio_0_90_s1_12[198];
+static uint16_t easf_filter_6tap_64p_ratio_1_00_s1_12[198];
+
+struct scale_ratio_to_reg_value_lookup easf_v_bf3_mode_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x0000},
+	{5, 10, 0x0000},
+	{6, 10, 0x0000},
+	{7, 10, 0x0000},
+	{8, 10, 0x0000},
+	{9, 10, 0x0000},
+	{1, 1, 0x0000},
+	{-1, -1, 0x0002},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_h_bf3_mode_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x0000},
+	{5, 10, 0x0000},
+	{6, 10, 0x0000},
+	{7, 10, 0x0000},
+	{8, 10, 0x0000},
+	{9, 10, 0x0000},
+	{1, 1, 0x0000},
+	{-1, -1, 0x0002},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_reducer_gain6_6tap_lookup[] = {
+	{3, 10, 0x4100},
+	{4, 10, 0x4100},
+	{5, 10, 0x4100},
+	{6, 10, 0x4100},
+	{7, 10, 0x4100},
+	{8, 10, 0x4100},
+	{9, 10, 0x4100},
+	{1, 1, 0x4100},
+	{-1, -1, 0x4100},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_reducer_gain4_6tap_lookup[] = {
+	{3, 10, 0x4000},
+	{4, 10, 0x4000},
+	{5, 10, 0x4000},
+	{6, 10, 0x4000},
+	{7, 10, 0x4000},
+	{8, 10, 0x4000},
+	{9, 10, 0x4000},
+	{1, 1, 0x4000},
+	{-1, -1, 0x4000},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_gain_ring6_6tap_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x251F},
+	{5, 10, 0x291F},
+	{6, 10, 0xA51F},
+	{7, 10, 0xA51F},
+	{8, 10, 0xAA66},
+	{9, 10, 0xA51F},
+	{1, 1, 0xA640},
+	{-1, -1, 0xA640},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_gain_ring4_6tap_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x9600},
+	{5, 10, 0xA460},
+	{6, 10, 0xA8E0},
+	{7, 10, 0xAC00},
+	{8, 10, 0xAD20},
+	{9, 10, 0xAFC0},
+	{1, 1, 0xB058},
+	{-1, -1, 0xB058},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_reducer_gain6_4tap_lookup[] = {
+	{3, 10, 0x4100},
+	{4, 10, 0x4100},
+	{5, 10, 0x4100},
+	{6, 10, 0x4100},
+	{7, 10, 0x4100},
+	{8, 10, 0x4100},
+	{9, 10, 0x4100},
+	{1, 1, 0x4100},
+	{-1, -1, 0x4100},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_reducer_gain4_4tap_lookup[] = {
+	{3, 10, 0x4000},
+	{4, 10, 0x4000},
+	{5, 10, 0x4000},
+	{6, 10, 0x4000},
+	{7, 10, 0x4000},
+	{8, 10, 0x4000},
+	{9, 10, 0x4000},
+	{1, 1, 0x4000},
+	{-1, -1, 0x4000},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_gain_ring6_4tap_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x0000},
+	{5, 10, 0x0000},
+	{6, 10, 0x0000},
+	{7, 10, 0x0000},
+	{8, 10, 0x0000},
+	{9, 10, 0x0000},
+	{1, 1, 0x0000},
+	{-1, -1, 0x0000},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_gain_ring4_4tap_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x0000},
+	{5, 10, 0x0000},
+	{6, 10, 0x9900},
+	{7, 10, 0xA100},
+	{8, 10, 0xA8C0},
+	{9, 10, 0xAB20},
+	{1, 1, 0xAC00},
+	{-1, -1, 0xAC00},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_3tap_dntilt_uptilt_offset_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x0000},
+	{5, 10, 0x0000},
+	{6, 10, 0x0000},
+	{7, 10, 0x0000},
+	{8, 10, 0x4100},
+	{9, 10, 0x9F00},
+	{1, 1, 0xA4C0},
+	{-1, -1, 0xA8D8},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_3tap_uptilt_maxval_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x0000},
+	{5, 10, 0x0000},
+	{6, 10, 0x0000},
+	{7, 10, 0x0000},
+	{8, 10, 0x4000},
+	{9, 10, 0x24FE},
+	{1, 1, 0x2D64},
+	{-1, -1, 0x3ADB},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_3tap_dntilt_slope_lookup[] = {
+	{3, 10, 0x3800},
+	{4, 10, 0x3800},
+	{5, 10, 0x3800},
+	{6, 10, 0x3800},
+	{7, 10, 0x3800},
+	{8, 10, 0x3886},
+	{9, 10, 0x3940},
+	{1, 1, 0x3A4E},
+	{-1, -1, 0x3B66},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_3tap_uptilt1_slope_lookup[] = {
+	{3, 10, 0x3800},
+	{4, 10, 0x3800},
+	{5, 10, 0x3800},
+	{6, 10, 0x3800},
+	{7, 10, 0x3800},
+	{8, 10, 0x36F4},
+	{9, 10, 0x359C},
+	{1, 1, 0x3360},
+	{-1, -1, 0x2F20},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_3tap_uptilt2_slope_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x0000},
+	{5, 10, 0x0000},
+	{6, 10, 0x0000},
+	{7, 10, 0x0000},
+	{8, 10, 0x0000},
+	{9, 10, 0x359C},
+	{1, 1, 0x31F0},
+	{-1, -1, 0x1F00},
+};
+
+struct scale_ratio_to_reg_value_lookup easf_3tap_uptilt2_offset_lookup[] = {
+	{3, 10, 0x0000},
+	{4, 10, 0x0000},
+	{5, 10, 0x0000},
+	{6, 10, 0x0000},
+	{7, 10, 0x0000},
+	{8, 10, 0x0000},
+	{9, 10, 0x9F00},
+	{1, 1, 0xA400},
+	{-1, -1, 0x9E00},
+};
+
+void spl_init_easf_filter_coeffs(void)
+{
+	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_30,
+		easf_filter_3tap_64p_ratio_0_30_s1_12, 3);
+	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_40,
+		easf_filter_3tap_64p_ratio_0_40_s1_12, 3);
+	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_50,
+		easf_filter_3tap_64p_ratio_0_50_s1_12, 3);
+	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_60,
+		easf_filter_3tap_64p_ratio_0_60_s1_12, 3);
+	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_70,
+		easf_filter_3tap_64p_ratio_0_70_s1_12, 3);
+	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_80,
+		easf_filter_3tap_64p_ratio_0_80_s1_12, 3);
+	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_0_90,
+		easf_filter_3tap_64p_ratio_0_90_s1_12, 3);
+	convert_filter_s1_10_to_s1_12(easf_filter_3tap_64p_ratio_1_00,
+		easf_filter_3tap_64p_ratio_1_00_s1_12, 3);
+
+	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_30,
+		easf_filter_4tap_64p_ratio_0_30_s1_12, 4);
+	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_40,
+		easf_filter_4tap_64p_ratio_0_40_s1_12, 4);
+	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_50,
+		easf_filter_4tap_64p_ratio_0_50_s1_12, 4);
+	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_60,
+		easf_filter_4tap_64p_ratio_0_60_s1_12, 4);
+	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_70,
+		easf_filter_4tap_64p_ratio_0_70_s1_12, 4);
+	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_80,
+		easf_filter_4tap_64p_ratio_0_80_s1_12, 4);
+	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_0_90,
+		easf_filter_4tap_64p_ratio_0_90_s1_12, 4);
+	convert_filter_s1_10_to_s1_12(easf_filter_4tap_64p_ratio_1_00,
+		easf_filter_4tap_64p_ratio_1_00_s1_12, 4);
+
+	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_30,
+		easf_filter_6tap_64p_ratio_0_30_s1_12, 6);
+	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_40,
+		easf_filter_6tap_64p_ratio_0_40_s1_12, 6);
+	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_50,
+		easf_filter_6tap_64p_ratio_0_50_s1_12, 6);
+	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_60,
+		easf_filter_6tap_64p_ratio_0_60_s1_12, 6);
+	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_70,
+		easf_filter_6tap_64p_ratio_0_70_s1_12, 6);
+	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_80,
+		easf_filter_6tap_64p_ratio_0_80_s1_12, 6);
+	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_0_90,
+		easf_filter_6tap_64p_ratio_0_90_s1_12, 6);
+	convert_filter_s1_10_to_s1_12(easf_filter_6tap_64p_ratio_1_00,
+		easf_filter_6tap_64p_ratio_1_00_s1_12, 6);
+}
+
+uint16_t *spl_get_easf_filter_3tap_64p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_from_fraction(3, 10).value)
+		return easf_filter_3tap_64p_ratio_0_30_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 10).value)
+		return easf_filter_3tap_64p_ratio_0_40_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 10).value)
+		return easf_filter_3tap_64p_ratio_0_50_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(6, 10).value)
+		return easf_filter_3tap_64p_ratio_0_60_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(7, 10).value)
+		return easf_filter_3tap_64p_ratio_0_70_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(8, 10).value)
+		return easf_filter_3tap_64p_ratio_0_80_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(9, 10).value)
+		return easf_filter_3tap_64p_ratio_0_90_s1_12;
+	else
+		return easf_filter_3tap_64p_ratio_1_00_s1_12;
+}
+
+uint16_t *spl_get_easf_filter_4tap_64p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_from_fraction(3, 10).value)
+		return easf_filter_4tap_64p_ratio_0_30_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 10).value)
+		return easf_filter_4tap_64p_ratio_0_40_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 10).value)
+		return easf_filter_4tap_64p_ratio_0_50_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(6, 10).value)
+		return easf_filter_4tap_64p_ratio_0_60_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(7, 10).value)
+		return easf_filter_4tap_64p_ratio_0_70_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(8, 10).value)
+		return easf_filter_4tap_64p_ratio_0_80_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(9, 10).value)
+		return easf_filter_4tap_64p_ratio_0_90_s1_12;
+	else
+		return easf_filter_4tap_64p_ratio_1_00_s1_12;
+}
+
+uint16_t *spl_get_easf_filter_6tap_64p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_from_fraction(3, 10).value)
+		return easf_filter_6tap_64p_ratio_0_30_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 10).value)
+		return easf_filter_6tap_64p_ratio_0_40_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 10).value)
+		return easf_filter_6tap_64p_ratio_0_50_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(6, 10).value)
+		return easf_filter_6tap_64p_ratio_0_60_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(7, 10).value)
+		return easf_filter_6tap_64p_ratio_0_70_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(8, 10).value)
+		return easf_filter_6tap_64p_ratio_0_80_s1_12;
+	else if (ratio.value < spl_fixpt_from_fraction(9, 10).value)
+		return easf_filter_6tap_64p_ratio_0_90_s1_12;
+	else
+		return easf_filter_6tap_64p_ratio_1_00_s1_12;
+}
+
+uint16_t *spl_dscl_get_easf_filter_coeffs_64p(int taps, struct spl_fixed31_32 ratio)
+{
+	if (taps == 6)
+		return spl_get_easf_filter_6tap_64p(ratio);
+	else if (taps == 4)
+		return spl_get_easf_filter_4tap_64p(ratio);
+	else if (taps == 3)
+		return spl_get_easf_filter_3tap_64p(ratio);
+	else {
+		/* should never happen, bug */
+		SPL_BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+}
+
+void spl_set_filters_data(struct dscl_prog_data *dscl_prog_data,
+		const struct spl_scaler_data *data, bool enable_easf_v,
+		bool enable_easf_h)
+{
+	/*
+	 * Old coefficients calculated scaling ratio = input / output
+	 * New coefficients are calculated based on = output / input
+	 */
+	if (enable_easf_h) {
+		dscl_prog_data->filter_h = spl_dscl_get_easf_filter_coeffs_64p(
+			data->taps.h_taps, data->recip_ratios.horz);
+
+		dscl_prog_data->filter_h_c = spl_dscl_get_easf_filter_coeffs_64p(
+			data->taps.h_taps_c, data->recip_ratios.horz_c);
+	} else {
+		dscl_prog_data->filter_h = spl_dscl_get_filter_coeffs_64p(
+			data->taps.h_taps, data->ratios.horz);
+
+		dscl_prog_data->filter_h_c = spl_dscl_get_filter_coeffs_64p(
+			data->taps.h_taps_c, data->ratios.horz_c);
+	}
+	if (enable_easf_v) {
+		dscl_prog_data->filter_v = spl_dscl_get_easf_filter_coeffs_64p(
+			data->taps.v_taps, data->recip_ratios.vert);
+
+		dscl_prog_data->filter_v_c = spl_dscl_get_easf_filter_coeffs_64p(
+			data->taps.v_taps_c, data->recip_ratios.vert_c);
+	} else {
+		dscl_prog_data->filter_v = spl_dscl_get_filter_coeffs_64p(
+			data->taps.v_taps, data->ratios.vert);
+
+		dscl_prog_data->filter_v_c = spl_dscl_get_filter_coeffs_64p(
+			data->taps.v_taps_c, data->ratios.vert_c);
+	}
+}
+
+static uint32_t spl_easf_get_scale_ratio_to_reg_value(struct spl_fixed31_32 ratio,
+	struct scale_ratio_to_reg_value_lookup *lookup_table_base_ptr,
+	unsigned int num_entries)
+{
+	unsigned int count = 0;
+	uint32_t value = 0;
+	struct scale_ratio_to_reg_value_lookup *lookup_table_index_ptr;
+
+	lookup_table_index_ptr = (lookup_table_base_ptr + num_entries - 1);
+	value = lookup_table_index_ptr->reg_value;
+
+	while (count < num_entries) {
+
+		lookup_table_index_ptr = (lookup_table_base_ptr + count);
+		if (lookup_table_index_ptr->numer < 0)
+			break;
+
+		if (ratio.value < spl_fixpt_from_fraction(
+			lookup_table_index_ptr->numer,
+			lookup_table_index_ptr->denom).value) {
+			value = lookup_table_index_ptr->reg_value;
+			break;
+		}
+
+		count++;
+	}
+	return value;
+}
+uint32_t spl_get_v_bf3_mode(struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries = sizeof(easf_v_bf3_mode_lookup) /
+		sizeof(struct scale_ratio_to_reg_value_lookup);
+	value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+		easf_v_bf3_mode_lookup, num_entries);
+	return value;
+}
+uint32_t spl_get_h_bf3_mode(struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries = sizeof(easf_h_bf3_mode_lookup) /
+		sizeof(struct scale_ratio_to_reg_value_lookup);
+	value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+		easf_h_bf3_mode_lookup, num_entries);
+	return value;
+}
+uint32_t spl_get_reducer_gain6(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 4) {
+		num_entries = sizeof(easf_reducer_gain6_4tap_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_reducer_gain6_4tap_lookup, num_entries);
+	} else if (taps == 6) {
+		num_entries = sizeof(easf_reducer_gain6_6tap_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_reducer_gain6_6tap_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
+uint32_t spl_get_reducer_gain4(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 4) {
+		num_entries = sizeof(easf_reducer_gain4_4tap_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_reducer_gain4_4tap_lookup, num_entries);
+	} else if (taps == 6) {
+		num_entries = sizeof(easf_reducer_gain4_6tap_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_reducer_gain4_6tap_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
+uint32_t spl_get_gainRing6(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 4) {
+		num_entries = sizeof(easf_gain_ring6_4tap_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_gain_ring6_4tap_lookup, num_entries);
+	} else if (taps == 6) {
+		num_entries = sizeof(easf_gain_ring6_6tap_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_gain_ring6_6tap_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
+uint32_t spl_get_gainRing4(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 4) {
+		num_entries = sizeof(easf_gain_ring4_4tap_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_gain_ring4_4tap_lookup, num_entries);
+	} else if (taps == 6) {
+		num_entries = sizeof(easf_gain_ring4_6tap_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_gain_ring4_6tap_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
+uint32_t spl_get_3tap_dntilt_uptilt_offset(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 3) {
+		num_entries = sizeof(easf_3tap_dntilt_uptilt_offset_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_3tap_dntilt_uptilt_offset_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
+uint32_t spl_get_3tap_uptilt_maxval(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 3) {
+		num_entries = sizeof(easf_3tap_uptilt_maxval_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_3tap_uptilt_maxval_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
+uint32_t spl_get_3tap_dntilt_slope(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 3) {
+		num_entries = sizeof(easf_3tap_dntilt_slope_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_3tap_dntilt_slope_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
+uint32_t spl_get_3tap_uptilt1_slope(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 3) {
+		num_entries = sizeof(easf_3tap_uptilt1_slope_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_3tap_uptilt1_slope_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
+uint32_t spl_get_3tap_uptilt2_slope(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 3) {
+		num_entries = sizeof(easf_3tap_uptilt2_slope_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_3tap_uptilt2_slope_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
+uint32_t spl_get_3tap_uptilt2_offset(int taps, struct spl_fixed31_32 ratio)
+{
+	uint32_t value;
+	unsigned int num_entries;
+
+	if (taps == 3) {
+		num_entries = sizeof(easf_3tap_uptilt2_offset_lookup) /
+			sizeof(struct scale_ratio_to_reg_value_lookup);
+		value = spl_easf_get_scale_ratio_to_reg_value(ratio,
+			easf_3tap_uptilt2_offset_lookup, num_entries);
+	} else
+		value = 0;
+	return value;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_easf_filters.h b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_easf_filters.h
new file mode 100644
index 000000000000..8bb2b8108e38
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_easf_filters.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: MIT */
+
+/* Copyright 2024 Advanced Micro Devices, Inc. */
+
+#ifndef __DC_SPL_SCL_EASF_FILTERS_H__
+#define __DC_SPL_SCL_EASF_FILTERS_H__
+
+#include "dc_spl_types.h"
+
+struct scale_ratio_to_reg_value_lookup {
+	int numer;
+	int denom;
+	const uint32_t reg_value;
+};
+
+void spl_init_easf_filter_coeffs(void);
+uint16_t *spl_get_easf_filter_3tap_64p(struct spl_fixed31_32 ratio);
+uint16_t *spl_get_easf_filter_4tap_64p(struct spl_fixed31_32 ratio);
+uint16_t *spl_get_easf_filter_6tap_64p(struct spl_fixed31_32 ratio);
+uint16_t *spl_dscl_get_easf_filter_coeffs_64p(int taps, struct spl_fixed31_32 ratio);
+void spl_set_filters_data(struct dscl_prog_data *dscl_prog_data,
+	const struct spl_scaler_data *data, bool enable_easf_v,
+	bool enable_easf_h);
+
+uint32_t spl_get_v_bf3_mode(struct spl_fixed31_32 ratio);
+uint32_t spl_get_h_bf3_mode(struct spl_fixed31_32 ratio);
+uint32_t spl_get_reducer_gain6(int taps, struct spl_fixed31_32 ratio);
+uint32_t spl_get_reducer_gain4(int taps, struct spl_fixed31_32 ratio);
+uint32_t spl_get_gainRing6(int taps, struct spl_fixed31_32 ratio);
+uint32_t spl_get_gainRing4(int taps, struct spl_fixed31_32 ratio);
+uint32_t spl_get_3tap_dntilt_uptilt_offset(int taps, struct spl_fixed31_32 ratio);
+uint32_t spl_get_3tap_uptilt_maxval(int taps, struct spl_fixed31_32 ratio);
+uint32_t spl_get_3tap_dntilt_slope(int taps, struct spl_fixed31_32 ratio);
+uint32_t spl_get_3tap_uptilt1_slope(int taps, struct spl_fixed31_32 ratio);
+uint32_t spl_get_3tap_uptilt2_slope(int taps, struct spl_fixed31_32 ratio);
+uint32_t spl_get_3tap_uptilt2_offset(int taps, struct spl_fixed31_32 ratio);
+
+#endif /* __DC_SPL_SCL_EASF_FILTERS_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_filters.c b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_filters.c
new file mode 100644
index 000000000000..b02c7b0b262b
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_filters.c
@@ -0,0 +1,1451 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#include "spl_debug.h"
+#include "dc_spl_scl_filters.h"
+//=========================================
+// <num_taps>    = 2
+// <num_phases>  = 16
+// <scale_ratio> = 0.833333 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = s1.10
+// <CoefOut>     = s1.12
+//=========================================
+static const uint16_t filter_2tap_16p[18] = {
+		0x1000, 0x0000,
+		0x0FF0, 0x0010,
+		0x0FB0, 0x0050,
+		0x0F34, 0x00CC,
+		0x0E68, 0x0198,
+		0x0D44, 0x02BC,
+		0x0BC4, 0x043C,
+		0x09FC, 0x0604,
+		0x0800, 0x0800
+};
+
+//=========================================
+// <num_taps>    = 3
+// <num_phases>  = 16
+// <scale_ratio> = 0.83333 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_3tap_16p_upscale[27] = {
+		0x0804, 0x07FC, 0x0000,
+		0x06AC, 0x0978, 0x3FDC,
+		0x055C, 0x0AF0, 0x3FB4,
+		0x0420, 0x0C50, 0x3F90,
+		0x0300, 0x0D88, 0x3F78,
+		0x0200, 0x0E90, 0x3F70,
+		0x0128, 0x0F5C, 0x3F7C,
+		0x007C, 0x0FD8, 0x3FAC,
+		0x0000, 0x1000, 0x0000
+};
+
+//=========================================
+// <num_taps>    = 3
+// <num_phases>  = 16
+// <scale_ratio> = 1.16666 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_3tap_16p_116[27] = {
+		0x0804, 0x07FC, 0x0000,
+		0x0700, 0x0914, 0x3FEC,
+		0x0604, 0x0A1C, 0x3FE0,
+		0x050C, 0x0B14, 0x3FE0,
+		0x041C, 0x0BF4, 0x3FF0,
+		0x0340, 0x0CB0, 0x0010,
+		0x0274, 0x0D3C, 0x0050,
+		0x01C0, 0x0D94, 0x00AC,
+		0x0128, 0x0DB4, 0x0124
+};
+
+//=========================================
+// <num_taps>    = 3
+// <num_phases>  = 16
+// <scale_ratio> = 1.49999 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_3tap_16p_149[27] = {
+		0x0804, 0x07FC, 0x0000,
+		0x0730, 0x08CC, 0x0004,
+		0x0660, 0x098C, 0x0014,
+		0x0590, 0x0A3C, 0x0034,
+		0x04C4, 0x0AD4, 0x0068,
+		0x0400, 0x0B54, 0x00AC,
+		0x0348, 0x0BB0, 0x0108,
+		0x029C, 0x0BEC, 0x0178,
+		0x0200, 0x0C00, 0x0200
+};
+
+//=========================================
+// <num_taps>    = 3
+// <num_phases>  = 16
+// <scale_ratio> = 1.83332 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_3tap_16p_183[27] = {
+		0x0804, 0x07FC, 0x0000,
+		0x0754, 0x0880, 0x002C,
+		0x06A8, 0x08F0, 0x0068,
+		0x05FC, 0x0954, 0x00B0,
+		0x0550, 0x09AC, 0x0104,
+		0x04A8, 0x09F0, 0x0168,
+		0x0408, 0x0A20, 0x01D8,
+		0x036C, 0x0A40, 0x0254,
+		0x02DC, 0x0A48, 0x02DC
+};
+
+//=========================================
+// <num_taps>    = 4
+// <num_phases>  = 16
+// <scale_ratio> = 0.83333 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_4tap_16p_upscale[36] = {
+		0x0000, 0x1000, 0x0000, 0x0000,
+		0x3F74, 0x0FDC, 0x00B4, 0x3FFC,
+		0x3F0C, 0x0F70, 0x0194, 0x3FF0,
+		0x3ECC, 0x0EC4, 0x0298, 0x3FD8,
+		0x3EAC, 0x0DE4, 0x03B8, 0x3FB8,
+		0x3EA4, 0x0CD8, 0x04F4, 0x3F90,
+		0x3EB8, 0x0BA0, 0x0644, 0x3F64,
+		0x3ED8, 0x0A54, 0x07A0, 0x3F34,
+		0x3F00, 0x08FC, 0x0900, 0x3F04
+};
+
+//=========================================
+// <num_taps>    = 4
+// <num_phases>  = 16
+// <scale_ratio> = 1.16666 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_4tap_16p_116[36] = {
+		0x01A8, 0x0CB4, 0x01A4, 0x0000,
+		0x0110, 0x0CB0, 0x0254, 0x3FEC,
+		0x0090, 0x0C80, 0x031C, 0x3FD4,
+		0x0024, 0x0C2C, 0x03F4, 0x3FBC,
+		0x3FD8, 0x0BAC, 0x04DC, 0x3FA0,
+		0x3F9C, 0x0B14, 0x05CC, 0x3F84,
+		0x3F70, 0x0A60, 0x06C4, 0x3F6C,
+		0x3F5C, 0x098C, 0x07BC, 0x3F5C,
+		0x3F54, 0x08AC, 0x08AC, 0x3F54
+};
+
+//=========================================
+// <num_taps>    = 4
+// <num_phases>  = 16
+// <scale_ratio> = 1.49999 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_4tap_16p_149[36] = {
+		0x02B8, 0x0A90, 0x02B8, 0x0000,
+		0x0230, 0x0A90, 0x0350, 0x3FF0,
+		0x01B8, 0x0A78, 0x03F0, 0x3FE0,
+		0x0148, 0x0A48, 0x049C, 0x3FD4,
+		0x00E8, 0x0A00, 0x054C, 0x3FCC,
+		0x0098, 0x09A0, 0x0600, 0x3FC8,
+		0x0054, 0x0928, 0x06B4, 0x3FD0,
+		0x001C, 0x08A4, 0x0760, 0x3FE0,
+		0x3FFC, 0x0804, 0x0804, 0x3FFC
+};
+
+//=========================================
+// <num_taps>    = 4
+// <num_phases>  = 16
+// <scale_ratio> = 1.83332 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_4tap_16p_183[36] = {
+		0x03B0, 0x08A0, 0x03B0, 0x0000,
+		0x0348, 0x0898, 0x041C, 0x0004,
+		0x02DC, 0x0884, 0x0490, 0x0010,
+		0x0278, 0x0864, 0x0500, 0x0024,
+		0x021C, 0x0838, 0x0570, 0x003C,
+		0x01C8, 0x07FC, 0x05E0, 0x005C,
+		0x0178, 0x07B8, 0x064C, 0x0084,
+		0x0130, 0x076C, 0x06B0, 0x00B4,
+		0x00F0, 0x0714, 0x0710, 0x00EC
+};
+
+//=========================================
+// <num_taps>    = 2
+// <num_phases>  = 64
+// <scale_ratio> = 0.833333 (input/output)
+// <sharpness>   = 0
+// <CoefType> = ModifiedLanczos
+// <CoefQuant> = s1.10
+// <CoefOut> = s1.12
+//=========================================
+static const uint16_t filter_2tap_64p[66] = {
+		0x1000, 0x0000,
+		0x1000, 0x0000,
+		0x0FFC, 0x0004,
+		0x0FF8, 0x0008,
+		0x0FF0, 0x0010,
+		0x0FE4, 0x001C,
+		0x0FD8, 0x0028,
+		0x0FC4, 0x003C,
+		0x0FB0, 0x0050,
+		0x0F98, 0x0068,
+		0x0F7C, 0x0084,
+		0x0F58, 0x00A8,
+		0x0F34, 0x00CC,
+		0x0F08, 0x00F8,
+		0x0ED8, 0x0128,
+		0x0EA4, 0x015C,
+		0x0E68, 0x0198,
+		0x0E28, 0x01D8,
+		0x0DE4, 0x021C,
+		0x0D98, 0x0268,
+		0x0D44, 0x02BC,
+		0x0CEC, 0x0314,
+		0x0C90, 0x0370,
+		0x0C2C, 0x03D4,
+		0x0BC4, 0x043C,
+		0x0B58, 0x04A8,
+		0x0AE8, 0x0518,
+		0x0A74, 0x058C,
+		0x09FC, 0x0604,
+		0x0980, 0x0680,
+		0x0900, 0x0700,
+		0x0880, 0x0780,
+		0x0800, 0x0800
+};
+
+//=========================================
+// <num_taps>    = 3
+// <num_phases>  = 64
+// <scale_ratio> = 0.83333 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_3tap_64p_upscale[99] = {
+		0x0804, 0x07FC, 0x0000,
+		0x07A8, 0x0860, 0x3FF8,
+		0x0754, 0x08BC, 0x3FF0,
+		0x0700, 0x0918, 0x3FE8,
+		0x06AC, 0x0978, 0x3FDC,
+		0x0654, 0x09D8, 0x3FD4,
+		0x0604, 0x0A34, 0x3FC8,
+		0x05B0, 0x0A90, 0x3FC0,
+		0x055C, 0x0AF0, 0x3FB4,
+		0x050C, 0x0B48, 0x3FAC,
+		0x04BC, 0x0BA0, 0x3FA4,
+		0x0470, 0x0BF4, 0x3F9C,
+		0x0420, 0x0C50, 0x3F90,
+		0x03D8, 0x0C9C, 0x3F8C,
+		0x038C, 0x0CF0, 0x3F84,
+		0x0344, 0x0D40, 0x3F7C,
+		0x0300, 0x0D88, 0x3F78,
+		0x02BC, 0x0DD0, 0x3F74,
+		0x027C, 0x0E14, 0x3F70,
+		0x023C, 0x0E54, 0x3F70,
+		0x0200, 0x0E90, 0x3F70,
+		0x01C8, 0x0EC8, 0x3F70,
+		0x0190, 0x0EFC, 0x3F74,
+		0x015C, 0x0F2C, 0x3F78,
+		0x0128, 0x0F5C, 0x3F7C,
+		0x00FC, 0x0F7C, 0x3F88,
+		0x00CC, 0x0FA4, 0x3F90,
+		0x00A4, 0x0FC0, 0x3F9C,
+		0x007C, 0x0FD8, 0x3FAC,
+		0x0058, 0x0FE8, 0x3FC0,
+		0x0038, 0x0FF4, 0x3FD4,
+		0x0018, 0x1000, 0x3FE8,
+		0x0000, 0x1000, 0x0000
+};
+
+//=========================================
+// <num_taps>    = 3
+// <num_phases>  = 64
+// <scale_ratio> = 1.16666 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_3tap_64p_116[99] = {
+		0x0804, 0x07FC, 0x0000,
+		0x07C0, 0x0844, 0x3FFC,
+		0x0780, 0x0888, 0x3FF8,
+		0x0740, 0x08D0, 0x3FF0,
+		0x0700, 0x0914, 0x3FEC,
+		0x06C0, 0x0958, 0x3FE8,
+		0x0684, 0x0998, 0x3FE4,
+		0x0644, 0x09DC, 0x3FE0,
+		0x0604, 0x0A1C, 0x3FE0,
+		0x05C4, 0x0A5C, 0x3FE0,
+		0x0588, 0x0A9C, 0x3FDC,
+		0x0548, 0x0ADC, 0x3FDC,
+		0x050C, 0x0B14, 0x3FE0,
+		0x04CC, 0x0B54, 0x3FE0,
+		0x0490, 0x0B8C, 0x3FE4,
+		0x0458, 0x0BC0, 0x3FE8,
+		0x041C, 0x0BF4, 0x3FF0,
+		0x03E0, 0x0C28, 0x3FF8,
+		0x03A8, 0x0C58, 0x0000,
+		0x0374, 0x0C88, 0x0004,
+		0x0340, 0x0CB0, 0x0010,
+		0x0308, 0x0CD8, 0x0020,
+		0x02D8, 0x0CFC, 0x002C,
+		0x02A0, 0x0D20, 0x0040,
+		0x0274, 0x0D3C, 0x0050,
+		0x0244, 0x0D58, 0x0064,
+		0x0214, 0x0D70, 0x007C,
+		0x01E8, 0x0D84, 0x0094,
+		0x01C0, 0x0D94, 0x00AC,
+		0x0198, 0x0DA0, 0x00C8,
+		0x0170, 0x0DAC, 0x00E4,
+		0x014C, 0x0DB0, 0x0104,
+		0x0128, 0x0DB4, 0x0124
+};
+
+//=========================================
+// <num_taps>    = 3
+// <num_phases>  = 64
+// <scale_ratio> = 1.49999 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_3tap_64p_149[99] = {
+		0x0804, 0x07FC, 0x0000,
+		0x07CC, 0x0834, 0x0000,
+		0x0798, 0x0868, 0x0000,
+		0x0764, 0x089C, 0x0000,
+		0x0730, 0x08CC, 0x0004,
+		0x0700, 0x08FC, 0x0004,
+		0x06CC, 0x092C, 0x0008,
+		0x0698, 0x095C, 0x000C,
+		0x0660, 0x098C, 0x0014,
+		0x062C, 0x09B8, 0x001C,
+		0x05FC, 0x09E4, 0x0020,
+		0x05C4, 0x0A10, 0x002C,
+		0x0590, 0x0A3C, 0x0034,
+		0x055C, 0x0A64, 0x0040,
+		0x0528, 0x0A8C, 0x004C,
+		0x04F8, 0x0AB0, 0x0058,
+		0x04C4, 0x0AD4, 0x0068,
+		0x0490, 0x0AF8, 0x0078,
+		0x0460, 0x0B18, 0x0088,
+		0x0430, 0x0B38, 0x0098,
+		0x0400, 0x0B54, 0x00AC,
+		0x03D0, 0x0B6C, 0x00C4,
+		0x03A0, 0x0B88, 0x00D8,
+		0x0374, 0x0B9C, 0x00F0,
+		0x0348, 0x0BB0, 0x0108,
+		0x0318, 0x0BC4, 0x0124,
+		0x02EC, 0x0BD4, 0x0140,
+		0x02C4, 0x0BE0, 0x015C,
+		0x029C, 0x0BEC, 0x0178,
+		0x0274, 0x0BF4, 0x0198,
+		0x024C, 0x0BFC, 0x01B8,
+		0x0228, 0x0BFC, 0x01DC,
+		0x0200, 0x0C00, 0x0200
+};
+
+//=========================================
+// <num_taps>    = 3
+// <num_phases>  = 64
+// <scale_ratio> = 1.83332 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_3tap_64p_183[99] = {
+		0x0804, 0x07FC, 0x0000,
+		0x07D4, 0x0824, 0x0008,
+		0x07AC, 0x0840, 0x0014,
+		0x0780, 0x0860, 0x0020,
+		0x0754, 0x0880, 0x002C,
+		0x0728, 0x089C, 0x003C,
+		0x0700, 0x08B8, 0x0048,
+		0x06D4, 0x08D4, 0x0058,
+		0x06A8, 0x08F0, 0x0068,
+		0x067C, 0x090C, 0x0078,
+		0x0650, 0x0924, 0x008C,
+		0x0628, 0x093C, 0x009C,
+		0x05FC, 0x0954, 0x00B0,
+		0x05D0, 0x096C, 0x00C4,
+		0x05A8, 0x0980, 0x00D8,
+		0x0578, 0x0998, 0x00F0,
+		0x0550, 0x09AC, 0x0104,
+		0x0528, 0x09BC, 0x011C,
+		0x04FC, 0x09D0, 0x0134,
+		0x04D4, 0x09E0, 0x014C,
+		0x04A8, 0x09F0, 0x0168,
+		0x0480, 0x09FC, 0x0184,
+		0x045C, 0x0A08, 0x019C,
+		0x0434, 0x0A14, 0x01B8,
+		0x0408, 0x0A20, 0x01D8,
+		0x03E0, 0x0A2C, 0x01F4,
+		0x03B8, 0x0A34, 0x0214,
+		0x0394, 0x0A38, 0x0234,
+		0x036C, 0x0A40, 0x0254,
+		0x0348, 0x0A44, 0x0274,
+		0x0324, 0x0A48, 0x0294,
+		0x0300, 0x0A48, 0x02B8,
+		0x02DC, 0x0A48, 0x02DC
+};
+
+//=========================================
+// <num_taps>    = 4
+// <num_phases>  = 64
+// <scale_ratio> = 0.83333 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_4tap_64p_upscale[132] = {
+		0x0000, 0x1000, 0x0000, 0x0000,
+		0x3FDC, 0x0FFC, 0x0028, 0x0000,
+		0x3FB4, 0x0FF8, 0x0054, 0x0000,
+		0x3F94, 0x0FE8, 0x0084, 0x0000,
+		0x3F74, 0x0FDC, 0x00B4, 0x3FFC,
+		0x3F58, 0x0FC4, 0x00E8, 0x3FFC,
+		0x3F3C, 0x0FAC, 0x0120, 0x3FF8,
+		0x3F24, 0x0F90, 0x0158, 0x3FF4,
+		0x3F0C, 0x0F70, 0x0194, 0x3FF0,
+		0x3EF8, 0x0F4C, 0x01D0, 0x3FEC,
+		0x3EE8, 0x0F20, 0x0210, 0x3FE8,
+		0x3ED8, 0x0EF4, 0x0254, 0x3FE0,
+		0x3ECC, 0x0EC4, 0x0298, 0x3FD8,
+		0x3EC0, 0x0E90, 0x02DC, 0x3FD4,
+		0x3EB8, 0x0E58, 0x0324, 0x3FCC,
+		0x3EB0, 0x0E20, 0x036C, 0x3FC4,
+		0x3EAC, 0x0DE4, 0x03B8, 0x3FB8,
+		0x3EA8, 0x0DA4, 0x0404, 0x3FB0,
+		0x3EA4, 0x0D60, 0x0454, 0x3FA8,
+		0x3EA4, 0x0D1C, 0x04A4, 0x3F9C,
+		0x3EA4, 0x0CD8, 0x04F4, 0x3F90,
+		0x3EA8, 0x0C88, 0x0548, 0x3F88,
+		0x3EAC, 0x0C3C, 0x059C, 0x3F7C,
+		0x3EB0, 0x0BF0, 0x05F0, 0x3F70,
+		0x3EB8, 0x0BA0, 0x0644, 0x3F64,
+		0x3EBC, 0x0B54, 0x0698, 0x3F58,
+		0x3EC4, 0x0B00, 0x06F0, 0x3F4C,
+		0x3ECC, 0x0AAC, 0x0748, 0x3F40,
+		0x3ED8, 0x0A54, 0x07A0, 0x3F34,
+		0x3EE0, 0x0A04, 0x07F8, 0x3F24,
+		0x3EEC, 0x09AC, 0x0850, 0x3F18,
+		0x3EF8, 0x0954, 0x08A8, 0x3F0C,
+		0x3F00, 0x08FC, 0x0900, 0x3F04
+};
+
+//=========================================
+// <num_taps>    = 4
+// <num_phases>  = 64
+// <scale_ratio> = 1.16666 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_4tap_64p_116[132] = {
+		0x01A8, 0x0CB4, 0x01A4, 0x0000,
+		0x017C, 0x0CB8, 0x01D0, 0x3FFC,
+		0x0158, 0x0CB8, 0x01F8, 0x3FF8,
+		0x0130, 0x0CB4, 0x0228, 0x3FF4,
+		0x0110, 0x0CB0, 0x0254, 0x3FEC,
+		0x00EC, 0x0CA8, 0x0284, 0x3FE8,
+		0x00CC, 0x0C9C, 0x02B4, 0x3FE4,
+		0x00AC, 0x0C90, 0x02E8, 0x3FDC,
+		0x0090, 0x0C80, 0x031C, 0x3FD4,
+		0x0070, 0x0C70, 0x0350, 0x3FD0,
+		0x0058, 0x0C5C, 0x0384, 0x3FC8,
+		0x003C, 0x0C48, 0x03BC, 0x3FC0,
+		0x0024, 0x0C2C, 0x03F4, 0x3FBC,
+		0x0010, 0x0C10, 0x042C, 0x3FB4,
+		0x3FFC, 0x0BF4, 0x0464, 0x3FAC,
+		0x3FE8, 0x0BD4, 0x04A0, 0x3FA4,
+		0x3FD8, 0x0BAC, 0x04DC, 0x3FA0,
+		0x3FC4, 0x0B8C, 0x0518, 0x3F98,
+		0x3FB4, 0x0B68, 0x0554, 0x3F90,
+		0x3FA8, 0x0B40, 0x0590, 0x3F88,
+		0x3F9C, 0x0B14, 0x05CC, 0x3F84,
+		0x3F90, 0x0AEC, 0x0608, 0x3F7C,
+		0x3F84, 0x0ABC, 0x0648, 0x3F78,
+		0x3F7C, 0x0A90, 0x0684, 0x3F70,
+		0x3F70, 0x0A60, 0x06C4, 0x3F6C,
+		0x3F6C, 0x0A2C, 0x0700, 0x3F68,
+		0x3F64, 0x09F8, 0x0740, 0x3F64,
+		0x3F60, 0x09C4, 0x077C, 0x3F60,
+		0x3F5C, 0x098C, 0x07BC, 0x3F5C,
+		0x3F58, 0x0958, 0x07F8, 0x3F58,
+		0x3F58, 0x091C, 0x0834, 0x3F58,
+		0x3F54, 0x08E4, 0x0870, 0x3F58,
+		0x3F54, 0x08AC, 0x08AC, 0x3F54
+};
+
+//=========================================
+// <num_taps>    = 4
+// <num_phases>  = 64
+// <scale_ratio> = 1.49999 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_4tap_64p_149[132] = {
+		0x02B8, 0x0A90, 0x02B8, 0x0000,
+		0x0294, 0x0A94, 0x02DC, 0x3FFC,
+		0x0274, 0x0A94, 0x0300, 0x3FF8,
+		0x0250, 0x0A94, 0x0328, 0x3FF4,
+		0x0230, 0x0A90, 0x0350, 0x3FF0,
+		0x0214, 0x0A8C, 0x0374, 0x3FEC,
+		0x01F0, 0x0A88, 0x03A0, 0x3FE8,
+		0x01D4, 0x0A80, 0x03C8, 0x3FE4,
+		0x01B8, 0x0A78, 0x03F0, 0x3FE0,
+		0x0198, 0x0A70, 0x041C, 0x3FDC,
+		0x0180, 0x0A64, 0x0444, 0x3FD8,
+		0x0164, 0x0A54, 0x0470, 0x3FD8,
+		0x0148, 0x0A48, 0x049C, 0x3FD4,
+		0x0130, 0x0A38, 0x04C8, 0x3FD0,
+		0x0118, 0x0A24, 0x04F4, 0x3FD0,
+		0x0100, 0x0A14, 0x0520, 0x3FCC,
+		0x00E8, 0x0A00, 0x054C, 0x3FCC,
+		0x00D4, 0x09E8, 0x057C, 0x3FC8,
+		0x00C0, 0x09D0, 0x05A8, 0x3FC8,
+		0x00AC, 0x09B8, 0x05D4, 0x3FC8,
+		0x0098, 0x09A0, 0x0600, 0x3FC8,
+		0x0084, 0x0984, 0x0630, 0x3FC8,
+		0x0074, 0x0964, 0x065C, 0x3FCC,
+		0x0064, 0x0948, 0x0688, 0x3FCC,
+		0x0054, 0x0928, 0x06B4, 0x3FD0,
+		0x0044, 0x0908, 0x06E0, 0x3FD4,
+		0x0038, 0x08E8, 0x070C, 0x3FD4,
+		0x002C, 0x08C4, 0x0738, 0x3FD8,
+		0x001C, 0x08A4, 0x0760, 0x3FE0,
+		0x0014, 0x087C, 0x078C, 0x3FE4,
+		0x0008, 0x0858, 0x07B4, 0x3FEC,
+		0x0000, 0x0830, 0x07DC, 0x3FF4,
+		0x3FFC, 0x0804, 0x0804, 0x3FFC
+};
+
+//=========================================
+// <num_taps>    = 4
+// <num_phases>  = 64
+// <scale_ratio> = 1.83332 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_4tap_64p_183[132] = {
+		0x03B0, 0x08A0, 0x03B0, 0x0000,
+		0x0394, 0x08A0, 0x03CC, 0x0000,
+		0x037C, 0x089C, 0x03E8, 0x0000,
+		0x0360, 0x089C, 0x0400, 0x0004,
+		0x0348, 0x0898, 0x041C, 0x0004,
+		0x032C, 0x0894, 0x0438, 0x0008,
+		0x0310, 0x0890, 0x0454, 0x000C,
+		0x02F8, 0x0888, 0x0474, 0x000C,
+		0x02DC, 0x0884, 0x0490, 0x0010,
+		0x02C4, 0x087C, 0x04AC, 0x0014,
+		0x02AC, 0x0874, 0x04C8, 0x0018,
+		0x0290, 0x086C, 0x04E4, 0x0020,
+		0x0278, 0x0864, 0x0500, 0x0024,
+		0x0264, 0x0858, 0x051C, 0x0028,
+		0x024C, 0x084C, 0x0538, 0x0030,
+		0x0234, 0x0844, 0x0554, 0x0034,
+		0x021C, 0x0838, 0x0570, 0x003C,
+		0x0208, 0x0828, 0x058C, 0x0044,
+		0x01F0, 0x081C, 0x05A8, 0x004C,
+		0x01DC, 0x080C, 0x05C4, 0x0054,
+		0x01C8, 0x07FC, 0x05E0, 0x005C,
+		0x01B4, 0x07EC, 0x05FC, 0x0064,
+		0x019C, 0x07DC, 0x0618, 0x0070,
+		0x018C, 0x07CC, 0x0630, 0x0078,
+		0x0178, 0x07B8, 0x064C, 0x0084,
+		0x0164, 0x07A8, 0x0664, 0x0090,
+		0x0150, 0x0794, 0x0680, 0x009C,
+		0x0140, 0x0780, 0x0698, 0x00A8,
+		0x0130, 0x076C, 0x06B0, 0x00B4,
+		0x0120, 0x0758, 0x06C8, 0x00C0,
+		0x0110, 0x0740, 0x06E0, 0x00D0,
+		0x0100, 0x072C, 0x06F8, 0x00DC,
+		0x00F0, 0x0714, 0x0710, 0x00EC
+};
+
+//=========================================
+// <num_taps>    = 5
+// <num_phases>  = 64
+// <scale_ratio> = 0.83333 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_5tap_64p_upscale[165] = {
+		0x3E40, 0x09C0, 0x09C0, 0x3E40, 0x0000,
+		0x3E50, 0x0964, 0x0A18, 0x3E34, 0x0000,
+		0x3E5C, 0x0908, 0x0A6C, 0x3E2C, 0x0004,
+		0x3E6C, 0x08AC, 0x0AC0, 0x3E20, 0x0008,
+		0x3E78, 0x0850, 0x0B14, 0x3E18, 0x000C,
+		0x3E88, 0x07F4, 0x0B60, 0x3E14, 0x0010,
+		0x3E98, 0x0798, 0x0BB0, 0x3E0C, 0x0014,
+		0x3EA8, 0x073C, 0x0C00, 0x3E08, 0x0014,
+		0x3EB8, 0x06E4, 0x0C48, 0x3E04, 0x0018,
+		0x3ECC, 0x0684, 0x0C90, 0x3E04, 0x001C,
+		0x3EDC, 0x062C, 0x0CD4, 0x3E04, 0x0020,
+		0x3EEC, 0x05D4, 0x0D1C, 0x3E04, 0x0020,
+		0x3EFC, 0x057C, 0x0D5C, 0x3E08, 0x0024,
+		0x3F0C, 0x0524, 0x0D98, 0x3E10, 0x0028,
+		0x3F20, 0x04CC, 0x0DD8, 0x3E14, 0x0028,
+		0x3F30, 0x0478, 0x0E14, 0x3E1C, 0x0028,
+		0x3F40, 0x0424, 0x0E48, 0x3E28, 0x002C,
+		0x3F50, 0x03D4, 0x0E7C, 0x3E34, 0x002C,
+		0x3F60, 0x0384, 0x0EAC, 0x3E44, 0x002C,
+		0x3F6C, 0x0338, 0x0EDC, 0x3E54, 0x002C,
+		0x3F7C, 0x02E8, 0x0F08, 0x3E68, 0x002C,
+		0x3F8C, 0x02A0, 0x0F2C, 0x3E7C, 0x002C,
+		0x3F98, 0x0258, 0x0F50, 0x3E94, 0x002C,
+		0x3FA4, 0x0210, 0x0F74, 0x3EB0, 0x0028,
+		0x3FB0, 0x01CC, 0x0F90, 0x3ECC, 0x0028,
+		0x3FC0, 0x018C, 0x0FA8, 0x3EE8, 0x0024,
+		0x3FC8, 0x014C, 0x0FC0, 0x3F0C, 0x0020,
+		0x3FD4, 0x0110, 0x0FD4, 0x3F2C, 0x001C,
+		0x3FE0, 0x00D4, 0x0FE0, 0x3F54, 0x0018,
+		0x3FE8, 0x009C, 0x0FF0, 0x3F7C, 0x0010,
+		0x3FF0, 0x0064, 0x0FFC, 0x3FA4, 0x000C,
+		0x3FFC, 0x0030, 0x0FFC, 0x3FD4, 0x0004,
+		0x0000, 0x0000, 0x1000, 0x0000, 0x0000
+};
+
+//=========================================
+// <num_taps>    = 5
+// <num_phases>  = 64
+// <scale_ratio> = 1.16666 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_5tap_64p_116[165] = {
+		0x3EDC, 0x0924, 0x0924, 0x3EDC, 0x0000,
+		0x3ED8, 0x08EC, 0x095C, 0x3EE0, 0x0000,
+		0x3ED4, 0x08B0, 0x0994, 0x3EE8, 0x0000,
+		0x3ED0, 0x0878, 0x09C8, 0x3EF0, 0x0000,
+		0x3ED0, 0x083C, 0x09FC, 0x3EF8, 0x0000,
+		0x3ED0, 0x0800, 0x0A2C, 0x3F04, 0x0000,
+		0x3ED0, 0x07C4, 0x0A5C, 0x3F10, 0x0000,
+		0x3ED0, 0x0788, 0x0A8C, 0x3F1C, 0x0000,
+		0x3ED0, 0x074C, 0x0AC0, 0x3F28, 0x3FFC,
+		0x3ED4, 0x0710, 0x0AE8, 0x3F38, 0x3FFC,
+		0x3ED8, 0x06D0, 0x0B18, 0x3F48, 0x3FF8,
+		0x3EDC, 0x0694, 0x0B3C, 0x3F5C, 0x3FF8,
+		0x3EE0, 0x0658, 0x0B68, 0x3F6C, 0x3FF4,
+		0x3EE4, 0x061C, 0x0B90, 0x3F80, 0x3FF0,
+		0x3EEC, 0x05DC, 0x0BB4, 0x3F98, 0x3FEC,
+		0x3EF0, 0x05A0, 0x0BD8, 0x3FB0, 0x3FE8,
+		0x3EF8, 0x0564, 0x0BF8, 0x3FC8, 0x3FE4,
+		0x3EFC, 0x0528, 0x0C1C, 0x3FE0, 0x3FE0,
+		0x3F04, 0x04EC, 0x0C38, 0x3FFC, 0x3FDC,
+		0x3F0C, 0x04B4, 0x0C54, 0x0014, 0x3FD8,
+		0x3F14, 0x047C, 0x0C70, 0x0030, 0x3FD0,
+		0x3F1C, 0x0440, 0x0C88, 0x0050, 0x3FCC,
+		0x3F24, 0x0408, 0x0CA0, 0x0070, 0x3FC4,
+		0x3F2C, 0x03D0, 0x0CB0, 0x0094, 0x3FC0,
+		0x3F34, 0x0398, 0x0CC4, 0x00B8, 0x3FB8,
+		0x3F3C, 0x0364, 0x0CD4, 0x00DC, 0x3FB0,
+		0x3F48, 0x032C, 0x0CE0, 0x0100, 0x3FAC,
+		0x3F50, 0x02F8, 0x0CEC, 0x0128, 0x3FA4,
+		0x3F58, 0x02C4, 0x0CF8, 0x0150, 0x3F9C,
+		0x3F60, 0x0290, 0x0D00, 0x017C, 0x3F94,
+		0x3F68, 0x0260, 0x0D04, 0x01A8, 0x3F8C,
+		0x3F74, 0x0230, 0x0D04, 0x01D4, 0x3F84,
+		0x3F7C, 0x0200, 0x0D08, 0x0200, 0x3F7C
+};
+
+//=========================================
+// <num_taps>    = 5
+// <num_phases>  = 64
+// <scale_ratio> = 1.49999 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_5tap_64p_149[165] = {
+		0x3FF4, 0x080C, 0x080C, 0x3FF4, 0x0000,
+		0x3FE8, 0x07E8, 0x0830, 0x0000, 0x0000,
+		0x3FDC, 0x07C8, 0x0850, 0x0010, 0x3FFC,
+		0x3FD0, 0x07A4, 0x0878, 0x001C, 0x3FF8,
+		0x3FC4, 0x0780, 0x0898, 0x0030, 0x3FF4,
+		0x3FB8, 0x075C, 0x08B8, 0x0040, 0x3FF4,
+		0x3FB0, 0x0738, 0x08D8, 0x0050, 0x3FF0,
+		0x3FA8, 0x0710, 0x08F8, 0x0064, 0x3FEC,
+		0x3FA0, 0x06EC, 0x0914, 0x0078, 0x3FE8,
+		0x3F98, 0x06C4, 0x0934, 0x008C, 0x3FE4,
+		0x3F90, 0x06A0, 0x094C, 0x00A4, 0x3FE0,
+		0x3F8C, 0x0678, 0x0968, 0x00B8, 0x3FDC,
+		0x3F84, 0x0650, 0x0984, 0x00D0, 0x3FD8,
+		0x3F80, 0x0628, 0x099C, 0x00E8, 0x3FD4,
+		0x3F7C, 0x0600, 0x09B8, 0x0100, 0x3FCC,
+		0x3F78, 0x05D8, 0x09D0, 0x0118, 0x3FC8,
+		0x3F74, 0x05B0, 0x09E4, 0x0134, 0x3FC4,
+		0x3F70, 0x0588, 0x09F8, 0x0150, 0x3FC0,
+		0x3F70, 0x0560, 0x0A08, 0x016C, 0x3FBC,
+		0x3F6C, 0x0538, 0x0A20, 0x0188, 0x3FB4,
+		0x3F6C, 0x0510, 0x0A30, 0x01A4, 0x3FB0,
+		0x3F6C, 0x04E8, 0x0A3C, 0x01C4, 0x3FAC,
+		0x3F6C, 0x04C0, 0x0A48, 0x01E4, 0x3FA8,
+		0x3F6C, 0x0498, 0x0A58, 0x0200, 0x3FA4,
+		0x3F6C, 0x0470, 0x0A60, 0x0224, 0x3FA0,
+		0x3F6C, 0x0448, 0x0A70, 0x0244, 0x3F98,
+		0x3F70, 0x0420, 0x0A78, 0x0264, 0x3F94,
+		0x3F70, 0x03F8, 0x0A80, 0x0288, 0x3F90,
+		0x3F74, 0x03D4, 0x0A84, 0x02A8, 0x3F8C,
+		0x3F74, 0x03AC, 0x0A8C, 0x02CC, 0x3F88,
+		0x3F78, 0x0384, 0x0A90, 0x02F0, 0x3F84,
+		0x3F7C, 0x0360, 0x0A90, 0x0314, 0x3F80,
+		0x3F7C, 0x033C, 0x0A90, 0x033C, 0x3F7C
+};
+
+//=========================================
+// <num_taps>    = 5
+// <num_phases>  = 64
+// <scale_ratio> = 1.83332 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_5tap_64p_183[165] = {
+		0x0168, 0x069C, 0x0698, 0x0164, 0x0000,
+		0x0154, 0x068C, 0x06AC, 0x0174, 0x0000,
+		0x0144, 0x0674, 0x06C0, 0x0188, 0x0000,
+		0x0138, 0x0664, 0x06D0, 0x0198, 0x3FFC,
+		0x0128, 0x0654, 0x06E0, 0x01A8, 0x3FFC,
+		0x0118, 0x0640, 0x06F0, 0x01BC, 0x3FFC,
+		0x010C, 0x0630, 0x0700, 0x01CC, 0x3FF8,
+		0x00FC, 0x061C, 0x0710, 0x01E0, 0x3FF8,
+		0x00F0, 0x060C, 0x071C, 0x01F0, 0x3FF8,
+		0x00E4, 0x05F4, 0x072C, 0x0204, 0x3FF8,
+		0x00D8, 0x05E4, 0x0738, 0x0218, 0x3FF4,
+		0x00CC, 0x05D0, 0x0744, 0x022C, 0x3FF4,
+		0x00C0, 0x05B8, 0x0754, 0x0240, 0x3FF4,
+		0x00B4, 0x05A4, 0x0760, 0x0254, 0x3FF4,
+		0x00A8, 0x0590, 0x076C, 0x0268, 0x3FF4,
+		0x009C, 0x057C, 0x0778, 0x027C, 0x3FF4,
+		0x0094, 0x0564, 0x0780, 0x0294, 0x3FF4,
+		0x0088, 0x0550, 0x0788, 0x02A8, 0x3FF8,
+		0x0080, 0x0538, 0x0794, 0x02BC, 0x3FF8,
+		0x0074, 0x0524, 0x079C, 0x02D4, 0x3FF8,
+		0x006C, 0x0510, 0x07A4, 0x02E8, 0x3FF8,
+		0x0064, 0x04F4, 0x07AC, 0x0300, 0x3FFC,
+		0x005C, 0x04E4, 0x07B0, 0x0314, 0x3FFC,
+		0x0054, 0x04C8, 0x07B8, 0x032C, 0x0000,
+		0x004C, 0x04B4, 0x07C0, 0x0340, 0x0000,
+		0x0044, 0x04A0, 0x07C4, 0x0358, 0x0000,
+		0x003C, 0x0488, 0x07C8, 0x0370, 0x0004,
+		0x0038, 0x0470, 0x07CC, 0x0384, 0x0008,
+		0x0030, 0x045C, 0x07D0, 0x039C, 0x0008,
+		0x002C, 0x0444, 0x07D0, 0x03B4, 0x000C,
+		0x0024, 0x042C, 0x07D4, 0x03CC, 0x0010,
+		0x0020, 0x0414, 0x07D4, 0x03E0, 0x0018,
+		0x001C, 0x03FC, 0x07D4, 0x03F8, 0x001C
+};
+
+//=========================================
+// <num_taps>    = 6
+// <num_phases>  = 64
+// <scale_ratio> = 0.83333 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_6tap_64p_upscale[198] = {
+		0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000,
+		0x000C, 0x3FD0, 0x0FFC, 0x0034, 0x3FF4, 0x0000,
+		0x0018, 0x3F9C, 0x0FF8, 0x006C, 0x3FE8, 0x0000,
+		0x0024, 0x3F6C, 0x0FF0, 0x00A8, 0x3FD8, 0x0000,
+		0x002C, 0x3F44, 0x0FE4, 0x00E4, 0x3FC8, 0x0000,
+		0x0038, 0x3F18, 0x0FD4, 0x0124, 0x3FB8, 0x0000,
+		0x0040, 0x3EF0, 0x0FC0, 0x0164, 0x3FA8, 0x0004,
+		0x0048, 0x3EC8, 0x0FAC, 0x01A8, 0x3F98, 0x0004,
+		0x0050, 0x3EA8, 0x0F94, 0x01EC, 0x3F84, 0x0004,
+		0x0058, 0x3E84, 0x0F74, 0x0234, 0x3F74, 0x0008,
+		0x0060, 0x3E68, 0x0F54, 0x027C, 0x3F60, 0x0008,
+		0x0064, 0x3E4C, 0x0F30, 0x02C8, 0x3F4C, 0x000C,
+		0x006C, 0x3E30, 0x0F04, 0x0314, 0x3F3C, 0x0010,
+		0x0070, 0x3E18, 0x0EDC, 0x0360, 0x3F28, 0x0014,
+		0x0074, 0x3E04, 0x0EB0, 0x03B0, 0x3F14, 0x0014,
+		0x0078, 0x3DF0, 0x0E80, 0x0400, 0x3F00, 0x0018,
+		0x0078, 0x3DE0, 0x0E4C, 0x0454, 0x3EEC, 0x001C,
+		0x007C, 0x3DD0, 0x0E14, 0x04A8, 0x3ED8, 0x0020,
+		0x007C, 0x3DC4, 0x0DDC, 0x04FC, 0x3EC4, 0x0024,
+		0x007C, 0x3DBC, 0x0DA0, 0x0550, 0x3EB0, 0x0028,
+		0x0080, 0x3DB4, 0x0D5C, 0x05A8, 0x3E9C, 0x002C,
+		0x0080, 0x3DAC, 0x0D1C, 0x0600, 0x3E88, 0x0030,
+		0x007C, 0x3DA8, 0x0CDC, 0x0658, 0x3E74, 0x0034,
+		0x007C, 0x3DA4, 0x0C94, 0x06B0, 0x3E64, 0x0038,
+		0x007C, 0x3DA4, 0x0C48, 0x0708, 0x3E50, 0x0040,
+		0x0078, 0x3DA4, 0x0C00, 0x0760, 0x3E40, 0x0044,
+		0x0078, 0x3DA8, 0x0BB4, 0x07B8, 0x3E2C, 0x0048,
+		0x0074, 0x3DAC, 0x0B68, 0x0810, 0x3E1C, 0x004C,
+		0x0070, 0x3DB4, 0x0B18, 0x0868, 0x3E0C, 0x0050,
+		0x006C, 0x3DBC, 0x0AC4, 0x08C4, 0x3DFC, 0x0054,
+		0x0068, 0x3DC4, 0x0A74, 0x0918, 0x3DF0, 0x0058,
+		0x0068, 0x3DCC, 0x0A20, 0x0970, 0x3DE0, 0x005C,
+		0x0064, 0x3DD4, 0x09C8, 0x09C8, 0x3DD4, 0x0064
+};
+
+//=========================================
+// <num_taps>    = 6
+// <num_phases>  = 64
+// <scale_ratio> = 1.16666 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_6tap_64p_116[198] = {
+		0x3F0C, 0x0240, 0x0D68, 0x0240, 0x3F0C, 0x0000,
+		0x3F18, 0x0210, 0x0D64, 0x0274, 0x3F00, 0x0000,
+		0x3F24, 0x01E0, 0x0D58, 0x02A8, 0x3EF8, 0x0004,
+		0x3F2C, 0x01B0, 0x0D58, 0x02DC, 0x3EEC, 0x0004,
+		0x3F38, 0x0180, 0x0D50, 0x0310, 0x3EE0, 0x0008,
+		0x3F44, 0x0154, 0x0D40, 0x0348, 0x3ED8, 0x0008,
+		0x3F50, 0x0128, 0x0D34, 0x037C, 0x3ECC, 0x000C,
+		0x3F5C, 0x00FC, 0x0D20, 0x03B4, 0x3EC4, 0x0010,
+		0x3F64, 0x00D4, 0x0D14, 0x03EC, 0x3EB8, 0x0010,
+		0x3F70, 0x00AC, 0x0CFC, 0x0424, 0x3EB0, 0x0014,
+		0x3F78, 0x0084, 0x0CE8, 0x0460, 0x3EA8, 0x0014,
+		0x3F84, 0x0060, 0x0CCC, 0x0498, 0x3EA0, 0x0018,
+		0x3F90, 0x003C, 0x0CB4, 0x04D0, 0x3E98, 0x0018,
+		0x3F98, 0x0018, 0x0C9C, 0x050C, 0x3E90, 0x0018,
+		0x3FA0, 0x3FFC, 0x0C78, 0x0548, 0x3E88, 0x001C,
+		0x3FAC, 0x3FDC, 0x0C54, 0x0584, 0x3E84, 0x001C,
+		0x3FB4, 0x3FBC, 0x0C3C, 0x05BC, 0x3E7C, 0x001C,
+		0x3FBC, 0x3FA0, 0x0C14, 0x05F8, 0x3E78, 0x0020,
+		0x3FC4, 0x3F84, 0x0BF0, 0x0634, 0x3E74, 0x0020,
+		0x3FCC, 0x3F68, 0x0BCC, 0x0670, 0x3E70, 0x0020,
+		0x3FD4, 0x3F50, 0x0BA4, 0x06AC, 0x3E6C, 0x0020,
+		0x3FDC, 0x3F38, 0x0B78, 0x06E8, 0x3E6C, 0x0020,
+		0x3FE0, 0x3F24, 0x0B50, 0x0724, 0x3E68, 0x0020,
+		0x3FE8, 0x3F0C, 0x0B24, 0x0760, 0x3E68, 0x0020,
+		0x3FF0, 0x3EFC, 0x0AF4, 0x0798, 0x3E68, 0x0020,
+		0x3FF4, 0x3EE8, 0x0AC8, 0x07D4, 0x3E68, 0x0020,
+		0x3FFC, 0x3ED8, 0x0A94, 0x0810, 0x3E6C, 0x001C,
+		0x0000, 0x3EC8, 0x0A64, 0x0848, 0x3E70, 0x001C,
+		0x0000, 0x3EB8, 0x0A38, 0x0880, 0x3E74, 0x001C,
+		0x0004, 0x3EAC, 0x0A04, 0x08BC, 0x3E78, 0x0018,
+		0x0008, 0x3EA4, 0x09D0, 0x08F4, 0x3E7C, 0x0014,
+		0x000C, 0x3E98, 0x0998, 0x092C, 0x3E84, 0x0014,
+		0x0010, 0x3E90, 0x0964, 0x0960, 0x3E8C, 0x0010
+};
+
+//=========================================
+// <num_taps>    = 6
+// <num_phases>  = 64
+// <scale_ratio> = 1.49999 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_6tap_64p_149[198] = {
+		0x3F14, 0x0394, 0x0AB0, 0x0394, 0x3F14, 0x0000,
+		0x3F18, 0x036C, 0x0AB0, 0x03B8, 0x3F14, 0x0000,
+		0x3F18, 0x0348, 0x0AAC, 0x03E0, 0x3F14, 0x0000,
+		0x3F1C, 0x0320, 0x0AAC, 0x0408, 0x3F10, 0x0000,
+		0x3F20, 0x02FC, 0x0AA8, 0x042C, 0x3F10, 0x0000,
+		0x3F24, 0x02D8, 0x0AA0, 0x0454, 0x3F10, 0x0000,
+		0x3F28, 0x02B4, 0x0A98, 0x047C, 0x3F10, 0x0000,
+		0x3F28, 0x0290, 0x0A90, 0x04A4, 0x3F14, 0x0000,
+		0x3F30, 0x026C, 0x0A84, 0x04CC, 0x3F14, 0x0000,
+		0x3F34, 0x024C, 0x0A7C, 0x04F4, 0x3F14, 0x3FFC,
+		0x3F38, 0x0228, 0x0A70, 0x051C, 0x3F18, 0x3FFC,
+		0x3F3C, 0x0208, 0x0A64, 0x0544, 0x3F1C, 0x3FF8,
+		0x3F40, 0x01E8, 0x0A54, 0x056C, 0x3F20, 0x3FF8,
+		0x3F44, 0x01C8, 0x0A48, 0x0594, 0x3F24, 0x3FF4,
+		0x3F4C, 0x01A8, 0x0A34, 0x05BC, 0x3F28, 0x3FF4,
+		0x3F50, 0x0188, 0x0A28, 0x05E4, 0x3F2C, 0x3FF0,
+		0x3F54, 0x016C, 0x0A10, 0x060C, 0x3F34, 0x3FF0,
+		0x3F5C, 0x014C, 0x09FC, 0x0634, 0x3F3C, 0x3FEC,
+		0x3F60, 0x0130, 0x09EC, 0x065C, 0x3F40, 0x3FE8,
+		0x3F68, 0x0114, 0x09D0, 0x0684, 0x3F48, 0x3FE8,
+		0x3F6C, 0x00F8, 0x09B8, 0x06AC, 0x3F54, 0x3FE4,
+		0x3F74, 0x00E0, 0x09A0, 0x06D0, 0x3F5C, 0x3FE0,
+		0x3F78, 0x00C4, 0x098C, 0x06F8, 0x3F64, 0x3FDC,
+		0x3F7C, 0x00AC, 0x0970, 0x0720, 0x3F70, 0x3FD8,
+		0x3F84, 0x0094, 0x0954, 0x0744, 0x3F7C, 0x3FD4,
+		0x3F88, 0x007C, 0x093C, 0x0768, 0x3F88, 0x3FD0,
+		0x3F90, 0x0064, 0x091C, 0x0790, 0x3F94, 0x3FCC,
+		0x3F94, 0x0050, 0x08FC, 0x07B4, 0x3FA4, 0x3FC8,
+		0x3F98, 0x003C, 0x08E0, 0x07D8, 0x3FB0, 0x3FC4,
+		0x3FA0, 0x0024, 0x08C0, 0x07FC, 0x3FC0, 0x3FC0,
+		0x3FA4, 0x0014, 0x08A4, 0x081C, 0x3FD0, 0x3FB8,
+		0x3FAC, 0x0000, 0x0880, 0x0840, 0x3FE0, 0x3FB4,
+		0x3FB0, 0x3FF0, 0x0860, 0x0860, 0x3FF0, 0x3FB0
+};
+
+//=========================================
+// <num_taps>    = 6
+// <num_phases>  = 64
+// <scale_ratio> = 1.83332 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_6tap_64p_183[198] = {
+		0x002C, 0x0420, 0x076C, 0x041C, 0x002C, 0x0000,
+		0x0028, 0x040C, 0x0768, 0x0430, 0x0034, 0x0000,
+		0x0020, 0x03F8, 0x0768, 0x0448, 0x003C, 0x3FFC,
+		0x0018, 0x03E4, 0x0768, 0x045C, 0x0044, 0x3FFC,
+		0x0014, 0x03D0, 0x0768, 0x0470, 0x004C, 0x3FF8,
+		0x000C, 0x03BC, 0x0764, 0x0484, 0x0058, 0x3FF8,
+		0x0008, 0x03A4, 0x0764, 0x049C, 0x0060, 0x3FF4,
+		0x0004, 0x0390, 0x0760, 0x04B0, 0x0068, 0x3FF4,
+		0x0000, 0x037C, 0x0760, 0x04C4, 0x0070, 0x3FF0,
+		0x3FFC, 0x0364, 0x075C, 0x04D8, 0x007C, 0x3FF0,
+		0x3FF8, 0x0350, 0x0758, 0x04F0, 0x0084, 0x3FEC,
+		0x3FF4, 0x033C, 0x0750, 0x0504, 0x0090, 0x3FEC,
+		0x3FF0, 0x0328, 0x074C, 0x0518, 0x009C, 0x3FE8,
+		0x3FEC, 0x0314, 0x0744, 0x052C, 0x00A8, 0x3FE8,
+		0x3FE8, 0x0304, 0x0740, 0x0540, 0x00B0, 0x3FE4,
+		0x3FE4, 0x02EC, 0x073C, 0x0554, 0x00BC, 0x3FE4,
+		0x3FE0, 0x02DC, 0x0734, 0x0568, 0x00C8, 0x3FE0,
+		0x3FE0, 0x02C4, 0x072C, 0x057C, 0x00D4, 0x3FE0,
+		0x3FDC, 0x02B4, 0x0724, 0x058C, 0x00E4, 0x3FDC,
+		0x3FDC, 0x02A0, 0x0718, 0x05A0, 0x00F0, 0x3FDC,
+		0x3FD8, 0x028C, 0x0714, 0x05B4, 0x00FC, 0x3FD8,
+		0x3FD8, 0x0278, 0x0704, 0x05C8, 0x010C, 0x3FD8,
+		0x3FD4, 0x0264, 0x0700, 0x05D8, 0x0118, 0x3FD8,
+		0x3FD4, 0x0254, 0x06F0, 0x05EC, 0x0128, 0x3FD4,
+		0x3FD0, 0x0244, 0x06E8, 0x05FC, 0x0134, 0x3FD4,
+		0x3FD0, 0x0230, 0x06DC, 0x060C, 0x0144, 0x3FD4,
+		0x3FD0, 0x021C, 0x06D0, 0x0620, 0x0154, 0x3FD0,
+		0x3FD0, 0x0208, 0x06C4, 0x0630, 0x0164, 0x3FD0,
+		0x3FD0, 0x01F8, 0x06B8, 0x0640, 0x0170, 0x3FD0,
+		0x3FCC, 0x01E8, 0x06AC, 0x0650, 0x0180, 0x3FD0,
+		0x3FCC, 0x01D8, 0x069C, 0x0660, 0x0190, 0x3FD0,
+		0x3FCC, 0x01C4, 0x068C, 0x0670, 0x01A4, 0x3FD0,
+		0x3FCC, 0x01B8, 0x0680, 0x067C, 0x01B4, 0x3FCC
+};
+
+//=========================================
+// <num_taps>    = 7
+// <num_phases>  = 64
+// <scale_ratio> = 0.83333 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_7tap_64p_upscale[231] = {
+		0x00B0, 0x3D98, 0x09BC, 0x09B8, 0x3D94, 0x00B0, 0x0000,
+		0x00AC, 0x3DA0, 0x0968, 0x0A10, 0x3D88, 0x00B4, 0x0000,
+		0x00A8, 0x3DAC, 0x0914, 0x0A60, 0x3D80, 0x00B8, 0x0000,
+		0x00A4, 0x3DB8, 0x08C0, 0x0AB4, 0x3D78, 0x00BC, 0x3FFC,
+		0x00A0, 0x3DC8, 0x0868, 0x0B00, 0x3D74, 0x00C0, 0x3FFC,
+		0x0098, 0x3DD8, 0x0818, 0x0B54, 0x3D6C, 0x00C0, 0x3FF8,
+		0x0094, 0x3DE8, 0x07C0, 0x0B9C, 0x3D6C, 0x00C4, 0x3FF8,
+		0x008C, 0x3DFC, 0x0768, 0x0BEC, 0x3D68, 0x00C4, 0x3FF8,
+		0x0088, 0x3E0C, 0x0714, 0x0C38, 0x3D68, 0x00C4, 0x3FF4,
+		0x0080, 0x3E20, 0x06BC, 0x0C80, 0x3D6C, 0x00C4, 0x3FF4,
+		0x0078, 0x3E34, 0x0668, 0x0CC4, 0x3D70, 0x00C4, 0x3FF4,
+		0x0074, 0x3E48, 0x0610, 0x0D08, 0x3D78, 0x00C4, 0x3FF0,
+		0x006C, 0x3E5C, 0x05BC, 0x0D48, 0x3D80, 0x00C4, 0x3FF0,
+		0x0068, 0x3E74, 0x0568, 0x0D84, 0x3D88, 0x00C0, 0x3FF0,
+		0x0060, 0x3E88, 0x0514, 0x0DC8, 0x3D94, 0x00BC, 0x3FEC,
+		0x0058, 0x3E9C, 0x04C0, 0x0E04, 0x3DA4, 0x00B8, 0x3FEC,
+		0x0054, 0x3EB4, 0x046C, 0x0E38, 0x3DB4, 0x00B4, 0x3FEC,
+		0x004C, 0x3ECC, 0x0418, 0x0E6C, 0x3DC8, 0x00B0, 0x3FEC,
+		0x0044, 0x3EE0, 0x03C8, 0x0EA4, 0x3DDC, 0x00A8, 0x3FEC,
+		0x0040, 0x3EF8, 0x0378, 0x0ED0, 0x3DF4, 0x00A0, 0x3FEC,
+		0x0038, 0x3F0C, 0x032C, 0x0EFC, 0x3E10, 0x0098, 0x3FEC,
+		0x0034, 0x3F24, 0x02DC, 0x0F24, 0x3E2C, 0x0090, 0x3FEC,
+		0x002C, 0x3F38, 0x0294, 0x0F4C, 0x3E48, 0x0088, 0x3FEC,
+		0x0028, 0x3F50, 0x0248, 0x0F68, 0x3E6C, 0x007C, 0x3FF0,
+		0x0020, 0x3F64, 0x0200, 0x0F88, 0x3E90, 0x0074, 0x3FF0,
+		0x001C, 0x3F7C, 0x01B8, 0x0FA4, 0x3EB4, 0x0068, 0x3FF0,
+		0x0018, 0x3F90, 0x0174, 0x0FBC, 0x3EDC, 0x0058, 0x3FF4,
+		0x0014, 0x3FA4, 0x0130, 0x0FD0, 0x3F08, 0x004C, 0x3FF4,
+		0x000C, 0x3FB8, 0x00F0, 0x0FE4, 0x3F34, 0x003C, 0x3FF8,
+		0x0008, 0x3FCC, 0x00B0, 0x0FF0, 0x3F64, 0x0030, 0x3FF8,
+		0x0004, 0x3FDC, 0x0070, 0x0FFC, 0x3F98, 0x0020, 0x3FFC,
+		0x0000, 0x3FF0, 0x0038, 0x0FFC, 0x3FCC, 0x0010, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000
+};
+
+//=========================================
+// <num_taps>    = 7
+// <num_phases>  = 64
+// <scale_ratio> = 1.16666 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_7tap_64p_116[231] = {
+		0x0020, 0x3E58, 0x0988, 0x0988, 0x3E58, 0x0020, 0x0000,
+		0x0024, 0x3E4C, 0x0954, 0x09C0, 0x3E64, 0x0018, 0x0000,
+		0x002C, 0x3E44, 0x091C, 0x09F4, 0x3E70, 0x0010, 0x0000,
+		0x0030, 0x3E3C, 0x08E8, 0x0A24, 0x3E80, 0x0008, 0x0000,
+		0x0034, 0x3E34, 0x08AC, 0x0A5C, 0x3E90, 0x0000, 0x0000,
+		0x003C, 0x3E30, 0x0870, 0x0A84, 0x3EA0, 0x3FFC, 0x0004,
+		0x0040, 0x3E28, 0x0838, 0x0AB4, 0x3EB4, 0x3FF4, 0x0004,
+		0x0044, 0x3E24, 0x07FC, 0x0AE4, 0x3EC8, 0x3FEC, 0x0004,
+		0x0048, 0x3E24, 0x07C4, 0x0B08, 0x3EDC, 0x3FE4, 0x0008,
+		0x0048, 0x3E20, 0x0788, 0x0B3C, 0x3EF4, 0x3FD8, 0x0008,
+		0x004C, 0x3E20, 0x074C, 0x0B60, 0x3F0C, 0x3FD0, 0x000C,
+		0x0050, 0x3E20, 0x0710, 0x0B8C, 0x3F24, 0x3FC4, 0x000C,
+		0x0050, 0x3E20, 0x06D4, 0x0BB0, 0x3F40, 0x3FBC, 0x0010,
+		0x0054, 0x3E24, 0x0698, 0x0BD4, 0x3F5C, 0x3FB0, 0x0010,
+		0x0054, 0x3E24, 0x065C, 0x0BFC, 0x3F78, 0x3FA4, 0x0014,
+		0x0054, 0x3E28, 0x0624, 0x0C1C, 0x3F98, 0x3F98, 0x0014,
+		0x0058, 0x3E2C, 0x05E4, 0x0C3C, 0x3FB8, 0x3F8C, 0x0018,
+		0x0058, 0x3E34, 0x05A8, 0x0C58, 0x3FD8, 0x3F80, 0x001C,
+		0x0058, 0x3E38, 0x0570, 0x0C78, 0x3FF8, 0x3F74, 0x001C,
+		0x0058, 0x3E40, 0x0534, 0x0C94, 0x0018, 0x3F68, 0x0020,
+		0x0058, 0x3E48, 0x04F4, 0x0CAC, 0x0040, 0x3F5C, 0x0024,
+		0x0058, 0x3E50, 0x04BC, 0x0CC4, 0x0064, 0x3F50, 0x0024,
+		0x0054, 0x3E58, 0x0484, 0x0CD8, 0x008C, 0x3F44, 0x0028,
+		0x0054, 0x3E60, 0x0448, 0x0CEC, 0x00B4, 0x3F38, 0x002C,
+		0x0054, 0x3E68, 0x0410, 0x0CFC, 0x00E0, 0x3F28, 0x0030,
+		0x0054, 0x3E74, 0x03D4, 0x0D0C, 0x010C, 0x3F1C, 0x0030,
+		0x0050, 0x3E7C, 0x03A0, 0x0D18, 0x0138, 0x3F10, 0x0034,
+		0x0050, 0x3E88, 0x0364, 0x0D24, 0x0164, 0x3F04, 0x0038,
+		0x004C, 0x3E94, 0x0330, 0x0D30, 0x0194, 0x3EF4, 0x0038,
+		0x004C, 0x3EA0, 0x02F8, 0x0D34, 0x01C4, 0x3EE8, 0x003C,
+		0x0048, 0x3EAC, 0x02C0, 0x0D3C, 0x01F4, 0x3EDC, 0x0040,
+		0x0048, 0x3EB8, 0x0290, 0x0D3C, 0x0224, 0x3ED0, 0x0040,
+		0x0044, 0x3EC4, 0x0258, 0x0D40, 0x0258, 0x3EC4, 0x0044
+};
+
+//=========================================
+// <num_taps>    = 7
+// <num_phases>  = 64
+// <scale_ratio> = 1.49999 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_7tap_64p_149[231] = {
+		0x3F68, 0x3FEC, 0x08A8, 0x08AC, 0x3FF0, 0x3F68, 0x0000,
+		0x3F70, 0x3FDC, 0x0888, 0x08CC, 0x0000, 0x3F60, 0x0000,
+		0x3F74, 0x3FC8, 0x0868, 0x08F0, 0x0014, 0x3F58, 0x0000,
+		0x3F7C, 0x3FB4, 0x0844, 0x0908, 0x002C, 0x3F54, 0x0004,
+		0x3F84, 0x3FA4, 0x0820, 0x0924, 0x0044, 0x3F4C, 0x0004,
+		0x3F88, 0x3F90, 0x0800, 0x0944, 0x005C, 0x3F44, 0x0004,
+		0x3F90, 0x3F80, 0x07D8, 0x095C, 0x0074, 0x3F40, 0x0008,
+		0x3F98, 0x3F70, 0x07B0, 0x097C, 0x008C, 0x3F38, 0x0008,
+		0x3F9C, 0x3F60, 0x0790, 0x0994, 0x00A8, 0x3F30, 0x0008,
+		0x3FA4, 0x3F54, 0x0764, 0x09B0, 0x00C4, 0x3F28, 0x0008,
+		0x3FA8, 0x3F48, 0x0740, 0x09C4, 0x00DC, 0x3F24, 0x000C,
+		0x3FB0, 0x3F38, 0x0718, 0x09DC, 0x00FC, 0x3F1C, 0x000C,
+		0x3FB4, 0x3F2C, 0x06F0, 0x09F4, 0x0118, 0x3F18, 0x000C,
+		0x3FBC, 0x3F24, 0x06C8, 0x0A08, 0x0134, 0x3F10, 0x000C,
+		0x3FC0, 0x3F18, 0x06A0, 0x0A1C, 0x0154, 0x3F08, 0x0010,
+		0x3FC8, 0x3F10, 0x0678, 0x0A2C, 0x0170, 0x3F04, 0x0010,
+		0x3FCC, 0x3F04, 0x0650, 0x0A40, 0x0190, 0x3F00, 0x0010,
+		0x3FD0, 0x3EFC, 0x0628, 0x0A54, 0x01B0, 0x3EF8, 0x0010,
+		0x3FD4, 0x3EF4, 0x0600, 0x0A64, 0x01D0, 0x3EF4, 0x0010,
+		0x3FDC, 0x3EEC, 0x05D8, 0x0A6C, 0x01F4, 0x3EF0, 0x0010,
+		0x3FE0, 0x3EE8, 0x05B0, 0x0A7C, 0x0214, 0x3EE8, 0x0010,
+		0x3FE4, 0x3EE0, 0x0588, 0x0A88, 0x0238, 0x3EE4, 0x0010,
+		0x3FE8, 0x3EDC, 0x055C, 0x0A98, 0x0258, 0x3EE0, 0x0010,
+		0x3FEC, 0x3ED8, 0x0534, 0x0AA0, 0x027C, 0x3EDC, 0x0010,
+		0x3FF0, 0x3ED4, 0x050C, 0x0AAC, 0x02A0, 0x3ED8, 0x000C,
+		0x3FF4, 0x3ED0, 0x04E4, 0x0AB4, 0x02C4, 0x3ED4, 0x000C,
+		0x3FF4, 0x3ECC, 0x04C0, 0x0ABC, 0x02E8, 0x3ED0, 0x000C,
+		0x3FF8, 0x3ECC, 0x0494, 0x0AC0, 0x030C, 0x3ED0, 0x000C,
+		0x3FFC, 0x3EC8, 0x046C, 0x0AC8, 0x0334, 0x3ECC, 0x0008,
+		0x0000, 0x3EC8, 0x0444, 0x0AC8, 0x0358, 0x3ECC, 0x0008,
+		0x0000, 0x3EC8, 0x041C, 0x0ACC, 0x0380, 0x3EC8, 0x0008,
+		0x0000, 0x3EC8, 0x03F4, 0x0AD0, 0x03A8, 0x3EC8, 0x0004,
+		0x0004, 0x3EC8, 0x03CC, 0x0AD0, 0x03CC, 0x3EC8, 0x0004
+};
+
+//=========================================
+// <num_taps>    = 7
+// <num_phases>  = 64
+// <scale_ratio> = 1.83332 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_7tap_64p_183[231] = {
+		0x3FA4, 0x01E8, 0x0674, 0x0674, 0x01E8, 0x3FA4, 0x0000,
+		0x3FA4, 0x01D4, 0x0668, 0x0684, 0x01F8, 0x3FA4, 0x0000,
+		0x3FA4, 0x01C4, 0x0658, 0x0690, 0x0208, 0x3FA8, 0x0000,
+		0x3FA0, 0x01B4, 0x064C, 0x06A0, 0x021C, 0x3FA8, 0x3FFC,
+		0x3FA0, 0x01A4, 0x063C, 0x06AC, 0x022C, 0x3FAC, 0x3FFC,
+		0x3FA0, 0x0194, 0x0630, 0x06B4, 0x0240, 0x3FAC, 0x3FFC,
+		0x3FA0, 0x0184, 0x0620, 0x06C4, 0x0250, 0x3FB0, 0x3FF8,
+		0x3FA0, 0x0174, 0x0614, 0x06CC, 0x0264, 0x3FB0, 0x3FF8,
+		0x3FA0, 0x0164, 0x0604, 0x06D8, 0x0278, 0x3FB4, 0x3FF4,
+		0x3FA0, 0x0154, 0x05F4, 0x06E4, 0x0288, 0x3FB8, 0x3FF4,
+		0x3FA0, 0x0148, 0x05E4, 0x06EC, 0x029C, 0x3FBC, 0x3FF0,
+		0x3FA0, 0x0138, 0x05D4, 0x06F4, 0x02B0, 0x3FC0, 0x3FF0,
+		0x3FA0, 0x0128, 0x05C4, 0x0704, 0x02C4, 0x3FC0, 0x3FEC,
+		0x3FA0, 0x011C, 0x05B4, 0x0708, 0x02D8, 0x3FC4, 0x3FEC,
+		0x3FA4, 0x010C, 0x05A4, 0x0714, 0x02E8, 0x3FC8, 0x3FE8,
+		0x3FA4, 0x0100, 0x0590, 0x0718, 0x02FC, 0x3FD0, 0x3FE8,
+		0x3FA4, 0x00F0, 0x0580, 0x0724, 0x0310, 0x3FD4, 0x3FE4,
+		0x3FA4, 0x00E4, 0x056C, 0x072C, 0x0324, 0x3FD8, 0x3FE4,
+		0x3FA8, 0x00D8, 0x055C, 0x0730, 0x0338, 0x3FDC, 0x3FE0,
+		0x3FA8, 0x00CC, 0x0548, 0x0738, 0x034C, 0x3FE4, 0x3FDC,
+		0x3FA8, 0x00BC, 0x0538, 0x0740, 0x0360, 0x3FE8, 0x3FDC,
+		0x3FAC, 0x00B0, 0x0528, 0x0744, 0x0374, 0x3FEC, 0x3FD8,
+		0x3FAC, 0x00A4, 0x0514, 0x0748, 0x0388, 0x3FF4, 0x3FD8,
+		0x3FB0, 0x0098, 0x0500, 0x074C, 0x039C, 0x3FFC, 0x3FD4,
+		0x3FB0, 0x0090, 0x04EC, 0x0750, 0x03B0, 0x0000, 0x3FD4,
+		0x3FB0, 0x0084, 0x04DC, 0x0758, 0x03C4, 0x0004, 0x3FD0,
+		0x3FB4, 0x0078, 0x04CC, 0x0758, 0x03D8, 0x000C, 0x3FCC,
+		0x3FB4, 0x006C, 0x04B8, 0x075C, 0x03EC, 0x0014, 0x3FCC,
+		0x3FB8, 0x0064, 0x04A0, 0x0760, 0x0400, 0x001C, 0x3FC8,
+		0x3FB8, 0x0058, 0x0490, 0x0760, 0x0414, 0x0024, 0x3FC8,
+		0x3FBC, 0x0050, 0x047C, 0x0760, 0x0428, 0x002C, 0x3FC4,
+		0x3FBC, 0x0048, 0x0464, 0x0764, 0x043C, 0x0034, 0x3FC4,
+		0x3FC0, 0x003C, 0x0454, 0x0764, 0x0450, 0x003C, 0x3FC0
+};
+
+//=========================================
+// <num_taps>    = 8
+// <num_phases>  = 64
+// <scale_ratio> = 0.83333 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_8tap_64p_upscale[264] = {
+		0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x3FFC, 0x0014, 0x3FC8, 0x1000, 0x0038, 0x3FEC, 0x0004, 0x0000,
+		0x3FF4, 0x0024, 0x3F94, 0x0FFC, 0x0074, 0x3FD8, 0x000C, 0x0000,
+		0x3FF0, 0x0038, 0x3F60, 0x0FEC, 0x00B4, 0x3FC4, 0x0014, 0x0000,
+		0x3FEC, 0x004C, 0x3F2C, 0x0FE4, 0x00F4, 0x3FAC, 0x0018, 0x0000,
+		0x3FE4, 0x005C, 0x3F00, 0x0FD4, 0x0138, 0x3F94, 0x0020, 0x0000,
+		0x3FE0, 0x006C, 0x3ED0, 0x0FC4, 0x017C, 0x3F7C, 0x0028, 0x0000,
+		0x3FDC, 0x007C, 0x3EA8, 0x0FA4, 0x01C4, 0x3F68, 0x0030, 0x0000,
+		0x3FD8, 0x0088, 0x3E80, 0x0F90, 0x020C, 0x3F50, 0x0038, 0x3FFC,
+		0x3FD4, 0x0098, 0x3E58, 0x0F70, 0x0258, 0x3F38, 0x0040, 0x3FFC,
+		0x3FD0, 0x00A4, 0x3E34, 0x0F54, 0x02A0, 0x3F1C, 0x004C, 0x3FFC,
+		0x3FD0, 0x00B0, 0x3E14, 0x0F28, 0x02F0, 0x3F04, 0x0054, 0x3FFC,
+		0x3FCC, 0x00BC, 0x3DF4, 0x0F08, 0x033C, 0x3EEC, 0x005C, 0x3FF8,
+		0x3FC8, 0x00C8, 0x3DD8, 0x0EDC, 0x038C, 0x3ED4, 0x0064, 0x3FF8,
+		0x3FC8, 0x00D0, 0x3DC0, 0x0EAC, 0x03E0, 0x3EBC, 0x006C, 0x3FF4,
+		0x3FC4, 0x00D8, 0x3DA8, 0x0E7C, 0x0430, 0x3EA4, 0x0078, 0x3FF4,
+		0x3FC4, 0x00E0, 0x3D94, 0x0E48, 0x0484, 0x3E8C, 0x0080, 0x3FF0,
+		0x3FC4, 0x00E8, 0x3D80, 0x0E10, 0x04D8, 0x3E74, 0x0088, 0x3FF0,
+		0x3FC4, 0x00F0, 0x3D70, 0x0DD8, 0x052C, 0x3E5C, 0x0090, 0x3FEC,
+		0x3FC0, 0x00F4, 0x3D60, 0x0DA0, 0x0584, 0x3E44, 0x0098, 0x3FEC,
+		0x3FC0, 0x00F8, 0x3D54, 0x0D68, 0x05D8, 0x3E2C, 0x00A0, 0x3FE8,
+		0x3FC0, 0x00FC, 0x3D48, 0x0D20, 0x0630, 0x3E18, 0x00AC, 0x3FE8,
+		0x3FC0, 0x0100, 0x3D40, 0x0CE0, 0x0688, 0x3E00, 0x00B4, 0x3FE4,
+		0x3FC4, 0x0100, 0x3D3C, 0x0C98, 0x06DC, 0x3DEC, 0x00BC, 0x3FE4,
+		0x3FC4, 0x0100, 0x3D38, 0x0C58, 0x0734, 0x3DD8, 0x00C0, 0x3FE0,
+		0x3FC4, 0x0104, 0x3D38, 0x0C0C, 0x078C, 0x3DC4, 0x00C8, 0x3FDC,
+		0x3FC4, 0x0100, 0x3D38, 0x0BC4, 0x07E4, 0x3DB0, 0x00D0, 0x3FDC,
+		0x3FC4, 0x0100, 0x3D38, 0x0B78, 0x083C, 0x3DA0, 0x00D8, 0x3FD8,
+		0x3FC8, 0x0100, 0x3D3C, 0x0B28, 0x0890, 0x3D90, 0x00DC, 0x3FD8,
+		0x3FC8, 0x00FC, 0x3D40, 0x0ADC, 0x08E8, 0x3D80, 0x00E4, 0x3FD4,
+		0x3FCC, 0x00FC, 0x3D48, 0x0A84, 0x093C, 0x3D74, 0x00E8, 0x3FD4,
+		0x3FCC, 0x00F8, 0x3D50, 0x0A38, 0x0990, 0x3D64, 0x00F0, 0x3FD0,
+		0x3FD0, 0x00F4, 0x3D58, 0x09E0, 0x09E4, 0x3D5C, 0x00F4, 0x3FD0
+};
+
+//=========================================
+// <num_taps>    = 8
+// <num_phases>  = 64
+// <scale_ratio> = 1.16666 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_8tap_64p_116[264] = {
+		0x0080, 0x3E90, 0x0268, 0x0D14, 0x0264, 0x3E90, 0x0080, 0x0000,
+		0x007C, 0x3E9C, 0x0238, 0x0D14, 0x0298, 0x3E84, 0x0080, 0x0000,
+		0x0078, 0x3EAC, 0x0200, 0x0D10, 0x02D0, 0x3E78, 0x0084, 0x0000,
+		0x0078, 0x3EB8, 0x01D0, 0x0D0C, 0x0304, 0x3E6C, 0x0084, 0x0000,
+		0x0074, 0x3EC8, 0x01A0, 0x0D00, 0x033C, 0x3E60, 0x0088, 0x0000,
+		0x0070, 0x3ED4, 0x0170, 0x0D00, 0x0374, 0x3E54, 0x0088, 0x3FFC,
+		0x006C, 0x3EE4, 0x0140, 0x0CF8, 0x03AC, 0x3E48, 0x0088, 0x3FFC,
+		0x006C, 0x3EF0, 0x0114, 0x0CE8, 0x03E4, 0x3E3C, 0x008C, 0x3FFC,
+		0x0068, 0x3F00, 0x00E8, 0x0CD8, 0x041C, 0x3E34, 0x008C, 0x3FFC,
+		0x0064, 0x3F10, 0x00BC, 0x0CCC, 0x0454, 0x3E28, 0x008C, 0x3FFC,
+		0x0060, 0x3F1C, 0x0090, 0x0CBC, 0x0490, 0x3E20, 0x008C, 0x3FFC,
+		0x005C, 0x3F2C, 0x0068, 0x0CA4, 0x04CC, 0x3E18, 0x008C, 0x3FFC,
+		0x0058, 0x3F38, 0x0040, 0x0C94, 0x0504, 0x3E10, 0x008C, 0x3FFC,
+		0x0054, 0x3F48, 0x001C, 0x0C7C, 0x0540, 0x3E08, 0x0088, 0x3FFC,
+		0x0050, 0x3F54, 0x3FF8, 0x0C60, 0x057C, 0x3E04, 0x0088, 0x3FFC,
+		0x004C, 0x3F64, 0x3FD4, 0x0C44, 0x05B8, 0x3DFC, 0x0088, 0x3FFC,
+		0x0048, 0x3F70, 0x3FB4, 0x0C28, 0x05F4, 0x3DF8, 0x0084, 0x3FFC,
+		0x0044, 0x3F80, 0x3F90, 0x0C0C, 0x0630, 0x3DF4, 0x0080, 0x3FFC,
+		0x0040, 0x3F8C, 0x3F70, 0x0BE8, 0x066C, 0x3DF4, 0x0080, 0x3FFC,
+		0x003C, 0x3F9C, 0x3F50, 0x0BC8, 0x06A8, 0x3DF0, 0x007C, 0x3FFC,
+		0x0038, 0x3FA8, 0x3F34, 0x0BA0, 0x06E4, 0x3DF0, 0x0078, 0x0000,
+		0x0034, 0x3FB4, 0x3F18, 0x0B80, 0x071C, 0x3DF0, 0x0074, 0x0000,
+		0x0030, 0x3FC0, 0x3EFC, 0x0B5C, 0x0758, 0x3DF0, 0x0070, 0x0000,
+		0x002C, 0x3FCC, 0x3EE4, 0x0B34, 0x0794, 0x3DF4, 0x0068, 0x0000,
+		0x002C, 0x3FDC, 0x3ECC, 0x0B08, 0x07CC, 0x3DF4, 0x0064, 0x0000,
+		0x0028, 0x3FE4, 0x3EB4, 0x0AE0, 0x0808, 0x3DF8, 0x0060, 0x0000,
+		0x0024, 0x3FF0, 0x3EA0, 0x0AB0, 0x0840, 0x3E00, 0x0058, 0x0004,
+		0x0020, 0x3FFC, 0x3E90, 0x0A84, 0x0878, 0x3E04, 0x0050, 0x0004,
+		0x001C, 0x0004, 0x3E7C, 0x0A54, 0x08B0, 0x3E0C, 0x004C, 0x0008,
+		0x0018, 0x000C, 0x3E68, 0x0A28, 0x08E8, 0x3E18, 0x0044, 0x0008,
+		0x0018, 0x0018, 0x3E54, 0x09F4, 0x0920, 0x3E20, 0x003C, 0x000C,
+		0x0014, 0x0020, 0x3E48, 0x09C0, 0x0954, 0x3E2C, 0x0034, 0x0010,
+		0x0010, 0x002C, 0x3E3C, 0x098C, 0x0988, 0x3E38, 0x002C, 0x0010
+};
+
+//=========================================
+// <num_taps>    = 8
+// <num_phases>  = 64
+// <scale_ratio> = 1.49999 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_8tap_64p_149[264] = {
+		0x0008, 0x3E8C, 0x03F8, 0x0AE8, 0x03F8, 0x3E8C, 0x0008, 0x0000,
+		0x000C, 0x3E8C, 0x03D0, 0x0AE8, 0x0420, 0x3E90, 0x0000, 0x0000,
+		0x000C, 0x3E8C, 0x03AC, 0x0AE8, 0x0444, 0x3E90, 0x0000, 0x0000,
+		0x0010, 0x3E90, 0x0384, 0x0AE0, 0x046C, 0x3E94, 0x3FFC, 0x0000,
+		0x0014, 0x3E90, 0x035C, 0x0ADC, 0x0494, 0x3E94, 0x3FF8, 0x0004,
+		0x0018, 0x3E90, 0x0334, 0x0AD8, 0x04BC, 0x3E98, 0x3FF4, 0x0004,
+		0x001C, 0x3E94, 0x0310, 0x0AD0, 0x04E4, 0x3E9C, 0x3FEC, 0x0004,
+		0x0020, 0x3E98, 0x02E8, 0x0AC4, 0x050C, 0x3EA0, 0x3FE8, 0x0008,
+		0x0020, 0x3E98, 0x02C4, 0x0AC0, 0x0534, 0x3EA4, 0x3FE4, 0x0008,
+		0x0024, 0x3E9C, 0x02A0, 0x0AB4, 0x055C, 0x3EAC, 0x3FDC, 0x0008,
+		0x0024, 0x3EA0, 0x027C, 0x0AA8, 0x0584, 0x3EB0, 0x3FD8, 0x000C,
+		0x0028, 0x3EA4, 0x0258, 0x0A9C, 0x05AC, 0x3EB8, 0x3FD0, 0x000C,
+		0x0028, 0x3EA8, 0x0234, 0x0A90, 0x05D4, 0x3EC0, 0x3FC8, 0x0010,
+		0x002C, 0x3EAC, 0x0210, 0x0A80, 0x05FC, 0x3EC8, 0x3FC4, 0x0010,
+		0x002C, 0x3EB4, 0x01F0, 0x0A70, 0x0624, 0x3ED0, 0x3FBC, 0x0010,
+		0x002C, 0x3EB8, 0x01CC, 0x0A60, 0x064C, 0x3EDC, 0x3FB4, 0x0014,
+		0x0030, 0x3EBC, 0x01A8, 0x0A50, 0x0674, 0x3EE4, 0x3FB0, 0x0014,
+		0x0030, 0x3EC4, 0x0188, 0x0A38, 0x069C, 0x3EF0, 0x3FA8, 0x0018,
+		0x0030, 0x3ECC, 0x0168, 0x0A28, 0x06C0, 0x3EFC, 0x3FA0, 0x0018,
+		0x0030, 0x3ED0, 0x0148, 0x0A14, 0x06E8, 0x3F08, 0x3F98, 0x001C,
+		0x0030, 0x3ED8, 0x012C, 0x0A00, 0x070C, 0x3F14, 0x3F90, 0x001C,
+		0x0034, 0x3EE0, 0x0108, 0x09E4, 0x0734, 0x3F24, 0x3F8C, 0x001C,
+		0x0034, 0x3EE4, 0x00EC, 0x09CC, 0x0758, 0x3F34, 0x3F84, 0x0020,
+		0x0034, 0x3EEC, 0x00D0, 0x09B8, 0x077C, 0x3F40, 0x3F7C, 0x0020,
+		0x0034, 0x3EF4, 0x00B4, 0x0998, 0x07A4, 0x3F50, 0x3F74, 0x0024,
+		0x0030, 0x3EFC, 0x0098, 0x0980, 0x07C8, 0x3F64, 0x3F6C, 0x0024,
+		0x0030, 0x3F04, 0x0080, 0x0968, 0x07E8, 0x3F74, 0x3F64, 0x0024,
+		0x0030, 0x3F0C, 0x0060, 0x094C, 0x080C, 0x3F88, 0x3F5C, 0x0028,
+		0x0030, 0x3F14, 0x0048, 0x0930, 0x0830, 0x3F98, 0x3F54, 0x0028,
+		0x0030, 0x3F1C, 0x0030, 0x0914, 0x0850, 0x3FAC, 0x3F4C, 0x0028,
+		0x0030, 0x3F24, 0x0018, 0x08F0, 0x0874, 0x3FC0, 0x3F44, 0x002C,
+		0x002C, 0x3F2C, 0x0000, 0x08D4, 0x0894, 0x3FD8, 0x3F3C, 0x002C,
+		0x002C, 0x3F34, 0x3FEC, 0x08B4, 0x08B4, 0x3FEC, 0x3F34, 0x002C
+};
+
+//=========================================
+// <num_taps>    = 8
+// <num_phases>  = 64
+// <scale_ratio> = 1.83332 (input/output)
+// <sharpness>   = 0
+// <CoefType>    = ModifiedLanczos
+// <CoefQuant>   = 1.10
+// <CoefOut>     = 1.12
+//=========================================
+static const uint16_t filter_8tap_64p_183[264] = {
+		0x3F88, 0x0048, 0x047C, 0x0768, 0x047C, 0x0048, 0x3F88, 0x0000,
+		0x3F88, 0x003C, 0x0468, 0x076C, 0x0490, 0x0054, 0x3F84, 0x0000,
+		0x3F8C, 0x0034, 0x0454, 0x0768, 0x04A4, 0x005C, 0x3F84, 0x0000,
+		0x3F8C, 0x0028, 0x0444, 0x076C, 0x04B4, 0x0068, 0x3F80, 0x0000,
+		0x3F90, 0x0020, 0x042C, 0x0768, 0x04C8, 0x0074, 0x3F80, 0x0000,
+		0x3F90, 0x0018, 0x041C, 0x0764, 0x04DC, 0x0080, 0x3F7C, 0x0000,
+		0x3F94, 0x0010, 0x0408, 0x075C, 0x04F0, 0x008C, 0x3F7C, 0x0000,
+		0x3F94, 0x0004, 0x03F8, 0x0760, 0x0500, 0x0098, 0x3F7C, 0x3FFC,
+		0x3F98, 0x0000, 0x03E0, 0x075C, 0x0514, 0x00A4, 0x3F78, 0x3FFC,
+		0x3F9C, 0x3FF8, 0x03CC, 0x0754, 0x0528, 0x00B0, 0x3F78, 0x3FFC,
+		0x3F9C, 0x3FF0, 0x03B8, 0x0754, 0x0538, 0x00BC, 0x3F78, 0x3FFC,
+		0x3FA0, 0x3FE8, 0x03A4, 0x0750, 0x054C, 0x00CC, 0x3F74, 0x3FF8,
+		0x3FA4, 0x3FE0, 0x0390, 0x074C, 0x055C, 0x00D8, 0x3F74, 0x3FF8,
+		0x3FA4, 0x3FDC, 0x037C, 0x0744, 0x0570, 0x00E4, 0x3F74, 0x3FF8,
+		0x3FA8, 0x3FD4, 0x0368, 0x0740, 0x0580, 0x00F4, 0x3F74, 0x3FF4,
+		0x3FA8, 0x3FCC, 0x0354, 0x073C, 0x0590, 0x0104, 0x3F74, 0x3FF4,
+		0x3FAC, 0x3FC8, 0x0340, 0x0730, 0x05A4, 0x0110, 0x3F74, 0x3FF4,
+		0x3FB0, 0x3FC0, 0x0330, 0x0728, 0x05B4, 0x0120, 0x3F74, 0x3FF0,
+		0x3FB0, 0x3FBC, 0x031C, 0x0724, 0x05C4, 0x0130, 0x3F70, 0x3FF0,
+		0x3FB4, 0x3FB4, 0x0308, 0x0720, 0x05D4, 0x013C, 0x3F70, 0x3FF0,
+		0x3FB8, 0x3FB0, 0x02F4, 0x0714, 0x05E4, 0x014C, 0x3F74, 0x3FEC,
+		0x3FB8, 0x3FAC, 0x02E0, 0x0708, 0x05F8, 0x015C, 0x3F74, 0x3FEC,
+		0x3FBC, 0x3FA8, 0x02CC, 0x0704, 0x0604, 0x016C, 0x3F74, 0x3FE8,
+		0x3FC0, 0x3FA0, 0x02BC, 0x06F8, 0x0614, 0x017C, 0x3F74, 0x3FE8,
+		0x3FC0, 0x3F9C, 0x02A8, 0x06F4, 0x0624, 0x018C, 0x3F74, 0x3FE4,
+		0x3FC4, 0x3F98, 0x0294, 0x06E8, 0x0634, 0x019C, 0x3F74, 0x3FE4,
+		0x3FC8, 0x3F94, 0x0284, 0x06D8, 0x0644, 0x01AC, 0x3F78, 0x3FE0,
+		0x3FC8, 0x3F90, 0x0270, 0x06D4, 0x0650, 0x01BC, 0x3F78, 0x3FE0,
+		0x3FCC, 0x3F8C, 0x025C, 0x06C8, 0x0660, 0x01D0, 0x3F78, 0x3FDC,
+		0x3FCC, 0x3F8C, 0x024C, 0x06B8, 0x066C, 0x01E0, 0x3F7C, 0x3FDC,
+		0x3FD0, 0x3F88, 0x0238, 0x06B0, 0x067C, 0x01F0, 0x3F7C, 0x3FD8,
+		0x3FD4, 0x3F84, 0x0228, 0x069C, 0x0688, 0x0204, 0x3F80, 0x3FD8,
+		0x3FD4, 0x3F84, 0x0214, 0x0694, 0x0694, 0x0214, 0x3F84, 0x3FD4
+};
+
+const uint16_t *spl_get_filter_3tap_16p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_one.value)
+		return filter_3tap_16p_upscale;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
+		return filter_3tap_16p_116;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
+		return filter_3tap_16p_149;
+	else
+		return filter_3tap_16p_183;
+}
+
+const uint16_t *spl_get_filter_3tap_64p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_one.value)
+		return filter_3tap_64p_upscale;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
+		return filter_3tap_64p_116;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
+		return filter_3tap_64p_149;
+	else
+		return filter_3tap_64p_183;
+}
+
+const uint16_t *spl_get_filter_4tap_16p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_one.value)
+		return filter_4tap_16p_upscale;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
+		return filter_4tap_16p_116;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
+		return filter_4tap_16p_149;
+	else
+		return filter_4tap_16p_183;
+}
+
+const uint16_t *spl_get_filter_4tap_64p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_one.value)
+		return filter_4tap_64p_upscale;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
+		return filter_4tap_64p_116;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
+		return filter_4tap_64p_149;
+	else
+		return filter_4tap_64p_183;
+}
+
+const uint16_t *spl_get_filter_5tap_64p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_one.value)
+		return filter_5tap_64p_upscale;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
+		return filter_5tap_64p_116;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
+		return filter_5tap_64p_149;
+	else
+		return filter_5tap_64p_183;
+}
+
+const uint16_t *spl_get_filter_6tap_64p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_one.value)
+		return filter_6tap_64p_upscale;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
+		return filter_6tap_64p_116;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
+		return filter_6tap_64p_149;
+	else
+		return filter_6tap_64p_183;
+}
+
+const uint16_t *spl_get_filter_7tap_64p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_one.value)
+		return filter_7tap_64p_upscale;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
+		return filter_7tap_64p_116;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
+		return filter_7tap_64p_149;
+	else
+		return filter_7tap_64p_183;
+}
+
+const uint16_t *spl_get_filter_8tap_64p(struct spl_fixed31_32 ratio)
+{
+	if (ratio.value < spl_fixpt_one.value)
+		return filter_8tap_64p_upscale;
+	else if (ratio.value < spl_fixpt_from_fraction(4, 3).value)
+		return filter_8tap_64p_116;
+	else if (ratio.value < spl_fixpt_from_fraction(5, 3).value)
+		return filter_8tap_64p_149;
+	else
+		return filter_8tap_64p_183;
+}
+
+const uint16_t *spl_get_filter_2tap_16p(void)
+{
+	return filter_2tap_16p;
+}
+
+const uint16_t *spl_get_filter_2tap_64p(void)
+{
+	return filter_2tap_64p;
+}
+
+const uint16_t *spl_dscl_get_filter_coeffs_64p(int taps, struct spl_fixed31_32 ratio)
+{
+	if (taps == 8)
+		return spl_get_filter_8tap_64p(ratio);
+	else if (taps == 7)
+		return spl_get_filter_7tap_64p(ratio);
+	else if (taps == 6)
+		return spl_get_filter_6tap_64p(ratio);
+	else if (taps == 5)
+		return spl_get_filter_5tap_64p(ratio);
+	else if (taps == 4)
+		return spl_get_filter_4tap_64p(ratio);
+	else if (taps == 3)
+		return spl_get_filter_3tap_64p(ratio);
+	else if (taps == 2)
+		return spl_get_filter_2tap_64p();
+	else if (taps == 1)
+		return NULL;
+	else {
+		/* should never happen, bug */
+		SPL_BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+}
+
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_filters.h b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_filters.h
new file mode 100644
index 000000000000..48202bc4f81e
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_scl_filters.h
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#ifndef __DC_SPL_SCL_FILTERS_H__
+#define __DC_SPL_SCL_FILTERS_H__
+
+#include "dc_spl_types.h"
+
+const uint16_t *spl_get_filter_3tap_16p(struct spl_fixed31_32 ratio);
+const uint16_t *spl_get_filter_3tap_64p(struct spl_fixed31_32 ratio);
+const uint16_t *spl_get_filter_4tap_16p(struct spl_fixed31_32 ratio);
+const uint16_t *spl_get_filter_4tap_64p(struct spl_fixed31_32 ratio);
+const uint16_t *spl_get_filter_5tap_64p(struct spl_fixed31_32 ratio);
+const uint16_t *spl_get_filter_6tap_64p(struct spl_fixed31_32 ratio);
+const uint16_t *spl_get_filter_7tap_64p(struct spl_fixed31_32 ratio);
+const uint16_t *spl_get_filter_8tap_64p(struct spl_fixed31_32 ratio);
+const uint16_t *spl_get_filter_2tap_16p(void);
+const uint16_t *spl_get_filter_2tap_64p(void);
+const uint16_t *spl_dscl_get_filter_coeffs_64p(int taps, struct spl_fixed31_32 ratio);
+
+#endif /* __DC_SPL_SCL_FILTERS_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_types.h b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_types.h
new file mode 100644
index 000000000000..467af9dd90de
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/dc_spl_types.h
@@ -0,0 +1,543 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#ifndef __DC_SPL_TYPES_H__
+#define __DC_SPL_TYPES_H__
+
+#include "spl_debug.h"
+#include "spl_os_types.h"   // swap
+#include "spl_fixpt31_32.h"	// fixed31_32 and related functions
+#include "spl_custom_float.h" // custom float and related functions
+
+struct spl_size {
+	uint32_t width;
+	uint32_t height;
+};
+struct spl_rect	{
+	int x;
+	int y;
+	int width;
+	int height;
+};
+
+struct spl_ratios {
+	struct spl_fixed31_32 horz;
+	struct spl_fixed31_32 vert;
+	struct spl_fixed31_32 horz_c;
+	struct spl_fixed31_32 vert_c;
+};
+struct spl_inits {
+	struct spl_fixed31_32 h;
+	struct spl_fixed31_32 h_c;
+	struct spl_fixed31_32 v;
+	struct spl_fixed31_32 v_c;
+};
+
+struct spl_taps	{
+	uint32_t v_taps;
+	uint32_t h_taps;
+	uint32_t v_taps_c;
+	uint32_t h_taps_c;
+	bool integer_scaling;
+};
+enum spl_view_3d {
+	SPL_VIEW_3D_NONE = 0,
+	SPL_VIEW_3D_FRAME_SEQUENTIAL,
+	SPL_VIEW_3D_SIDE_BY_SIDE,
+	SPL_VIEW_3D_TOP_AND_BOTTOM,
+	SPL_VIEW_3D_COUNT,
+	SPL_VIEW_3D_FIRST = SPL_VIEW_3D_FRAME_SEQUENTIAL
+};
+/* Pixel format */
+enum spl_pixel_format {
+	/*graph*/
+	SPL_PIXEL_FORMAT_UNINITIALIZED,
+	SPL_PIXEL_FORMAT_INDEX8,
+	SPL_PIXEL_FORMAT_RGB565,
+	SPL_PIXEL_FORMAT_ARGB8888,
+	SPL_PIXEL_FORMAT_ARGB2101010,
+	SPL_PIXEL_FORMAT_ARGB2101010_XRBIAS,
+	SPL_PIXEL_FORMAT_FP16,
+	/*video*/
+	SPL_PIXEL_FORMAT_420BPP8,
+	SPL_PIXEL_FORMAT_420BPP10,
+	/*end of pixel format definition*/
+	SPL_PIXEL_FORMAT_GRPH_BEGIN = SPL_PIXEL_FORMAT_INDEX8,
+	SPL_PIXEL_FORMAT_GRPH_END = SPL_PIXEL_FORMAT_FP16,
+	SPL_PIXEL_FORMAT_SUBSAMPLED_BEGIN = SPL_PIXEL_FORMAT_420BPP8,
+	SPL_PIXEL_FORMAT_SUBSAMPLED_END = SPL_PIXEL_FORMAT_420BPP10,
+	SPL_PIXEL_FORMAT_VIDEO_BEGIN = SPL_PIXEL_FORMAT_420BPP8,
+	SPL_PIXEL_FORMAT_VIDEO_END = SPL_PIXEL_FORMAT_420BPP10,
+	SPL_PIXEL_FORMAT_INVALID,
+	SPL_PIXEL_FORMAT_UNKNOWN
+};
+
+enum lb_memory_config {
+	/* Enable all 3 pieces of memory */
+	LB_MEMORY_CONFIG_0 = 0,
+
+	/* Enable only the first piece of memory */
+	LB_MEMORY_CONFIG_1 = 1,
+
+	/* Enable only the second piece of memory */
+	LB_MEMORY_CONFIG_2 = 2,
+
+	/* Only applicable in 4:2:0 mode, enable all 3 pieces of memory and the
+	 * last piece of chroma memory used for the luma storage
+	 */
+	LB_MEMORY_CONFIG_3 = 3
+};
+
+/* Rotation angle */
+enum spl_rotation_angle {
+	SPL_ROTATION_ANGLE_0 = 0,
+	SPL_ROTATION_ANGLE_90,
+	SPL_ROTATION_ANGLE_180,
+	SPL_ROTATION_ANGLE_270,
+	SPL_ROTATION_ANGLE_COUNT
+};
+enum spl_color_space {
+	SPL_COLOR_SPACE_UNKNOWN,
+	SPL_COLOR_SPACE_SRGB,
+	SPL_COLOR_SPACE_XR_RGB,
+	SPL_COLOR_SPACE_SRGB_LIMITED,
+	SPL_COLOR_SPACE_MSREF_SCRGB,
+	SPL_COLOR_SPACE_YCBCR601,
+	SPL_COLOR_SPACE_YCBCR709,
+	SPL_COLOR_SPACE_XV_YCC_709,
+	SPL_COLOR_SPACE_XV_YCC_601,
+	SPL_COLOR_SPACE_YCBCR601_LIMITED,
+	SPL_COLOR_SPACE_YCBCR709_LIMITED,
+	SPL_COLOR_SPACE_2020_RGB_FULLRANGE,
+	SPL_COLOR_SPACE_2020_RGB_LIMITEDRANGE,
+	SPL_COLOR_SPACE_2020_YCBCR,
+	SPL_COLOR_SPACE_ADOBERGB,
+	SPL_COLOR_SPACE_DCIP3,
+	SPL_COLOR_SPACE_DISPLAYNATIVE,
+	SPL_COLOR_SPACE_DOLBYVISION,
+	SPL_COLOR_SPACE_APPCTRL,
+	SPL_COLOR_SPACE_CUSTOMPOINTS,
+	SPL_COLOR_SPACE_YCBCR709_BLACK,
+};
+
+enum chroma_cositing {
+	CHROMA_COSITING_NONE,
+	CHROMA_COSITING_LEFT,
+	CHROMA_COSITING_TOPLEFT,
+	CHROMA_COSITING_COUNT
+};
+
+// Scratch space for calculating scaler params
+struct spl_scaler_data {
+	int h_active;
+	int v_active;
+	struct spl_taps taps;
+	struct spl_rect viewport;
+	struct spl_rect viewport_c;
+	struct spl_rect recout;
+	struct spl_ratios ratios;
+	struct spl_ratios recip_ratios;
+	struct spl_inits inits;
+};
+
+enum spl_transfer_func_type {
+	SPL_TF_TYPE_PREDEFINED,
+	SPL_TF_TYPE_DISTRIBUTED_POINTS,
+	SPL_TF_TYPE_BYPASS,
+	SPL_TF_TYPE_HWPWL
+};
+
+enum spl_transfer_func_predefined {
+	SPL_TRANSFER_FUNCTION_SRGB,
+	SPL_TRANSFER_FUNCTION_BT709,
+	SPL_TRANSFER_FUNCTION_PQ,
+	SPL_TRANSFER_FUNCTION_LINEAR,
+	SPL_TRANSFER_FUNCTION_UNITY,
+	SPL_TRANSFER_FUNCTION_HLG,
+	SPL_TRANSFER_FUNCTION_HLG12,
+	SPL_TRANSFER_FUNCTION_GAMMA22,
+	SPL_TRANSFER_FUNCTION_GAMMA24,
+	SPL_TRANSFER_FUNCTION_GAMMA26
+};
+
+/*==============================================================*/
+/* Below structs are defined to hold hw register data */
+
+// SPL output is used to set below registers
+
+// MPC_SIZE - set based on scl_data h_active and v_active
+struct mpc_size	{
+	uint32_t width;
+	uint32_t height;
+};
+// SCL_MODE - set based on scl_data.ratios and always_scale
+enum scl_mode {
+	SCL_MODE_SCALING_444_BYPASS = 0,
+	SCL_MODE_SCALING_444_RGB_ENABLE = 1,
+	SCL_MODE_SCALING_444_YCBCR_ENABLE = 2,
+	SCL_MODE_SCALING_420_YCBCR_ENABLE = 3,
+	SCL_MODE_SCALING_420_LUMA_BYPASS = 4,
+	SCL_MODE_SCALING_420_CHROMA_BYPASS = 5,
+	SCL_MODE_DSCL_BYPASS = 6
+};
+// SCL_BLACK_COLOR - set based on scl_data.format
+struct scl_black_color	{
+	uint32_t offset_rgb_y;
+	uint32_t offset_rgb_cbcr;
+};
+// RATIO - set based on scl_data.ratios
+struct ratio	{
+	uint32_t h_scale_ratio;
+	uint32_t v_scale_ratio;
+	uint32_t h_scale_ratio_c;
+	uint32_t v_scale_ratio_c;
+};
+
+// INIT - set based on scl_data.init
+struct init	{
+	// SCL_HORZ_FILTER_INIT
+	uint32_t h_filter_init_frac;	//	SCL_H_INIT_FRAC
+	uint32_t h_filter_init_int;	//	SCL_H_INIT_INT
+	// SCL_HORZ_FILTER_INIT_C
+	uint32_t h_filter_init_frac_c;	//	SCL_H_INIT_FRAC_C
+	uint32_t h_filter_init_int_c;	//	SCL_H_INIT_INT_C
+	// SCL_VERT_FILTER_INIT
+	uint32_t v_filter_init_frac;	//	SCL_V_INIT_FRAC
+	uint32_t v_filter_init_int;	//	SCL_V_INIT_INT
+	//	SCL_VERT_FILTER_INIT_C
+	uint32_t v_filter_init_frac_c;	//	SCL_V_INIT_FRAC_C
+	uint32_t v_filter_init_int_c;	//	SCL_V_INIT_INT_C
+	//	SCL_VERT_FILTER_INIT_BOT
+	uint32_t v_filter_init_bot_frac;	//	SCL_V_INIT_FRAC_BOT
+	uint32_t v_filter_init_bot_int;	//	SCL_V_INIT_INT_BOT
+	//	SCL_VERT_FILTER_INIT_BOT_C
+	uint32_t v_filter_init_bot_frac_c;	//	SCL_V_INIT_FRAC_BOT_C
+	uint32_t v_filter_init_bot_int_c;	//	SCL_V_INIT_INT_BOT_C
+};
+
+// FILTER - calculated based on scl_data ratios and taps
+
+// iSHARP
+struct isharp_noise_det {
+	uint32_t enable;	// ISHARP_NOISEDET_EN
+	uint32_t mode;		// ISHARP_NOISEDET_MODE
+	uint32_t uthreshold;	// ISHARP_NOISEDET_UTHRE
+	uint32_t dthreshold;	// ISHARP_NOISEDET_DTHRE
+	uint32_t pwl_start_in;	// ISHARP_NOISEDET_PWL_START_IN
+	uint32_t pwl_end_in;	// ISHARP_NOISEDET_PWL_END_IN
+	uint32_t pwl_slope;	// ISHARP_NOISEDET_PWL_SLOPE
+};
+struct isharp_lba	{
+	uint32_t mode;	// ISHARP_LBA_MODE
+	uint32_t in_seg[6];
+	uint32_t base_seg[6];
+	uint32_t slope_seg[6];
+};
+struct isharp_fmt	{
+	uint32_t mode;	// ISHARP_FMT_MODE
+	uint32_t norm;	// ISHARP_FMT_NORM
+};
+struct isharp_nldelta_sclip	{
+	uint32_t enable_p;	// ISHARP_NLDELTA_SCLIP_EN_P
+	uint32_t pivot_p;	// ISHARP_NLDELTA_SCLIP_PIVOT_P
+	uint32_t slope_p;	// ISHARP_NLDELTA_SCLIP_SLOPE_P
+	uint32_t enable_n;	// ISHARP_NLDELTA_SCLIP_EN_N
+	uint32_t pivot_n;	// ISHARP_NLDELTA_SCLIP_PIVOT_N
+	uint32_t slope_n;	// ISHARP_NLDELTA_SCLIP_SLOPE_N
+};
+enum isharp_en	{
+	ISHARP_DISABLE,
+	ISHARP_ENABLE
+};
+#define ISHARP_LUT_TABLE_SIZE 32
+// Below struct holds values that can be directly used to program
+// hardware registers. No conversion/clamping is required
+struct dscl_prog_data {
+	struct spl_rect recout; // RECOUT - set based on scl_data.recout
+	struct mpc_size mpc_size;
+	uint32_t dscl_mode;
+	struct scl_black_color scl_black_color;
+	struct ratio ratios;
+	struct init init;
+	struct spl_taps taps;	// TAPS - set based on scl_data.taps
+	struct spl_rect viewport;
+	struct spl_rect viewport_c;
+	// raw filter
+	const uint16_t *filter_h;
+	const uint16_t *filter_v;
+	const uint16_t *filter_h_c;
+	const uint16_t *filter_v_c;
+	// EASF registers
+	uint32_t easf_matrix_mode;
+	uint32_t easf_ltonl_en;
+	uint32_t easf_v_en;
+	uint32_t easf_v_sharp_factor;
+	uint32_t easf_v_ring;
+	uint32_t easf_v_bf1_en;
+	uint32_t easf_v_bf2_mode;
+	uint32_t easf_v_bf3_mode;
+	uint32_t easf_v_bf2_flat1_gain;
+	uint32_t easf_v_bf2_flat2_gain;
+	uint32_t easf_v_bf2_roc_gain;
+	uint32_t easf_v_ringest_3tap_dntilt_uptilt;
+	uint32_t easf_v_ringest_3tap_uptilt_max;
+	uint32_t easf_v_ringest_3tap_dntilt_slope;
+	uint32_t easf_v_ringest_3tap_uptilt1_slope;
+	uint32_t easf_v_ringest_3tap_uptilt2_slope;
+	uint32_t easf_v_ringest_3tap_uptilt2_offset;
+	uint32_t easf_v_ringest_eventap_reduceg1;
+	uint32_t easf_v_ringest_eventap_reduceg2;
+	uint32_t easf_v_ringest_eventap_gain1;
+	uint32_t easf_v_ringest_eventap_gain2;
+	uint32_t easf_v_bf_maxa;
+	uint32_t easf_v_bf_maxb;
+	uint32_t easf_v_bf_mina;
+	uint32_t easf_v_bf_minb;
+	uint32_t easf_v_bf1_pwl_in_seg0;
+	uint32_t easf_v_bf1_pwl_base_seg0;
+	uint32_t easf_v_bf1_pwl_slope_seg0;
+	uint32_t easf_v_bf1_pwl_in_seg1;
+	uint32_t easf_v_bf1_pwl_base_seg1;
+	uint32_t easf_v_bf1_pwl_slope_seg1;
+	uint32_t easf_v_bf1_pwl_in_seg2;
+	uint32_t easf_v_bf1_pwl_base_seg2;
+	uint32_t easf_v_bf1_pwl_slope_seg2;
+	uint32_t easf_v_bf1_pwl_in_seg3;
+	uint32_t easf_v_bf1_pwl_base_seg3;
+	uint32_t easf_v_bf1_pwl_slope_seg3;
+	uint32_t easf_v_bf1_pwl_in_seg4;
+	uint32_t easf_v_bf1_pwl_base_seg4;
+	uint32_t easf_v_bf1_pwl_slope_seg4;
+	uint32_t easf_v_bf1_pwl_in_seg5;
+	uint32_t easf_v_bf1_pwl_base_seg5;
+	uint32_t easf_v_bf1_pwl_slope_seg5;
+	uint32_t easf_v_bf1_pwl_in_seg6;
+	uint32_t easf_v_bf1_pwl_base_seg6;
+	uint32_t easf_v_bf1_pwl_slope_seg6;
+	uint32_t easf_v_bf1_pwl_in_seg7;
+	uint32_t easf_v_bf1_pwl_base_seg7;
+	uint32_t easf_v_bf3_pwl_in_set0;
+	uint32_t easf_v_bf3_pwl_base_set0;
+	uint32_t easf_v_bf3_pwl_slope_set0;
+	uint32_t easf_v_bf3_pwl_in_set1;
+	uint32_t easf_v_bf3_pwl_base_set1;
+	uint32_t easf_v_bf3_pwl_slope_set1;
+	uint32_t easf_v_bf3_pwl_in_set2;
+	uint32_t easf_v_bf3_pwl_base_set2;
+	uint32_t easf_v_bf3_pwl_slope_set2;
+	uint32_t easf_v_bf3_pwl_in_set3;
+	uint32_t easf_v_bf3_pwl_base_set3;
+	uint32_t easf_v_bf3_pwl_slope_set3;
+	uint32_t easf_v_bf3_pwl_in_set4;
+	uint32_t easf_v_bf3_pwl_base_set4;
+	uint32_t easf_v_bf3_pwl_slope_set4;
+	uint32_t easf_v_bf3_pwl_in_set5;
+	uint32_t easf_v_bf3_pwl_base_set5;
+	uint32_t easf_h_en;
+	uint32_t easf_h_sharp_factor;
+	uint32_t easf_h_ring;
+	uint32_t easf_h_bf1_en;
+	uint32_t easf_h_bf2_mode;
+	uint32_t easf_h_bf3_mode;
+	uint32_t easf_h_bf2_flat1_gain;
+	uint32_t easf_h_bf2_flat2_gain;
+	uint32_t easf_h_bf2_roc_gain;
+	uint32_t easf_h_ringest_eventap_reduceg1;
+	uint32_t easf_h_ringest_eventap_reduceg2;
+	uint32_t easf_h_ringest_eventap_gain1;
+	uint32_t easf_h_ringest_eventap_gain2;
+	uint32_t easf_h_bf_maxa;
+	uint32_t easf_h_bf_maxb;
+	uint32_t easf_h_bf_mina;
+	uint32_t easf_h_bf_minb;
+	uint32_t easf_h_bf1_pwl_in_seg0;
+	uint32_t easf_h_bf1_pwl_base_seg0;
+	uint32_t easf_h_bf1_pwl_slope_seg0;
+	uint32_t easf_h_bf1_pwl_in_seg1;
+	uint32_t easf_h_bf1_pwl_base_seg1;
+	uint32_t easf_h_bf1_pwl_slope_seg1;
+	uint32_t easf_h_bf1_pwl_in_seg2;
+	uint32_t easf_h_bf1_pwl_base_seg2;
+	uint32_t easf_h_bf1_pwl_slope_seg2;
+	uint32_t easf_h_bf1_pwl_in_seg3;
+	uint32_t easf_h_bf1_pwl_base_seg3;
+	uint32_t easf_h_bf1_pwl_slope_seg3;
+	uint32_t easf_h_bf1_pwl_in_seg4;
+	uint32_t easf_h_bf1_pwl_base_seg4;
+	uint32_t easf_h_bf1_pwl_slope_seg4;
+	uint32_t easf_h_bf1_pwl_in_seg5;
+	uint32_t easf_h_bf1_pwl_base_seg5;
+	uint32_t easf_h_bf1_pwl_slope_seg5;
+	uint32_t easf_h_bf1_pwl_in_seg6;
+	uint32_t easf_h_bf1_pwl_base_seg6;
+	uint32_t easf_h_bf1_pwl_slope_seg6;
+	uint32_t easf_h_bf1_pwl_in_seg7;
+	uint32_t easf_h_bf1_pwl_base_seg7;
+	uint32_t easf_h_bf3_pwl_in_set0;
+	uint32_t easf_h_bf3_pwl_base_set0;
+	uint32_t easf_h_bf3_pwl_slope_set0;
+	uint32_t easf_h_bf3_pwl_in_set1;
+	uint32_t easf_h_bf3_pwl_base_set1;
+	uint32_t easf_h_bf3_pwl_slope_set1;
+	uint32_t easf_h_bf3_pwl_in_set2;
+	uint32_t easf_h_bf3_pwl_base_set2;
+	uint32_t easf_h_bf3_pwl_slope_set2;
+	uint32_t easf_h_bf3_pwl_in_set3;
+	uint32_t easf_h_bf3_pwl_base_set3;
+	uint32_t easf_h_bf3_pwl_slope_set3;
+	uint32_t easf_h_bf3_pwl_in_set4;
+	uint32_t easf_h_bf3_pwl_base_set4;
+	uint32_t easf_h_bf3_pwl_slope_set4;
+	uint32_t easf_h_bf3_pwl_in_set5;
+	uint32_t easf_h_bf3_pwl_base_set5;
+	uint32_t easf_matrix_c0;
+	uint32_t easf_matrix_c1;
+	uint32_t easf_matrix_c2;
+	uint32_t easf_matrix_c3;
+	// iSharp
+	uint32_t isharp_en;     //      ISHARP_EN
+	struct isharp_noise_det isharp_noise_det;       //      ISHARP_NOISEDET
+	uint32_t isharp_nl_en;  //      ISHARP_NL_EN ? TODO:check this
+	struct isharp_lba isharp_lba;   //      ISHARP_LBA
+	struct isharp_fmt isharp_fmt;   //      ISHARP_FMT
+	uint32_t isharp_delta[ISHARP_LUT_TABLE_SIZE];
+	struct isharp_nldelta_sclip isharp_nldelta_sclip;       //      ISHARP_NLDELTA_SCLIP
+	/* blur and scale filter */
+	const uint16_t *filter_blur_scale_v;
+	const uint16_t *filter_blur_scale_h;
+	int sharpness_level; /* Track sharpness level */
+};
+
+/* SPL input and output definitions */
+// SPL scratch struct
+struct spl_scratch {
+	// Pack all SPL outputs in scl_data
+	struct spl_scaler_data scl_data;
+};
+
+/* SPL input and output definitions */
+// SPL outputs struct
+struct spl_out	{
+	// Pack all output need to program hw registers
+	struct dscl_prog_data *dscl_prog_data;
+};
+
+// end of SPL outputs
+
+// SPL inputs
+
+// Basic input information
+struct basic_in	{
+	enum spl_pixel_format format; // Pixel Format
+	enum chroma_cositing cositing; /* Chroma Subsampling Offset */
+	struct spl_rect src_rect; // Source rect
+	struct spl_rect dst_rect; // Destination Rect
+	struct spl_rect clip_rect; // Clip rect
+	enum spl_rotation_angle rotation;  // Rotation
+	bool horizontal_mirror;  // Horizontal mirror
+	struct { // previous mpc_combine_h - split count
+		bool use_recout_width_aligned;
+		union {
+			int mpc_num_h_slices;
+			int mpc_recout_width_align;
+		} num_slices_recout_width;
+	} num_h_slices_recout_width_align;
+	int mpc_h_slice_index; // previous mpc_combine_v - split_idx
+	// Inputs for adaptive scaler - TODO
+	enum spl_transfer_func_type tf_type; /* Transfer function type */
+	enum spl_transfer_func_predefined tf_predefined_type; /* Transfer function predefined type */
+	// enum dc_transfer_func_predefined tf;
+	enum spl_color_space color_space;	//	Color Space
+	unsigned int max_luminance;	//	Max Luminance TODO: Is determined in dc_hw_sequencer.c is_sdr
+	bool film_grain_applied;	//	Film Grain Applied // TODO: To check from where to get this?
+};
+
+// Basic output information
+struct basic_out {
+	struct spl_size output_size; // Output Size
+	struct spl_rect dst_rect;	// Destination Rect
+	struct spl_rect src_rect;	// Source rect
+	int odm_combine_factor;	// deprecated
+	struct spl_rect odm_slice_rect; // OPP input rect in timing active
+	enum spl_view_3d view_format;	// TODO: View format Check if it is chroma subsampling
+	bool always_scale;	// Is always scale enabled? Required for getting SCL_MODE
+	int max_downscale_src_width; // Required to get optimal no of taps
+	bool alpha_en;
+	bool use_two_pixels_per_container;
+};
+enum sharpness_setting	{
+	SHARPNESS_HW_OFF = 0,
+	SHARPNESS_ZERO,
+	SHARPNESS_CUSTOM
+};
+struct spl_sharpness_range {
+	int sdr_rgb_min;
+	int sdr_rgb_max;
+	int sdr_rgb_mid;
+	int sdr_yuv_min;
+	int sdr_yuv_max;
+	int sdr_yuv_mid;
+	int hdr_rgb_min;
+	int hdr_rgb_max;
+	int hdr_rgb_mid;
+};
+struct adaptive_sharpness {
+	bool enable;
+	int sharpness_level;
+	struct spl_sharpness_range sharpness_range;
+};
+enum linear_light_scaling	{	// convert it in translation logic
+	LLS_PREF_DONT_CARE = 0,
+	LLS_PREF_YES,
+	LLS_PREF_NO
+};
+enum sharpen_policy {
+	SHARPEN_ALWAYS = 0,
+	SHARPEN_YUV = 1,
+	SHARPEN_RGB_FULLSCREEN_YUV = 2,
+	SHARPEN_FULLSCREEN_ALL = 3
+};
+enum scale_to_sharpness_policy {
+	NO_SCALE_TO_SHARPNESS_ADJ = 0,
+	SCALE_TO_SHARPNESS_ADJ_YUV = 1,
+	SCALE_TO_SHARPNESS_ADJ_ALL = 2
+};
+struct spl_callbacks {
+	void (*spl_calc_lb_num_partitions)
+		(bool alpha_en,
+		const struct spl_scaler_data *scl_data,
+		enum lb_memory_config lb_config,
+		int *num_part_y,
+		int *num_part_c);
+};
+
+struct spl_debug {
+	int visual_confirm_base_offset;
+	int visual_confirm_dpp_offset;
+	enum scale_to_sharpness_policy scale_to_sharpness_policy;
+};
+
+struct spl_in	{
+	struct basic_out basic_out;
+	struct basic_in basic_in;
+	// Basic slice information
+	int odm_slice_index;	// ODM Slice Index using get_odm_split_index
+	struct spl_taps scaling_quality; // Explicit Scaling Quality
+	struct spl_callbacks callbacks;
+	// Inputs for isharp and EASF
+	struct adaptive_sharpness adaptive_sharpness;	//	Adaptive Sharpness
+	enum linear_light_scaling lls_pref;	//	Linear Light Scaling
+	bool prefer_easf;
+	bool disable_easf;
+	struct spl_debug debug;
+	bool is_fullscreen;
+	bool is_hdr_on;
+	int h_active;
+	int v_active;
+	int sdr_white_level_nits;
+	enum sharpen_policy sharpen_policy;
+};
+// end of SPL inputs
+
+#endif /* __DC_SPL_TYPES_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/spl_custom_float.c b/drivers/gpu/drm/amd/display/dc/sspl/spl_custom_float.c
new file mode 100644
index 000000000000..be2f34d034c5
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/spl_custom_float.c
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#include "spl_debug.h"
+#include "spl_custom_float.h"
+
+static bool spl_build_custom_float(struct spl_fixed31_32 value,
+			       const struct spl_custom_float_format *format,
+			       bool *negative,
+			       uint32_t *mantissa,
+			       uint32_t *exponenta)
+{
+	uint32_t exp_offset = (1 << (format->exponenta_bits - 1)) - 1;
+
+	const struct spl_fixed31_32 mantissa_constant_plus_max_fraction =
+		spl_fixpt_from_fraction((1LL << (format->mantissa_bits + 1)) - 1,
+				       1LL << format->mantissa_bits);
+
+	struct spl_fixed31_32 mantiss;
+
+	if (spl_fixpt_eq(value, spl_fixpt_zero)) {
+		*negative = false;
+		*mantissa = 0;
+		*exponenta = 0;
+		return true;
+	}
+
+	if (spl_fixpt_lt(value, spl_fixpt_zero)) {
+		*negative = format->sign;
+		value = spl_fixpt_neg(value);
+	} else {
+		*negative = false;
+	}
+
+	if (spl_fixpt_lt(value, spl_fixpt_one)) {
+		uint32_t i = 1;
+
+		do {
+			value = spl_fixpt_shl(value, 1);
+			++i;
+		} while (spl_fixpt_lt(value, spl_fixpt_one));
+
+		--i;
+
+		if (exp_offset <= i) {
+			*mantissa = 0;
+			*exponenta = 0;
+			return true;
+		}
+
+		*exponenta = exp_offset - i;
+	} else if (spl_fixpt_le(mantissa_constant_plus_max_fraction, value)) {
+		uint32_t i = 1;
+
+		do {
+			value = spl_fixpt_shr(value, 1);
+			++i;
+		} while (spl_fixpt_lt(mantissa_constant_plus_max_fraction, value));
+
+		*exponenta = exp_offset + i - 1;
+	} else {
+		*exponenta = exp_offset;
+	}
+
+	mantiss = spl_fixpt_sub(value, spl_fixpt_one);
+
+	if (spl_fixpt_lt(mantiss, spl_fixpt_zero) ||
+	    spl_fixpt_lt(spl_fixpt_one, mantiss))
+		mantiss = spl_fixpt_zero;
+	else
+		mantiss = spl_fixpt_shl(mantiss, format->mantissa_bits);
+
+	*mantissa = spl_fixpt_floor(mantiss);
+
+	return true;
+}
+
+static bool spl_setup_custom_float(const struct spl_custom_float_format *format,
+			       bool negative,
+			       uint32_t mantissa,
+			       uint32_t exponenta,
+			       uint32_t *result)
+{
+	uint32_t i = 0;
+	uint32_t j = 0;
+	uint32_t value = 0;
+
+	/* verification code:
+	 * once calculation is ok we can remove it
+	 */
+
+	const uint32_t mantissa_mask =
+		(1 << (format->mantissa_bits + 1)) - 1;
+
+	const uint32_t exponenta_mask =
+		(1 << (format->exponenta_bits + 1)) - 1;
+
+	if (mantissa & ~mantissa_mask) {
+		SPL_BREAK_TO_DEBUGGER();
+		mantissa = mantissa_mask;
+	}
+
+	if (exponenta & ~exponenta_mask) {
+		SPL_BREAK_TO_DEBUGGER();
+		exponenta = exponenta_mask;
+	}
+
+	/* end of verification code */
+
+	while (i < format->mantissa_bits) {
+		uint32_t mask = 1 << i;
+
+		if (mantissa & mask)
+			value |= mask;
+
+		++i;
+	}
+
+	while (j < format->exponenta_bits) {
+		uint32_t mask = 1 << j;
+
+		if (exponenta & mask)
+			value |= mask << i;
+
+		++j;
+	}
+
+	if (negative && format->sign)
+		value |= 1 << (i + j);
+
+	*result = value;
+
+	return true;
+}
+
+bool spl_convert_to_custom_float_format(struct spl_fixed31_32 value,
+				    const struct spl_custom_float_format *format,
+				    uint32_t *result)
+{
+	uint32_t mantissa;
+	uint32_t exponenta;
+	bool negative;
+
+	return spl_build_custom_float(value, format, &negative, &mantissa, &exponenta) &&
+				  spl_setup_custom_float(format,
+						     negative,
+						     mantissa,
+						     exponenta,
+						     result);
+}
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/spl_custom_float.h b/drivers/gpu/drm/amd/display/dc/sspl/spl_custom_float.h
new file mode 100644
index 000000000000..cdc4e107b9de
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/spl_custom_float.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: MIT */
+
+/* Copyright 2024 Advanced Micro Devices, Inc. */
+
+#ifndef SPL_CUSTOM_FLOAT_H_
+#define SPL_CUSTOM_FLOAT_H_
+
+#include "spl_os_types.h"
+#include "spl_fixpt31_32.h"
+
+struct spl_custom_float_format {
+	uint32_t mantissa_bits;
+	uint32_t exponenta_bits;
+	bool sign;
+};
+
+struct spl_custom_float_value {
+	uint32_t mantissa;
+	uint32_t exponenta;
+	uint32_t value;
+	bool negative;
+};
+
+bool spl_convert_to_custom_float_format(
+	struct spl_fixed31_32 value,
+	const struct spl_custom_float_format *format,
+	uint32_t *result);
+
+#endif //SPL_CUSTOM_FLOAT_H_
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/spl_debug.h b/drivers/gpu/drm/amd/display/dc/sspl/spl_debug.h
new file mode 100644
index 000000000000..a6f6132df241
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/spl_debug.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: MIT */
+
+/* Copyright 2024 Advanced Micro Devices, Inc. */
+
+#ifndef SPL_DEBUG_H
+#define SPL_DEBUG_H
+
+#if defined(CONFIG_HAVE_KGDB) || defined(CONFIG_KGDB)
+#define SPL_ASSERT_CRITICAL(expr) do {	\
+	if (WARN_ON(!(expr))) { \
+		kgdb_breakpoint(); \
+	} \
+} while (0)
+#else
+#define SPL_ASSERT_CRITICAL(expr) do {	\
+	if (WARN_ON(!(expr))) { \
+		; \
+	} \
+} while (0)
+#endif /* CONFIG_HAVE_KGDB || CONFIG_KGDB */
+
+#if defined(CONFIG_DEBUG_KERNEL_DC)
+#define SPL_ASSERT(expr) SPL_ASSERT_CRITICAL(expr)
+#else
+#define SPL_ASSERT(expr) WARN_ON(!(expr))
+#endif /* CONFIG_DEBUG_KERNEL_DC */
+
+#define SPL_BREAK_TO_DEBUGGER() SPL_ASSERT(0)
+
+#endif  // SPL_DEBUG_H
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/spl_fixpt31_32.c b/drivers/gpu/drm/amd/display/dc/sspl/spl_fixpt31_32.c
new file mode 100644
index 000000000000..131f1e3949d3
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/spl_fixpt31_32.c
@@ -0,0 +1,497 @@
+// SPDX-License-Identifier: MIT
+//
+// Copyright 2024 Advanced Micro Devices, Inc.
+
+#include "spl_fixpt31_32.h"
+
+static const struct spl_fixed31_32 spl_fixpt_two_pi = { 26986075409LL };
+static const struct spl_fixed31_32 spl_fixpt_ln2 = { 2977044471LL };
+static const struct spl_fixed31_32 spl_fixpt_ln2_div_2 = { 1488522236LL };
+
+static inline unsigned long long abs_i64(
+	long long arg)
+{
+	if (arg > 0)
+		return (unsigned long long)arg;
+	else
+		return (unsigned long long)(-arg);
+}
+
+/*
+ * @brief
+ * result = dividend / divisor
+ * *remainder = dividend % divisor
+ */
+static inline unsigned long long spl_complete_integer_division_u64(
+	unsigned long long dividend,
+	unsigned long long divisor,
+	unsigned long long *remainder)
+{
+	unsigned long long result;
+
+	SPL_ASSERT(divisor);
+
+	result = spl_div64_u64_rem(dividend, divisor, remainder);
+
+	return result;
+}
+
+
+#define FRACTIONAL_PART_MASK \
+	((1ULL << FIXED31_32_BITS_PER_FRACTIONAL_PART) - 1)
+
+#define GET_INTEGER_PART(x) \
+	((x) >> FIXED31_32_BITS_PER_FRACTIONAL_PART)
+
+#define GET_FRACTIONAL_PART(x) \
+	(FRACTIONAL_PART_MASK & (x))
+
+struct spl_fixed31_32 spl_fixpt_from_fraction(long long numerator, long long denominator)
+{
+	struct spl_fixed31_32 res;
+
+	bool arg1_negative = numerator < 0;
+	bool arg2_negative = denominator < 0;
+
+	unsigned long long arg1_value = arg1_negative ? -numerator : numerator;
+	unsigned long long arg2_value = arg2_negative ? -denominator : denominator;
+
+	unsigned long long remainder;
+
+	/* determine integer part */
+
+	unsigned long long res_value = spl_complete_integer_division_u64(
+		arg1_value, arg2_value, &remainder);
+
+	SPL_ASSERT(res_value <= (unsigned long long)LONG_MAX);
+
+	/* determine fractional part */
+	{
+		unsigned int i = FIXED31_32_BITS_PER_FRACTIONAL_PART;
+
+		do {
+			remainder <<= 1;
+
+			res_value <<= 1;
+
+			if (remainder >= arg2_value) {
+				res_value |= 1;
+				remainder -= arg2_value;
+			}
+		} while (--i != 0);
+	}
+
+	/* round up LSB */
+	{
+		unsigned long long summand = (remainder << 1) >= arg2_value;
+
+		SPL_ASSERT(res_value <= (unsigned long long)LLONG_MAX - summand);
+
+		res_value += summand;
+	}
+
+	res.value = (long long)res_value;
+
+	if (arg1_negative ^ arg2_negative)
+		res.value = -res.value;
+
+	return res;
+}
+
+struct spl_fixed31_32 spl_fixpt_mul(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	struct spl_fixed31_32 res;
+
+	bool arg1_negative = arg1.value < 0;
+	bool arg2_negative = arg2.value < 0;
+
+	unsigned long long arg1_value = arg1_negative ? -arg1.value : arg1.value;
+	unsigned long long arg2_value = arg2_negative ? -arg2.value : arg2.value;
+
+	unsigned long long arg1_int = GET_INTEGER_PART(arg1_value);
+	unsigned long long arg2_int = GET_INTEGER_PART(arg2_value);
+
+	unsigned long long arg1_fra = GET_FRACTIONAL_PART(arg1_value);
+	unsigned long long arg2_fra = GET_FRACTIONAL_PART(arg2_value);
+
+	unsigned long long tmp;
+
+	res.value = arg1_int * arg2_int;
+
+	SPL_ASSERT(res.value <= (long long)LONG_MAX);
+
+	res.value <<= FIXED31_32_BITS_PER_FRACTIONAL_PART;
+
+	tmp = arg1_int * arg2_fra;
+
+	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
+
+	res.value += tmp;
+
+	tmp = arg2_int * arg1_fra;
+
+	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
+
+	res.value += tmp;
+
+	tmp = arg1_fra * arg2_fra;
+
+	tmp = (tmp >> FIXED31_32_BITS_PER_FRACTIONAL_PART) +
+		(tmp >= (unsigned long long)spl_fixpt_half.value);
+
+	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
+
+	res.value += tmp;
+
+	if (arg1_negative ^ arg2_negative)
+		res.value = -res.value;
+
+	return res;
+}
+
+struct spl_fixed31_32 spl_fixpt_sqr(struct spl_fixed31_32 arg)
+{
+	struct spl_fixed31_32 res;
+
+	unsigned long long arg_value = abs_i64(arg.value);
+
+	unsigned long long arg_int = GET_INTEGER_PART(arg_value);
+
+	unsigned long long arg_fra = GET_FRACTIONAL_PART(arg_value);
+
+	unsigned long long tmp;
+
+	res.value = arg_int * arg_int;
+
+	SPL_ASSERT(res.value <= (long long)LONG_MAX);
+
+	res.value <<= FIXED31_32_BITS_PER_FRACTIONAL_PART;
+
+	tmp = arg_int * arg_fra;
+
+	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
+
+	res.value += tmp;
+
+	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
+
+	res.value += tmp;
+
+	tmp = arg_fra * arg_fra;
+
+	tmp = (tmp >> FIXED31_32_BITS_PER_FRACTIONAL_PART) +
+		(tmp >= (unsigned long long)spl_fixpt_half.value);
+
+	SPL_ASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));
+
+	res.value += tmp;
+
+	return res;
+}
+
+struct spl_fixed31_32 spl_fixpt_recip(struct spl_fixed31_32 arg)
+{
+	/*
+	 * @note
+	 * Good idea to use Newton's method
+	 */
+
+	SPL_ASSERT(arg.value);
+
+	return spl_fixpt_from_fraction(
+		spl_fixpt_one.value,
+		arg.value);
+}
+
+struct spl_fixed31_32 spl_fixpt_sinc(struct spl_fixed31_32 arg)
+{
+	struct spl_fixed31_32 square;
+
+	struct spl_fixed31_32 res = spl_fixpt_one;
+
+	int n = 27;
+
+	struct spl_fixed31_32 arg_norm = arg;
+
+	if (spl_fixpt_le(
+		spl_fixpt_two_pi,
+		spl_fixpt_abs(arg))) {
+		arg_norm = spl_fixpt_sub(
+			arg_norm,
+			spl_fixpt_mul_int(
+				spl_fixpt_two_pi,
+				(int)spl_div64_s64(
+					arg_norm.value,
+					spl_fixpt_two_pi.value)));
+	}
+
+	square = spl_fixpt_sqr(arg_norm);
+
+	do {
+		res = spl_fixpt_sub(
+			spl_fixpt_one,
+			spl_fixpt_div_int(
+				spl_fixpt_mul(
+					square,
+					res),
+				n * (n - 1)));
+
+		n -= 2;
+	} while (n > 2);
+
+	if (arg.value != arg_norm.value)
+		res = spl_fixpt_div(
+			spl_fixpt_mul(res, arg_norm),
+			arg);
+
+	return res;
+}
+
+struct spl_fixed31_32 spl_fixpt_sin(struct spl_fixed31_32 arg)
+{
+	return spl_fixpt_mul(
+		arg,
+		spl_fixpt_sinc(arg));
+}
+
+struct spl_fixed31_32 spl_fixpt_cos(struct spl_fixed31_32 arg)
+{
+	/* TODO implement argument normalization */
+
+	const struct spl_fixed31_32 square = spl_fixpt_sqr(arg);
+
+	struct spl_fixed31_32 res = spl_fixpt_one;
+
+	int n = 26;
+
+	do {
+		res = spl_fixpt_sub(
+			spl_fixpt_one,
+			spl_fixpt_div_int(
+				spl_fixpt_mul(
+					square,
+					res),
+				n * (n - 1)));
+
+		n -= 2;
+	} while (n != 0);
+
+	return res;
+}
+
+/*
+ * @brief
+ * result = exp(arg),
+ * where abs(arg) < 1
+ *
+ * Calculated as Taylor series.
+ */
+static struct spl_fixed31_32 spl_fixed31_32_exp_from_taylor_series(struct spl_fixed31_32 arg)
+{
+	unsigned int n = 9;
+
+	struct spl_fixed31_32 res = spl_fixpt_from_fraction(
+		n + 2,
+		n + 1);
+	/* TODO find correct res */
+
+	SPL_ASSERT(spl_fixpt_lt(arg, spl_fixpt_one));
+
+	do
+		res = spl_fixpt_add(
+			spl_fixpt_one,
+			spl_fixpt_div_int(
+				spl_fixpt_mul(
+					arg,
+					res),
+				n));
+	while (--n != 1);
+
+	return spl_fixpt_add(
+		spl_fixpt_one,
+		spl_fixpt_mul(
+			arg,
+			res));
+}
+
+struct spl_fixed31_32 spl_fixpt_exp(struct spl_fixed31_32 arg)
+{
+	/*
+	 * @brief
+	 * Main equation is:
+	 * exp(x) = exp(r + m * ln(2)) = (1 << m) * exp(r),
+	 * where m = round(x / ln(2)), r = x - m * ln(2)
+	 */
+
+	if (spl_fixpt_le(
+		spl_fixpt_ln2_div_2,
+		spl_fixpt_abs(arg))) {
+		int m = spl_fixpt_round(
+			spl_fixpt_div(
+				arg,
+				spl_fixpt_ln2));
+
+		struct spl_fixed31_32 r = spl_fixpt_sub(
+			arg,
+			spl_fixpt_mul_int(
+				spl_fixpt_ln2,
+				m));
+
+		SPL_ASSERT(m != 0);
+
+		SPL_ASSERT(spl_fixpt_lt(
+			spl_fixpt_abs(r),
+			spl_fixpt_one));
+
+		if (m > 0)
+			return spl_fixpt_shl(
+				spl_fixed31_32_exp_from_taylor_series(r),
+				(unsigned char)m);
+		else
+			return spl_fixpt_div_int(
+				spl_fixed31_32_exp_from_taylor_series(r),
+				1LL << -m);
+	} else if (arg.value != 0)
+		return spl_fixed31_32_exp_from_taylor_series(arg);
+	else
+		return spl_fixpt_one;
+}
+
+struct spl_fixed31_32 spl_fixpt_log(struct spl_fixed31_32 arg)
+{
+	struct spl_fixed31_32 res = spl_fixpt_neg(spl_fixpt_one);
+	/* TODO improve 1st estimation */
+
+	struct spl_fixed31_32 error;
+
+	SPL_ASSERT(arg.value > 0);
+	/* TODO if arg is negative, return NaN */
+	/* TODO if arg is zero, return -INF */
+
+	do {
+		struct spl_fixed31_32 res1 = spl_fixpt_add(
+			spl_fixpt_sub(
+				res,
+				spl_fixpt_one),
+			spl_fixpt_div(
+				arg,
+				spl_fixpt_exp(res)));
+
+		error = spl_fixpt_sub(
+			res,
+			res1);
+
+		res = res1;
+		/* TODO determine max_allowed_error based on quality of exp() */
+	} while (abs_i64(error.value) > 100ULL);
+
+	return res;
+}
+
+
+/* this function is a generic helper to translate fixed point value to
+ * specified integer format that will consist of integer_bits integer part and
+ * fractional_bits fractional part. For example it is used in
+ * spl_fixpt_u2d19 to receive 2 bits integer part and 19 bits fractional
+ * part in 32 bits. It is used in hw programming (scaler)
+ */
+
+static inline unsigned int spl_ux_dy(
+	long long value,
+	unsigned int integer_bits,
+	unsigned int fractional_bits)
+{
+	/* 1. create mask of integer part */
+	unsigned int result = (1 << integer_bits) - 1;
+	/* 2. mask out fractional part */
+	unsigned int fractional_part = FRACTIONAL_PART_MASK & value;
+	/* 3. shrink fixed point integer part to be of integer_bits width*/
+	result &= GET_INTEGER_PART(value);
+	/* 4. make space for fractional part to be filled in after integer */
+	result <<= fractional_bits;
+	/* 5. shrink fixed point fractional part to of fractional_bits width*/
+	fractional_part >>= FIXED31_32_BITS_PER_FRACTIONAL_PART - fractional_bits;
+	/* 6. merge the result */
+	return result | fractional_part;
+}
+
+static inline unsigned int spl_clamp_ux_dy(
+	long long value,
+	unsigned int integer_bits,
+	unsigned int fractional_bits,
+	unsigned int min_clamp)
+{
+	unsigned int truncated_val = spl_ux_dy(value, integer_bits, fractional_bits);
+
+	if (value >= (1LL << (integer_bits + FIXED31_32_BITS_PER_FRACTIONAL_PART)))
+		return (1 << (integer_bits + fractional_bits)) - 1;
+	else if (truncated_val > min_clamp)
+		return truncated_val;
+	else
+		return min_clamp;
+}
+
+unsigned int spl_fixpt_u4d19(struct spl_fixed31_32 arg)
+{
+	return spl_ux_dy(arg.value, 4, 19);
+}
+
+unsigned int spl_fixpt_u3d19(struct spl_fixed31_32 arg)
+{
+	return spl_ux_dy(arg.value, 3, 19);
+}
+
+unsigned int spl_fixpt_u2d19(struct spl_fixed31_32 arg)
+{
+	return spl_ux_dy(arg.value, 2, 19);
+}
+
+unsigned int spl_fixpt_u0d19(struct spl_fixed31_32 arg)
+{
+	return spl_ux_dy(arg.value, 0, 19);
+}
+
+unsigned int spl_fixpt_clamp_u0d14(struct spl_fixed31_32 arg)
+{
+	return spl_clamp_ux_dy(arg.value, 0, 14, 1);
+}
+
+unsigned int spl_fixpt_clamp_u0d10(struct spl_fixed31_32 arg)
+{
+	return spl_clamp_ux_dy(arg.value, 0, 10, 1);
+}
+
+int spl_fixpt_s4d19(struct spl_fixed31_32 arg)
+{
+	if (arg.value < 0)
+		return -(int)spl_ux_dy(spl_fixpt_abs(arg).value, 4, 19);
+	else
+		return spl_ux_dy(arg.value, 4, 19);
+}
+
+struct spl_fixed31_32 spl_fixpt_from_ux_dy(unsigned int value,
+	unsigned int integer_bits,
+	unsigned int fractional_bits)
+{
+	struct spl_fixed31_32 fixpt_value = spl_fixpt_zero;
+	struct spl_fixed31_32 fixpt_int_value = spl_fixpt_zero;
+	long long frac_mask = ((long long)1 << (long long)integer_bits) - 1;
+
+	fixpt_value.value = (long long)value << (FIXED31_32_BITS_PER_FRACTIONAL_PART - fractional_bits);
+	frac_mask = frac_mask << fractional_bits;
+	fixpt_int_value.value = value & frac_mask;
+	fixpt_int_value.value <<= (FIXED31_32_BITS_PER_FRACTIONAL_PART - fractional_bits);
+	fixpt_value.value |= fixpt_int_value.value;
+	return fixpt_value;
+}
+
+struct spl_fixed31_32 spl_fixpt_from_int_dy(unsigned int int_value,
+	unsigned int frac_value,
+	unsigned int integer_bits,
+	unsigned int fractional_bits)
+{
+	struct spl_fixed31_32 fixpt_value = spl_fixpt_from_int(int_value);
+
+	fixpt_value.value |= (long long)frac_value << (FIXED31_32_BITS_PER_FRACTIONAL_PART - fractional_bits);
+	return fixpt_value;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/spl_fixpt31_32.h b/drivers/gpu/drm/amd/display/dc/sspl/spl_fixpt31_32.h
new file mode 100644
index 000000000000..ed2647f9a099
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/spl_fixpt31_32.h
@@ -0,0 +1,522 @@
+/* SPDX-License-Identifier: MIT */
+
+/* Copyright 2024 Advanced Micro Devices, Inc. */
+
+#ifndef __SPL_FIXED31_32_H__
+#define __SPL_FIXED31_32_H__
+
+#include "spl_debug.h"
+#include "spl_os_types.h"   // swap
+
+#ifndef LLONG_MAX
+#define LLONG_MAX 9223372036854775807ll
+#endif
+#ifndef LLONG_MIN
+#define LLONG_MIN (-LLONG_MAX - 1ll)
+#endif
+
+#define FIXED31_32_BITS_PER_FRACTIONAL_PART 32
+#ifndef LLONG_MIN
+#define LLONG_MIN (1LL<<63)
+#endif
+#ifndef LLONG_MAX
+#define LLONG_MAX (-1LL>>1)
+#endif
+
+/*
+ * @brief
+ * Arithmetic operations on real numbers
+ * represented as fixed-point numbers.
+ * There are: 1 bit for sign,
+ * 31 bit for integer part,
+ * 32 bits for fractional part.
+ *
+ * @note
+ * Currently, overflows and underflows are asserted;
+ * no special result returned.
+ */
+
+struct spl_fixed31_32 {
+	long long value;
+};
+
+
+/*
+ * @brief
+ * Useful constants
+ */
+
+static const struct spl_fixed31_32 spl_fixpt_zero = { 0 };
+static const struct spl_fixed31_32 spl_fixpt_epsilon = { 1LL };
+static const struct spl_fixed31_32 spl_fixpt_half = { 0x80000000LL };
+static const struct spl_fixed31_32 spl_fixpt_one = { 0x100000000LL };
+
+/*
+ * @brief
+ * Initialization routines
+ */
+
+/*
+ * @brief
+ * result = numerator / denominator
+ */
+struct spl_fixed31_32 spl_fixpt_from_fraction(long long numerator, long long denominator);
+
+/*
+ * @brief
+ * result = arg
+ */
+static inline struct spl_fixed31_32 spl_fixpt_from_int(int arg)
+{
+	struct spl_fixed31_32 res;
+
+	res.value = (long long) arg << FIXED31_32_BITS_PER_FRACTIONAL_PART;
+
+	return res;
+}
+
+/*
+ * @brief
+ * Unary operators
+ */
+
+/*
+ * @brief
+ * result = -arg
+ */
+static inline struct spl_fixed31_32 spl_fixpt_neg(struct spl_fixed31_32 arg)
+{
+	struct spl_fixed31_32 res;
+
+	res.value = -arg.value;
+
+	return res;
+}
+
+/*
+ * @brief
+ * result = abs(arg) := (arg >= 0) ? arg : -arg
+ */
+static inline struct spl_fixed31_32 spl_fixpt_abs(struct spl_fixed31_32 arg)
+{
+	if (arg.value < 0)
+		return spl_fixpt_neg(arg);
+	else
+		return arg;
+}
+
+/*
+ * @brief
+ * Binary relational operators
+ */
+
+/*
+ * @brief
+ * result = arg1 < arg2
+ */
+static inline bool spl_fixpt_lt(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	return arg1.value < arg2.value;
+}
+
+/*
+ * @brief
+ * result = arg1 <= arg2
+ */
+static inline bool spl_fixpt_le(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	return arg1.value <= arg2.value;
+}
+
+/*
+ * @brief
+ * result = arg1 == arg2
+ */
+static inline bool spl_fixpt_eq(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	return arg1.value == arg2.value;
+}
+
+/*
+ * @brief
+ * result = min(arg1, arg2) := (arg1 <= arg2) ? arg1 : arg2
+ */
+static inline struct spl_fixed31_32 spl_fixpt_min(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	if (arg1.value <= arg2.value)
+		return arg1;
+	else
+		return arg2;
+}
+
+/*
+ * @brief
+ * result = max(arg1, arg2) := (arg1 <= arg2) ? arg2 : arg1
+ */
+static inline struct spl_fixed31_32 spl_fixpt_max(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	if (arg1.value <= arg2.value)
+		return arg2;
+	else
+		return arg1;
+}
+
+/*
+ * @brief
+ *          | min_value, when arg <= min_value
+ * result = | arg, when min_value < arg < max_value
+ *          | max_value, when arg >= max_value
+ */
+static inline struct spl_fixed31_32 spl_fixpt_clamp(
+	struct spl_fixed31_32 arg,
+	struct spl_fixed31_32 min_value,
+	struct spl_fixed31_32 max_value)
+{
+	if (spl_fixpt_le(arg, min_value))
+		return min_value;
+	else if (spl_fixpt_le(max_value, arg))
+		return max_value;
+	else
+		return arg;
+}
+
+/*
+ * @brief
+ * Binary shift operators
+ */
+
+/*
+ * @brief
+ * result = arg << shift
+ */
+static inline struct spl_fixed31_32 spl_fixpt_shl(struct spl_fixed31_32 arg, unsigned char shift)
+{
+	SPL_ASSERT(((arg.value >= 0) && (arg.value <= LLONG_MAX >> shift)) ||
+		((arg.value < 0) && (arg.value >= ~(LLONG_MAX >> shift))));
+
+	arg.value = arg.value << shift;
+
+	return arg;
+}
+
+/*
+ * @brief
+ * result = arg >> shift
+ */
+static inline struct spl_fixed31_32 spl_fixpt_shr(struct spl_fixed31_32 arg, unsigned char shift)
+{
+	bool negative = arg.value < 0;
+
+	if (negative)
+		arg.value = -arg.value;
+	arg.value = arg.value >> shift;
+	if (negative)
+		arg.value = -arg.value;
+	return arg;
+}
+
+/*
+ * @brief
+ * Binary additive operators
+ */
+
+/*
+ * @brief
+ * result = arg1 + arg2
+ */
+static inline struct spl_fixed31_32 spl_fixpt_add(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	struct spl_fixed31_32 res;
+
+	SPL_ASSERT(((arg1.value >= 0) && (LLONG_MAX - arg1.value >= arg2.value)) ||
+		((arg1.value < 0) && (LLONG_MIN - arg1.value <= arg2.value)));
+
+	res.value = arg1.value + arg2.value;
+
+	return res;
+}
+
+/*
+ * @brief
+ * result = arg1 + arg2
+ */
+static inline struct spl_fixed31_32 spl_fixpt_add_int(struct spl_fixed31_32 arg1, int arg2)
+{
+	return spl_fixpt_add(arg1, spl_fixpt_from_int(arg2));
+}
+
+/*
+ * @brief
+ * result = arg1 - arg2
+ */
+static inline struct spl_fixed31_32 spl_fixpt_sub(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	struct spl_fixed31_32 res;
+
+	SPL_ASSERT(((arg2.value >= 0) && (LLONG_MIN + arg2.value <= arg1.value)) ||
+		((arg2.value < 0) && (LLONG_MAX + arg2.value >= arg1.value)));
+
+	res.value = arg1.value - arg2.value;
+
+	return res;
+}
+
+/*
+ * @brief
+ * result = arg1 - arg2
+ */
+static inline struct spl_fixed31_32 spl_fixpt_sub_int(struct spl_fixed31_32 arg1, int arg2)
+{
+	return spl_fixpt_sub(arg1, spl_fixpt_from_int(arg2));
+}
+
+
+/*
+ * @brief
+ * Binary multiplicative operators
+ */
+
+/*
+ * @brief
+ * result = arg1 * arg2
+ */
+struct spl_fixed31_32 spl_fixpt_mul(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2);
+
+
+/*
+ * @brief
+ * result = arg1 * arg2
+ */
+static inline struct spl_fixed31_32 spl_fixpt_mul_int(struct spl_fixed31_32 arg1, int arg2)
+{
+	return spl_fixpt_mul(arg1, spl_fixpt_from_int(arg2));
+}
+
+/*
+ * @brief
+ * result = square(arg) := arg * arg
+ */
+struct spl_fixed31_32 spl_fixpt_sqr(struct spl_fixed31_32 arg);
+
+/*
+ * @brief
+ * result = arg1 / arg2
+ */
+static inline struct spl_fixed31_32 spl_fixpt_div_int(struct spl_fixed31_32 arg1, long long arg2)
+{
+	return spl_fixpt_from_fraction(arg1.value, spl_fixpt_from_int((int)arg2).value);
+}
+
+/*
+ * @brief
+ * result = arg1 / arg2
+ */
+static inline struct spl_fixed31_32 spl_fixpt_div(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	return spl_fixpt_from_fraction(arg1.value, arg2.value);
+}
+
+/*
+ * @brief
+ * Reciprocal function
+ */
+
+/*
+ * @brief
+ * result = reciprocal(arg) := 1 / arg
+ *
+ * @note
+ * No special actions taken in case argument is zero.
+ */
+struct spl_fixed31_32 spl_fixpt_recip(struct spl_fixed31_32 arg);
+
+/*
+ * @brief
+ * Trigonometric functions
+ */
+
+/*
+ * @brief
+ * result = sinc(arg) := sin(arg) / arg
+ *
+ * @note
+ * Argument specified in radians,
+ * internally it's normalized to [-2pi...2pi] range.
+ */
+struct spl_fixed31_32 spl_fixpt_sinc(struct spl_fixed31_32 arg);
+
+/*
+ * @brief
+ * result = sin(arg)
+ *
+ * @note
+ * Argument specified in radians,
+ * internally it's normalized to [-2pi...2pi] range.
+ */
+struct spl_fixed31_32 spl_fixpt_sin(struct spl_fixed31_32 arg);
+
+/*
+ * @brief
+ * result = cos(arg)
+ *
+ * @note
+ * Argument specified in radians
+ * and should be in [-2pi...2pi] range -
+ * passing arguments outside that range
+ * will cause incorrect result!
+ */
+struct spl_fixed31_32 spl_fixpt_cos(struct spl_fixed31_32 arg);
+
+/*
+ * @brief
+ * Transcendent functions
+ */
+
+/*
+ * @brief
+ * result = exp(arg)
+ *
+ * @note
+ * Currently, function is verified for abs(arg) <= 1.
+ */
+struct spl_fixed31_32 spl_fixpt_exp(struct spl_fixed31_32 arg);
+
+/*
+ * @brief
+ * result = log(arg)
+ *
+ * @note
+ * Currently, abs(arg) should be less than 1.
+ * No normalization is done.
+ * Currently, no special actions taken
+ * in case of invalid argument(s). Take care!
+ */
+struct spl_fixed31_32 spl_fixpt_log(struct spl_fixed31_32 arg);
+
+/*
+ * @brief
+ * Power function
+ */
+
+/*
+ * @brief
+ * result = pow(arg1, arg2)
+ *
+ * @note
+ * Currently, abs(arg1) should be less than 1. Take care!
+ */
+static inline struct spl_fixed31_32 spl_fixpt_pow(struct spl_fixed31_32 arg1, struct spl_fixed31_32 arg2)
+{
+	if (arg1.value == 0)
+		return arg2.value == 0 ? spl_fixpt_one : spl_fixpt_zero;
+
+	return spl_fixpt_exp(
+		spl_fixpt_mul(
+			spl_fixpt_log(arg1),
+			arg2));
+}
+
+/*
+ * @brief
+ * Rounding functions
+ */
+
+/*
+ * @brief
+ * result = floor(arg) := greatest integer lower than or equal to arg
+ */
+static inline int spl_fixpt_floor(struct spl_fixed31_32 arg)
+{
+	unsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;
+
+	if (arg.value >= 0)
+		return (int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
+	else
+		return -(int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
+}
+
+/*
+ * @brief
+ * result = round(arg) := integer nearest to arg
+ */
+static inline int spl_fixpt_round(struct spl_fixed31_32 arg)
+{
+	unsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;
+
+	const long long summand = spl_fixpt_half.value;
+
+	SPL_ASSERT(LLONG_MAX - (long long)arg_value >= summand);
+
+	arg_value += summand;
+
+	if (arg.value >= 0)
+		return (int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
+	else
+		return -(int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
+}
+
+/*
+ * @brief
+ * result = ceil(arg) := lowest integer greater than or equal to arg
+ */
+static inline int spl_fixpt_ceil(struct spl_fixed31_32 arg)
+{
+	unsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;
+
+	const long long summand = spl_fixpt_one.value -
+		spl_fixpt_epsilon.value;
+
+	SPL_ASSERT(LLONG_MAX - (long long)arg_value >= summand);
+
+	arg_value += summand;
+
+	if (arg.value >= 0)
+		return (int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
+	else
+		return -(int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);
+}
+
+/* the following two function are used in scaler hw programming to convert fixed
+ * point value to format 2 bits from integer part and 19 bits from fractional
+ * part. The same applies for u0d19, 0 bits from integer part and 19 bits from
+ * fractional
+ */
+
+unsigned int spl_fixpt_u4d19(struct spl_fixed31_32 arg);
+
+unsigned int spl_fixpt_u3d19(struct spl_fixed31_32 arg);
+
+unsigned int spl_fixpt_u2d19(struct spl_fixed31_32 arg);
+
+unsigned int spl_fixpt_u0d19(struct spl_fixed31_32 arg);
+
+unsigned int spl_fixpt_clamp_u0d14(struct spl_fixed31_32 arg);
+
+unsigned int spl_fixpt_clamp_u0d10(struct spl_fixed31_32 arg);
+
+int spl_fixpt_s4d19(struct spl_fixed31_32 arg);
+
+static inline struct spl_fixed31_32 spl_fixpt_truncate(struct spl_fixed31_32 arg, unsigned int frac_bits)
+{
+	bool negative = arg.value < 0;
+
+	if (frac_bits >= FIXED31_32_BITS_PER_FRACTIONAL_PART) {
+		SPL_ASSERT(frac_bits == FIXED31_32_BITS_PER_FRACTIONAL_PART);
+		return arg;
+	}
+
+	if (negative)
+		arg.value = -arg.value;
+	arg.value &= (~0ULL) << (FIXED31_32_BITS_PER_FRACTIONAL_PART - frac_bits);
+	if (negative)
+		arg.value = -arg.value;
+	return arg;
+}
+
+struct spl_fixed31_32 spl_fixpt_from_ux_dy(unsigned int value, unsigned int integer_bits, unsigned int fractional_bits);
+struct spl_fixed31_32 spl_fixpt_from_int_dy(unsigned int int_value,
+		unsigned int frac_value,
+		unsigned int integer_bits,
+		unsigned int fractional_bits);
+
+#endif
diff --git a/drivers/gpu/drm/amd/display/dc/sspl/spl_os_types.h b/drivers/gpu/drm/amd/display/dc/sspl/spl_os_types.h
new file mode 100644
index 000000000000..2e6ba71960ac
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/sspl/spl_os_types.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: MIT */
+
+/* Copyright 2024 Advanced Micro Devices, Inc. */
+/* Copyright 2019 Raptor Engineering, LLC */
+
+#ifndef _SPL_OS_TYPES_H_
+#define _SPL_OS_TYPES_H_
+
+#include "spl_debug.h"
+
+#include <linux/slab.h>
+#include <linux/kgdb.h>
+#include <linux/kref.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+
+/*
+ *
+ * general debug capabilities
+ *
+ */
+
+static inline uint64_t spl_div_u64_rem(uint64_t dividend, uint32_t divisor, uint32_t *remainder)
+{
+	return div_u64_rem(dividend, divisor, remainder);
+}
+
+static inline uint64_t spl_div_u64(uint64_t dividend, uint32_t divisor)
+{
+	return div_u64(dividend, divisor);
+}
+
+static inline uint64_t spl_div64_u64(uint64_t dividend, uint64_t divisor)
+{
+	return div64_u64(dividend, divisor);
+}
+
+static inline uint64_t spl_div64_u64_rem(uint64_t dividend, uint64_t divisor, uint64_t *remainder)
+{
+	return div64_u64_rem(dividend, divisor, remainder);
+}
+
+static inline int64_t spl_div64_s64(int64_t dividend, int64_t divisor)
+{
+	return div64_s64(dividend, divisor);
+}
+
+#define spl_swap(a, b) \
+	do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)
+
+#ifndef spl_min
+#define spl_min(a, b)    (((a) < (b)) ? (a):(b))
+#endif
+
+#endif /* _SPL_OS_TYPES_H_ */
-- 
2.52.0

