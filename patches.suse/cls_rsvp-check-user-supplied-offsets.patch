From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 3 Jun 2024 00:21:56 +0200
Subject: cls_rsvp: check user supplied offsets
Patch-mainline: Never, code dropped in v6.3-rc1
References: CVE-2023-42755 bsc#1215702

RSVP classifier accesses and masks packet data at offsets provided by
userspace without any checks, allowing users to make the classifier access
data past allocated buffer. Limit the offset to 0-65535 range when
processing the netlink message and ignore entries which would access
offsets outside of available linear buffer. It's not perfect but these
entries would make no practical sense anyway.

This issue is known as CVE-2023-42755.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 net/sched/cls_rsvp.h | 10 ++++++++++
 1 file changed, 10 insertions(+)

--- a/net/sched/cls_rsvp.h
+++ b/net/sched/cls_rsvp.h
@@ -128,6 +128,7 @@ static int rsvp_classify(struct sk_buff *skb, const struct tcf_proto *tp,
 			 struct tcf_result *res)
 {
 	struct rsvp_head *head = rcu_dereference_bh(tp->root);
+	unsigned int xprt_offset;
 	struct rsvp_session *s;
 	struct rsvp_filter *f;
 	unsigned int h1, h2;
@@ -163,12 +164,15 @@ static int rsvp_classify(struct sk_buff *skb, const struct tcf_proto *tp,
 	if (ip_is_fragment(nhptr))
 		return -1;
 #endif
+	xprt_offset = xprt - (u8 *)nhptr;
 
 	h1 = hash_dst(dst, protocol, tunnelid);
 	h2 = hash_src(src);
 
 	for (s = rcu_dereference_bh(head->ht[h1]); s;
 	     s = rcu_dereference_bh(s->next)) {
+		if (!pskb_network_may_pull(skb, xprt_offset + s->dpi.offset))
+			continue;
 		if (dst[RSVP_DST_LEN-1] == s->dst[RSVP_DST_LEN - 1] &&
 		    protocol == s->protocol &&
 		    !(s->dpi.mask &
@@ -182,6 +186,8 @@ static int rsvp_classify(struct sk_buff *skb, const struct tcf_proto *tp,
 
 			for (f = rcu_dereference_bh(s->ht[h2]); f;
 			     f = rcu_dereference_bh(f->next)) {
+				if (!pskb_network_may_pull(skb, xprt_offset + f->spi.offset))
+					continue;
 				if (src[RSVP_DST_LEN-1] == f->src[RSVP_DST_LEN - 1] &&
 				    !(f->spi.mask & (*(u32 *)(xprt + f->spi.offset) ^ f->spi.key))
 #if RSVP_DST_LEN == 4
@@ -556,6 +562,10 @@ static int rsvp_change(struct net *net, struct sk_buff *in_skb,
 	}
 	if (tb[TCA_RSVP_PINFO]) {
 		pinfo = nla_data(tb[TCA_RSVP_PINFO]);
+		err = -EINVAL;
+		if (pinfo->spi.offset < 0 || pinfo->spi.offset > 65535 ||
+		    pinfo->dpi.offset < 0 || pinfo->dpi.offset > 65535)
+			goto errout;
 		f->spi = pinfo->spi;
 		f->tunnelhdr = pinfo->tunnelhdr;
 	}
