From 04ae08596737c4d3872dfb6e617c918d9ecf073e Mon Sep 17 00:00:00 2001
From: Charles Keepax <ckeepax@opensource.cirrus.com>
Date: Mon, 13 Sep 2021 17:00:44 +0100
Subject: [PATCH] ASoC: wm_adsp: Switch to using wm_coeff_read_ctrl for compressed buffers
Git-commit: 04ae08596737c4d3872dfb6e617c918d9ecf073e
Patch-mainline: v5.16-rc1
References: bsc#1203699

When parsing a compressed buffer from the firmware the driver currently
open codes reading the firmware coefficient containing the buffer
description. Improve this slightly by using the coefficient read
functions already provided by the wm_adsp driver. It is worth noting
this change requires the running variable to be set before
wm_adsp_buffer_init is called, however this is safe, since its all still
under the power lock and nothing in the compressed code gates itself on
running.

Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Signed-off-by: Simon Trimmer <simont@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20210913160057.103842-4-simont@opensource.cirrus.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/codecs/wm_adsp.c | 24 +++++++-----------------
 1 file changed, 7 insertions(+), 17 deletions(-)

diff --git a/sound/soc/codecs/wm_adsp.c b/sound/soc/codecs/wm_adsp.c
index b300af6fdd41..9c3d4b96fd7c 100644
--- a/sound/soc/codecs/wm_adsp.c
+++ b/sound/soc/codecs/wm_adsp.c
@@ -3277,14 +3277,14 @@ int wm_adsp_event(struct snd_soc_dapm_widget *w,
 				goto err;
 		}
 
+		dsp->running = true;
+
 		if (wm_adsp_fw[dsp->fw].num_caps != 0) {
 			ret = wm_adsp_buffer_init(dsp);
 			if (ret < 0)
 				goto err;
 		}
 
-		dsp->running = true;
-
 		mutex_unlock(&dsp->pwr_lock);
 		break;
 
@@ -3869,26 +3869,21 @@ static int wm_adsp_buffer_parse_coeff(struct wm_coeff_ctl *ctl)
 {
 	struct wm_adsp_host_buf_coeff_v1 coeff_v1;
 	struct wm_adsp_compr_buf *buf;
-	unsigned int reg, version;
-	__be32 bufp;
+	unsigned int version;
 	int ret, i;
 
-	ret = wm_coeff_base_reg(ctl, &reg);
-	if (ret)
-		return ret;
-
 	for (i = 0; i < 5; ++i) {
-		ret = regmap_raw_read(ctl->dsp->regmap, reg, &bufp, sizeof(bufp));
+		ret = wm_coeff_read_ctrl(ctl, &coeff_v1, sizeof(coeff_v1));
 		if (ret < 0)
 			return ret;
 
-		if (bufp)
+		if (coeff_v1.host_buf_ptr)
 			break;
 
 		usleep_range(1000, 2000);
 	}
 
-	if (!bufp) {
+	if (!coeff_v1.host_buf_ptr) {
 		adsp_err(ctl->dsp, "Failed to acquire host buffer\n");
 		return -EIO;
 	}
@@ -3898,7 +3893,7 @@ static int wm_adsp_buffer_parse_coeff(struct wm_coeff_ctl *ctl)
 		return -ENOMEM;
 
 	buf->host_buf_mem_type = ctl->alg_region.type;
-	buf->host_buf_ptr = be32_to_cpu(bufp);
+	buf->host_buf_ptr = be32_to_cpu(coeff_v1.host_buf_ptr);
 
 	ret = wm_adsp_buffer_populate(buf);
 	if (ret < 0)
@@ -3913,11 +3908,6 @@ static int wm_adsp_buffer_parse_coeff(struct wm_coeff_ctl *ctl)
 		return 0;
 	}
 
-	ret = regmap_raw_read(ctl->dsp->regmap, reg, &coeff_v1,
-			      sizeof(coeff_v1));
-	if (ret < 0)
-		return ret;
-
 	version = be32_to_cpu(coeff_v1.versions) & HOST_BUF_COEFF_COMPAT_VER_MASK;
 	version >>= HOST_BUF_COEFF_COMPAT_VER_SHIFT;
 
-- 
2.35.3

