From 8a09bb1be67a54b1ab66272731faa0c04b9b675d Mon Sep 17 00:00:00 2001
From: Sakari Ailus <sakari.ailus@linux.intel.com>
Date: Thu, 2 May 2024 16:49:50 +0100
Subject: [PATCH] media: intel/ipu6: Don't re-allocate memory for firmware
Git-commit: 8a09bb1be67a54b1ab66272731faa0c04b9b675d
References: jsc#PED-10837
Patch-mainline: v6.10-rc1

The ipu6 driver allocated vmalloc memory for the firmware if
request_firmware() somehow managed not to use vmalloc to allocate it.

Still how the memory is allocated by request_firmware() is not specified
in its API, so be prepared for kmalloc-allocated firmware, too. Instead of
allocating new vmalloc-backed buffer for the firmware, obtain the pages
from virtual addresses instead.

Link: https://lore.kernel.org/linux-media/20240502154950.549015-1-sakari.ailus@linux.intel.com
Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
Closes: https://lore.kernel.org/all/20240501102236.3b2585d1@canb.auug.org.au/
Fixes: 25fedc021985 ("media: intel/ipu6: add Intel IPU6 PCI device driver")
Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
Signed-off-by: Oliver Neukum <oneukum@suse.com>

---
 drivers/media/pci/intel/ipu6/ipu6-buttress.c |  7 +++-
 drivers/media/pci/intel/ipu6/ipu6.c          | 41 +-------------------
 2 files changed, 7 insertions(+), 41 deletions(-)

diff --git a/drivers/media/pci/intel/ipu6/ipu6-buttress.c b/drivers/media/pci/intel/ipu6/ipu6-buttress.c
index dbcf1aa87872..23c537e7ce1e 100644
--- a/drivers/media/pci/intel/ipu6/ipu6-buttress.c
+++ b/drivers/media/pci/intel/ipu6/ipu6-buttress.c
@@ -552,12 +552,16 @@ int ipu6_buttress_reset_authentication(struct ipu6_device *isp)
 int ipu6_buttress_map_fw_image(struct ipu6_bus_device *sys,
 			       const struct firmware *fw, struct sg_table *sgt)
 {
+	bool is_vmalloc = is_vmalloc_addr(fw->data);
 	struct page **pages;
 	const void *addr;
 	unsigned long n_pages;
 	unsigned int i;
 	int ret;
 
+	if (!is_vmalloc && !virt_addr_valid(fw->data))
+		return -EDOM;
+
 	n_pages = PHYS_PFN(PAGE_ALIGN(fw->size));
 
 	pages = kmalloc_array(n_pages, sizeof(*pages), GFP_KERNEL);
@@ -566,7 +570,8 @@ int ipu6_buttress_map_fw_image(struct ipu6_bus_device *sys,
 
 	addr = fw->data;
 	for (i = 0; i < n_pages; i++) {
-		struct page *p = vmalloc_to_page(addr);
+		struct page *p = is_vmalloc ?
+			vmalloc_to_page(addr) : virt_to_page(addr);
 
 		if (!p) {
 			ret = -ENOMEM;
diff --git a/drivers/media/pci/intel/ipu6/ipu6.c b/drivers/media/pci/intel/ipu6/ipu6.c
index 7bcd9c5a381a..2cf04251c9e7 100644
--- a/drivers/media/pci/intel/ipu6/ipu6.c
+++ b/drivers/media/pci/intel/ipu6/ipu6.c
@@ -503,45 +503,6 @@ static void ipu6_configure_vc_mechanism(struct ipu6_device *isp)
 	writel(val, isp->base + BUTTRESS_REG_BTRS_CTRL);
 }
 
-static int request_cpd_fw(const struct firmware **firmware_p, const char *name,
-			  struct device *device)
-{
-	const struct firmware *fw;
-	struct firmware *dst;
-	int ret = 0;
-
-	ret = request_firmware(&fw, name, device);
-	if (ret)
-		return ret;
-
-	if (is_vmalloc_addr(fw->data)) {
-		*firmware_p = fw;
-		return 0;
-	}
-
-	dst = kzalloc(sizeof(*dst), GFP_KERNEL);
-	if (!dst) {
-		ret = -ENOMEM;
-		goto release_firmware;
-	}
-
-	dst->size = fw->size;
-	dst->data = vmalloc(fw->size);
-	if (!dst->data) {
-		kfree(dst);
-		ret = -ENOMEM;
-		goto release_firmware;
-	}
-
-	memcpy((void *)dst->data, fw->data, fw->size);
-	*firmware_p = dst;
-
-release_firmware:
-	release_firmware(fw);
-
-	return ret;
-}
-
 static int ipu6_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	struct ipu6_buttress_ctrl *isys_ctrl = NULL, *psys_ctrl = NULL;
@@ -627,7 +588,7 @@ static int ipu6_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (ret)
 		return ret;
 
-	ret = request_cpd_fw(&isp->cpd_fw, isp->cpd_fw_name, dev);
+	ret = request_firmware(&isp->cpd_fw, isp->cpd_fw_name, dev);
 	if (ret) {
 		dev_err_probe(&isp->pdev->dev, ret,
 			      "Requesting signed firmware %s failed\n",
-- 
2.47.1

