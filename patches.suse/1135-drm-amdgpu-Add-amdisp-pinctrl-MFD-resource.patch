From dce1b8239803c456e5c6a9f45164d16cf11e3470 Mon Sep 17 00:00:00 2001
From: Benjamin Chan <benjamin.chan@amd.com>
Date: Fri, 31 Jan 2025 14:03:46 -0500
Subject: drm/amdgpu: Add amdisp pinctrl MFD resource
Git-commit: dce1b8239803c456e5c6a9f45164d16cf11e3470
Patch-mainline: v6.15-rc1
References: jsc#PED-13979 jsc#PED-14039 jsc#PED-14046 jsc#PED-14211 jsc#PED-14333 jsc#PED-14487 jsc#PED-14488 jsc#PED-14497 jsc#PED-14499

AMDISP GPIO control uses a dedicated pinctrl driver,
and requires MFD hotadd GPIO resources.

Co-developed-by: Pratap Nirujogi <pratap.nirujogi@amd.com>
Signed-off-by: Benjamin Chan <benjamin.chan@amd.com>
Signed-off-by: Pratap Nirujogi <pratap.nirujogi@amd.com>
Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>

---
 drivers/gpu/drm/amd/amdgpu/amdgpu_isp.h |  1 +
 drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.c | 42 +++++++++++++++++--------
 drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.h |  4 +--
 drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.c | 39 ++++++++++++++++-------
 drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.h |  5 ++-
 5 files changed, 62 insertions(+), 29 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_isp.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_isp.h
index b03664c66dd6..4f3b7b5d9c1f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_isp.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_isp.h
@@ -50,6 +50,7 @@ struct amdgpu_isp {
 	struct mfd_cell *isp_cell;
 	struct resource *isp_res;
 	struct resource *isp_i2c_res;
+	struct resource *isp_gpio_res;
 	struct isp_platform_data *isp_pdata;
 	unsigned int harvest_config;
 	const struct firmware	*fw;
diff --git a/drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.c b/drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.c
index 2475564b2c08..0027a639c7e6 100644
--- a/drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.c
@@ -50,7 +50,7 @@ static int isp_v4_1_0_hw_init(struct amdgpu_isp *isp)
 
 	isp_base = adev->rmmio_base;
 
-	isp->isp_cell = kcalloc(2, sizeof(struct mfd_cell), GFP_KERNEL);
+	isp->isp_cell = kcalloc(3, sizeof(struct mfd_cell), GFP_KERNEL);
 	if (!isp->isp_cell) {
 		r = -ENOMEM;
 		drm_err(&adev->ddev,
@@ -58,7 +58,7 @@ static int isp_v4_1_0_hw_init(struct amdgpu_isp *isp)
 		goto failure;
 	}
 
-	num_res = MAX_ISP410_MEM_RES + MAX_ISP410_SENSOR_RES + MAX_ISP410_INT_SRC;
+	num_res = MAX_ISP410_MEM_RES + MAX_ISP410_INT_SRC;
 	isp->isp_res = kcalloc(num_res, sizeof(struct resource),
 			       GFP_KERNEL);
 	if (!isp->isp_res) {
@@ -91,14 +91,7 @@ static int isp_v4_1_0_hw_init(struct amdgpu_isp *isp)
 	isp->isp_res[1].start = isp_base + ISP410_PHY0_OFFSET;
 	isp->isp_res[1].end = isp_base + ISP410_PHY0_OFFSET + ISP410_PHY0_SIZE;
 
-	isp->isp_res[2].name = "isp_gpio_sensor0_reg";
-	isp->isp_res[2].flags = IORESOURCE_MEM;
-	isp->isp_res[2].start = isp_base + ISP410_GPIO_SENSOR0_OFFSET;
-	isp->isp_res[2].end = isp_base + ISP410_GPIO_SENSOR0_OFFSET +
-			      ISP410_GPIO_SENSOR0_SIZE;
-
-	for (idx = MAX_ISP410_MEM_RES + MAX_ISP410_SENSOR_RES, int_idx = 0;
-	     idx < num_res; idx++, int_idx++) {
+	for (idx = MAX_ISP410_MEM_RES, int_idx = 0; idx < num_res; idx++, int_idx++) {
 		isp->isp_res[idx].name = "isp_4_1_0_irq";
 		isp->isp_res[idx].flags = IORESOURCE_IRQ;
 		isp->isp_res[idx].start =
@@ -113,8 +106,8 @@ static int isp_v4_1_0_hw_init(struct amdgpu_isp *isp)
 	isp->isp_cell[0].platform_data = isp->isp_pdata;
 	isp->isp_cell[0].pdata_size = sizeof(struct isp_platform_data);
 
-	isp->isp_i2c_res = kcalloc(1, sizeof(struct resource),
-				   GFP_KERNEL);
+	/* initialize isp i2c platform data */
+	isp->isp_i2c_res = kcalloc(1, sizeof(struct resource), GFP_KERNEL);
 	if (!isp->isp_i2c_res) {
 		r = -ENOMEM;
 		drm_err(&adev->ddev,
@@ -133,7 +126,28 @@ static int isp_v4_1_0_hw_init(struct amdgpu_isp *isp)
 	isp->isp_cell[1].platform_data = isp->isp_pdata;
 	isp->isp_cell[1].pdata_size = sizeof(struct isp_platform_data);
 
-	r = mfd_add_hotplug_devices(isp->parent, isp->isp_cell, 2);
+	/* initialize isp gpiochip platform data */
+	isp->isp_gpio_res = kcalloc(1, sizeof(struct resource), GFP_KERNEL);
+	if (!isp->isp_gpio_res) {
+		r = -ENOMEM;
+		drm_err(&adev->ddev,
+			"%s: isp gpio res alloc failed\n", __func__);
+		goto failure;
+	}
+
+	isp->isp_gpio_res[0].name = "isp_gpio_reg";
+	isp->isp_gpio_res[0].flags = IORESOURCE_MEM;
+	isp->isp_gpio_res[0].start = isp_base + ISP410_GPIO_SENSOR_OFFSET;
+	isp->isp_gpio_res[0].end = isp_base + ISP410_GPIO_SENSOR_OFFSET +
+				   ISP410_GPIO_SENSOR_SIZE;
+
+	isp->isp_cell[2].name = "amdisp-pinctrl";
+	isp->isp_cell[2].num_resources = 1;
+	isp->isp_cell[2].resources = &isp->isp_gpio_res[0];
+	isp->isp_cell[2].platform_data = isp->isp_pdata;
+	isp->isp_cell[2].pdata_size = sizeof(struct isp_platform_data);
+
+	r = mfd_add_hotplug_devices(isp->parent, isp->isp_cell, 3);
 	if (r) {
 		drm_err(&adev->ddev,
 			"%s: add mfd hotplug device failed\n", __func__);
@@ -148,6 +162,7 @@ static int isp_v4_1_0_hw_init(struct amdgpu_isp *isp)
 	kfree(isp->isp_res);
 	kfree(isp->isp_cell);
 	kfree(isp->isp_i2c_res);
+	kfree(isp->isp_gpio_res);
 
 	return r;
 }
@@ -160,6 +175,7 @@ static int isp_v4_1_0_hw_fini(struct amdgpu_isp *isp)
 	kfree(isp->isp_cell);
 	kfree(isp->isp_pdata);
 	kfree(isp->isp_i2c_res);
+	kfree(isp->isp_gpio_res);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.h b/drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.h
index 7db24c0f1080..4d239198edd0 100644
--- a/drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/isp_v4_1_0.h
@@ -42,8 +42,8 @@
 #define ISP410_I2C0_OFFSET 0x66400
 #define ISP410_I2C0_SIZE 0x100
 
-#define ISP410_GPIO_SENSOR0_OFFSET 0x6613C
-#define ISP410_GPIO_SENSOR0_SIZE 0x4
+#define ISP410_GPIO_SENSOR_OFFSET 0x6613C
+#define ISP410_GPIO_SENSOR_SIZE 0x54
 
 void isp_v4_1_0_set_isp_funcs(struct amdgpu_isp *isp);
 
diff --git a/drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.c b/drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.c
index 3ee5942bc24d..69dd92f6e86d 100644
--- a/drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.c
+++ b/drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.c
@@ -50,7 +50,7 @@ static int isp_v4_1_1_hw_init(struct amdgpu_isp *isp)
 
 	isp_base = adev->rmmio_base;
 
-	isp->isp_cell = kcalloc(2, sizeof(struct mfd_cell), GFP_KERNEL);
+	isp->isp_cell = kcalloc(3, sizeof(struct mfd_cell), GFP_KERNEL);
 	if (!isp->isp_cell) {
 		r = -ENOMEM;
 		drm_err(&adev->ddev,
@@ -58,7 +58,7 @@ static int isp_v4_1_1_hw_init(struct amdgpu_isp *isp)
 		goto failure;
 	}
 
-	num_res = MAX_ISP411_MEM_RES + MAX_ISP411_SENSOR_RES + MAX_ISP411_INT_SRC;
+	num_res = MAX_ISP411_MEM_RES + MAX_ISP411_INT_SRC;
 
 	isp->isp_res = kcalloc(num_res, sizeof(struct resource),
 			       GFP_KERNEL);
@@ -92,14 +92,7 @@ static int isp_v4_1_1_hw_init(struct amdgpu_isp *isp)
 	isp->isp_res[1].start = isp_base + ISP411_PHY0_OFFSET;
 	isp->isp_res[1].end = isp_base + ISP411_PHY0_OFFSET + ISP411_PHY0_SIZE;
 
-	isp->isp_res[2].name = "isp_4_1_1_sensor0_reg";
-	isp->isp_res[2].flags = IORESOURCE_MEM;
-	isp->isp_res[2].start = isp_base + ISP411_GPIO_SENSOR0_OFFSET;
-	isp->isp_res[2].end = isp_base + ISP411_GPIO_SENSOR0_OFFSET +
-			      ISP411_GPIO_SENSOR0_SIZE;
-
-	for (idx = MAX_ISP411_MEM_RES + MAX_ISP411_SENSOR_RES, int_idx = 0;
-	     idx < num_res; idx++, int_idx++) {
+	for (idx = MAX_ISP411_MEM_RES, int_idx = 0; idx < num_res; idx++, int_idx++) {
 		isp->isp_res[idx].name = "isp_4_1_1_irq";
 		isp->isp_res[idx].flags = IORESOURCE_IRQ;
 		isp->isp_res[idx].start =
@@ -114,6 +107,7 @@ static int isp_v4_1_1_hw_init(struct amdgpu_isp *isp)
 	isp->isp_cell[0].platform_data = isp->isp_pdata;
 	isp->isp_cell[0].pdata_size = sizeof(struct isp_platform_data);
 
+	/* initialize isp i2c platform data */
 	isp->isp_i2c_res = kcalloc(1, sizeof(struct resource), GFP_KERNEL);
 	if (!isp->isp_i2c_res) {
 		r = -ENOMEM;
@@ -133,7 +127,28 @@ static int isp_v4_1_1_hw_init(struct amdgpu_isp *isp)
 	isp->isp_cell[1].platform_data = isp->isp_pdata;
 	isp->isp_cell[1].pdata_size = sizeof(struct isp_platform_data);
 
-	r = mfd_add_hotplug_devices(isp->parent, isp->isp_cell, 2);
+	/* initialize isp gpiochip platform data */
+	isp->isp_gpio_res = kcalloc(1, sizeof(struct resource), GFP_KERNEL);
+	if (!isp->isp_gpio_res) {
+		r = -ENOMEM;
+		drm_err(&adev->ddev,
+			"%s: isp gpio res alloc failed\n", __func__);
+		goto failure;
+	}
+
+	isp->isp_gpio_res[0].name = "isp_gpio_reg";
+	isp->isp_gpio_res[0].flags = IORESOURCE_MEM;
+	isp->isp_gpio_res[0].start = isp_base + ISP411_GPIO_SENSOR_OFFSET;
+	isp->isp_gpio_res[0].end = isp_base + ISP411_GPIO_SENSOR_OFFSET +
+				   ISP411_GPIO_SENSOR_SIZE;
+
+	isp->isp_cell[2].name = "amdisp-pinctrl";
+	isp->isp_cell[2].num_resources = 1;
+	isp->isp_cell[2].resources = &isp->isp_gpio_res[0];
+	isp->isp_cell[2].platform_data = isp->isp_pdata;
+	isp->isp_cell[2].pdata_size = sizeof(struct isp_platform_data);
+
+	r = mfd_add_hotplug_devices(isp->parent, isp->isp_cell, 3);
 	if (r) {
 		drm_err(&adev->ddev,
 			"%s: add mfd hotplug device failed\n", __func__);
@@ -148,6 +163,7 @@ static int isp_v4_1_1_hw_init(struct amdgpu_isp *isp)
 	kfree(isp->isp_res);
 	kfree(isp->isp_cell);
 	kfree(isp->isp_i2c_res);
+	kfree(isp->isp_gpio_res);
 
 	return r;
 }
@@ -160,6 +176,7 @@ static int isp_v4_1_1_hw_fini(struct amdgpu_isp *isp)
 	kfree(isp->isp_cell);
 	kfree(isp->isp_pdata);
 	kfree(isp->isp_i2c_res);
+	kfree(isp->isp_gpio_res);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.h b/drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.h
index 40887ddeb08c..fe45d70d87f1 100644
--- a/drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.h
+++ b/drivers/gpu/drm/amd/amdgpu/isp_v4_1_1.h
@@ -33,7 +33,6 @@
 #include "ivsrcid/isp/irqsrcs_isp_4_1.h"
 
 #define MAX_ISP411_MEM_RES 2
-#define MAX_ISP411_SENSOR_RES 1
 #define MAX_ISP411_INT_SRC 8
 
 #define ISP411_PHY0_OFFSET 0x66700
@@ -42,8 +41,8 @@
 #define ISP411_I2C0_OFFSET 0x66400
 #define ISP411_I2C0_SIZE 0x100
 
-#define ISP411_GPIO_SENSOR0_OFFSET 0x6613C
-#define ISP411_GPIO_SENSOR0_SIZE 0x4
+#define ISP411_GPIO_SENSOR_OFFSET 0x6613C
+#define ISP411_GPIO_SENSOR_SIZE 0x54
 
 void isp_v4_1_1_set_isp_funcs(struct amdgpu_isp *isp);
 
-- 
2.52.0

