From: Mario Limonciello <mario.limonciello@amd.com>
Date: Fri, 21 Apr 2023 09:07:24 -0500
Message-ID: <20230421140725.495-1-mario.limonciello@amd.com>
Subject: [PATCH] thunderbolt: Clear registers properly when auto clear isn't in use
Patch-mainline: Submitted, linux-usb ML
References: bsc#1210165

When `QUIRK_AUTO_CLEAR_INT` isn't set, interrupt masking should be
cleared by writing to Interrupt Mask Clear (IMR) and interrupt
status should be cleared properly at shutdown/init.

This fixes an error where interrupts are left enabled during resume
from hibernation with `CONFIG_USB4=y`.

Fixes: 468c49f44759 ("thunderbolt: Disable interrupt auto clear for rings")
Reported-by: Takashi Iwai <tiwai@suse.de>
Link: https://bugzilla.kernel.org/show_bug.cgi?id=217343
Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
Tested-by: Takashi Iwai <tiwai@suse.de>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/thunderbolt/nhi.c      | 28 +++++++++++++++++++++-------
 drivers/thunderbolt/nhi_regs.h |  1 +
 2 files changed, 22 insertions(+), 7 deletions(-)

diff --git a/drivers/thunderbolt/nhi.c b/drivers/thunderbolt/nhi.c
index cfebec107f3f..bc2060115610 100644
--- a/drivers/thunderbolt/nhi.c
+++ b/drivers/thunderbolt/nhi.c
@@ -61,8 +61,9 @@ static int ring_interrupt_index(const struct tb_ring *ring)
  */
 static void ring_interrupt_active(struct tb_ring *ring, bool active)
 {
-	int reg = REG_RING_INTERRUPT_BASE +
-		  ring_interrupt_index(ring) / 32 * 4;
+	int index = ring_interrupt_index(ring) / 32 * 4;
+	int reg = REG_RING_INTERRUPT_BASE + index;
+	int clear = REG_RING_INTERRUPT_MASK_CLEAR_BASE + index;
 	int interrupt_bit = ring_interrupt_index(ring) & 31;
 	int mask = 1 << interrupt_bit;
 	u32 old, new;
@@ -123,7 +124,11 @@ static void ring_interrupt_active(struct tb_ring *ring, bool active)
 					 "interrupt for %s %d is already %s\n",
 					 RING_TYPE(ring), ring->hop,
 					 active ? "enabled" : "disabled");
-	iowrite32(new, ring->nhi->iobase + reg);
+
+	if (active)
+		iowrite32(new, ring->nhi->iobase + reg);
+	else
+		iowrite32(mask, ring->nhi->iobase + clear);
 }
 
 /*
@@ -135,12 +140,21 @@ static void nhi_disable_interrupts(struct tb_nhi *nhi)
 {
 	int i = 0;
 	/* disable interrupts */
-	for (i = 0; i < RING_INTERRUPT_REG_COUNT(nhi); i++)
-		iowrite32(0, nhi->iobase + REG_RING_INTERRUPT_BASE + 4 * i);
+	for (i = 0; i < RING_INTERRUPT_REG_COUNT(nhi); i++) {
+		if (nhi->quirks & QUIRK_AUTO_CLEAR_INT)
+			iowrite32(0, nhi->iobase + REG_RING_INTERRUPT_BASE + 4 * i);
+		else
+			iowrite32(0xffffffff,
+				  nhi->iobase + REG_RING_INTERRUPT_MASK_CLEAR_BASE + 4 * i);
+	}
 
 	/* clear interrupt status bits */
-	for (i = 0; i < RING_NOTIFY_REG_COUNT(nhi); i++)
-		ioread32(nhi->iobase + REG_RING_NOTIFY_BASE + 4 * i);
+	for (i = 0; i < RING_NOTIFY_REG_COUNT(nhi); i++) {
+		if (nhi->quirks & QUIRK_AUTO_CLEAR_INT)
+			ioread32(nhi->iobase + REG_RING_NOTIFY_BASE + 4 * i);
+		else
+			iowrite32(0xffffffff, nhi->iobase + REG_RING_INT_CLEAR + 4 * i);
+	}
 }
 
 /* ring helper methods */
diff --git a/drivers/thunderbolt/nhi_regs.h b/drivers/thunderbolt/nhi_regs.h
index faef165a919c..db95ad5d2814 100644
--- a/drivers/thunderbolt/nhi_regs.h
+++ b/drivers/thunderbolt/nhi_regs.h
@@ -92,6 +92,7 @@ struct ring_desc {
  */
 #define REG_RING_INTERRUPT_BASE	0x38200
 #define RING_INTERRUPT_REG_COUNT(nhi) ((31 + 2 * nhi->hop_count) / 32)
+#define REG_RING_INTERRUPT_MASK_CLEAR_BASE	0x38208
 
 #define REG_INT_THROTTLING_RATE	0x38c00
 
-- 
2.35.3

