From: Chuck Lever <chuck.lever@oracle.com>
Date: Thu, 1 Sep 2022 15:10:12 -0400
Subject: [PATCH] NFSD: Protect against send buffer overflow in NFSv3 READDIR
Git-commit: 640f87c190e0d1b2a0fcb2ecf6d2cd53b1c41991
Patch-mainline: v6.1
References: bsc#1205128 CVE-2022-43945 bsc#1210124

Since before the git era, NFSD has conserved the number of pages
held by each nfsd thread by combining the RPC receive and send
buffers into a single array of pages. This works because there are
no cases where an operation needs a large RPC Call message and a
large RPC Reply message at the same time.

Once an RPC Call has been received, svc_process() updates
svc_rqst::rq_res to describe the part of rq_pages that can be
used for constructing the Reply. This means that the send buffer
(rq_res) shrinks when the received RPC record containing the RPC
Call is large.

A client can force this shrinkage on TCP by sending a correctly-
formed RPC Call header contained in an RPC record that is
excessively large. The full maximum payload size cannot be
constructed in that case.

Thanks to Aleksi Illikainen and Kari Hulkko for uncovering this
issue.

Reported-by: Ben Ronallo <Benjamin.Ronallo@synopsys.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
Reviewed-by: Jeff Layton <jlayton@kernel.org>
Acked-by: NeilBrown <neilb@suse.com>

---
 fs/nfsd/nfs3proc.c |   19 ++++++++++++++++---
 fs/nfsd/nfs3xdr.c  |    8 +++++++-
 2 files changed, 23 insertions(+), 4 deletions(-)

--- a/fs/nfsd/nfs3proc.c
+++ b/fs/nfsd/nfs3proc.c
@@ -459,9 +459,15 @@ nfsd3_proc_readdir(struct svc_rqst *rqst
 				SVCFH_fmt(&argp->fh),
 				argp->count, (u32) argp->cookie);
 
+	count = argp->count;
+	if (count > svc_max_payload(rqstp))
+		count = svc_max_payload(rqstp);
 	/* Make sure we've room for the NULL ptr & eof flag, and shrink to
 	 * client read size */
-	count = (argp->count >> 2) - 2;
+	count = count >> 2;
+	if (count < 2)
+		count = 2;
+	count -= 2;
 
 	/* Read directory and encode entries on the fly */
 	fh_copy(&resp->fh, &argp->fh);
@@ -512,7 +518,7 @@ nfsd3_proc_readdirplus(struct svc_rqst *
 	struct nfsd3_readdirargs *argp = rqstp->rq_argp;
 	struct nfsd3_readdirres  *resp = rqstp->rq_resp;
 	__be32	nfserr;
-	int	count = 0;
+	int	count;
 	loff_t	offset;
 	struct page **p;
 	caddr_t	page_addr = NULL;
@@ -521,9 +527,15 @@ nfsd3_proc_readdirplus(struct svc_rqst *
 				SVCFH_fmt(&argp->fh),
 				argp->count, (u32) argp->cookie);
 
+	count = argp->count;
+	if (count > svc_max_payload(rqstp))
+		count = svc_max_payload(rqstp);
 	/* Convert byte count to number of words (i.e. >> 2),
 	 * and reserve room for the NULL ptr & eof flag (-2 words) */
-	resp->count = (argp->count >> 2) - 2;
+	count = argp->count >> 2;
+	if (count < 2)
+		count = 2;
+	resp->count = count - 2;
 
 	/* Read directory and encode entries on the fly */
 	fh_copy(&resp->fh, &argp->fh);
@@ -546,6 +558,7 @@ nfsd3_proc_readdirplus(struct svc_rqst *
 				     &resp->common,
 				     nfs3svc_encode_entry_plus);
 	memcpy(resp->verf, argp->verf, 8);
+	count = 0;
 	for (p = rqstp->rq_respages + 1; p < rqstp->rq_next_page; p++) {
 		page_addr = page_address(*p);
 
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@ -602,6 +602,11 @@ nfs3svc_decode_readdirplusargs(struct sv
 	struct nfsd3_readdirargs *args = rqstp->rq_argp;
 	int len;
 	u32 max_blocksize = svc_max_payload(rqstp);
+	unsigned int pages;
+
+	/* calculate available pages for reply body */
+	pages = (rqstp->rq_server->sv_max_mesg / PAGE_SIZE + 1);
+	pages -= (rqstp->rq_next_page - rqstp->rq_pages);
 
 	p = decode_fh(p, &args->fh);
 	if (!p)
@@ -611,7 +616,8 @@ nfs3svc_decode_readdirplusargs(struct sv
 	args->dircount = ntohl(*p++);
 	args->count    = ntohl(*p++);
 
-	len = args->count = min(args->count, max_blocksize);
+	args->count = min(args->count, max_blocksize);
+	len = args->count = min_t(unsigned int, args->count, pages * PAGE_SIZE);
 	while (len > 0) {
 		struct page *p = *(rqstp->rq_next_page++);
 		if (!args->buffer)
