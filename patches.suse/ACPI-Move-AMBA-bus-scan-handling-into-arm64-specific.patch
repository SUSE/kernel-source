From: Sudeep Holla <sudeep.holla@arm.com>
Date: Thu, 27 Jul 2023 14:33:47 +0100
Subject: ACPI: Move AMBA bus scan handling into arm64 specific directory
Patch-mainline: v6.6-rc1
Git-commit: fc001b36e50f4136c6b8d9fceaf17fc145ffbd0d
References: jsc#PED-6741

Commit fcea0ccf4fd7 ("ACPI: bus: Consolidate all arm specific
initialisation into acpi_arm_init()") moved all of the ARM-specific
initialization into acpi_arm_init(). However, acpi_amba.c being outside
of drivers/acpi/arm64 got ignored and hence acpi_amba_init() was not
moved into acpi_arm_init().

Move the AMBA platform bus support into arm64 specific folder and make
acpi_amba_init() part of acpi_arm_init().

Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/acpi/Makefile       |    1 
 drivers/acpi/acpi_amba.c    |  130 --------------------------------------------
 drivers/acpi/arm64/Makefile |    1 
 drivers/acpi/arm64/amba.c   |  130 ++++++++++++++++++++++++++++++++++++++++++++
 drivers/acpi/arm64/init.c   |    2 
 drivers/acpi/arm64/init.h   |    1 
 drivers/acpi/internal.h     |    5 -
 drivers/acpi/scan.c         |    1 
 8 files changed, 134 insertions(+), 137 deletions(-)
 rename drivers/acpi/{acpi_amba.c => arm64/amba.c} (99%)

--- a/drivers/acpi/Makefile
+++ b/drivers/acpi/Makefile
@@ -50,7 +50,6 @@ acpi-$(CONFIG_PCI)		+= acpi_lpss.o
 acpi-y				+= acpi_apd.o
 acpi-y				+= acpi_platform.o
 acpi-y				+= acpi_pnp.o
-acpi-$(CONFIG_ARM_AMBA)	+= acpi_amba.o
 acpi-y				+= power.o
 acpi-y				+= event.o
 acpi-y				+= evged.o
--- a/drivers/acpi/acpi_amba.c
+++ /dev/null
@@ -1,130 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-
-/*
- * ACPI support for platform bus type.
- *
- * Copyright (C) 2015, Linaro Ltd
- * Author: Graeme Gregory <graeme.gregory@linaro.org>
- */
-
-#include <linux/acpi.h>
-#include <linux/amba/bus.h>
-#include <linux/clkdev.h>
-#include <linux/clk-provider.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/ioport.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-
-#include "internal.h"
-
-static const struct acpi_device_id amba_id_list[] = {
-	{"ARMH0061", 0}, /* PL061 GPIO Device */
-	{"ARMH0330", 0}, /* ARM DMA Controller DMA-330 */
-	{"ARMHC500", 0}, /* ARM CoreSight ETM4x */
-	{"ARMHC501", 0}, /* ARM CoreSight ETR */
-	{"ARMHC502", 0}, /* ARM CoreSight STM */
-	{"ARMHC503", 0}, /* ARM CoreSight Debug */
-	{"ARMHC979", 0}, /* ARM CoreSight TPIU */
-	{"ARMHC97C", 0}, /* ARM CoreSight SoC-400 TMC, SoC-600 ETF/ETB */
-	{"ARMHC98D", 0}, /* ARM CoreSight Dynamic Replicator */
-	{"ARMHC9CA", 0}, /* ARM CoreSight CATU */
-	{"ARMHC9FF", 0}, /* ARM CoreSight Dynamic Funnel */
-	{"", 0},
-};
-
-static void amba_register_dummy_clk(void)
-{
-	static struct clk *amba_dummy_clk;
-
-	/* If clock already registered */
-	if (amba_dummy_clk)
-		return;
-
-	amba_dummy_clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL, 0, 0);
-	clk_register_clkdev(amba_dummy_clk, "apb_pclk", NULL);
-}
-
-static int amba_handler_attach(struct acpi_device *adev,
-				const struct acpi_device_id *id)
-{
-	struct acpi_device *parent = acpi_dev_parent(adev);
-	struct amba_device *dev;
-	struct resource_entry *rentry;
-	struct list_head resource_list;
-	bool address_found = false;
-	int irq_no = 0;
-	int ret;
-
-	/* If the ACPI node already has a physical device attached, skip it. */
-	if (adev->physical_node_count)
-		return 0;
-
-	dev = amba_device_alloc(dev_name(&adev->dev), 0, 0);
-	if (!dev) {
-		dev_err(&adev->dev, "%s(): amba_device_alloc() failed\n",
-			__func__);
-		return -ENOMEM;
-	}
-
-	INIT_LIST_HEAD(&resource_list);
-	ret = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);
-	if (ret < 0)
-		goto err_free;
-
-	list_for_each_entry(rentry, &resource_list, node) {
-		switch (resource_type(rentry->res)) {
-		case IORESOURCE_MEM:
-			if (!address_found) {
-				dev->res = *rentry->res;
-				dev->res.name = dev_name(&dev->dev);
-				address_found = true;
-			}
-			break;
-		case IORESOURCE_IRQ:
-			if (irq_no < AMBA_NR_IRQS)
-				dev->irq[irq_no++] = rentry->res->start;
-			break;
-		default:
-			dev_warn(&adev->dev, "Invalid resource\n");
-			break;
-		}
-	}
-
-	acpi_dev_free_resource_list(&resource_list);
-
-	/*
-	 * If the ACPI node has a parent and that parent has a physical device
-	 * attached to it, that physical device should be the parent of
-	 * the amba device we are about to create.
-	 */
-	if (parent)
-		dev->dev.parent = acpi_get_first_physical_node(parent);
-
-	ACPI_COMPANION_SET(&dev->dev, adev);
-
-	ret = amba_device_add(dev, &iomem_resource);
-	if (ret) {
-		dev_err(&adev->dev, "%s(): amba_device_add() failed (%d)\n",
-		       __func__, ret);
-		goto err_free;
-	}
-
-	return 1;
-
-err_free:
-	amba_device_put(dev);
-	return ret;
-}
-
-static struct acpi_scan_handler amba_handler = {
-	.ids = amba_id_list,
-	.attach = amba_handler_attach,
-};
-
-void __init acpi_amba_init(void)
-{
-	amba_register_dummy_clk();
-	acpi_scan_add_handler(&amba_handler);
-}
--- a/drivers/acpi/arm64/Makefile
+++ b/drivers/acpi/arm64/Makefile
@@ -3,4 +3,5 @@ obj-$(CONFIG_ACPI_AGDI) 	+= agdi.o
 obj-$(CONFIG_ACPI_IORT) 	+= iort.o
 obj-$(CONFIG_ACPI_GTDT) 	+= gtdt.o
 obj-$(CONFIG_ACPI_APMT) 	+= apmt.o
+obj-$(CONFIG_ARM_AMBA)		+= amba.o
 obj-y				+= dma.o init.o
--- /dev/null
+++ b/drivers/acpi/arm64/amba.c
@@ -0,0 +1,130 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/*
+ * ACPI support for platform bus type.
+ *
+ * Copyright (C) 2015, Linaro Ltd
+ * Author: Graeme Gregory <graeme.gregory@linaro.org>
+ */
+
+#include <linux/acpi.h>
+#include <linux/amba/bus.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "init.h"
+
+static const struct acpi_device_id amba_id_list[] = {
+	{"ARMH0061", 0}, /* PL061 GPIO Device */
+	{"ARMH0330", 0}, /* ARM DMA Controller DMA-330 */
+	{"ARMHC500", 0}, /* ARM CoreSight ETM4x */
+	{"ARMHC501", 0}, /* ARM CoreSight ETR */
+	{"ARMHC502", 0}, /* ARM CoreSight STM */
+	{"ARMHC503", 0}, /* ARM CoreSight Debug */
+	{"ARMHC979", 0}, /* ARM CoreSight TPIU */
+	{"ARMHC97C", 0}, /* ARM CoreSight SoC-400 TMC, SoC-600 ETF/ETB */
+	{"ARMHC98D", 0}, /* ARM CoreSight Dynamic Replicator */
+	{"ARMHC9CA", 0}, /* ARM CoreSight CATU */
+	{"ARMHC9FF", 0}, /* ARM CoreSight Dynamic Funnel */
+	{"", 0},
+};
+
+static void amba_register_dummy_clk(void)
+{
+	static struct clk *amba_dummy_clk;
+
+	/* If clock already registered */
+	if (amba_dummy_clk)
+		return;
+
+	amba_dummy_clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL, 0, 0);
+	clk_register_clkdev(amba_dummy_clk, "apb_pclk", NULL);
+}
+
+static int amba_handler_attach(struct acpi_device *adev,
+				const struct acpi_device_id *id)
+{
+	struct acpi_device *parent = acpi_dev_parent(adev);
+	struct amba_device *dev;
+	struct resource_entry *rentry;
+	struct list_head resource_list;
+	bool address_found = false;
+	int irq_no = 0;
+	int ret;
+
+	/* If the ACPI node already has a physical device attached, skip it. */
+	if (adev->physical_node_count)
+		return 0;
+
+	dev = amba_device_alloc(dev_name(&adev->dev), 0, 0);
+	if (!dev) {
+		dev_err(&adev->dev, "%s(): amba_device_alloc() failed\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&resource_list);
+	ret = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);
+	if (ret < 0)
+		goto err_free;
+
+	list_for_each_entry(rentry, &resource_list, node) {
+		switch (resource_type(rentry->res)) {
+		case IORESOURCE_MEM:
+			if (!address_found) {
+				dev->res = *rentry->res;
+				dev->res.name = dev_name(&dev->dev);
+				address_found = true;
+			}
+			break;
+		case IORESOURCE_IRQ:
+			if (irq_no < AMBA_NR_IRQS)
+				dev->irq[irq_no++] = rentry->res->start;
+			break;
+		default:
+			dev_warn(&adev->dev, "Invalid resource\n");
+			break;
+		}
+	}
+
+	acpi_dev_free_resource_list(&resource_list);
+
+	/*
+	 * If the ACPI node has a parent and that parent has a physical device
+	 * attached to it, that physical device should be the parent of
+	 * the amba device we are about to create.
+	 */
+	if (parent)
+		dev->dev.parent = acpi_get_first_physical_node(parent);
+
+	ACPI_COMPANION_SET(&dev->dev, adev);
+
+	ret = amba_device_add(dev, &iomem_resource);
+	if (ret) {
+		dev_err(&adev->dev, "%s(): amba_device_add() failed (%d)\n",
+		       __func__, ret);
+		goto err_free;
+	}
+
+	return 1;
+
+err_free:
+	amba_device_put(dev);
+	return ret;
+}
+
+static struct acpi_scan_handler amba_handler = {
+	.ids = amba_id_list,
+	.attach = amba_handler_attach,
+};
+
+void __init acpi_amba_init(void)
+{
+	amba_register_dummy_clk();
+	acpi_scan_add_handler(&amba_handler);
+}
--- a/drivers/acpi/arm64/init.c
+++ b/drivers/acpi/arm64/init.c
@@ -10,4 +10,6 @@ void __init acpi_arm_init(void)
 		acpi_apmt_init();
 	if (IS_ENABLED(CONFIG_ACPI_IORT))
 		acpi_iort_init();
+	if (IS_ENABLED(CONFIG_ARM_AMBA))
+		acpi_amba_init();
 }
--- a/drivers/acpi/arm64/init.h
+++ b/drivers/acpi/arm64/init.h
@@ -4,3 +4,4 @@
 void __init acpi_agdi_init(void);
 void __init acpi_apmt_init(void);
 void __init acpi_iort_init(void);
+void __init acpi_amba_init(void);
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -28,11 +28,6 @@ void acpi_processor_init(void);
 void acpi_platform_init(void);
 void acpi_pnp_init(void);
 void acpi_int340x_thermal_init(void);
-#ifdef CONFIG_ARM_AMBA
-void acpi_amba_init(void);
-#else
-static inline void acpi_amba_init(void) {}
-#endif
 int acpi_sysfs_init(void);
 void acpi_gpe_apply_masked_gpes(void);
 void acpi_container_init(void);
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2616,7 +2616,6 @@ void __init acpi_scan_init(void)
 	acpi_watchdog_init();
 	acpi_pnp_init();
 	acpi_int340x_thermal_init();
-	acpi_amba_init();
 	acpi_init_lpit();
 
 	acpi_scan_add_handler(&generic_device_handler);
