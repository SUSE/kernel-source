From cac99f73f0752e1c83674e12fb2c605dca9ce474 Mon Sep 17 00:00:00 2001
From: Heiner Kallweit <hkallweit1@gmail.com>
Date: Thu, 31 Oct 2024 20:32:52 +0100
Subject: [PATCH] ALSA: hda: intel: Don't free interrupt when suspending
Git-commit: cac99f73f0752e1c83674e12fb2c605dca9ce474
Patch-mainline: v6.13-rc1
References: stable-fixes

There's no need to free/re-request the interrupt on system suspend.
PCI core takes care, using functions like pci_restore_msi_state().

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
Link: https://patch.msgid.link/1b7e109b-eb69-4542-8022-4ac8f9116474@gmail.com
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/pci/hda/hda_intel.c | 13 -------------
 1 file changed, 13 deletions(-)

diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index b4540c5cd2a6..9fc5e6c5d800 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -1040,14 +1040,6 @@ static int azx_suspend(struct device *dev)
 	chip = card->private_data;
 	bus = azx_bus(chip);
 	azx_shutdown_chip(chip);
-	if (bus->irq >= 0) {
-		free_irq(bus->irq, chip);
-		bus->irq = -1;
-		chip->card->sync_irq = -1;
-	}
-
-	if (chip->msi)
-		pci_disable_msi(chip->pci);
 
 	trace_azx_suspend(chip);
 	return 0;
@@ -1062,11 +1054,6 @@ static int __maybe_unused azx_resume(struct device *dev)
 		return 0;
 
 	chip = card->private_data;
-	if (chip->msi)
-		if (pci_enable_msi(chip->pci) < 0)
-			chip->msi = 0;
-	if (azx_acquire_irq(chip, 1) < 0)
-		return -EIO;
 
 	__azx_runtime_resume(chip);
 
-- 
2.43.0

