From: Jakub Kicinski <kuba@kernel.org>
Date: Thu, 11 Jul 2024 15:07:05 -0700
Subject: eth: bnxt: allow deleting RSS contexts when the device is down
Patch-mainline: v6.11-rc1
Git-commit: 667ac333dbb7e265b3f5bc4bc94e236f64682c86
References: jsc#PED-11221

Contexts get deleted from FW when the device is down, but they
are kept in SW and re-added back on open. bnxt_set_rxfh_context()
apparently does not want to deal with complexity of dealing with
both the device down and device up cases. This is perhaps acceptable
for creating new contexts, but not being able to delete contexts
makes core-driven cleanups messy. Specifically with the new RSS
API core will try to delete contexts automatically after bringing
the device down.

Support the delete-while-down case. Skip the FW logic and delete
just the driver state.

Reviewed-by: Pavan Chebbi <pavan.chebbi@broadcom.com>
Link: https://patch.msgid.link/20240711220713.283778-4-kuba@kernel.org
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/broadcom/bnxt/bnxt.c         |   10 ++++++----
 drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c |    6 ++++--
 2 files changed, 10 insertions(+), 6 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -10213,10 +10213,12 @@ void bnxt_del_one_rss_ctx(struct bnxt *b
 	struct bnxt_ntuple_filter *ntp_fltr;
 	int i;
 
-	bnxt_hwrm_vnic_free_one(bp, &rss_ctx->vnic);
-	for (i = 0; i < BNXT_MAX_CTX_PER_VNIC; i++) {
-		if (vnic->fw_rss_cos_lb_ctx[i] != INVALID_HW_RING_ID)
-			bnxt_hwrm_vnic_ctx_free_one(bp, vnic, i);
+	if (netif_running(bp->dev)) {
+		bnxt_hwrm_vnic_free_one(bp, &rss_ctx->vnic);
+		for (i = 0; i < BNXT_MAX_CTX_PER_VNIC; i++) {
+			if (vnic->fw_rss_cos_lb_ctx[i] != INVALID_HW_RING_ID)
+				bnxt_hwrm_vnic_ctx_free_one(bp, vnic, i);
+		}
 	}
 	if (!all)
 		return;
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@ -1874,6 +1874,7 @@ static int bnxt_set_rxfh_context(struct
 	struct bnxt_rss_ctx *rss_ctx;
 	struct bnxt_vnic_info *vnic;
 	bool modify = false;
+	bool delete;
 	int bit_id;
 	int rc;
 
@@ -1882,7 +1883,8 @@ static int bnxt_set_rxfh_context(struct
 		return -EOPNOTSUPP;
 	}
 
-	if (!netif_running(bp->dev)) {
+	delete = *rss_context != ETH_RXFH_CONTEXT_ALLOC && rxfh->rss_delete;
+	if (!netif_running(bp->dev) && !delete) {
 		NL_SET_ERR_MSG_MOD(extack, "Unable to set RSS contexts when interface is down");
 		return -EAGAIN;
 	}
@@ -1894,7 +1896,7 @@ static int bnxt_set_rxfh_context(struct
 					       *rss_context);
 			return -EINVAL;
 		}
-		if (*rss_context && rxfh->rss_delete) {
+		if (delete) {
 			bnxt_del_one_rss_ctx(bp, rss_ctx, true);
 			return 0;
 		}
