From: Petr Mladek <pmladek@suse.com>
Date: Thu, 14 Dec 2023 14:24:59 +0100
Subject: [PATCH] vsprintf/kallsyms: Prevent invalid data when printing symbol
Patch-mainline: not yet, need splitting and sending, 2024-01-08
References: bsc#1217602

There are several situations when vsprintf() might read garbage when
printing a symbol, especially when printing a module buildid.

1. __sprint_symbol() might read module->name and module->buildid when
   the module has been already removed.

   The module structure is handled by RCU. Prevent the removal by
   disabling the preemption.

2. kallsyms_lookup_buildid() might return invalid @modbuildid
   pointer when the address was found by either
   bpf_address_lookup() or ftrace_mod_address_lookup().

   Update these function to update @buildid pointer the same way as
   @modname. Also warn when @buildid is not set together with @modname.

3. kallsyms_lookup_buildid() might return @namebuf without
   the trailing '\0'.

   It tries to prevent it by setting the last byte to '\0' at
   the beginning. And the old module_address_lookup() uses
   strncpy(namebuf, ret, KSYM_NAME_LEN - 1). But  the newer
   __bpf_address_lookup() uses the unsafe
   strncpy(sym, ksym->name, KSYM_NAME_LEN).

   Remove the attempt to prevent it. Instead, make sure that all
   the callers always produce '\0' terminated strings by using strscpy().
   It makes them more secure even in other code paths.

4. The behavior is not consistent on failure. Most output parameters are
   not touched and might contain garbage. The only exception is @namebuf
   which is filed by the empty string because some callers do not check
   the return value, probably from historic reasons.

   Document the behavior.

Finally, module_buildid() and append_buildid() functions are created
to remove #ifdef parts from a more complex code.

Signed-off-by: Petr Mladek <pmladek@suse.com>
---
 include/linux/filter.h | 15 +++++--
 include/linux/ftrace.h |  6 ++-
 include/linux/module.h | 17 ++++++++
 kernel/bpf/core.c      |  2 +-
 kernel/kallsyms.c      | 93 ++++++++++++++++++++++++++++++++++--------
 kernel/module.c        | 11 ++---
 kernel/trace/ftrace.c  |  5 ++-
 7 files changed, 115 insertions(+), 34 deletions(-)

diff --git a/include/linux/filter.h b/include/linux/filter.h
index 83b896044e79..185600abb78d 100644
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@ -1121,12 +1121,18 @@ int bpf_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
 
 static inline const char *
 bpf_address_lookup(unsigned long addr, unsigned long *size,
-		   unsigned long *off, char **modname, char *sym)
+		   unsigned long *off, char **modname,
+		   const unsigned char **modbuildid, char *sym)
 {
 	const char *ret = __bpf_address_lookup(addr, size, off, sym);
 
-	if (ret && modname)
-		*modname = NULL;
+	if (ret) {
+		if (modname)
+			*modname = NULL;
+		if (modbuildid)
+			*modbuildid = NULL;
+	}
+
 	return ret;
 }
 
@@ -1187,7 +1193,8 @@ static inline int bpf_get_kallsym(unsigned int symnum, unsigned long *value,
 
 static inline const char *
 bpf_address_lookup(unsigned long addr, unsigned long *size,
-		   unsigned long *off, char **modname, char *sym)
+		   unsigned long *off, char **modname,
+		   const unsigned char **modbuildid, char *sym)
 {
 	return NULL;
 }
diff --git a/include/linux/ftrace.h b/include/linux/ftrace.h
index a69f363b61bf..5881efec7025 100644
--- a/include/linux/ftrace.h
+++ b/include/linux/ftrace.h
@@ -58,11 +58,13 @@ struct ftrace_direct_func;
 	defined(CONFIG_DYNAMIC_FTRACE)
 const char *
 ftrace_mod_address_lookup(unsigned long addr, unsigned long *size,
-		   unsigned long *off, char **modname, char *sym);
+		   unsigned long *off, char **modname,
+		   const unsigned char **modbuildid, char *sym);
 #else
 static inline const char *
 ftrace_mod_address_lookup(unsigned long addr, unsigned long *size,
-		   unsigned long *off, char **modname, char *sym)
+		   unsigned long *off, char **modname,
+		   const unsigned char **modbuildid, char *sym)
 {
 	return NULL;
 }
diff --git a/include/linux/module.h b/include/linux/module.h
index 8a298d820dbc..ce63e0083238 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -633,6 +633,18 @@ static inline void __module_get(struct module *module)
 	__mod ? __mod->name : "kernel";		\
 })
 
+#ifdef CONFIG_STACKTRACE_BUILD_ID
+static inline const unsigned char *module_buildid(struct module *mod)
+{
+	return mod->build_id;
+}
+#else
+static inline const unsigned char *module_buildid(struct module *mod)
+{
+	return NULL;
+}
+#endif
+
 /* Dereference module function descriptor */
 void *dereference_module_function_descriptor(struct module *mod, void *ptr);
 
@@ -741,6 +753,11 @@ static inline void module_put(struct module *module)
 
 #define module_name(mod) "kernel"
 
+static inline const unsigned char *module_buildid(struct module *mod)
+{
+	return NULL;
+}
+
 /* For kallsyms to ask for address resolution.  NULL means not found. */
 static inline const char *module_address_lookup(unsigned long addr,
 					  unsigned long *symbolsize,
diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c
index 0a28a8095d3e..a3d381f2c42b 100644
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -686,7 +686,7 @@ const char *__bpf_address_lookup(unsigned long addr, unsigned long *size,
 		unsigned long symbol_start = ksym->start;
 		unsigned long symbol_end = ksym->end;
 
-		strncpy(sym, ksym->name, KSYM_NAME_LEN);
+		strscpy(sym, ksym->name, KSYM_NAME_LEN);
 
 		ret = sym;
 		if (size)
diff --git a/kernel/kallsyms.c b/kernel/kallsyms.c
index 0ba87982d017..322d9e734fc8 100644
--- a/kernel/kallsyms.c
+++ b/kernel/kallsyms.c
@@ -65,6 +65,8 @@ static unsigned int kallsyms_expand_symbol(unsigned int off,
 	const char *tptr;
 	const u8 *data;
 
+	result[0] = '\0';
+
 	/* Get the compressed symbol length from the first symbol byte. */
 	data = &kallsyms_names[off];
 	len = *data;
@@ -304,6 +306,27 @@ int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,
 	       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);
 }
 
+/*
+ * Find details about the symbol on the given address.
+ *
+ * Return pointer to the symbol name stored in the given @namebuf on success,
+ * NULL on failure.
+ *
+ * The other parameters are set to valid values on success. They are not
+ * touched on failure except for @namebuf[*].
+ *
+ * IMPORTANT: @modname and @modbuildid point to mod->name and mod->buildid
+ *	from the related struct module. The structure is guarded by RCU.
+ *	The caller has to disable preemption to keep them valid.
+ *
+ *	The two parameters are set to NULL when the symbol comes from
+ *	the kernel core. @modbuildid might be NULL also when
+ *	CONFIG_STACKTRACE_BUILD_ID is not enabled.
+ *
+ * [*] On error, @namebuf is updated to contain the empty string. It is
+ *     a historic and obsolete behavior. Some code paths still depend
+ *     on it though.
+ */
 static const char *kallsyms_lookup_buildid(unsigned long addr,
 			unsigned long *symbolsize,
 			unsigned long *offset, char **modname,
@@ -311,7 +334,12 @@ static const char *kallsyms_lookup_buildid(unsigned long addr,
 {
 	const char *ret;
 
-	namebuf[KSYM_NAME_LEN - 1] = 0;
+	/*
+	 * The function returns pointer to namebuf on success and
+	 * NULL on error. But some callers ignore the return value.
+	 * Instead they expect @namebuf filled either with valid
+	 * or empty string.
+	 */
 	namebuf[0] = 0;
 
 	if (is_ksym_addr(addr)) {
@@ -334,12 +362,12 @@ static const char *kallsyms_lookup_buildid(unsigned long addr,
 	ret = module_address_lookup(addr, symbolsize, offset,
 				    modname, modbuildid, namebuf);
 	if (!ret)
-		ret = bpf_address_lookup(addr, symbolsize,
-					 offset, modname, namebuf);
+		ret = bpf_address_lookup(addr, symbolsize, offset,
+					 modname, modbuildid, namebuf);
 
 	if (!ret)
-		ret = ftrace_mod_address_lookup(addr, symbolsize,
-						offset, modname, namebuf);
+		ret = ftrace_mod_address_lookup(addr, symbolsize, offset,
+						modname, modbuildid, namebuf);
 
 found:
 	cleanup_symbol_name(namebuf);
@@ -416,6 +444,34 @@ int lookup_symbol_attrs(unsigned long addr, unsigned long *size,
 	return 0;
 }
 
+#ifdef CONFIG_STACKTRACE_BUILD_ID
+
+static int append_buildid(char *buffer,  const char *modname,
+			  const unsigned char *buildid)
+{
+	if (modname && !buildid) {
+		pr_warn("Undefined buildid for the module %s\n", modname);
+		return 0;
+	}
+
+	/* build ID should match length of sprintf */
+#ifdef CONFIG_MODULES
+	static_assert(sizeof(typeof_member(struct module, build_id)) == 20);
+#endif
+
+	return sprintf(buffer, " %20phN", buildid);
+}
+
+#else /* CONFIG_STACKTRACE_BUILD_ID */
+
+static int append_buildid(char *buffer,   const char *modname,
+			  const unsigned char *buildid)
+{
+	return 0;
+}
+
+#endif /* CONFIG_STACKTRACE_BUILD_ID */
+
 /* Look up a kernel symbol and return it in a text buffer. */
 static int __sprint_symbol(char *buffer, unsigned long address,
 			   int symbol_offset, int add_offset, int add_buildid)
@@ -426,11 +482,16 @@ static int __sprint_symbol(char *buffer, unsigned long address,
 	unsigned long offset, size;
 	int len;
 
+	/* Prevent module removal until modname and modbuildid are printed */
+	preempt_disable();
+
 	address += symbol_offset;
-	name = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,
-				       buffer);
-	if (!name)
-		return sprintf(buffer, "0x%lx", address - symbol_offset);
+	name = kallsyms_lookup_buildid(address, &size, &offset,
+				       &modname, &buildid, buffer);
+	if (!name) {
+		len = sprintf(buffer, "0x%lx", address - symbol_offset);
+		goto out;
+	}
 
 	if (name != buffer)
 		strcpy(buffer, name);
@@ -442,18 +503,14 @@ static int __sprint_symbol(char *buffer, unsigned long address,
 
 	if (modname) {
 		len += sprintf(buffer + len, " [%s", modname);
-#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)
-		if (add_buildid && buildid) {
-			/* build ID should match length of sprintf */
-#if IS_ENABLED(CONFIG_MODULES)
-			static_assert(sizeof(typeof_member(struct module, build_id)) == 20);
-#endif
-			len += sprintf(buffer + len, " %20phN", buildid);
-		}
-#endif
+		if (add_buildid)
+			len += append_buildid(buffer + len, modname, buildid);
 		len += sprintf(buffer + len, "]");
 	}
 
+out:
+	preempt_enable();
+
 	return len;
 }
 
diff --git a/kernel/module.c b/kernel/module.c
index ed13917ea5f3..2105a2853aa3 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -4289,19 +4289,14 @@ const char *module_address_lookup(unsigned long addr,
 	if (mod) {
 		if (modname)
 			*modname = mod->name;
-		if (modbuildid) {
-#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)
-			*modbuildid = mod->build_id;
-#else
-			*modbuildid = NULL;
-#endif
-		}
+		if (modbuildid)
+			*modbuildid = module_buildid(mod);
 
 		ret = find_kallsyms_symbol(mod, addr, size, offset);
 	}
 	/* Make a copy in here where it's safe */
 	if (ret) {
-		strncpy(namebuf, ret, KSYM_NAME_LEN - 1);
+		strscpy(namebuf, ret, KSYM_NAME_LEN);
 		ret = namebuf;
 	}
 	preempt_enable();
diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index 7b180f61e6d3..a7f31dafed56 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -6631,7 +6631,8 @@ ftrace_func_address_lookup(struct ftrace_mod_map *mod_map,
 
 const char *
 ftrace_mod_address_lookup(unsigned long addr, unsigned long *size,
-		   unsigned long *off, char **modname, char *sym)
+		   unsigned long *off, char **modname,
+		   const unsigned char **modbuildid, char *sym)
 {
 	struct ftrace_mod_map *mod_map;
 	const char *ret = NULL;
@@ -6643,6 +6644,8 @@ ftrace_mod_address_lookup(unsigned long addr, unsigned long *size,
 		if (ret) {
 			if (modname)
 				*modname = mod_map->mod->name;
+			if (modbuildid)
+				*modbuildid = module_buildid(mod_map->mod);
 			break;
 		}
 	}
-- 
2.43.0

