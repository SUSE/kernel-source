From 8c3b7d278ffc4d30b0809d1b7066a94963a0d2ca Mon Sep 17 00:00:00 2001
From: Thomas Zimmermann <tzimmermann@suse.de>
Date: Tue, 4 Feb 2025 14:26:38 +0100
Subject: drm/ast: astdp: Inline mode-index calculation
Git-commit: 8c3b7d278ffc4d30b0809d1b7066a94963a0d2ca
Patch-mainline: v6.15-rc1
References: jsc#PED-13979 jsc#PED-14039 jsc#PED-14046 jsc#PED-14211 jsc#PED-14333 jsc#PED-14487 jsc#PED-14488 jsc#PED-14497 jsc#PED-14499

Programming the astdp transmitter chip requires a magic value for
individual modes. Inline the helper for calculating the value into
its only caller (i.e., the encoder's atomic_mode_set).

With further refactoring, the atomic check will be able to detect
invalid modes before attempting to program them.

Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
Reviewed-by: Jocelyn Falempe <jfalempe@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20250204133209.403327-3-tzimmermann@suse.de
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>

---
 drivers/gpu/drm/ast/ast_dp.c | 52 +++++++++++++++---------------------
 1 file changed, 21 insertions(+), 31 deletions(-)

diff --git a/drivers/gpu/drm/ast/ast_dp.c b/drivers/gpu/drm/ast/ast_dp.c
index 9c49b507a0d2..e7b00153c37e 100644
--- a/drivers/gpu/drm/ast/ast_dp.c
+++ b/drivers/gpu/drm/ast/ast_dp.c
@@ -52,7 +52,7 @@ to_ast_astdp_connector_state(const struct drm_connector_state *state)
 	return container_of(state, struct ast_astdp_connector_state, base);
 }
 
-static int __ast_astdp_get_mode_index(unsigned int hdisplay, unsigned int vdisplay)
+static int ast_astdp_get_mode_index(unsigned int hdisplay, unsigned int vdisplay)
 {
 	const struct ast_astdp_mode_index_table_entry *entry = ast_astdp_mode_index_table;
 
@@ -65,35 +65,6 @@ static int __ast_astdp_get_mode_index(unsigned int hdisplay, unsigned int vdispl
 	return -EINVAL;
 }
 
-static int ast_astdp_get_mode_index(const struct ast_vbios_enhtable *vmode)
-{
-	int mode_index;
-	u8 refresh_rate_index;
-
-	mode_index = __ast_astdp_get_mode_index(vmode->hde, vmode->vde);
-	if (mode_index < 0)
-		return mode_index;
-
-	if (vmode->refresh_rate_index < 1 || vmode->refresh_rate_index > 255)
-		return -EINVAL;
-	refresh_rate_index = vmode->refresh_rate_index - 1;
-
-	/* FIXME: Why are we doing this? */
-	switch (mode_index) {
-	case ASTDP_1280x800_60_RB:
-	case ASTDP_1440x900_60_RB:
-	case ASTDP_1600x900_60_RB:
-	case ASTDP_1680x1050_60_RB:
-		mode_index = (u8)(mode_index - (u8)refresh_rate_index);
-		break;
-	default:
-		mode_index = (u8)(mode_index + (u8)refresh_rate_index);
-		break;
-	}
-
-	return mode_index;
-}
-
 static bool ast_astdp_is_connected(struct ast_device *ast)
 {
 	if (!ast_get_index_reg_mask(ast, AST_IO_VGACRI, 0xDF, AST_IO_VGACRDF_HPD))
@@ -333,13 +304,32 @@ static void ast_astdp_encoder_helper_atomic_mode_set(struct drm_encoder *encoder
 	struct drm_device *dev = encoder->dev;
 	struct ast_device *ast = to_ast_device(dev);
 	struct ast_crtc_state *ast_crtc_state = to_ast_crtc_state(crtc_state);
+	const struct ast_vbios_enhtable *vmode = ast_crtc_state->vmode;
 	int mode_index;
+	u8 refresh_rate_index;
 	u8 vgacre0, vgacre1, vgacre2;
 
-	mode_index = ast_astdp_get_mode_index(ast_crtc_state->vmode);
+	mode_index = ast_astdp_get_mode_index(vmode->hde, vmode->vde);
 	if (drm_WARN_ON(dev, mode_index < 0))
 		return;
 
+	if (drm_WARN_ON(dev, vmode->refresh_rate_index < 1 || vmode->refresh_rate_index > 255))
+		return;
+	refresh_rate_index = vmode->refresh_rate_index - 1;
+
+	/* FIXME: Why are we doing this? */
+	switch (mode_index) {
+	case ASTDP_1280x800_60_RB:
+	case ASTDP_1440x900_60_RB:
+	case ASTDP_1600x900_60_RB:
+	case ASTDP_1680x1050_60_RB:
+		mode_index = (u8)(mode_index - (u8)refresh_rate_index);
+		break;
+	default:
+		mode_index = (u8)(mode_index + (u8)refresh_rate_index);
+		break;
+	}
+
 	/*
 	 * CRE0[7:0]: MISC0 ((0x00: 18-bpp) or (0x20: 24-bpp)
 	 * CRE1[7:0]: MISC1 (default: 0x00)
-- 
2.52.0

