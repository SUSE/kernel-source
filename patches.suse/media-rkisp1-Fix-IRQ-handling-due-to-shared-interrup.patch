From ffb635bb398fc07cb38f8a7b4a82cbe5f412f08e Mon Sep 17 00:00:00 2001
From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
Date: Mon, 18 Dec 2023 08:54:01 +0100
Subject: [PATCH] media: rkisp1: Fix IRQ handling due to shared interrupts
Git-commit: ffb635bb398fc07cb38f8a7b4a82cbe5f412f08e
Patch-mainline: v6.8-rc5
References: CVE-2023-52660 bsc#1224443

[ backport note: simplified to match with SLE15-SP5 code -- tiwai ]

The driver requests the interrupts as IRQF_SHARED, so the interrupt
handlers can be called at any time. If such a call happens while the ISP
is powered down, the SoC will hang as the driver tries to access the
ISP registers.

This can be reproduced even without the platform sharing the IRQ line:
Enable CONFIG_DEBUG_SHIRQ and unload the driver, and the board will
hang.

Fix this by adding a new field, 'irqs_enabled', which is used to bail
out from the interrupt handler when the ISP is not operational.

Link: https://lore.kernel.org/r/20231218-rkisp-shirq-fix-v1-2-173007628248@ideasonboard.com

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/media/platform/rockchip/rkisp1/rkisp1-capture.c |    3 +++
 drivers/media/platform/rockchip/rkisp1/rkisp1-common.h  |    2 ++
 drivers/media/platform/rockchip/rkisp1/rkisp1-dev.c     |    8 ++++++++
 drivers/media/platform/rockchip/rkisp1/rkisp1-isp.c     |    3 +++
 4 files changed, 16 insertions(+)

--- a/drivers/media/platform/rockchip/rkisp1/rkisp1-capture.c
+++ b/drivers/media/platform/rockchip/rkisp1/rkisp1-capture.c
@@ -690,6 +690,9 @@ void rkisp1_capture_isr(struct rkisp1_de
 	unsigned int i;
 	u32 status;
 
+	if (!rkisp1->irqs_enabled)
+		return;
+
 	status = rkisp1_read(rkisp1, RKISP1_CIF_MI_MIS);
 	rkisp1_write(rkisp1, status, RKISP1_CIF_MI_ICR);
 
--- a/drivers/media/platform/rockchip/rkisp1/rkisp1-common.h
+++ b/drivers/media/platform/rockchip/rkisp1/rkisp1-common.h
@@ -349,6 +349,7 @@ struct rkisp1_debug {
  * @pipe:	   media pipeline
  * @stream_lock:   serializes {start/stop}_streaming callbacks between the capture devices.
  * @debug:	   debug params to be exposed on debugfs
+ * @irqs_enabled:  the hardware is enabled and can cause interrupts
  */
 struct rkisp1_device {
 	void __iomem *base_addr;
@@ -368,6 +369,7 @@ struct rkisp1_device {
 	struct media_pipeline pipe;
 	struct mutex stream_lock; /* serialize {start/stop}_streaming cb between capture devices */
 	struct rkisp1_debug debug;
+	bool irqs_enabled;
 };
 
 /*
--- a/drivers/media/platform/rockchip/rkisp1/rkisp1-dev.c
+++ b/drivers/media/platform/rockchip/rkisp1/rkisp1-dev.c
@@ -309,6 +309,10 @@ static int __maybe_unused rkisp1_runtime
 {
 	struct rkisp1_device *rkisp1 = dev_get_drvdata(dev);
 
+	rkisp1->irqs_enabled = false;
+	/* Make sure the IRQ handler will see the above */
+	mb();
+
 	clk_bulk_disable_unprepare(rkisp1->clk_size, rkisp1->clks);
 	return pinctrl_pm_select_sleep_state(dev);
 }
@@ -325,6 +329,10 @@ static int __maybe_unused rkisp1_runtime
 	if (ret)
 		return ret;
 
+	rkisp1->irqs_enabled = true;
+	/* Make sure the IRQ handler will see the above */
+	mb();
+
 	return 0;
 }
 
--- a/drivers/media/platform/rockchip/rkisp1/rkisp1-isp.c
+++ b/drivers/media/platform/rockchip/rkisp1/rkisp1-isp.c
@@ -1166,6 +1166,9 @@ void rkisp1_isp_isr(struct rkisp1_device
 {
 	u32 status, isp_err;
 
+	if (!rkisp1->irqs_enabled)
+		return;
+
 	status = rkisp1_read(rkisp1, RKISP1_CIF_ISP_MIS);
 	if (!status)
 		return;
