From fa8809a519d85f498f43fadaf82e10831f20625a Mon Sep 17 00:00:00 2001
From: Johannes Berg <johannes.berg@intel.com>
Date: Mon, 28 Aug 2023 13:59:55 +0200
Subject: [PATCH] wifi: cfg80211: hold wiphy lock in cfg80211_any_wiphy_oper_chan()
Git-commit: fa8809a519d85f498f43fadaf82e10831f20625a
Patch-mainline: v6.7-rc1
References: bsc#1227149

We have the RTNL here for the iteration, but we need to lock
each wiphy separately as well for using its data. Hold the
wiphy lock for all of the ones in the iteration. Note that
this implies we cannot already hold the wiphy mutex for the
wiphy passed by the argument, but that's true now.

Signed-off-by: Johannes Berg <johannes.berg@intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 net/wireless/chan.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index 3c691ae904d1..b2469e2c1e70 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -824,13 +824,17 @@ bool cfg80211_any_wiphy_oper_chan(struct wiphy *wiphy,
 		return false;
 
 	for_each_rdev(rdev) {
+		bool found;
+
 		if (!reg_dfs_domain_same(wiphy, &rdev->wiphy))
 			continue;
 
-		if (cfg80211_is_wiphy_oper_chan(&rdev->wiphy, chan))
-			return true;
+		wiphy_lock(&rdev->wiphy);
+		found = cfg80211_is_wiphy_oper_chan(&rdev->wiphy, chan) ||
+			cfg80211_offchan_chain_is_active(rdev, chan);
+		wiphy_unlock(&rdev->wiphy);
 
-		if (cfg80211_offchan_chain_is_active(rdev, chan))
+		if (found)
 			return true;
 	}
 
-- 
2.43.0

