From: Carolina Jubran <cjubran@nvidia.com>
Date: Wed, 16 Oct 2024 20:36:05 +0300
Subject: net/mlx5: Add parent group support in rate group structure
Patch-mainline: v6.13-rc1
Git-commit: 54200dbc685c6fcfcd59b132ff5d9979563bc01d
References: jsc#PED-9900 jsc#PED-11429

Introduce a `parent` field in the `mlx5_esw_rate_group` structure to
support hierarchical group relationships.

The `parent` can reference another group or be set to `NULL`,
indicating the group is connected to the root TSAR.

This change enables the ability to manage groups in a hierarchical
structure for future enhancements.

Signed-off-by: Carolina Jubran <cjubran@nvidia.com>
Reviewed-by: Cosmin Ratiu <cratiu@nvidia.com>
Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
Reviewed-by: Daniel Machon <daniel.machon@microchip.com>
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c |   17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c
@@ -72,6 +72,8 @@ struct mlx5_esw_rate_group {
 	u32 min_rate;
 	/* A computed value indicating relative min_rate between group members. */
 	u32 bw_share;
+	/* The parent group of this group. */
+	struct mlx5_esw_rate_group *parent;
 	/* Membership in the parent list. */
 	struct list_head parent_entry;
 	/* The type of this group node in the rate hierarchy. */
@@ -505,7 +507,8 @@ static int esw_qos_vport_update_group(st
 }
 
 static struct mlx5_esw_rate_group *
-__esw_qos_alloc_rate_group(struct mlx5_eswitch *esw, u32 tsar_ix, enum sched_node_type type)
+__esw_qos_alloc_rate_group(struct mlx5_eswitch *esw, u32 tsar_ix, enum sched_node_type type,
+			   struct mlx5_esw_rate_group *parent)
 {
 	struct mlx5_esw_rate_group *group;
 
@@ -516,6 +519,7 @@ __esw_qos_alloc_rate_group(struct mlx5_e
 	group->esw = esw;
 	group->tsar_ix = tsar_ix;
 	group->type = type;
+	group->parent = parent;
 	INIT_LIST_HEAD(&group->members);
 	list_add_tail(&group->parent_entry, &esw->qos.domain->groups);
 	return group;
@@ -528,7 +532,8 @@ static void __esw_qos_free_rate_group(st
 }
 
 static struct mlx5_esw_rate_group *
-__esw_qos_create_vports_rate_group(struct mlx5_eswitch *esw, struct netlink_ext_ack *extack)
+__esw_qos_create_vports_rate_group(struct mlx5_eswitch *esw, struct mlx5_esw_rate_group *parent,
+				   struct netlink_ext_ack *extack)
 {
 	struct mlx5_esw_rate_group *group;
 	u32 tsar_ix;
@@ -540,7 +545,7 @@ __esw_qos_create_vports_rate_group(struc
 		return ERR_PTR(err);
 	}
 
-	group = __esw_qos_alloc_rate_group(esw, tsar_ix, SCHED_NODE_TYPE_VPORTS_TSAR);
+	group = __esw_qos_alloc_rate_group(esw, tsar_ix, SCHED_NODE_TYPE_VPORTS_TSAR, parent);
 	if (!group) {
 		NL_SET_ERR_MSG_MOD(extack, "E-Switch alloc group failed");
 		err = -ENOMEM;
@@ -583,7 +588,7 @@ esw_qos_create_vports_rate_group(struct
 	if (err)
 		return ERR_PTR(err);
 
-	group = __esw_qos_create_vports_rate_group(esw, extack);
+	group = __esw_qos_create_vports_rate_group(esw, NULL, extack);
 	if (IS_ERR(group))
 		esw_qos_put(esw);
 
@@ -628,13 +633,13 @@ static int esw_qos_create(struct mlx5_es
 	}
 
 	if (MLX5_CAP_QOS(dev, log_esw_max_sched_depth)) {
-		esw->qos.group0 = __esw_qos_create_vports_rate_group(esw, extack);
+		esw->qos.group0 = __esw_qos_create_vports_rate_group(esw, NULL, extack);
 	} else {
 		/* The eswitch doesn't support scheduling groups.
 		 * Create a software-only group0 using the root TSAR to attach vport QoS to.
 		 */
 		if (!__esw_qos_alloc_rate_group(esw, esw->qos.root_tsar_ix,
-						SCHED_NODE_TYPE_VPORTS_TSAR))
+						SCHED_NODE_TYPE_VPORTS_TSAR, NULL))
 			esw->qos.group0 = ERR_PTR(-ENOMEM);
 	}
 	if (IS_ERR(esw->qos.group0)) {
