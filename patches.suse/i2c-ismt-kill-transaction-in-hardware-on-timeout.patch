From 46b2dfc0aa79277c2ed119975de72f49bddd77c9 Mon Sep 17 00:00:00 2001
From: Vasily Khoruzhick <vasilykh@arista.com>
Date: Mon, 19 Aug 2024 13:51:04 -0700
Subject: [PATCH] i2c: ismt: kill transaction in hardware on timeout
Git-commit: 46b2dfc0aa79277c2ed119975de72f49bddd77c9
References: git-fixes
Patch-mainline: v6.12-rc1

On Intel Denverton SoC ismt controller may enter weird state when
transaction gets stuck. It times out in the driver, but unless
transaction is explicitly killed in the controller, it won't be able to
perform new transactions anymore.

The issue is extremely difficult to reproduce and may take weeks of non-
stop smbus traffic.

Numerous hours with logic analyzer didn't yield any useful results, it
looks like the controller stops toggling SCK line, i.e. the issue is
likely in the controller, since device doesn't do clock stretching, so
nothing is driving SCK except the host.

Explicitly kill transaction on timeout to recover the controller from
this state.

Signed-off-by: Vasily Khoruzhick <vasilykh@arista.com>
Signed-off-by: Andi Shyti <andi.shyti@kernel.org>
Signed-off-by: Oliver Neukum <oneukum@suse.com>

---
 drivers/i2c/busses/i2c-ismt.c |   10 ++++++++++
 1 file changed, 10 insertions(+)

--- a/drivers/i2c/busses/i2c-ismt.c
+++ b/drivers/i2c/busses/i2c-ismt.c
@@ -382,6 +382,15 @@ static int ismt_process_desc(const struc
 }
 
 /**
+ * ismt_kill_transaction() - kill current transaction
+ * @priv: iSMT private data
+ */
+static void ismt_kill_transaction(struct ismt_priv *priv)
+{
+	writel(ISMT_GCTRL_KILL, priv->smba + ISMT_GR_GCTRL);
+}
+
+/**
  * ismt_access() - process an SMBus command
  * @adap: the i2c host adapter
  * @addr: address of the i2c/SMBus target
@@ -623,6 +632,7 @@ static int ismt_access(struct i2c_adapte
 		dma_unmap_single(dev, dma_addr, dma_size, dma_direction);
 
 	if (unlikely(!time_left)) {
+		ismt_kill_transaction(priv);
 		dev_err(dev, "completion wait timed out\n");
 		ret = -ETIMEDOUT;
 		goto out;
