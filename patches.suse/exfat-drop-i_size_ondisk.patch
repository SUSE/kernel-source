From fba27cf005038a5fedf001b49636594819dbb1d5 Mon Sep 17 00:00:00 2001
From: Yuezhang Mo <Yuezhang.Mo@sony.com>
Date: Fri, 12 Jan 2024 10:32:58 +0800
Subject: [PATCH] exfat: drop ->i_size_ondisk
Git-commit: fba27cf005038a5fedf001b49636594819dbb1d5
Patch-mainline: v6.12-rc1
References: git-fixes

->i_size_ondisk is no longer used by exfat_write_begin() after
commit(11a347fb6cef exfat: change to get file size from DataLength),
drop it.

Signed-off-by: Yuezhang Mo <Yuezhang.Mo@sony.com>
Signed-off-by: Namjae Jeon <linkinjeon@kernel.org>
Acked-by: Anthony Iliopoulos <ailiop@suse.com>

---
 fs/exfat/exfat_fs.h |   10 +++++-----
 fs/exfat/file.c     |    8 ++------
 fs/exfat/inode.c    |   17 +++++------------
 fs/exfat/namei.c    |    1 -
 fs/exfat/super.c    |    1 -
 5 files changed, 12 insertions(+), 25 deletions(-)

--- a/fs/exfat/exfat_fs.h
+++ b/fs/exfat/exfat_fs.h
@@ -309,11 +309,6 @@ struct exfat_inode_info {
 	/* for avoiding the race between alloc and free */
 	unsigned int cache_valid_id;
 
-	/*
-	 * NOTE: i_size_ondisk is 64bits, so must hold ->inode_lock to access.
-	 * physically allocated size.
-	 */
-	loff_t i_size_ondisk;
 	/* block-aligned i_size (used in cont_write_begin) */
 	loff_t i_size_aligned;
 	/* on-disk position of directory entry or 0 */
@@ -417,6 +412,11 @@ static inline bool is_valid_cluster(stru
 	return clus >= EXFAT_FIRST_CLUSTER && clus < sbi->num_clusters;
 }
 
+static inline loff_t exfat_ondisk_size(const struct inode *inode)
+{
+	return ((loff_t)inode->i_blocks) << 9;
+}
+
 /* super.c */
 int exfat_set_volume_dirty(struct super_block *sb);
 int exfat_clear_volume_dirty(struct super_block *sb);
--- a/fs/exfat/file.c
+++ b/fs/exfat/file.c
@@ -26,7 +26,7 @@ static int exfat_cont_expand(struct inod
 	if (ret)
 		return ret;
 
-	num_clusters = EXFAT_B_TO_CLU_ROUND_UP(ei->i_size_ondisk, sbi);
+	num_clusters = EXFAT_B_TO_CLU(exfat_ondisk_size(inode), sbi);
 	new_num_clusters = EXFAT_B_TO_CLU_ROUND_UP(size, sbi);
 
 	if (new_num_clusters == num_clusters)
@@ -72,7 +72,6 @@ out:
 	i_size_write(inode, size);
 
 	ei->i_size_aligned = round_up(size, sb->s_blocksize);
-	ei->i_size_ondisk = ei->i_size_aligned;
 	inode->i_blocks = round_up(size, sbi->cluster_size) >> 9;
 	mark_inode_dirty(inode);
 
@@ -154,7 +153,7 @@ int __exfat_truncate(struct inode *inode
 	exfat_set_volume_dirty(sb);
 
 	num_clusters_new = EXFAT_B_TO_CLU_ROUND_UP(i_size_read(inode), sbi);
-	num_clusters_phys = EXFAT_B_TO_CLU_ROUND_UP(ei->i_size_ondisk, sbi);
+	num_clusters_phys = EXFAT_B_TO_CLU(exfat_ondisk_size(inode), sbi);
 
 	exfat_chain_set(&clu, ei->start_clu, num_clusters_phys, ei->flags);
 
@@ -265,9 +264,6 @@ write_size:
 		aligned_size++;
 	}
 
-	if (ei->i_size_ondisk > i_size_read(inode))
-		ei->i_size_ondisk = aligned_size;
-
 	if (ei->i_size_aligned > i_size_read(inode))
 		ei->i_size_aligned = aligned_size;
 	mutex_unlock(&sbi->s_lock);
--- a/fs/exfat/inode.c
+++ b/fs/exfat/inode.c
@@ -127,11 +127,9 @@ static int exfat_map_cluster(struct inod
 	struct exfat_sb_info *sbi = EXFAT_SB(sb);
 	struct exfat_inode_info *ei = EXFAT_I(inode);
 	unsigned int local_clu_offset = clu_offset;
-	unsigned int num_to_be_allocated = 0, num_clusters = 0;
+	unsigned int num_to_be_allocated = 0, num_clusters;
 
-	if (ei->i_size_ondisk > 0)
-		num_clusters =
-			EXFAT_B_TO_CLU_ROUND_UP(ei->i_size_ondisk, sbi);
+	num_clusters = EXFAT_B_TO_CLU(exfat_ondisk_size(inode), sbi);
 
 	if (clu_offset >= num_clusters)
 		num_to_be_allocated = clu_offset - num_clusters + 1;
@@ -265,10 +263,10 @@ static int exfat_map_new_buffer(struct e
 	set_buffer_new(bh);
 
 	/*
-	 * Adjust i_size_aligned if i_size_ondisk is bigger than it.
+	 * Adjust i_size_aligned if ondisk_size is bigger than it.
 	 */
-	if (ei->i_size_ondisk > ei->i_size_aligned)
-		ei->i_size_aligned = ei->i_size_ondisk;
+	if (exfat_ondisk_size(&ei->vfs_inode) > ei->i_size_aligned)
+		ei->i_size_aligned = exfat_ondisk_size(&ei->vfs_inode);
 	return 0;
 }
 
@@ -314,10 +312,6 @@ static int exfat_get_block(struct inode
 	max_blocks = min(mapped_blocks, max_blocks);
 
 	pos = EXFAT_BLK_TO_B((iblock + 1), sb);
-	if ((create && iblock >= last_block) || buffer_delay(bh_result)) {
-		if (ei->i_size_ondisk < pos)
-			ei->i_size_ondisk = pos;
-	}
 
 	map_bh(bh_result, sb, phys);
 	if (buffer_delay(bh_result))
@@ -672,7 +666,6 @@ static int exfat_fill_inode(struct inode
 	}
 
 	ei->i_size_aligned = size;
-	ei->i_size_ondisk = size;
 
 	exfat_save_attr(inode, info->attr);
 
--- a/fs/exfat/namei.c
+++ b/fs/exfat/namei.c
@@ -404,7 +404,6 @@ static int exfat_find_empty_entry(struct
 
 		/* directory inode should be updated in here */
 		i_size_write(inode, size);
-		ei->i_size_ondisk += sbi->cluster_size;
 		ei->i_size_aligned += sbi->cluster_size;
 		ei->valid_size += sbi->cluster_size;
 		ei->flags = p_dir->flags;
--- a/fs/exfat/super.c
+++ b/fs/exfat/super.c
@@ -376,7 +376,6 @@ static int exfat_read_root(struct inode
 	inode->i_blocks = round_up(i_size_read(inode), sbi->cluster_size) >> 9;
 	ei->i_pos = ((loff_t)sbi->root_dir << 32) | 0xffffffff;
 	ei->i_size_aligned = i_size_read(inode);
-	ei->i_size_ondisk = i_size_read(inode);
 
 	exfat_save_attr(inode, ATTR_SUBDIR);
 	inode->i_mtime = inode->i_atime = ei->i_crtime = inode_set_ctime_current(inode);
