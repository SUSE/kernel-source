From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Subject: platform/x86/intel-uncore-freq: Do not present separate package-die domain
References: jsc#PED-10382
Patch-Mainline: v6.12-rc1
Git-commit: bb9a9bf2787fbe1a4e003daabc8f7a31c17740d6

The scope of uncore control is per power domain with TPMI.

There are two types of processor topologies can be presented by CPUID
extended topology leaf irrespective of the hardware architecture:

1. A die is not enumerated in CPUID. In this case there is only one die
in a package is visible. In this case there can be multiple power domains
in a single die.
2. A power domain in a package is enumerated as a die in CPUID. So
there is one power domain per die.

To allow die level controls, the current implementation creates a root
domain and aggregates all information from power domains in it. This
is well suited for configuration 1 above.

But for configuration 2 above, the root domain will present the same
information as present by power domain. So, no use of aggregating. To
check the configuration, call topology_max_dies_per_package(). If it is
more than one, avoid creating root domain.

Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Reviewed-by: Ilpo JÃ¤rvinen <ilpo.jarvinen@linux.intel.com>
Link: https://lore.kernel.org/r/20240820204558.1296319-1-srinivas.pandruvada@linux.intel.com
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Signed-off-by: Hans de Goede <hdegoede@redhat.com>


Signed-off-by:  <trenn@suse.com>
---
 drivers/platform/x86/intel/uncore-frequency/uncore-frequency-tpmi.c |    7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

--- a/drivers/platform/x86/intel/uncore-frequency/uncore-frequency-tpmi.c
+++ b/drivers/platform/x86/intel/uncore-frequency/uncore-frequency-tpmi.c
@@ -427,6 +427,9 @@
 
 	auxiliary_set_drvdata(auxdev, tpmi_uncore);
 
+	if (topology_max_dies_per_package() > 1)
+		return 0;
+
 	tpmi_uncore->root_cluster.root_domain = true;
 	tpmi_uncore->root_cluster.uncore_root = tpmi_uncore;
 
@@ -450,7 +453,9 @@
 {
 	struct tpmi_uncore_struct *tpmi_uncore = auxiliary_get_drvdata(auxdev);
 
-	uncore_freq_remove_die_entry(&tpmi_uncore->root_cluster.uncore_data);
+	if (tpmi_uncore->root_cluster.root_domain)
+		uncore_freq_remove_die_entry(&tpmi_uncore->root_cluster.uncore_data);
+
 	remove_cluster_entries(tpmi_uncore);
 
 	uncore_freq_common_exit();
