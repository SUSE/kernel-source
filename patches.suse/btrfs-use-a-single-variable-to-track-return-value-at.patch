From: Filipe Manana <fdmanana@suse.com>
Date: Wed, 14 May 2025 12:24:25 +0100
Subject: [PATCH] btrfs: use a single variable to track return value at
 btrfs_page_mkwrite()
Git-commit: 1ce06d45d92242ffd9c576b736e1e755531fe6dd
Patch-mainline: v6.16-rc1
References: bsc#1247949

We have two variables to track return values, ret and ret2, with types
vm_fault_t (an unsigned int type) and int, which makes it a bit confusing
and harder to keep track. So use a single variable, of type int, and under
the 'out' label return vmf_error(ret) in case ret contains an error,
otherwise return VM_FAULT_NOPAGE. This is equivalent to what we had before
and it's simpler.

Reviewed-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
---
 fs/btrfs/file.c | 37 ++++++++++++++++---------------------
 1 file changed, 16 insertions(+), 21 deletions(-)

diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c
index e95c271f3..275ba4314 100644
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -1906,8 +1906,7 @@ static vm_fault_t btrfs_page_mkwrite(struct vm_fault *vmf)
 	unsigned long zero_start;
 	loff_t size;
 	size_t fsize = folio_size(folio);
-	vm_fault_t ret;
-	int ret2;
+	int ret;
 	u64 reserved_space;
 	u64 page_start;
 	u64 page_end;
@@ -1930,21 +1929,14 @@ static vm_fault_t btrfs_page_mkwrite(struct vm_fault *vmf)
 	 * end up waiting indefinitely to get a lock on the page currently
 	 * being processed by btrfs_page_mkwrite() function.
 	 */
-	ret2 = btrfs_delalloc_reserve_space(BTRFS_I(inode), &data_reserved,
-					    page_start, reserved_space);
-	if (ret2) {
-		ret = vmf_error(ret2);
+	ret = btrfs_delalloc_reserve_space(BTRFS_I(inode), &data_reserved,
+					   page_start, reserved_space);
+	if (ret < 0)
 		goto out_noreserve;
-	}
 
-	ret2 = file_update_time(vmf->vma->vm_file);
-	if (ret2) {
-		ret = vmf_error(ret2);
+	ret = file_update_time(vmf->vma->vm_file);
+	if (ret < 0)
 		goto out;
-	}
-
-	/* Make the VM retry the fault. */
-	ret = VM_FAULT_NOPAGE;
 again:
 	down_read(&BTRFS_I(inode)->i_mmap_lock);
 	folio_lock(folio);
@@ -1958,9 +1950,8 @@ static vm_fault_t btrfs_page_mkwrite(struct vm_fault *vmf)
 	folio_wait_writeback(folio);
 
 	lock_extent(io_tree, page_start, page_end, &cached_state);
-	ret2 = set_folio_extent_mapped(folio);
-	if (ret2 < 0) {
-		ret = vmf_error(ret2);
+	ret = set_folio_extent_mapped(folio);
+	if (ret < 0) {
 		unlock_extent(io_tree, page_start, page_end, &cached_state);
 		goto out_unlock;
 	}
@@ -2000,11 +1991,10 @@ static vm_fault_t btrfs_page_mkwrite(struct vm_fault *vmf)
 			  EXTENT_DELALLOC | EXTENT_DO_ACCOUNTING |
 			  EXTENT_DEFRAG, &cached_state);
 
-	ret2 = btrfs_set_extent_delalloc(BTRFS_I(inode), page_start, end, 0,
+	ret = btrfs_set_extent_delalloc(BTRFS_I(inode), page_start, end, 0,
 					&cached_state);
-	if (ret2) {
+	if (ret) {
 		unlock_extent(io_tree, page_start, page_end, &cached_state);
-		ret = vmf_error(ret2);
 		goto out_unlock;
 	}
 
@@ -2041,7 +2031,12 @@ static vm_fault_t btrfs_page_mkwrite(struct vm_fault *vmf)
 	extent_changeset_free(data_reserved);
 out_noreserve:
 	sb_end_pagefault(inode->i_sb);
-	return ret;
+
+	if (ret < 0)
+		return vmf_error(ret);
+
+	/* Make the VM retry the fault. */
+	return VM_FAULT_NOPAGE;
 }
 
 static const struct vm_operations_struct btrfs_file_vm_ops = {
-- 
2.35.3

