From: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Date: Sun, 3 Nov 2024 14:59:38 -0800
Subject: bpf: Tighten tail call checks for lingering locks, RCU,
 preempt_disable
Patch-mainline: v6.13-rc1
Git-commit: 46f7ed32f7a873d6675ea72e1d6317df41a55f81
References: jsc#PED-11651
X-Info: minor context change due to upstream commit f18b03fabaa9 "bpf: Implement BPF exceptions" not backported
X-Info: active_preempt_lock conditional dropped because upstream commit f18b03fabaa9 "bpf: Implement BPF exceptions" not backported

There are three situations when a program logically exits and transfers
control to the kernel or another program: bpf_throw, BPF_EXIT, and tail
calls. The former two check for any lingering locks and references, but
tail calls currently do not. Expand the checks to check for spin locks,
RCU read sections and preempt disabled sections.

Spin locks are indirectly preventing tail calls as function calls are
disallowed, but the checks for preemption and RCU are more relaxed,
hence ensure tail calls are prevented in their presence.

Fixes: 9bb00b2895cb ("bpf: Add kfunc bpf_rcu_read_lock/unlock()")
Fixes: fc7566ad0a82 ("bpf: Introduce bpf_preempt_[disable,enable] kfuncs")
Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: https://lore.kernel.org/r/20241103225940.1408302-2-memxor@gmail.com
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
[ shung-hsi.yu: check_reference_leak() only takes one argument before commit
  f18b03fabaa9 ("bpf: Implement BPF exceptions"), and active_preempt_lock is
  not defined before commit fc7566ad0a82 ("bpf: Introduce
  bpf_preempt_[disable,enable] kfuncs") ]
Signed-off-by: Shung-Hsi Yu <shung-hsi.yu@suse.com>
---
 kernel/bpf/verifier.c |   11 +++++++++++
 1 file changed, 11 insertions(+)

--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -10231,11 +10231,22 @@ static int check_helper_call(struct bpf_
 
 	switch (func_id) {
 	case BPF_FUNC_tail_call:
+		if (env->cur_state->active_lock.ptr) {
+			verbose(env, "tail_call cannot be used inside bpf_spin_lock-ed region\n");
+			return -EINVAL;
+		}
+
 		err = check_reference_leak(env);
 		if (err) {
 			verbose(env, "tail_call would lead to reference leak\n");
 			return err;
 		}
+
+		if (env->cur_state->active_rcu_lock) {
+			verbose(env, "tail_call cannot be used inside bpf_rcu_read_lock-ed region\n");
+			return -EINVAL;
+		}
+
 		break;
 	case BPF_FUNC_get_local_storage:
 		/* check that flags argument in get_local_storage(map, flags) is 0,
