From: Filipe Manana <fdmanana@suse.com>
Date: Tue, 18 Jun 2024 08:28:30 +0100
Git-commit: 119474bdbac0858053cf367c8c932dd5c4bb4e85
Patch-mainline: v6.11-rc1
References: bsc#1230794 CVE-2024-46752
Subject: [PATCH] btrfs: remove NULL transaction support for
 btrfs_lookup_extent_info()

There are no callers of btrfs_lookup_extent_info() that pass a NULL value
for the transaction handle argument, so there's no point in having special
logic to deal with the NULL. The last caller that passed a NULL value was
removed in commit 19b546d7a1b2 ("btrfs: relocation:
Use btrfs_find_all_leafs to locate data extent parent tree leaves").

So remove the NULL handling from btrfs_lookup_extent_info().

Reviewed-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
---
 fs/btrfs/extent-tree.c | 15 +--------------
 1 file changed, 1 insertion(+), 14 deletions(-)

diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 985c0f12a..149f07293 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -127,11 +127,6 @@ int btrfs_lookup_extent_info(struct btrfs_trans_handle *trans,
 	if (!path)
 		return -ENOMEM;
 
-	if (!trans) {
-		path->skip_locking = 1;
-		path->search_commit_root = 1;
-	}
-
 search_again:
 	key.objectid = bytenr;
 	key.offset = offset;
@@ -168,11 +163,6 @@ int btrfs_lookup_extent_info(struct btrfs_trans_handle *trans,
 		} else {
 			ret = -EINVAL;
 			btrfs_print_v0_err(fs_info);
-			if (trans)
-				btrfs_abort_transaction(trans, ret);
-			else
-				btrfs_handle_fs_error(fs_info, ret, NULL);
-
 			goto out_free;
 		}
 
@@ -183,9 +173,6 @@ int btrfs_lookup_extent_info(struct btrfs_trans_handle *trans,
 		ret = 0;
 	}
 
-	if (!trans)
-		goto out;
-
 	delayed_refs = &trans->transaction->delayed_refs;
 	spin_lock(&delayed_refs->lock);
 	head = btrfs_find_delayed_ref_head(delayed_refs, bytenr);
@@ -216,7 +203,7 @@ int btrfs_lookup_extent_info(struct btrfs_trans_handle *trans,
 		mutex_unlock(&head->mutex);
 	}
 	spin_unlock(&delayed_refs->lock);
-out:
+
 	WARN_ON(num_refs == 0);
 	if (refs)
 		*refs = num_refs;
-- 
2.35.3

