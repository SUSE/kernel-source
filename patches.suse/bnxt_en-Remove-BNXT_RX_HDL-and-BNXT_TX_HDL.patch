From: Michael Chan <michael.chan@broadcom.com>
Date: Mon, 13 Nov 2023 16:16:13 -0800
Subject: bnxt_en: Remove BNXT_RX_HDL and BNXT_TX_HDL
Patch-mainline: v6.8-rc1
Git-commit: 9c0b06de6fb6f3b5871011aae19305b40084e037
References: jsc#PED-7574

These 2 constants were used for the one RX and one TX completion
ring pointer in the cpr->cp_ring_arr fixed array.  Now that we've
changed to allocating the array for the exact number of entries to
support more TX rings, we no longer use these constants.

The array index as well as the type of completion ring (RX/TX) are
now encoded in the handle for the completion ring.  This will allow
us to locate the completion ring during NAPI for any number of
completion rings sharing the same MSIX.  In the following patches,
we'll be adding support for more TX rings associated with the same
MSIX vector.

Reviewed-by: Andy Gospodarek <andrew.gospodarek@broadcom.com>
Signed-off-by: Michael Chan <michael.chan@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/broadcom/bnxt/bnxt.c |   51 +++++++++++++++++-------------
 drivers/net/ethernet/broadcom/bnxt/bnxt.h |   17 ++++++++--
 2 files changed, 44 insertions(+), 24 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -2921,12 +2921,15 @@ static int bnxt_poll_p5(struct napi_stru
 
 		if (nqcmp->type == cpu_to_le16(NQ_CN_TYPE_CQ_NOTIFICATION)) {
 			u32 idx = le32_to_cpu(nqcmp->cq_handle_low);
+			u32 cq_type = BNXT_NQ_HDL_TYPE(idx);
 			struct bnxt_cp_ring_info *cpr2;
 
 			/* No more budget for RX work */
-			if (budget && work_done >= budget && idx == BNXT_RX_HDL)
+			if (budget && work_done >= budget &&
+			    cq_type == BNXT_NQ_HDL_TYPE_RX)
 				break;
 
+			idx = BNXT_NQ_HDL_IDX(idx);
 			cpr2 = &cpr->cp_ring_arr[idx];
 			work_done += __bnxt_poll_work(bp, cpr2,
 						      budget - work_done);
@@ -2942,8 +2945,9 @@ static int bnxt_poll_p5(struct napi_stru
 		BNXT_DB_NQ_P5(&cpr->cp_db, raw_cons);
 	}
 poll_done:
-	cpr_rx = &cpr->cp_ring_arr[BNXT_RX_HDL];
-	if (cpr_rx->bnapi && (bp->flags & BNXT_FLAG_DIM)) {
+	cpr_rx = &cpr->cp_ring_arr[0];
+	if (cpr_rx->cp_ring_type == BNXT_NQ_HDL_TYPE_RX &&
+	    (bp->flags & BNXT_FLAG_DIM)) {
 		struct dim_sample dim_sample = {};
 
 		dim_update_sample(cpr->event_ctr,
@@ -3607,6 +3611,7 @@ static int bnxt_alloc_cp_rings(struct bn
 		struct bnxt_napi *bnapi = bp->bnapi[i];
 		struct bnxt_cp_ring_info *cpr, *cpr2;
 		struct bnxt_ring_struct *ring;
+		int cp_count = 0, k;
 
 		if (!bnapi)
 			continue;
@@ -3627,30 +3632,32 @@ static int bnxt_alloc_cp_rings(struct bn
 		if (!(bp->flags & BNXT_FLAG_CHIP_P5))
 			continue;
 
-		cpr->cp_ring_count = 2;
-		cpr->cp_ring_arr = kcalloc(cpr->cp_ring_count, sizeof(*cpr),
+		if (i < bp->rx_nr_rings)
+			cp_count++;
+		if ((sh && i < bp->tx_nr_rings) ||
+		    (!sh && i >= bp->rx_nr_rings))
+			cp_count++;
+
+		cpr->cp_ring_arr = kcalloc(cp_count, sizeof(*cpr),
 					   GFP_KERNEL);
-		if (!cpr->cp_ring_arr) {
-			cpr->cp_ring_count = 0;
+		if (!cpr->cp_ring_arr)
 			return -ENOMEM;
-		}
+		cpr->cp_ring_count = cp_count;
 
-		if (i < bp->rx_nr_rings) {
-			cpr2 = &cpr->cp_ring_arr[BNXT_RX_HDL];
-			rc = bnxt_alloc_cp_sub_ring(bp, cpr2);
-			if (rc)
-				return rc;
-			cpr2->bnapi = bnapi;
-			bp->rx_ring[i].rx_cpr = cpr2;
-		}
-		if ((sh && i < bp->tx_nr_rings) ||
-		    (!sh && i >= bp->rx_nr_rings)) {
-			cpr2 = &cpr->cp_ring_arr[BNXT_TX_HDL];
+		for (k = 0; k < cp_count; k++) {
+			cpr2 = &cpr->cp_ring_arr[k];
 			rc = bnxt_alloc_cp_sub_ring(bp, cpr2);
 			if (rc)
 				return rc;
 			cpr2->bnapi = bnapi;
-			bp->tx_ring[j++].tx_cpr = cpr2;
+			cpr2->cp_idx = k;
+			if (!k && i < bp->rx_nr_rings) {
+				bp->rx_ring[i].rx_cpr = cpr2;
+				cpr2->cp_ring_type = BNXT_NQ_HDL_TYPE_RX;
+			} else {
+				bp->tx_ring[j++].tx_cpr = cpr2;
+				cpr2->cp_ring_type = BNXT_NQ_HDL_TYPE_TX;
+			}
 		}
 	}
 	return 0;
@@ -6038,7 +6045,7 @@ static int bnxt_hwrm_ring_alloc(struct b
 			u32 type2 = HWRM_RING_ALLOC_CMPL;
 
 			ring = &cpr2->cp_ring_struct;
-			ring->handle = BNXT_TX_HDL;
+			ring->handle = BNXT_SET_NQ_HDL(cpr2);
 			map_idx = bnapi->index;
 			rc = hwrm_ring_alloc_send_msg(bp, ring, type2, map_idx);
 			if (rc)
@@ -6075,7 +6082,7 @@ static int bnxt_hwrm_ring_alloc(struct b
 			u32 type2 = HWRM_RING_ALLOC_CMPL;
 
 			ring = &cpr2->cp_ring_struct;
-			ring->handle = BNXT_RX_HDL;
+			ring->handle = BNXT_SET_NQ_HDL(cpr2);
 			rc = hwrm_ring_alloc_send_msg(bp, ring, type2, map_idx);
 			if (rc)
 				goto err_out;
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -549,6 +549,19 @@ struct nqe_cn {
 	__le32	cq_handle_high;
 };
 
+#define BNXT_NQ_HDL_IDX_MASK	0x00ffffff
+#define BNXT_NQ_HDL_TYPE_MASK	0xff000000
+#define BNXT_NQ_HDL_TYPE_SHIFT	24
+#define BNXT_NQ_HDL_TYPE_RX	0x00
+#define BNXT_NQ_HDL_TYPE_TX	0x01
+
+#define BNXT_NQ_HDL_IDX(hdl)	((hdl) & BNXT_NQ_HDL_IDX_MASK)
+#define BNXT_NQ_HDL_TYPE(hdl)	(((hdl) & BNXT_NQ_HDL_TYPE_MASK) >>	\
+				 BNXT_NQ_HDL_TYPE_SHIFT)
+
+#define BNXT_SET_NQ_HDL(cpr)						\
+	(((cpr)->cp_ring_type << BNXT_NQ_HDL_TYPE_SHIFT) | (cpr)->cp_idx)
+
 #define DB_IDX_MASK						0xffffff
 #define DB_IDX_VALID						(0x1 << 26)
 #define DB_IRQ_DIS						(0x1 << 27)
@@ -1003,6 +1016,8 @@ struct bnxt_cp_ring_info {
 
 	u8			had_work_done:1;
 	u8			has_more_work:1;
+	u8			cp_ring_type;
+	u8			cp_idx;
 
 	u32			last_cp_raw_cons;
 
@@ -1029,8 +1044,6 @@ struct bnxt_cp_ring_info {
 
 	int			cp_ring_count;
 	struct bnxt_cp_ring_info *cp_ring_arr;
-#define BNXT_RX_HDL	0
-#define BNXT_TX_HDL	1
 };
 
 struct bnxt_napi {
