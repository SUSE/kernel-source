From c5b7a2400edc458b22133d5e5394bea26eab1923 Mon Sep 17 00:00:00 2001
From: Andreas Gruenbacher <agruenba@redhat.com>
Date: Tue, 19 Nov 2024 10:44:56 +0100
Subject: [PATCH] gfs2: Only defer deletes when we have an iopen glock
Git-commit: c5b7a2400edc458b22133d5e5394bea26eab1923
Patch-mainline: v6.13-rc1
References: bsc#1247220

The mechanism to defer deleting unlinked inodes is tied to
delete_work_func(), which is tied to iopen glocks.  When we don't have
an iopen glock, we must carry out deletes immediately instead.

Fixes a NULL pointer dereference in gfs2_evict_inode().

Fixes: 8c21c2c71e66 ("gfs2: Call gfs2_queue_verify_delete from gfs2_evict_inode")
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
Signed-off-by: Su Yue <glass.su@suse.com>
---
 fs/gfs2/super.c | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index 597d2bf679ed..597d62be90fe 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -1503,10 +1503,13 @@ static void gfs2_evict_inode(struct inode *inode)
 	    !test_bit(SDF_KILL, &sdp->sd_flags)) {
 		struct gfs2_glock *io_gl = ip->i_iopen_gh.gh_gl;
 
-		gfs2_glock_hold(io_gl);
-		if (!gfs2_queue_verify_delete(io_gl, true))
-			gfs2_glock_put(io_gl);
-		goto out;
+		if (io_gl) {
+			gfs2_glock_hold(io_gl);
+			if (!gfs2_queue_verify_delete(io_gl, true))
+				gfs2_glock_put(io_gl);
+			goto out;
+		}
+		behavior = EVICT_SHOULD_DELETE;
 	}
 	if (behavior == EVICT_SHOULD_DELETE)
 		ret = evict_unlinked_inode(inode);
-- 
2.43.0

